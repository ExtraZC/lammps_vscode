

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>3.7. Packages with extra build options &mdash; LAMMPS documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="LAMMPS documentation" href="index.html"/>
        <link rel="up" title="3. Build LAMMPS" href="Build.html"/>
        <link rel="next" title="3.8. Notes for building LAMMPS on Windows" href="Build_windows.html"/>
        <link rel="prev" title="3.6. Include packages in build" href="Build_package.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        

        
          <a href="Manual.html">
        

        
          
          <img src="_static/lammps-logo.png" class="logo" />
        
        </a>

        <div class="lammps_version">Version: <b>19 Mar 2020</b></div>

        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <p class="caption"><span class="caption-text">User Documentation</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="Install.html">2. Install LAMMPS</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Build.html">3. Build LAMMPS</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Build_cmake.html">3.1. Build LAMMPS with CMake</a></li>
<li class="toctree-l2"><a class="reference internal" href="Build_make.html">3.2. Build LAMMPS with make</a></li>
<li class="toctree-l2"><a class="reference internal" href="Build_link.html">3.3. Link LAMMPS as a library to another code</a></li>
<li class="toctree-l2"><a class="reference internal" href="Build_basics.html">3.4. Basic build options</a></li>
<li class="toctree-l2"><a class="reference internal" href="Build_settings.html">3.5. Optional build settings</a></li>
<li class="toctree-l2"><a class="reference internal" href="Build_package.html">3.6. Include packages in build</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">3.7. Packages with extra build options</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#compress-package">3.7.1. COMPRESS package</a></li>
<li class="toctree-l3"><a class="reference internal" href="#gpu-package">3.7.2. GPU package</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kim-package">3.7.3. KIM package</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kokkos-package">3.7.4. KOKKOS package</a></li>
<li class="toctree-l3"><a class="reference internal" href="#latte-package">3.7.5. LATTE package</a></li>
<li class="toctree-l3"><a class="reference internal" href="#message-package">3.7.6. MESSAGE package</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mscg-package">3.7.7. MSCG package</a></li>
<li class="toctree-l3"><a class="reference internal" href="#opt-package">3.7.8. OPT package</a></li>
<li class="toctree-l3"><a class="reference internal" href="#poems-package">3.7.9. POEMS package</a></li>
<li class="toctree-l3"><a class="reference internal" href="#python-package">3.7.10. PYTHON package</a></li>
<li class="toctree-l3"><a class="reference internal" href="#voronoi-package">3.7.11. VORONOI package</a></li>
<li class="toctree-l3"><a class="reference internal" href="#user-adios-package">3.7.12. USER-ADIOS package</a></li>
<li class="toctree-l3"><a class="reference internal" href="#user-atc-package">3.7.13. USER-ATC package</a></li>
<li class="toctree-l3"><a class="reference internal" href="#user-awpmd-package">3.7.14. USER-AWPMD package</a></li>
<li class="toctree-l3"><a class="reference internal" href="#user-colvars-package">3.7.15. USER-COLVARS package</a></li>
<li class="toctree-l3"><a class="reference internal" href="#user-plumed-package">3.7.16. USER-PLUMED package</a></li>
<li class="toctree-l3"><a class="reference internal" href="#user-h5md-package">3.7.17. USER-H5MD package</a></li>
<li class="toctree-l3"><a class="reference internal" href="#user-intel-package">3.7.18. USER-INTEL package</a></li>
<li class="toctree-l3"><a class="reference internal" href="#user-molfile-package">3.7.19. USER-MOLFILE package</a></li>
<li class="toctree-l3"><a class="reference internal" href="#user-netcdf-package">3.7.20. USER-NETCDF package</a></li>
<li class="toctree-l3"><a class="reference internal" href="#user-omp-package">3.7.21. USER-OMP package</a></li>
<li class="toctree-l3"><a class="reference internal" href="#user-qmmm-package">3.7.22. USER-QMMM package</a></li>
<li class="toctree-l3"><a class="reference internal" href="#user-quip-package">3.7.23. USER-QUIP package</a></li>
<li class="toctree-l3"><a class="reference internal" href="#user-scafacos-package">3.7.24. USER-SCAFACOS package</a></li>
<li class="toctree-l3"><a class="reference internal" href="#user-smd-package">3.7.25. USER-SMD package</a></li>
<li class="toctree-l3"><a class="reference internal" href="#user-vtk-package">3.7.26. USER-VTK package</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Build_windows.html">3.8. Notes for building LAMMPS on Windows</a></li>
<li class="toctree-l2"><a class="reference internal" href="Build_development.html">3.9. Development build options (CMake only)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Run_head.html">4. Run LAMMPS</a></li>
<li class="toctree-l1"><a class="reference internal" href="Commands.html">5. Commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="Packages.html">6. Optional packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="Speed.html">7. Accelerate performance</a></li>
<li class="toctree-l1"><a class="reference internal" href="Howto.html">8. Howto discussions</a></li>
<li class="toctree-l1"><a class="reference internal" href="Examples.html">9. Example scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tools.html">10. Auxiliary tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="Modify.html">11. Modify &amp; extend LAMMPS</a></li>
<li class="toctree-l1"><a class="reference internal" href="Python_head.html">12. Use Python with LAMMPS</a></li>
<li class="toctree-l1"><a class="reference internal" href="Errors.html">13. Errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="Manual_build.html">14. Building the LAMMPS manual</a></li>
</ul>
<p class="caption"><span class="caption-text">Index</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="commands_list.html">Commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="fixes.html">Fixes</a></li>
<li class="toctree-l1"><a class="reference internal" href="computes.html">Computes</a></li>
<li class="toctree-l1"><a class="reference internal" href="pairs.html">Pair Styles</a></li>
<li class="toctree-l1"><a class="reference internal" href="bonds.html">Bond Styles</a></li>
<li class="toctree-l1"><a class="reference internal" href="angles.html">Angle Styles</a></li>
<li class="toctree-l1"><a class="reference internal" href="dihedrals.html">Dihedral Styles</a></li>
<li class="toctree-l1"><a class="reference internal" href="impropers.html">Improper Styles</a></li>
<li class="toctree-l1"><a class="reference internal" href="fix_modify_atc_commands.html">fix_modify AtC commands</a></li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="Manual.html">LAMMPS</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="Manual.html">Docs</a> &raquo;</li>
      
          <li><a href="Build.html"><span class="section-number">3. </span>Build LAMMPS</a> &raquo;</li>
      
    <li><span class="section-number">3.7. </span>Packages with extra build options</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="http://lammps.sandia.gov">Website</a>
            <a href="Commands_all.html">Commands</a>
        
      </li>
  </ul>
  <hr style="margin-top: 6px; margin-bottom: 6px;" width="100%"/>
  
    <div class="rst-footer-buttons" style="margin-bottom: 1em" role="navigation" aria-label="footer navigation">
      
        <a href="Build_windows.html" class="btn btn-neutral float-right" title="3.8. Notes for building LAMMPS on Windows" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Build_package.html" class="btn btn-neutral" title="3.6. Include packages in build" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="packages-with-extra-build-options">
<h1><span class="section-number">3.7. </span>Packages with extra build options</h1>
<p>When building with some packages, additional steps may be required,
in addition to:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ cmake -D <span class="nv">PKG_NAME</span><span class="o">=</span>yes
</pre></div>
</div>
<p>or</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ make yes-name
</pre></div>
</div>
<p>as described on the <a class="reference internal" href="Build_package.html"><span class="doc">Build_package</span></a> doc page.</p>
<p>For a CMake build there may be additional optional or required
variables to set.  For a build with make, a provided library under the
lammps/lib directory may need to be built first.  Or an external
library may need to exist on your system or be downloaded and built.
You may need to tell LAMMPS where it is found on your system.</p>
<p>This is the list of packages that may require additional steps.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#compress"><span class="std std-ref">COMPRESS</span></a></p></td>
<td><p><a class="reference internal" href="#gpu"><span class="std std-ref">GPU</span></a></p></td>
<td><p><a class="reference internal" href="#kim"><span class="std std-ref">KIM</span></a></p></td>
<td><p><a class="reference internal" href="#kokkos"><span class="std std-ref">KOKKOS</span></a></p></td>
<td><p><a class="reference internal" href="#latte"><span class="std std-ref">LATTE</span></a></p></td>
<td><p><a class="reference internal" href="#message"><span class="std std-ref">MESSAGE</span></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mscg"><span class="std std-ref">MSCG</span></a></p></td>
<td><p><a class="reference internal" href="#opt"><span class="std std-ref">OPT</span></a></p></td>
<td><p><a class="reference internal" href="#poems"><span class="std std-ref">POEMS</span></a></p></td>
<td><p><a class="reference internal" href="#python"><span class="std std-ref">PYTHON</span></a></p></td>
<td><p><a class="reference internal" href="#voronoi"><span class="std std-ref">VORONOI</span></a></p></td>
<td><p><a class="reference internal" href="#user-adios"><span class="std std-ref">USER-ADIOS</span></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#user-atc"><span class="std std-ref">USER-ATC</span></a></p></td>
<td><p><a class="reference internal" href="#user-awpmd"><span class="std std-ref">USER-AWPMD</span></a></p></td>
<td><p><a class="reference internal" href="#user-colvars"><span class="std std-ref">USER-COLVARS</span></a></p></td>
<td><p><a class="reference internal" href="#user-h5md"><span class="std std-ref">USER-H5MD</span></a></p></td>
<td><p><a class="reference internal" href="#user-intel"><span class="std std-ref">USER-INTEL</span></a></p></td>
<td><p><a class="reference internal" href="#user-molfile"><span class="std std-ref">USER-MOLFILE</span></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#user-netcdf"><span class="std std-ref">USER-NETCDF</span></a></p></td>
<td><p><a class="reference internal" href="#user-plumed"><span class="std std-ref">USER-PLUMED</span></a></p></td>
<td><p><a class="reference internal" href="#user-omp"><span class="std std-ref">USER-OMP</span></a></p></td>
<td><p><a class="reference internal" href="#user-qmmm"><span class="std std-ref">USER-QMMM</span></a></p></td>
<td><p><a class="reference internal" href="#user-quip"><span class="std std-ref">USER-QUIP</span></a></p></td>
<td><p><a class="reference internal" href="#user-scafacos"><span class="std std-ref">USER-SCAFACOS</span></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#user-smd"><span class="std std-ref">USER-SMD</span></a></p></td>
<td><p><a class="reference internal" href="#user-vtk"><span class="std std-ref">USER-VTK</span></a></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<div class="section" id="compress-package">
<span id="compress"></span><h2><span class="section-number">3.7.1. </span>COMPRESS package</h2>
<p>To build with this package you must have the zlib compression library
available on your system.</p>
<p><strong>CMake build</strong>:</p>
<p>If CMake cannot find the library, you can set these variables:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>-D <span class="nv">ZLIB_INCLUDE_DIR</span><span class="o">=</span>path    <span class="c1"># path to zlib.h header file</span>
-D <span class="nv">ZLIB_LIBRARIES</span><span class="o">=</span>path      <span class="c1"># path to libz.a (.so) file</span>
</pre></div>
</div>
<p><strong>Traditional make</strong>:</p>
<p>If make cannot find the library, you can edit the file
lib/compress/Makefile.lammps to specify the paths and library
name.</p>
<hr class="docutils" />
</div>
<div class="section" id="gpu-package">
<span id="gpu"></span><h2><span class="section-number">3.7.2. </span>GPU package</h2>
<p>To build with this package, you must choose options for precision and
which GPU hardware to build for.</p>
<p><strong>CMake build</strong>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>-D <span class="nv">GPU_API</span><span class="o">=</span>value          <span class="c1"># value = opencl (default) or cuda</span>
-D <span class="nv">GPU_PREC</span><span class="o">=</span>value         <span class="c1"># precision setting</span>
                          <span class="c1"># value = double or mixed (default) or single</span>
-D <span class="nv">OCL_TUNE</span><span class="o">=</span>value         <span class="c1"># hardware choice for GPU_API=opencl</span>
                          <span class="c1"># generic (default) or intel (Intel CPU) or fermi, kepler, cypress (NVIDIA)</span>
-D <span class="nv">GPU_ARCH</span><span class="o">=</span>value         <span class="c1"># primary GPU hardware choice for GPU_API=cuda</span>
                          <span class="c1"># value = sm_XX, see below</span>
                          <span class="c1"># default is sm_30</span>
-D <span class="nv">CUDPP_OPT</span><span class="o">=</span>value        <span class="c1"># optimization setting for GPU_API=cuda</span>
                          <span class="c1"># enables CUDA Performance Primitives Optimizations</span>
                          <span class="c1"># value = yes (default) or no</span>
-D <span class="nv">CUDA_MPS_SUPPORT</span><span class="o">=</span>value <span class="c1"># enables some tweaks required to run with active nvidia-cuda-mps daemon</span>
                          <span class="c1"># value = yes or no (default)</span>
</pre></div>
</div>
<p>GPU_ARCH settings for different GPU hardware is as follows:</p>
<ul class="simple">
<li><p>sm_12 or sm_13 for GT200 (supported by CUDA 3.2 until CUDA 6.5)</p></li>
<li><p>sm_20 or sm_21 for Fermi (supported by CUDA 3.2 until CUDA 7.5)</p></li>
<li><p>sm_30 or sm_35 or sm_37 for Kepler (supported since CUDA 5)</p></li>
<li><p>sm_50 or sm_52 for Maxwell (supported since CUDA 6)</p></li>
<li><p>sm_60 or sm_61 for Pascal (supported since CUDA 8)</p></li>
<li><p>sm_70 for Volta (supported since CUDA 9)</p></li>
<li><p>sm_75 for Turing (supported since CUDA 10)</p></li>
</ul>
<p>A more detailed list can be found, for example,
at <a class="reference external" href="https://en.wikipedia.org/wiki/CUDA#GPUs_supported">Wikipedia’s CUDA article</a></p>
<p>CMake can detect which version of the CUDA toolkit is used and thus can
include support for <strong>all</strong> major GPU architectures supported by this toolkit.
Thus the GPU_ARCH setting is merely an optimization, to have code for
the preferred GPU architecture directly included rather than having to wait
for the JIT compiler of the CUDA driver to translate it.</p>
<p><strong>Traditional make</strong>:</p>
<p>Before building LAMMPS, you must build the GPU library in <code class="docutils literal notranslate"><span class="pre">lib/gpu</span></code>.
You can do this manually if you prefer; follow the instructions in
<code class="docutils literal notranslate"><span class="pre">lib/gpu/README</span></code>.  Note that the GPU library uses MPI calls, so you must
use the same MPI library (or the STUBS library) settings as the main
LAMMPS code.  This also applies to the <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_BIGBIG</span></code>,
<code class="docutils literal notranslate"><span class="pre">-DLAMMPS_SMALLBIG</span></code>, or <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_SMALLSMALL</span></code> settings in whichever
Makefile you use.</p>
<p>You can also build the library in one step from the <code class="docutils literal notranslate"><span class="pre">lammps/src</span></code> dir,
using a command like these, which simply invoke the <code class="docutils literal notranslate"><span class="pre">lib/gpu/Install.py</span></code>
script with the specified args:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ make lib-gpu               <span class="c1"># print help message</span>
$ make lib-gpu <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-b&quot;</span>     <span class="c1"># build GPU library with default Makefile.linux</span>
$ make lib-gpu <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-m xk7 -p single -o xk7.single&quot;</span>  <span class="c1"># create new Makefile.xk7.single, altered for single-precision</span>
$ make lib-gpu <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-m mpi -a sm_60 -p mixed -b&quot;</span> <span class="c1"># build GPU library with mixed precision and P100 using other settings in Makefile.mpi</span>
</pre></div>
</div>
<p>Note that this procedure starts with a Makefile.machine in lib/gpu, as
specified by the “-m” switch.  For your convenience, machine makefiles
for “mpi” and “serial” are provided, which have the same settings as
the corresponding machine makefiles in the main LAMMPS source
folder. In addition you can alter 4 important settings in the
Makefile.machine you start from via the corresponding -c, -a, -p, -e
switches (as in the examples above), and also save a copy of the new
Makefile if desired:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">CUDA_HOME</span></code> = where NVIDIA CUDA software is installed on your system</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CUDA_ARCH</span></code> = sm_XX, what GPU hardware you have, same as CMake GPU_ARCH above</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CUDA_PRECISION</span></code> = precision (double, mixed, single)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EXTRAMAKE</span></code> = which Makefile.lammps.* file to copy to Makefile.lammps</p></li>
</ul>
<p>The file Makefile.linux_multi is set up to include support for multiple
GPU architectures as supported by the CUDA toolkit in use. This is done
through using the “–gencode ” flag, which can be used multiple times and
thus support all GPU architectures supported by your CUDA compiler.</p>
<p>If the library build is successful, 3 files should be created:
<code class="docutils literal notranslate"><span class="pre">lib/gpu/libgpu.a</span></code>, <code class="docutils literal notranslate"><span class="pre">lib/gpu/nvc_get_devices</span></code>, and
<code class="docutils literal notranslate"><span class="pre">lib/gpu/Makefile.lammps</span></code>.  The latter has settings that enable LAMMPS
to link with CUDA libraries.  If the settings in <code class="docutils literal notranslate"><span class="pre">Makefile.lammps</span></code> for
your machine are not correct, the LAMMPS build will fail, and
<code class="docutils literal notranslate"><span class="pre">lib/gpu/Makefile.lammps</span></code> may need to be edited.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you re-build the GPU library in lib/gpu, you should always
un-install the GPU package in lammps/src, then re-install it and
re-build LAMMPS.  This is because the compilation of files in the GPU
package uses the library settings from the lib/gpu/Makefile.machine
used to build the GPU library.</p>
</div>
<hr class="docutils" />
</div>
<div class="section" id="kim-package">
<span id="kim"></span><h2><span class="section-number">3.7.3. </span>KIM package</h2>
<p>To build with this package, the KIM library with API v2 must be downloaded
and built on your system. It must include the KIM models that you want to
use with LAMMPS.</p>
<p>If you would like to use the <a class="reference internal" href="kim_commands.html"><span class="doc">kim_query</span></a>
command, you also need to have libcurl installed with the matching
development headers and the curl-config tool.</p>
<p>If you would like to use the <a class="reference internal" href="kim_commands.html"><span class="doc">kim_property</span></a>
command, you need to build LAMMPS with the Python 3.6 or later package
installed. See the <a class="reference internal" href="python.html"><span class="doc">Python</span></a> doc page for more info on building
LAMMPS with the version of Python on your system.
After successfully building LAMMPS with Python, you need to
install the kim-property Python package, which can be easily done using
<em>pip</em> as <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">kim-property</span></code>, or from the <em>conda-forge</em> channel as
<code class="docutils literal notranslate"><span class="pre">conda</span> <span class="pre">install</span> <span class="pre">kim-property</span></code> if LAMMPS is built in Conda. More detailed
information is available at:
<a class="reference external" href="https://github.com/openkim/kim-property#installing-kim-property">kim-property installation</a>.</p>
<p>In addition to installing the KIM API, it is also necessary to install the
library of KIM models (interatomic potentials).
See <a class="reference external" href="http://openkim.org/doc/usage/obtaining-models">Obtaining KIM Models</a> to
learn how to install a pre-build binary of the OpenKIM Repository of Models.
See the list of all KIM models here: <a class="reference external" href="https://openkim.org/browse/models">https://openkim.org/browse/models</a></p>
<p>(Also note that when downloading and installing from source
the KIM API library with all its models, may take a long time (tens of
minutes to hours) to build.  Of course you only need to do that once.)</p>
<p><strong>CMake build</strong>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>-D <span class="nv">DOWNLOAD_KIM</span><span class="o">=</span>value           <span class="c1"># download OpenKIM API v2 for build, value = no (default) or yes</span>
-D <span class="nv">LMP_DEBUG_CURL</span><span class="o">=</span>value         <span class="c1"># set libcurl verbose mode on/off, value = off (default) or on</span>
-D <span class="nv">LMP_NO_SSL_CHECK</span><span class="o">=</span>value       <span class="c1"># tell libcurl to not verify the peer, value = no (default) or yes</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">DOWNLOAD_KIM</span></code> is set, the KIM library will be downloaded and built
inside the CMake build directory.  If the KIM library is already on
your system (in a location CMake cannot find it), set the <code class="docutils literal notranslate"><span class="pre">PKG_CONFIG_PATH</span></code>
environment variable so that libkim-api can be found.</p>
<p><em>For using OpenKIM web queries in LAMMPS</em>:</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">LMP_DEBUG_CURL</span></code> environment variable is set, the libcurl verbose
mode will be on, and any libcurl calls within the KIM web query display a
lot of information about libcurl operations.  You hardly ever want this
set in production use, you will almost always want this when you debug or
report problems.</p>
<p>The libcurl performs peer SSL certificate verification by default. This
verification is done using a CA certificate store that the SSL library can
use to make sure the peer’s server certificate is valid. If SSL reports an
error (“certificate verify failed”) during the handshake and thus refuses
further communication with that server, you can set <code class="docutils literal notranslate"><span class="pre">LMP_NO_SSL_CHECK</span></code>.
If <code class="docutils literal notranslate"><span class="pre">LMP_NO_SSL_CHECK</span></code> is set, libcurl does not verify the peer and connection
succeeds regardless of the names in the certificate. This option is insecure.
As an alternative, you can specify your own CA cert path by setting the
environment variable <code class="docutils literal notranslate"><span class="pre">CURL_CA_BUNDLE</span></code> to the path of your choice. A call
to the KIM web query would get this value from the environmental variable.</p>
<p><strong>Traditional make</strong>:</p>
<p>You can download and build the KIM library manually if you prefer;
follow the instructions in <code class="docutils literal notranslate"><span class="pre">lib/kim/README</span></code>.  You can also do it in one
step from the lammps/src dir, using a command like these, which simply
invoke the <code class="docutils literal notranslate"><span class="pre">lib/kim/Install.py</span></code> script with the specified args.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ make lib-kim              <span class="c1"># print help message</span>
$ make lib-kim <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-b &quot;</span>   <span class="c1"># (re-)install KIM API lib with only example models</span>
$ make lib-kim <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-b -a Glue_Ercolessi_Adams_Al__MO_324507536345_001&quot;</span>  <span class="c1"># ditto plus one model</span>
$ make lib-kim <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-b -a everything&quot;</span>     <span class="c1"># install KIM API lib with all models</span>
$ make lib-kim <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-n -a EAM_Dynamo_Ackland_W__MO_141627196590_002&quot;</span>       <span class="c1"># add one model or model driver</span>
$ make lib-kim <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-p /usr/local&quot;</span> <span class="c1"># use an existing KIM API installation at the provided location</span>
$ make lib-kim <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-p /usr/local -a EAM_Dynamo_Ackland_W__MO_141627196590_002&quot;</span> <span class="c1"># ditto but add one model or driver</span>
</pre></div>
</div>
<p>Settings for OpenKIM web queries discussed above need to be applied by adding
them to the <code class="docutils literal notranslate"><span class="pre">LMP_INC</span></code> variable through editing the Makefile.machine you are
using.  For example:</p>
<div class="highlight-make notranslate"><div class="highlight"><pre><span></span><span class="nv">LMP_INC</span> <span class="o">=</span>       -DLMP_NO_SSL_CHECK
</pre></div>
</div>
<hr class="docutils" />
</div>
<div class="section" id="kokkos-package">
<span id="kokkos"></span><h2><span class="section-number">3.7.4. </span>KOKKOS package</h2>
<p>To build with this package, you must choose which hardware you want to
build for, either CPUs (multi-threading via OpenMP) or KNLs (OpenMP)
or GPUs (NVIDIA Cuda).</p>
<p>For a CMake or make build, these are the possible choices for the
<code class="docutils literal notranslate"><span class="pre">KOKKOS_ARCH</span></code> settings described below.  Note that for CMake, these are
really Kokkos variables, not LAMMPS variables.  Hence you must use
case-sensitive values, e.g. BDW, not bdw.</p>
<ul class="simple">
<li><p>AMDAVX = AMD 64-bit x86 CPUs</p></li>
<li><p>EPYC   = AMD EPYC Zen class CPUs</p></li>
<li><p>ARMv80 = ARMv8.0 Compatible CPU</p></li>
<li><p>ARMv81 = ARMv8.1 Compatible CPU</p></li>
<li><p>ARMv8-ThunderX = ARMv8 Cavium ThunderX CPU</p></li>
<li><p>ARMv8-TX2 = ARMv8 Cavium ThunderX2 CPU</p></li>
<li><p>WSM = Intel Westmere CPUs</p></li>
<li><p>SNB = Intel Sandy/Ivy Bridge CPUs</p></li>
<li><p>HSW = Intel Haswell CPUs</p></li>
<li><p>BDW = Intel Broadwell Xeon E-class CPUs</p></li>
<li><p>SKX = Intel Sky Lake Xeon E-class HPC CPUs (AVX512)</p></li>
<li><p>KNC = Intel Knights Corner Xeon Phi</p></li>
<li><p>KNL = Intel Knights Landing Xeon Phi</p></li>
<li><p>BGQ = IBM Blue Gene/Q CPUs</p></li>
<li><p>Power7 = IBM POWER8 CPUs</p></li>
<li><p>Power8 = IBM POWER8 CPUs</p></li>
<li><p>Power9 = IBM POWER9 CPUs</p></li>
<li><p>Kepler = NVIDIA Kepler default (generation CC 3.5)</p></li>
<li><p>Kepler30 = NVIDIA Kepler generation CC 3.0</p></li>
<li><p>Kepler32 = NVIDIA Kepler generation CC 3.2</p></li>
<li><p>Kepler35 = NVIDIA Kepler generation CC 3.5</p></li>
<li><p>Kepler37 = NVIDIA Kepler generation CC 3.7</p></li>
<li><p>Maxwell = NVIDIA Maxwell default (generation CC 5.0)</p></li>
<li><p>Maxwell50 = NVIDIA Maxwell generation CC 5.0</p></li>
<li><p>Maxwell52 = NVIDIA Maxwell generation CC 5.2</p></li>
<li><p>Maxwell53 = NVIDIA Maxwell generation CC 5.3</p></li>
<li><p>Pascal60 = NVIDIA Pascal generation CC 6.0</p></li>
<li><p>Pascal61 = NVIDIA Pascal generation CC 6.1</p></li>
<li><p>Volta70 = NVIDIA Volta generation CC 7.0</p></li>
<li><p>Volta72 = NVIDIA Volta generation CC 7.2</p></li>
<li><p>Turing75 = NVIDIA Turing generation CC 7.5</p></li>
</ul>
<p><strong>CMake build</strong>:</p>
<p>For multicore CPUs using OpenMP, set these 2 variables.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>-D <span class="nv">KOKKOS_ARCH</span><span class="o">=</span>archCPU         <span class="c1"># archCPU = CPU from list above</span>
-D <span class="nv">KOKKOS_ENABLE_OPENMP</span><span class="o">=</span>yes
</pre></div>
</div>
<p>For Intel KNLs using OpenMP, set these 2 variables:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>-D <span class="nv">KOKKOS_ARCH</span><span class="o">=</span>KNL
-D <span class="nv">KOKKOS_ENABLE_OPENMP</span><span class="o">=</span>yes
</pre></div>
</div>
<p>For NVIDIA GPUs using CUDA, set these 4 variables:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>-D <span class="nv">KOKKOS_ARCH</span><span class="o">=</span><span class="s2">&quot;archCPU;archGPU&quot;</span>   <span class="c1"># archCPU = CPU from list above that is hosting the GPU</span>
                                   <span class="c1"># archGPU = GPU from list above</span>
-D <span class="nv">KOKKOS_ENABLE_CUDA</span><span class="o">=</span>yes
-D <span class="nv">KOKKOS_ENABLE_OPENMP</span><span class="o">=</span>yes
-D <span class="nv">CMAKE_CXX_COMPILER</span><span class="o">=</span>wrapper      <span class="c1"># wrapper = full path to Cuda nvcc wrapper</span>
</pre></div>
</div>
<p>The wrapper value is the Cuda nvcc compiler wrapper provided in the
Kokkos library: <code class="docutils literal notranslate"><span class="pre">lib/kokkos/bin/nvcc_wrapper</span></code>.  The setting should
include the full path name to the wrapper, e.g.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>-D <span class="nv">CMAKE_CXX_COMPILER</span><span class="o">=</span>/home/username/lammps/lib/kokkos/bin/nvcc_wrapper
</pre></div>
</div>
<p><strong>Traditional make</strong>:</p>
<p>Choose which hardware to support in <code class="docutils literal notranslate"><span class="pre">Makefile.machine</span></code> via
<code class="docutils literal notranslate"><span class="pre">KOKKOS_DEVICES</span></code> and <code class="docutils literal notranslate"><span class="pre">KOKKOS_ARCH</span></code> settings.  See the
<code class="docutils literal notranslate"><span class="pre">src/MAKE/OPTIONS/Makefile.kokkos\*</span></code> files for examples.</p>
<p>For multicore CPUs using OpenMP:</p>
<div class="highlight-make notranslate"><div class="highlight"><pre><span></span><span class="nv">KOKKOS_DEVICES</span> <span class="o">=</span> OpenMP
<span class="nv">KOKKOS_ARCH</span> <span class="o">=</span> archCPU      <span class="c1"># archCPU = CPU from list above</span>
</pre></div>
</div>
<p>For Intel KNLs using OpenMP:</p>
<div class="highlight-make notranslate"><div class="highlight"><pre><span></span><span class="nv">KOKKOS_DEVICES</span> <span class="o">=</span> OpenMP
<span class="nv">KOKKOS_ARCH</span> <span class="o">=</span> KNL
</pre></div>
</div>
<p>For NVIDIA GPUs using CUDA:</p>
<div class="highlight-make notranslate"><div class="highlight"><pre><span></span><span class="nv">KOKKOS_DEVICES</span> <span class="o">=</span> Cuda
<span class="nv">KOKKOS_ARCH</span> <span class="o">=</span> archCPU,archGPU    <span class="c1"># archCPU = CPU from list above that is hosting the GPU</span>
<span class="c">                                 # archGPU = GPU from list above</span>
<span class="nv">FFT_INC</span> <span class="o">=</span> -DFFT_CUFFT            <span class="c1"># enable use of cuFFT (optional)</span>
<span class="nv">FFT_LIB</span> <span class="o">=</span> -lcufft                <span class="c1"># link to cuFFT library</span>
</pre></div>
</div>
<p>For GPUs, you also need the following 2 lines in your Makefile.machine
before the CC line is defined, in this case for use with OpenMPI mpicxx.
The 2 lines define a nvcc wrapper compiler, which will use nvcc for
compiling CUDA files and use a C++ compiler for non-Kokkos, non-CUDA
files.</p>
<div class="highlight-make notranslate"><div class="highlight"><pre><span></span><span class="nv">KOKKOS_ABSOLUTE_PATH</span> <span class="o">=</span> <span class="k">$(</span>shell <span class="nb">cd</span> <span class="k">$(</span>KOKKOS_PATH<span class="k">)</span><span class="p">;</span> <span class="nb">pwd</span><span class="k">)</span>
<span class="k">export </span><span class="nv">OMPI_CXX</span> <span class="o">=</span> <span class="k">$(</span>KOKKOS_ABSOLUTE_PATH<span class="k">)</span>/config/nvcc_wrapper
<span class="nv">CC</span> <span class="o">=</span>            mpicxx
</pre></div>
</div>
<hr class="docutils" />
</div>
<div class="section" id="latte-package">
<span id="latte"></span><h2><span class="section-number">3.7.5. </span>LATTE package</h2>
<p>To build with this package, you must download and build the LATTE
library.</p>
<p><strong>CMake build</strong>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>-D <span class="nv">DOWNLOAD_LATTE</span><span class="o">=</span>value    <span class="c1"># download LATTE for build, value = no (default) or yes</span>
-D <span class="nv">LATTE_LIBRARY</span><span class="o">=</span>path      <span class="c1"># LATTE library file (only needed if a custom location)</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">DOWNLOAD_LATTE</span></code> is set, the LATTE library will be downloaded and
built inside the CMake build directory.  If the LATTE library is
already on your system (in a location CMake cannot find it),
<code class="docutils literal notranslate"><span class="pre">LATTE_LIBRARY</span></code> is the filename (plus path) of the LATTE library file,
not the directory the library file is in.</p>
<p><strong>Traditional make</strong>:</p>
<p>You can download and build the LATTE library manually if you prefer;
follow the instructions in <code class="docutils literal notranslate"><span class="pre">lib/latte/README</span></code>.  You can also do it in
one step from the <code class="docutils literal notranslate"><span class="pre">lammps/src</span></code> dir, using a command like these, which
simply invokes the <code class="docutils literal notranslate"><span class="pre">lib/latte/Install.py</span></code> script with the specified
args:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ make lib-latte                          <span class="c1"># print help message</span>
$ make lib-latte <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-b&quot;</span>                <span class="c1"># download and build in lib/latte/LATTE-master</span>
$ make lib-latte <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-p </span><span class="nv">$HOME</span><span class="s2">/latte&quot;</span>    <span class="c1"># use existing LATTE installation in $HOME/latte</span>
$ make lib-latte <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-b -m gfortran&quot;</span>    <span class="c1"># download and build in lib/latte and</span>
                                         <span class="c1">#   copy Makefile.lammps.gfortran to Makefile.lammps</span>
</pre></div>
</div>
<p>Note that 3 symbolic (soft) links, “includelink” and “liblink” and
“filelink.o”, are created in lib/latte to point into the LATTE home
dir.  When LAMMPS itself is built it will use these links.  You should
also check that the Makefile.lammps file you create is appropriate for
the compiler you use on your system to build LATTE.</p>
<hr class="docutils" />
</div>
<div class="section" id="message-package">
<span id="message"></span><h2><span class="section-number">3.7.6. </span>MESSAGE package</h2>
<p>This package can optionally include support for messaging via sockets,
using the open-source <a class="reference external" href="http://zeromq.org">ZeroMQ library</a>, which must
be installed on your system.</p>
<p><strong>CMake build</strong>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>-D <span class="nv">MESSAGE_ZMQ</span><span class="o">=</span>value    <span class="c1"># build with ZeroMQ support, value = no (default) or yes</span>
-D <span class="nv">ZMQ_LIBRARY</span><span class="o">=</span>path     <span class="c1"># ZMQ library file (only needed if a custom location)</span>
-D <span class="nv">ZMQ_INCLUDE_DIR</span><span class="o">=</span>path <span class="c1"># ZMQ include directory (only needed if a custom location)</span>
</pre></div>
</div>
<p><strong>Traditional make</strong>:</p>
<p>Before building LAMMPS, you must build the CSlib library in
<code class="docutils literal notranslate"><span class="pre">lib/message</span></code>.  You can build the CSlib library manually if you prefer;
follow the instructions in <code class="docutils literal notranslate"><span class="pre">lib/message/README</span></code>.  You can also do it in
one step from the <code class="docutils literal notranslate"><span class="pre">lammps/src</span></code> dir, using a command like these, which
simply invoke the <code class="docutils literal notranslate"><span class="pre">lib/message/Install.py</span></code> script with the specified args:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ make lib-message               <span class="c1"># print help message</span>
$ make lib-message <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-m -z&quot;</span>  <span class="c1"># build with MPI and socket (ZMQ) support</span>
$ make lib-message <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-s&quot;</span>     <span class="c1"># build as serial lib with no ZMQ support</span>
</pre></div>
</div>
<p>The build should produce two files: <code class="docutils literal notranslate"><span class="pre">lib/message/cslib/src/libmessage.a</span></code>
and <code class="docutils literal notranslate"><span class="pre">lib/message/Makefile.lammps</span></code>.  The latter is copied from an
existing <code class="docutils literal notranslate"><span class="pre">Makefile.lammps.\*</span></code> and has settings to link with the ZeroMQ
library if requested in the build.</p>
<hr class="docutils" />
</div>
<div class="section" id="mscg-package">
<span id="mscg"></span><h2><span class="section-number">3.7.7. </span>MSCG package</h2>
<p>To build with this package, you must download and build the MS-CG
library.  Building the MS-CG library requires that the GSL
(GNU Scientific Library) headers and libraries are installed on your
machine.  See the <code class="docutils literal notranslate"><span class="pre">lib/mscg/README</span></code> and <code class="docutils literal notranslate"><span class="pre">MSCG/Install</span></code> files for
more details.</p>
<p><strong>CMake build</strong>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>-D <span class="nv">DOWNLOAD_MSCG</span><span class="o">=</span>value    <span class="c1"># download MSCG for build, value = no (default) or yes</span>
-D <span class="nv">MSCG_LIBRARY</span><span class="o">=</span>path      <span class="c1"># MSCG library file (only needed if a custom location)</span>
-D <span class="nv">MSCG_INCLUDE_DIR</span><span class="o">=</span>path  <span class="c1"># MSCG include directory (only needed if a custom location)</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">DOWNLOAD_MSCG</span></code> is set, the MSCG library will be downloaded and built
inside the CMake build directory.  If the MSCG library is already on
your system (in a location CMake cannot find it), <code class="docutils literal notranslate"><span class="pre">MSCG_LIBRARY</span></code> is the
filename (plus path) of the MSCG library file, not the directory the
library file is in.  <code class="docutils literal notranslate"><span class="pre">MSCG_INCLUDE_DIR</span></code> is the directory the MSCG
include file is in.</p>
<p><strong>Traditional make</strong>:</p>
<p>You can download and build the MS-CG library manually if you prefer;
follow the instructions in <code class="docutils literal notranslate"><span class="pre">lib/mscg/README</span></code>.  You can also do it in one
step from the <code class="docutils literal notranslate"><span class="pre">lammps/src</span></code> dir, using a command like these, which simply
invoke the <code class="docutils literal notranslate"><span class="pre">lib/mscg/Install.py</span></code> script with the specified args:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ make lib-mscg             <span class="c1"># print help message</span>
$ make lib-mscg <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-b -m serial&quot;</span>   <span class="c1"># download and build in lib/mscg/MSCG-release-master</span>
                                     <span class="c1"># with the settings compatible with &quot;make serial&quot;</span>
$ make lib-mscg <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-b -m mpi&quot;</span>      <span class="c1"># download and build in lib/mscg/MSCG-release-master</span>
                                     <span class="c1"># with the settings compatible with &quot;make mpi&quot;</span>
$ make lib-mscg <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-p /usr/local/mscg-release&quot;</span> <span class="c1"># use the existing MS-CG installation in /usr/local/mscg-release</span>
</pre></div>
</div>
<p>Note that 2 symbolic (soft) links, “includelink” and “liblink”, will
be created in <code class="docutils literal notranslate"><span class="pre">lib/mscg</span></code> to point to the MS-CG <code class="docutils literal notranslate"><span class="pre">src/installation</span></code>
dir.  When LAMMPS is built in src it will use these links.  You should
not need to edit the <code class="docutils literal notranslate"><span class="pre">lib/mscg/Makefile.lammps</span></code> file.</p>
<hr class="docutils" />
</div>
<div class="section" id="opt-package">
<span id="opt"></span><h2><span class="section-number">3.7.8. </span>OPT package</h2>
<p><strong>CMake build</strong>:</p>
<p>No additional settings are needed besides <code class="docutils literal notranslate"><span class="pre">-D</span> <span class="pre">PKG_OPT=yes</span></code></p>
<p><strong>Traditional make</strong>:</p>
<p>The compile flag “-restrict” must be used to build LAMMPS with the OPT
package when using Intel compilers.  It should be added to the CCFLAGS
line of your Makefile.machine.  See src/MAKE/OPTIONS/Makefile.opt for
an example.</p>
<hr class="docutils" />
</div>
<div class="section" id="poems-package">
<span id="poems"></span><h2><span class="section-number">3.7.9. </span>POEMS package</h2>
<p><strong>CMake build</strong>:</p>
<p>No additional settings are needed besides <code class="docutils literal notranslate"><span class="pre">-D</span> <span class="pre">PKG_OPT=yes</span></code></p>
<p><strong>Traditional make</strong>:</p>
<p>Before building LAMMPS, you must build the POEMS library in <code class="docutils literal notranslate"><span class="pre">lib/poems</span></code>.
You can do this manually if you prefer; follow the instructions in
<code class="docutils literal notranslate"><span class="pre">lib/poems/README</span></code>.  You can also do it in one step from the <code class="docutils literal notranslate"><span class="pre">lammps/src</span></code>
dir, using a command like these, which simply invoke the
<code class="docutils literal notranslate"><span class="pre">lib/poems/Install.py</span></code> script with the specified args:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ make lib-poems                   <span class="c1"># print help message</span>
$ make lib-poems <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-m serial&quot;</span>  <span class="c1"># build with GNU g++ compiler (settings as with &quot;make serial&quot;)</span>
$ make lib-poems <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-m mpi&quot;</span>     <span class="c1"># build with default MPI C++ compiler (settings as with &quot;make mpi&quot;)</span>
$ make lib-poems <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-m icc&quot;</span>     <span class="c1"># build with Intel icc compiler</span>
</pre></div>
</div>
<p>The build should produce two files: <code class="docutils literal notranslate"><span class="pre">lib/poems/libpoems.a</span></code> and
<code class="docutils literal notranslate"><span class="pre">lib/poems/Makefile.lammps</span></code>.  The latter is copied from an existing
<code class="docutils literal notranslate"><span class="pre">Makefile.lammps.\*</span></code> and has settings needed to build LAMMPS with the
POEMS library (though typically the settings are just blank).  If
necessary, you can edit/create a new <code class="docutils literal notranslate"><span class="pre">lib/poems/Makefile.machine</span></code> file
for your system, which should define an <code class="docutils literal notranslate"><span class="pre">EXTRAMAKE</span></code> variable to specify
a corresponding <code class="docutils literal notranslate"><span class="pre">Makefile.lammps.machine</span></code> file.</p>
<hr class="docutils" />
</div>
<div class="section" id="python-package">
<span id="python"></span><h2><span class="section-number">3.7.10. </span>PYTHON package</h2>
<p>Building with the PYTHON package requires you have a Python shared
library available on your system, which needs to be a Python 2.7
version or a Python 3.x version.  See <code class="docutils literal notranslate"><span class="pre">lib/python/README</span></code> for more
details.</p>
<p><strong>CMake build</strong>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>-D <span class="nv">PYTHON_EXECUTABLE</span><span class="o">=</span>path   <span class="c1"># path to Python executable to use</span>
</pre></div>
</div>
<p>Without this setting, CMake will guess the default Python on your
system.  To use a different Python version, you can either create a
virtualenv, activate it and then run cmake.  Or you can set the
PYTHON_EXECUTABLE variable to specify which Python interpreter should
be used.  Note note that you will also need to have the development
headers installed for this version, e.g. python2-devel.</p>
<p><strong>Traditional make</strong>:</p>
<p>The build uses the <code class="docutils literal notranslate"><span class="pre">lib/python/Makefile.lammps</span></code> file in the compile/link
process to find Python.  You should only need to create a new
<code class="docutils literal notranslate"><span class="pre">Makefile.lammps.\*</span></code> file (and copy it to <code class="docutils literal notranslate"><span class="pre">Makefile.lammps</span></code>) if
the LAMMPS build fails.</p>
<hr class="docutils" />
</div>
<div class="section" id="voronoi-package">
<span id="voronoi"></span><h2><span class="section-number">3.7.11. </span>VORONOI package</h2>
<p>To build with this package, you must download and build the <a class="reference external" href="http://math.lbl.gov/voro++">Voro++ library</a>.</p>
<p><strong>CMake build</strong>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>-D <span class="nv">DOWNLOAD_VORO</span><span class="o">=</span>value    <span class="c1"># download Voro++ for build, value = no (default) or yes</span>
-D <span class="nv">VORO_LIBRARY</span><span class="o">=</span>path      <span class="c1"># Voro++ library file (only needed if at custom location)</span>
-D <span class="nv">VORO_INCLUDE_DIR</span><span class="o">=</span>path  <span class="c1"># Voro++ include directory (only needed if at custom location)</span>
</pre></div>
</div>
<p>If DOWNLOAD_VORO is set, the Voro++ library will be downloaded and
built inside the CMake build directory.  If the Voro++ library is
already on your system (in a location CMake cannot find it),
VORO_LIBRARY is the filename (plus path) of the Voro++ library file,
not the directory the library file is in.  VORO_INCLUDE_DIR is the
directory the Voro++ include file is in.</p>
<p><strong>Traditional make</strong>:</p>
<p>You can download and build the Voro++ library manually if you prefer;
follow the instructions in lib/voronoi/README.  You can also do it in
one step from the lammps/src dir, using a command like these, which
simply invoke the lib/voronoi/Install.py script with the specified
args:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ make lib-voronoi                          <span class="c1"># print help message</span>
$ make lib-voronoi <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-b&quot;</span>                <span class="c1"># download and build the default version in lib/voronoi/voro++-&lt;version&gt;</span>
$ make lib-voronoi <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-p </span><span class="nv">$HOME</span><span class="s2">/voro++&quot;</span>   <span class="c1"># use existing Voro++ installation in $HOME/voro++</span>
$ make lib-voronoi <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-b -v voro++0.4.6&quot;</span> <span class="c1"># download and build the 0.4.6 version in lib/voronoi/voro++-0.4.6</span>
</pre></div>
</div>
<p>Note that 2 symbolic (soft) links, “includelink” and “liblink”, are
created in lib/voronoi to point to the Voro++ src dir.  When LAMMPS
builds in src it will use these links.  You should not need to edit
the lib/voronoi/Makefile.lammps file.</p>
<hr class="docutils" />
</div>
<div class="section" id="user-adios-package">
<span id="user-adios"></span><h2><span class="section-number">3.7.12. </span>USER-ADIOS package</h2>
<p>The USER-ADIOS package requires the <a class="reference external" href="https://github.com/ornladios/ADIOS2">ADIOS I/O library</a>,
version 2.3.1 or newer. Make sure that you have ADIOS built either with or
without MPI to match if you build LAMMPS with or without MPI.
ADIOS compilation settings for LAMMPS are automatically detected, if the PATH
and LD_LIBRARY_PATH environment variables have been updated for the local ADIOS
installation and the instructions below are followed for the respective build systems.</p>
<p><strong>CMake build</strong>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>-D <span class="nv">ADIOS2_DIR</span><span class="o">=</span>path        <span class="c1"># path is where ADIOS 2.x is installed</span>
-D PKG_USER-ADIOS<span class="o">=</span>yes
</pre></div>
</div>
<p><strong>Traditional make</strong>:</p>
<p>Turn on the USER-ADIOS package before building LAMMPS. If the ADIOS 2.x software is installed in PATH, there is nothing else to do:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ make yes-user-adios
</pre></div>
</div>
<p>otherwise, set ADIOS2_DIR environment variable when turning on the package:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ <span class="nv">ADIOS2_DIR</span><span class="o">=</span>path make yes-user-adios   <span class="c1"># path is where ADIOS 2.x is installed</span>
</pre></div>
</div>
<hr class="docutils" />
</div>
<div class="section" id="user-atc-package">
<span id="user-atc"></span><h2><span class="section-number">3.7.13. </span>USER-ATC package</h2>
<p>The USER-ATC package requires the MANYBODY package also be installed.</p>
<p><strong>CMake build</strong>:</p>
<p>No additional settings are needed besides “-D PKG_USER-ATC=yes”
and “-D PKG_MANYBODY=yes”.</p>
<p><strong>Traditional make</strong>:</p>
<p>Before building LAMMPS, you must build the ATC library in lib/atc.
You can do this manually if you prefer; follow the instructions in
lib/atc/README.  You can also do it in one step from the lammps/src
dir, using a command like these, which simply invoke the
lib/atc/Install.py script with the specified args:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ make lib-atc                      <span class="c1"># print help message</span>
$ make lib-atc <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-m serial&quot;</span>     <span class="c1"># build with GNU g++ compiler and MPI STUBS (settings as with &quot;make serial&quot;)</span>
$ make lib-atc <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-m mpi&quot;</span>        <span class="c1"># build with default MPI compiler (settings as with &quot;make mpi&quot;)</span>
$ make lib-atc <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-m icc&quot;</span>        <span class="c1"># build with Intel icc compiler</span>
</pre></div>
</div>
<p>The build should produce two files: lib/atc/libatc.a and
lib/atc/Makefile.lammps.  The latter is copied from an existing
Makefile.lammps.* and has settings needed to build LAMMPS with the ATC
library.  If necessary, you can edit/create a new
lib/atc/Makefile.machine file for your system, which should define an
EXTRAMAKE variable to specify a corresponding Makefile.lammps.machine
file.</p>
<p>Note that the Makefile.lammps file has settings for the BLAS and
LAPACK linear algebra libraries.  As explained in lib/atc/README these
can either exist on your system, or you can use the files provided in
lib/linalg.  In the latter case you also need to build the library in
lib/linalg with a command like these:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ make lib-linalg                     <span class="c1"># print help message</span>
$ make lib-linalg <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-m serial&quot;</span>    <span class="c1"># build with GNU Fortran compiler (settings as with &quot;make serial&quot;)</span>
$ make lib-linalg <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-m mpi&quot;</span>       <span class="c1"># build with default MPI Fortran compiler (settings as with &quot;make mpi&quot;)</span>
$ make lib-linalg <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-m gfortran&quot;</span>  <span class="c1"># build with GNU Fortran compiler</span>
</pre></div>
</div>
<hr class="docutils" />
</div>
<div class="section" id="user-awpmd-package">
<span id="user-awpmd"></span><h2><span class="section-number">3.7.14. </span>USER-AWPMD package</h2>
<p><strong>CMake build</strong>:</p>
<p>No additional settings are needed besides “-D PKG_USER-AQPMD=yes”.</p>
<p><strong>Traditional make</strong>:</p>
<p>Before building LAMMPS, you must build the AWPMD library in lib/awpmd.
You can do this manually if you prefer; follow the instructions in
lib/awpmd/README.  You can also do it in one step from the lammps/src
dir, using a command like these, which simply invoke the
lib/awpmd/Install.py script with the specified args:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ make lib-awpmd                   <span class="c1"># print help message</span>
$ make lib-awpmd <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-m serial&quot;</span>  <span class="c1"># build with GNU g++ compiler and MPI STUBS (settings as with &quot;make serial&quot;)</span>
$ make lib-awpmd <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-m mpi&quot;</span>     <span class="c1"># build with default MPI compiler (settings as with &quot;make mpi&quot;)</span>
$ make lib-awpmd <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-m icc&quot;</span>     <span class="c1"># build with Intel icc compiler</span>
</pre></div>
</div>
<p>The build should produce two files: lib/awpmd/libawpmd.a and
lib/awpmd/Makefile.lammps.  The latter is copied from an existing
Makefile.lammps.* and has settings needed to build LAMMPS with the
AWPMD library.  If necessary, you can edit/create a new
lib/awpmd/Makefile.machine file for your system, which should define
an EXTRAMAKE variable to specify a corresponding
Makefile.lammps.machine file.</p>
<p>Note that the Makefile.lammps file has settings for the BLAS and
LAPACK linear algebra libraries.  As explained in lib/awpmd/README
these can either exist on your system, or you can use the files
provided in lib/linalg.  In the latter case you also need to build the
library in lib/linalg with a command like these:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ make lib-linalg                     <span class="c1"># print help message</span>
$ make lib-linalg <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-m serial&quot;</span>    <span class="c1"># build with GNU Fortran compiler (settings as with &quot;make serial&quot;)</span>
$ make lib-linalg <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-m mpi&quot;</span>       <span class="c1"># build with default MPI Fortran compiler (settings as with &quot;make mpi&quot;)</span>
$ make lib-linalg <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-m gfortran&quot;</span>  <span class="c1"># build with GNU Fortran compiler</span>
</pre></div>
</div>
<hr class="docutils" />
</div>
<div class="section" id="user-colvars-package">
<span id="user-colvars"></span><h2><span class="section-number">3.7.15. </span>USER-COLVARS package</h2>
<p>This package includes into the LAMMPS distribution the Colvars library, which
can be built for the most part with all major versions of the C++ language.</p>
<p>A few of the most recent features require C++11 support.  In particular, the
library is optionally built together with the
<a class="reference external" href="https://simtk.org/projects/lepton">Lepton</a> library, a copy of which is also
included in the LAMMPS distribution.  Lepton implements the
<a class="reference external" href="http://colvars.github.io/colvars-refman-lammps/colvars-refman-lammps.html#colvar|customFunction">customFunction</a>
feature, and requires C++11 support.</p>
<p>See <a class="reference external" href="https://colvars.github.io/README-c++11.html">here</a> for a detailed list of
C++11-only features.</p>
<p><strong>CMake build</strong>:</p>
<p>This is the recommended build recipe: no additional settings are normally
needed besides “-D PKG_USER-COLVARS=yes”.</p>
<p>Building and linking of Lepton (or other C++11-only features) is enabled
automatically when compilation is carried out with C++11 support, and disabled
otherwise.  Optionally, Lepton build may be manually controlled with the flag
“-D COLVARS_LEPTON=yes|no”.</p>
<p><strong>Traditional make</strong>:</p>
<p>Before building LAMMPS, one must build the Colvars library in lib/colvars.</p>
<p>This can be done manually in the same folder by using or adapting one of the
provided Makefiles: for example, Makefile.g++ for the GNU compiler.</p>
<p>In general, it is safer to use build setting consistent with the rest of
LAMMPS.  This is best carried out from the LAMMPS src directory using a
command like these, which simply invoke the lib/colvars/Install.py script with
the specified args:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ make lib-colvars                      <span class="c1"># print help message</span>
$ make lib-colvars <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-m serial&quot;</span>     <span class="c1"># build with GNU g++ compiler (settings as with &quot;make serial&quot;)</span>
$ make lib-colvars <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-m mpi&quot;</span>        <span class="c1"># build with default MPI compiler (settings as with &quot;make mpi&quot;)</span>
$ make lib-colvars <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-m g++-debug&quot;</span>  <span class="c1"># build with GNU g++ compiler and colvars debugging enabled</span>
</pre></div>
</div>
<p>The “machine” argument of the “-m” flag is used to find a Makefile.machine to
use as build recipe.  If it does not already exist in lib/colvars, it will be
auto-generated by using compiler flags consistent with those parsed from the
core LAMMPS makefiles.</p>
<p>Optional flags may be specified as environment variables:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ <span class="nv">COLVARS_DEBUG</span><span class="o">=</span>yes make lib-colvars <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-m machine&quot;</span>  <span class="c1"># Build with debug code (much slower)</span>
$ <span class="nv">COLVARS_LEPTON</span><span class="o">=</span>no make lib-colvars <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-m machine&quot;</span>  <span class="c1"># Build without Lepton (included otherwise)</span>
</pre></div>
</div>
<p>The build should produce two files: the library lib/colvars/libcolvars.a
(which also includes Lepton objects if enabled) and the specification file
lib/colvars/Makefile.lammps.  The latter is auto-generated, and normally does
not need to be edited.</p>
<hr class="docutils" />
</div>
<div class="section" id="user-plumed-package">
<span id="user-plumed"></span><h2><span class="section-number">3.7.16. </span>USER-PLUMED package</h2>
<p>Before building LAMMPS with this package, you must first build PLUMED.
PLUMED can be built as part of the LAMMPS build or installed separately
from LAMMPS using the generic <a class="reference external" href="https://plumed.github.io/doc-master/user-doc/html/_installation.html">plumed installation instructions</a>.
The USER-PLUMED package has been tested to work with Plumed versions
2.4.x, 2.5.x, and 2.6.x and will error out, when trying to run calculations
with a different version of the Plumed kernel.</p>
<p>PLUMED can be linked into MD codes in three different modes: static,
shared, and runtime.  With the “static” mode, all the code that PLUMED
requires is linked statically into LAMMPS. LAMMPS is then fully
independent from the PLUMED installation, but you have to rebuild/relink
it in order to update the PLUMED code inside it.  With the “shared”
linkage mode, LAMMPS is linked to a shared library that contains the
PLUMED code.  This library should preferably be installed in a globally
accessible location. When PLUMED is linked in this way the same library
can be used by multiple MD packages.  Furthermore, the PLUMED library
LAMMPS uses can be updated without the need for a recompile of LAMMPS
for as long as the shared PLUMED library is ABI-compatible.</p>
<p>The third linkage mode is “runtime” which allows the user to specify
which PLUMED kernel should be used at runtime by using the PLUMED_KERNEL
environment variable. This variable should point to the location of the
libplumedKernel.so dynamical shared object, which is then loaded at
runtime. This mode of linking is particularly convenient for doing
PLUMED development and comparing multiple PLUMED versions as these sorts
of comparisons can be done without recompiling the hosting MD code. All
three linkage modes are supported by LAMMPS on selected operating
systems (e.g. Linux) and using either CMake or traditional make
build. The “static” mode should be the most portable, while the
“runtime” mode support in LAMMPS makes the most assumptions about
operating system and compiler environment. If one mode does not work,
try a different one, switch to a different build system, consider a
global PLUMED installation or consider downloading PLUMED during the
LAMMPS build.</p>
<p><strong>CMake build</strong>:</p>
<p>When the “-D PKG_USER-PLUMED” flag is included in the cmake command you
must ensure that GSL is installed in locations that are specified in
your environment.  There are then two additional commands that control
the manner in which PLUMED is obtained and linked into LAMMPS.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>-D <span class="nv">DOWNLOAD_PLUMED</span><span class="o">=</span>value   <span class="c1"># download PLUMED for build, value = no (default) or yes</span>
-D <span class="nv">PLUMED_MODE</span><span class="o">=</span>value       <span class="c1"># Linkage mode for PLUMED, value = static (default), shared, or runtime</span>
</pre></div>
</div>
<p>If DOWNLOAD_PLUMED is set to “yes”, the PLUMED library will be
downloaded (the version of PLUMED that will be downloaded is hard-coded
to a vetted version of PLUMED, usually a recent stable release version)
and built inside the CMake build directory.  If DOWNLOAD_PLUMED is set
to “no” (the default), CMake will try to detect and link to an installed
version of PLUMED.  For this to work, the PLUMED library has to be
installed into a location where the pkg-config tool can find it or the
PKG_CONFIG_PATH environment variable has to be set up accordingly.
PLUMED should be installed in such a location if you compile it using
the default make; make install commands.</p>
<p>The PLUMED_MODE setting determines the linkage mode for the PLUMED
library.  The allowed values for this flag are “static” (default),
“shared”, or “runtime”.  For a discussion of PLUMED linkage modes,
please see above.  When DOWNLOAD_PLUMED is enabled the static linkage
mode is recommended.</p>
<p><strong>Traditional make</strong>:</p>
<p>PLUMED needs to be installed before the USER-PLUMED package is installed
so that LAMMPS can find the right settings when compiling and linking
the LAMMPS executable.  You can either download and build PLUMED inside
the LAMMPS plumed library folder or use a previously installed PLUMED
library and point LAMMPS to its location. You also have to choose the
linkage mode: “static” (default), “shared” or “runtime”.  For a
discussion of PLUMED linkage modes, please see above.</p>
<p>Download/compilation/configuration of the plumed library can be done
from the src folder through the following make args:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ make lib-plumed                         <span class="c1"># print help message</span>
$ make lib-plumed <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-b&quot;</span>               <span class="c1"># download and build PLUMED in lib/plumed/plumed2</span>
$ make lib-plumed <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-p </span><span class="nv">$HOME</span><span class="s2">/.local&quot;</span>  <span class="c1"># use existing PLUMED installation in $HOME/.local</span>
$ make lib-plumed <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-p /usr/local -m shared&quot;</span>  <span class="c1"># use existing PLUMED installation in</span>
                                                 <span class="c1"># /usr/local and use shared linkage mode</span>
</pre></div>
</div>
<p>Note that 2 symbolic (soft) links, “includelink” and “liblink” are
created in lib/plumed that point to the location of the PLUMED build to
use. A new file lib/plumed/Makefile.lammps is also created with settings
suitable for LAMMPS to compile and link PLUMED using the desired linkage
mode. After this step is completed, you can install the USER-PLUMED
package and compile LAMMPS in the usual manner:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ make yes-user-plumed
$ make machine
</pre></div>
</div>
<p>Once this compilation completes you should be able to run LAMMPS in the
usual way.  For shared linkage mode, libplumed.so must be found by the
LAMMPS executable, which on many operating systems means, you have to
set the LD_LIBRARY_PATH environment variable accordingly.</p>
<p>Support for the different linkage modes in LAMMPS varies for different
operating systems, using the static linkage is expected to be the most
portable, and thus set to be the default.</p>
<p>If you want to change the linkage mode, you have to re-run “make
lib-plumed” with the desired settings <strong>and</strong> do a re-install if the
USER-PLUMED package with “make yes-user-plumed” to update the required
makefile settings with the changes in the lib/plumed folder.</p>
<hr class="docutils" />
</div>
<div class="section" id="user-h5md-package">
<span id="user-h5md"></span><h2><span class="section-number">3.7.17. </span>USER-H5MD package</h2>
<p>To build with this package you must have the HDF5 software package
installed on your system, which should include the h5cc compiler and
the HDF5 library.</p>
<p><strong>CMake build</strong>:</p>
<p>No additional settings are needed besides “-D PKG_USER-H5MD=yes”.</p>
<p>This should auto-detect the H5MD library on your system.  Several
advanced CMake H5MD options exist if you need to specify where it is
installed.  Use the ccmake (terminal window) or cmake-gui (graphical)
tools to see these options and set them interactively from their user
interfaces.</p>
<p><strong>Traditional make</strong>:</p>
<p>Before building LAMMPS, you must build the CH5MD library in lib/h5md.
You can do this manually if you prefer; follow the instructions in
lib/h5md/README.  You can also do it in one step from the lammps/src
dir, using a command like these, which simply invoke the
lib/h5md/Install.py script with the specified args:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ make lib-h5md                     <span class="c1"># print help message</span>
$ make lib-h5md <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-m h5cc&quot;</span>      <span class="c1"># build with h5cc compiler</span>
</pre></div>
</div>
<p>The build should produce two files: lib/h5md/libch5md.a and
lib/h5md/Makefile.lammps.  The latter is copied from an existing
Makefile.lammps.* and has settings needed to build LAMMPS with the
system HDF5 library.  If necessary, you can edit/create a new
lib/h5md/Makefile.machine file for your system, which should define an
EXTRAMAKE variable to specify a corresponding Makefile.lammps.machine
file.</p>
<hr class="docutils" />
</div>
<div class="section" id="user-intel-package">
<span id="user-intel"></span><h2><span class="section-number">3.7.18. </span>USER-INTEL package</h2>
<p>To build with this package, you must choose which hardware you want to
build for, either x86 CPUs or Intel KNLs in offload mode.  You should
also typically <a class="reference internal" href="#user-omp"><span class="std std-ref">install the USER-OMP package</span></a>, as it can be
used in tandem with the USER-INTEL package to good effect, as explained
on the <a class="reference internal" href="Speed_intel.html"><span class="doc">Speed intel</span></a> doc page.</p>
<p><strong>CMake build</strong>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>-D <span class="nv">INTEL_ARCH</span><span class="o">=</span>value     <span class="c1"># value = cpu (default) or knl</span>
-D <span class="nv">INTEL_LRT_MODE</span><span class="o">=</span>value <span class="c1"># value = threads, none, or c++11</span>
</pre></div>
</div>
<p>In Long-range thread mode (LRT) a modified verlet style is used, that
operates the Kspace calculation in a separate thread concurrently to
other calculations. This has to be enabled in the <a class="reference internal" href="package.html"><span class="doc">package intel</span></a>
command at runtime. With the setting “threads” it used the pthreads
library, while c++11 will use the built-in thread support of C++11
compilers. The option “none” skips compilation of this feature. The
default is to use “threads” if pthreads is available and otherwise “none”.</p>
<p>Best performance is achieved with Intel hardware, Intel compilers, as well as
the Intel TBB and MKL libraries. However, the code also compiles, links, and
runs with other compilers and without TBB and MKL.</p>
<p><strong>Traditional make</strong>:</p>
<p>Choose which hardware to compile for in Makefile.machine via the
following settings.  See src/MAKE/OPTIONS/Makefile.intel_cpu* and
Makefile.knl files for examples. and src/USER-INTEL/README for
additional information.</p>
<p>For CPUs:</p>
<div class="highlight-make notranslate"><div class="highlight"><pre><span></span><span class="nv">OPTFLAGS</span> <span class="o">=</span>      -xHost -O2 -fp-model <span class="nv">fast</span><span class="o">=</span><span class="m">2</span> -no-prec-div -qoverride-limits -qopt-zmm-usage<span class="o">=</span>high
<span class="nv">CCFLAGS</span> <span class="o">=</span>       -g -qopenmp -DLAMMPS_MEMALIGN<span class="o">=</span><span class="m">64</span> -no-offload -fno-alias -ansi-alias -restrict <span class="k">$(</span>OPTFLAGS<span class="k">)</span>
<span class="nv">LINKFLAGS</span> <span class="o">=</span>     -g -qopenmp <span class="k">$(</span>OPTFLAGS<span class="k">)</span>
<span class="nv">LIB</span> <span class="o">=</span>           -ltbbmalloc
</pre></div>
</div>
<p>For KNLs:</p>
<div class="highlight-make notranslate"><div class="highlight"><pre><span></span><span class="nv">OPTFLAGS</span> <span class="o">=</span>      -xMIC-AVX512 -O2 -fp-model <span class="nv">fast</span><span class="o">=</span><span class="m">2</span> -no-prec-div -qoverride-limits
<span class="nv">CCFLAGS</span> <span class="o">=</span>       -g -qopenmp -DLAMMPS_MEMALIGN<span class="o">=</span><span class="m">64</span> -no-offload -fno-alias -ansi-alias -restrict <span class="k">$(</span>OPTFLAGS<span class="k">)</span>
<span class="nv">LINKFLAGS</span> <span class="o">=</span>     -g -qopenmp <span class="k">$(</span>OPTFLAGS<span class="k">)</span>
<span class="nv">LIB</span> <span class="o">=</span>           -ltbbmalloc
</pre></div>
</div>
<hr class="docutils" />
</div>
<div class="section" id="user-molfile-package">
<span id="user-molfile"></span><h2><span class="section-number">3.7.19. </span>USER-MOLFILE package</h2>
<p><strong>CMake build</strong>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>-D <span class="nv">MOLFILE_INCLUDE_DIRS</span><span class="o">=</span>path   <span class="c1"># (optional) path where VMD molfile plugin headers are installed</span>
-D PKG_USER-MOLFILE<span class="o">=</span>yes
</pre></div>
</div>
<p>Using “-D PKG_USER-MOLFILE=yes” enables the package, and setting
“-D MOLFILE_INCLUDE DIRS” allows to provide a custom location for
the molfile plugin header files. These should match the ABI of the
plugin files used, and thus one typically sets them to include
folder of the local VMD installation in use. LAMMPS ships with a
couple of default header files that correspond to a popular VMD
version, usually the latest release.</p>
<p><strong>Traditional make</strong>:</p>
<p>The lib/molfile/Makefile.lammps file has a setting for a dynamic
loading library libdl.a that is typically present on all systems.  It
is required for LAMMPS to link with this package.  If the setting is
not valid for your system, you will need to edit the Makefile.lammps
file.  See lib/molfile/README and lib/molfile/Makefile.lammps for
details. It is also possible to configure a different folder with
the VMD molfile plugin header files. LAMMPS ships with a couple of
default headers, but these are not compatible with all VMD versions,
so it is often best to change this setting to the location of the
same include files of the local VMD installation in use.</p>
<hr class="docutils" />
</div>
<div class="section" id="user-netcdf-package">
<span id="user-netcdf"></span><h2><span class="section-number">3.7.20. </span>USER-NETCDF package</h2>
<p>To build with this package you must have the NetCDF library installed
on your system.</p>
<p><strong>CMake build</strong>:</p>
<p>No additional settings are needed besides “-D PKG_USER-NETCDF=yes”.</p>
<p>This should auto-detect the NETCDF library if it is installed on your
system at standard locations.  Several advanced CMake NETCDF options
exist if you need to specify where it was installed.  Use the ccmake
(terminal window) or cmake-gui (graphical) tools to see these options
and set them interactively from their user interfaces.</p>
<p><strong>Traditional make</strong>:</p>
<p>The lib/netcdf/Makefile.lammps file has settings for NetCDF include
and library files which LAMMPS needs to build with this package.  If
the settings are not valid for your system, you will need to edit the
Makefile.lammps file.  See lib/netcdf/README for details.</p>
<hr class="docutils" />
</div>
<div class="section" id="user-omp-package">
<span id="user-omp"></span><h2><span class="section-number">3.7.21. </span>USER-OMP package</h2>
<p><strong>CMake build</strong>:</p>
<p>No additional settings are required besides “-D PKG_USER-OMP=yes”.  If
CMake detects OpenMP support, the USER-OMP code will be compiled with
multi-threading support enabled, otherwise as optimized serial code.</p>
<p><strong>Traditional make</strong>:</p>
<p>To enable multi-threading support in the USER-OMP package (and other
styles supporting OpenMP) the following compile and link flags must
be added to your Makefile.machine file.
See src/MAKE/OPTIONS/Makefile.omp for an example.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CCFLAGS: -fopenmp               # for GNU and Clang Compilers
CCFLAGS: -qopenmp -restrict     # for Intel compilers on Linux
LINKFLAGS: -fopenmp             # for GNU and Clang Compilers
LINKFLAGS: -qopenmp             # for Intel compilers on Linux
</pre></div>
</div>
<p>For other platforms and compilers, please consult the documentation
about OpenMP support for your compiler. Please see the note about
how to address compatibility <a class="reference internal" href="Build_basics.html#default-none-issues"><span class="std std-ref">issues with the ‘default(none)’ directive</span></a> of some compilers.</p>
<hr class="docutils" />
</div>
<div class="section" id="user-qmmm-package">
<span id="user-qmmm"></span><h2><span class="section-number">3.7.22. </span>USER-QMMM package</h2>
<p>For using LAMMPS to do QM/MM simulations via the USER-QMMM package you
need to build LAMMPS as a library.  A LAMMPS executable with fix qmmm
included can be built, but will not be able to do a QM/MM simulation
on as such.  You must also build a QM code - currently only Quantum
ESPRESSO (QE) is supported - and create a new executable which links
LAMMPS and the QM code together.  Details are given in the
lib/qmmm/README file.  It is also recommended to read the instructions
for <a class="reference internal" href="Build_link.html"><span class="doc">linking with LAMMPS as a library</span></a> for
background information.  This requires compatible Quantum Espresso
and LAMMPS versions.  The current interface and makefiles have last
been verified to work in February 2020 with Quantum Espresso versions
6.3 to 6.5.</p>
<p><strong>CMake build</strong>:</p>
<p>When using CMake, building a LAMMPS library is required and it is
recommended to build a shared library, since any libraries built from
the sources in the <em>lib</em> folder (including the essential libqmmm.a)
are not included in the static LAMMPS library and (currently) not
installed, while their code is included in the shared LAMMPS library.
Thus a typical command line to configure building LAMMPS for USER-QMMM
would be:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>cmake -C ../cmake/presets/minimal.cmake -D PKG_USER-QMMM<span class="o">=</span>yes <span class="se">\</span>
        -D <span class="nv">BUILD_LIB</span><span class="o">=</span>yes -DBUILD_SHARED_LIBS<span class="o">=</span>yes ../cmake
</pre></div>
</div>
<p>After completing the LAMMPS build and also configuring and compiling
Quantum ESPRESSO with external library support (via “make couple”),
go back to the lib/qmmm folder and follow the instructions on the
README file to build the combined LAMMPS/QE QM/MM executable
(pwqmmm.x) in the lib/qmmm folder.  You need to make certain, that</p>
<p><strong>Traditional make</strong>:</p>
<p>Before building LAMMPS, you must build the QMMM library in lib/qmmm.
You can do this manually if you prefer; follow the first two steps
explained in lib/qmmm/README.  You can also do it in one step from the
lammps/src dir, using a command like these, which simply invoke the
lib/qmmm/Install.py script with the specified args:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ make lib-qmmm                      <span class="c1"># print help message</span>
$ make lib-qmmm <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-m serial&quot;</span>     <span class="c1"># build with GNU Fortran compiler (settings as in &quot;make serial&quot;)</span>
$ make lib-qmmm <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-m mpi&quot;</span>        <span class="c1"># build with default MPI compiler (settings as in &quot;make mpi&quot;)</span>
$ make lib-qmmm <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-m gfortran&quot;</span>   <span class="c1"># build with GNU Fortran compiler</span>
</pre></div>
</div>
<p>The build should produce two files: lib/qmmm/libqmmm.a and
lib/qmmm/Makefile.lammps.  The latter is copied from an existing
Makefile.lammps.* and has settings needed to build LAMMPS with the
QMMM library (though typically the settings are just blank).  If
necessary, you can edit/create a new lib/qmmm/Makefile.machine file
for your system, which should define an EXTRAMAKE variable to specify
a corresponding Makefile.lammps.machine file.</p>
<p>You can then install QMMM package and build LAMMPS in the usual
manner.  After completing the LAMMPS build and compiling Quantum
ESPRESSO with external library support (via “make couple”), go back to
the lib/qmmm folder and follow the instructions in the README file to
build the combined LAMMPS/QE QM/MM executable (pwqmmm.x) in the
lib/qmmm folder.</p>
<hr class="docutils" />
</div>
<div class="section" id="user-quip-package">
<span id="user-quip"></span><h2><span class="section-number">3.7.23. </span>USER-QUIP package</h2>
<p>To build with this package, you must download and build the QUIP
library.  It can be obtained from GitHub.  For support of GAP
potentials, additional files with specific licensing conditions need
to be downloaded and configured.  See step 1 and step 1.1 in the
lib/quip/README file for details on how to do this.</p>
<p><strong>CMake build</strong>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>-D <span class="nv">QUIP_LIBRARY</span><span class="o">=</span>path     <span class="c1"># path to libquip.a (only needed if a custom location)</span>
</pre></div>
</div>
<p>CMake will not download and build the QUIP library.  But once you have
done that, a CMake build of LAMMPS with “-D PKG_USER-QUIP=yes” should
work.  Set QUIP_LIBRARY if CMake cannot find the QUIP library.</p>
<p><strong>Traditional make</strong>:</p>
<p>The download/build procedure for the QUIP library, described in
lib/quip/README file requires setting two environment variables,
QUIP_ROOT and QUIP_ARCH.  These are accessed by the
lib/quip/Makefile.lammps file which is used when you compile and link
LAMMPS with this package.  You should only need to edit
Makefile.lammps if the LAMMPS build can not use its settings to
successfully build on your system.</p>
<hr class="docutils" />
</div>
<div class="section" id="user-scafacos-package">
<span id="user-scafacos"></span><h2><span class="section-number">3.7.24. </span>USER-SCAFACOS package</h2>
<p>To build with this package, you must download and build the <a class="reference external" href="http://www.scafacos.de">ScaFaCoS Coulomb solver library</a></p>
<p><strong>CMake build</strong>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>-D <span class="nv">DOWNLOAD_SCAFACOS</span><span class="o">=</span>value    <span class="c1"># download ScaFaCoS for build, value = no (default) or yes</span>
-D <span class="nv">SCAFACOS_LIBRARY</span><span class="o">=</span>path      <span class="c1"># ScaFaCos library file (only needed if at custom location)</span>
-D <span class="nv">SCAFACOS_INCLUDE_DIR</span><span class="o">=</span>path  <span class="c1"># ScaFaCoS include directory (only needed if at custom location)</span>
</pre></div>
</div>
<p>If DOWNLOAD_SCAFACOS is set, the ScaFaCoS library will be downloaded
and built inside the CMake build directory.  If the ScaFaCoS library
is already on your system (in a location CMake cannot find it),
SCAFACOS_LIBRARY is the filename (plus path) of the ScaFaCoS library
file, not the directory the library file is in.  SCAFACOS_INCLUDE_DIR
is the directory the ScaFaCoS include file is in.</p>
<p><strong>Traditional make</strong>:</p>
<p>You can download and build the ScaFaCoS library manually if you
prefer; follow the instructions in lib/scafacos/README.  You can also
do it in one step from the lammps/src dir, using a command like these,
which simply invoke the lib/scafacos/Install.py script with the
specified args:</p>
<p>make lib-scafacos                         # print help message
make lib-scafacos args=”-b”               # download and build in lib/scafacos/scafacos-&lt;version&gt;
make lib-scafacos args=”-p $HOME/scafacos  # use existing ScaFaCoS installation in $HOME/scafacos</p>
<p>Note that 2 symbolic (soft) links, “includelink” and “liblink”, are
created in lib/scafacos to point to the ScaFaCoS src dir.  When LAMMPS
builds in src it will use these links.  You should not need to edit
the lib/scafacos/Makefile.lammps file.</p>
<hr class="docutils" />
</div>
<div class="section" id="user-smd-package">
<span id="user-smd"></span><h2><span class="section-number">3.7.25. </span>USER-SMD package</h2>
<p>To build with this package, you must download the Eigen3 library.
Eigen3 is a template library, so you do not need to build it.</p>
<p><strong>CMake build</strong>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>-D DOWNLOAD_EIGEN3            <span class="c1"># download Eigen3, value = no (default) or yes</span>
-D <span class="nv">EIGEN3_INCLUDE_DIR</span><span class="o">=</span>path    <span class="c1"># path to Eigen library (only needed if a custom location)</span>
</pre></div>
</div>
<p>If DOWNLOAD_EIGEN3 is set, the Eigen3 library will be downloaded and
inside the CMake build directory.  If the Eigen3 library is already on
your system (in a location CMake cannot find it), EIGEN3_INCLUDE_DIR
is the directory the Eigen3++ include file is in.</p>
<p><strong>Traditional make</strong>:</p>
<p>You can download the Eigen3 library manually if you prefer; follow the
instructions in lib/smd/README.  You can also do it in one step from
the lammps/src dir, using a command like these, which simply invoke
the lib/smd/Install.py script with the specified args:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ make lib-smd                         <span class="c1"># print help message</span>
$ make lib-smd <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-b&quot;</span>               <span class="c1"># download to lib/smd/eigen3</span>
$ make lib-smd <span class="nv">args</span><span class="o">=</span><span class="s2">&quot;-p /usr/include/eigen3&quot;</span>    <span class="c1"># use existing Eigen installation in /usr/include/eigen3</span>
</pre></div>
</div>
<p>Note that a symbolic (soft) link named “includelink” is created in
lib/smd to point to the Eigen dir.  When LAMMPS builds it will use
this link.  You should not need to edit the lib/smd/Makefile.lammps
file.</p>
<hr class="docutils" />
</div>
<div class="section" id="user-vtk-package">
<span id="user-vtk"></span><h2><span class="section-number">3.7.26. </span>USER-VTK package</h2>
<p>To build with this package you must have the VTK library installed on
your system.</p>
<p><strong>CMake build</strong>:</p>
<p>No additional settings are needed besides “-D PKG_USER-VTK=yes”.</p>
<p>This should auto-detect the VTK library if it is installed on your
system at standard locations.  Several advanced VTK options exist if
you need to specify where it was installed.  Use the ccmake (terminal
window) or cmake-gui (graphical) tools to see these options and set
them interactively from their user interfaces.</p>
<p><strong>Traditional make</strong>:</p>
<p>The lib/vtk/Makefile.lammps file has settings for accessing VTK files
and its library, which LAMMPS needs to build with this package.  If
the settings are not valid for your system, check if one of the other
lib/vtk/Makefile.lammps.* files is compatible and copy it to
Makefile.lammps.  If none of the provided files work, you will need to
edit the Makefile.lammps file.  See lib/vtk/README for details.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Build_windows.html" class="btn btn-neutral float-right" title="3.8. Notes for building LAMMPS on Windows" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Build_package.html" class="btn btn-neutral" title="3.6. Include packages in build" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr style="margin-top: 6px; margin-bottom: 6px;" width="100%"/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2003-2020 Sandia Corporation.
    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="_static/language_data.js"></script>
      <script type="text/javascript" src="_static/mathjax/es5/tex-mml-chtml.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>