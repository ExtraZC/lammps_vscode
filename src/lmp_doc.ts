export const command_docs = [
{
    "command": "compute ackland/atom",
    "description": "Defines a computation that calculates the local lattice structure\n  according to the formulation given in (Ackland).\n  Historically, LAMMPS had two, slightly different implementations of\n  the algorithm from the paper. With the legacy keyword, it is\n  possible to switch between the pre-2015 (legacy yes) and post-2015\n  implementation (legacy no). The post-2015 variant is the default.\n  In contrast to the centro-symmetry parameter this method is stable against\n  temperature boost, because it is based not on the distance between\n  particles but the angles.  Therefore statistical fluctuations are\n  averaged out a little more.  A comparison with the Common Neighbor\n  Analysis metric is made in the paper.\n  The result is a number which is mapped to the following different\n  lattice structures:\n  \n  0 = UNKNOWN\n  1 = BCC\n  2 = FCC\n  3 = HCP\n  4 = ICO\n  \n  The neighbor list needed to compute this quantity is constructed each\n  time the calculation is performed (i.e. each time a snapshot of atoms\n  is dumped).  Thus it can be inefficient to compute/dump this quantity\n  too frequently or to have multiple compute/dump commands, each of\n  which computes this quantity.-\n  Output info:\n  This compute calculates a per-atom vector, which can be accessed by\n  any command that uses per-atom values from a compute as input.  See\n  the Howto output doc page for an overview of\n  LAMMPS output options.\n  ",
    "syntax": "compute ID group-ID ackland/atom keyword/value\n  \n  \n  \n  ID, group-ID are documented in compute command\n  ackland/atom = style name of this compute command\n  zero or more keyword/value pairs may be appended\n  keyword = legacy\n  legacy yes/no = use (yes) or do not use (no) legacy ackland algorithm implementation\n  \n  \n  ",
    "examples": "compute 1 all ackland/atom\n  compute 1 all ackland/atom legacy yes\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  The per-atom vector values will be unitless since they are the\n  integers defined above.\n  "
},
{
    "command": "compute adf",
    "description": "Define a computation that calculates one or more angular distribution functions\n  (ADF) for a group of particles.  Each ADF is calculated in histogram form\n  by measuring the angle formed by a central atom and two neighbor atoms and\n  binning these angles into Nbin bins.\n  Only neighbors for which Rinner < R < Router are counted, where\n  Rinner and Router are specified separately for the first and second\n  neighbor atom in each requested ADF.\n  \n  Note\n  If you have a bonded system, then the settings of\n  special_bonds command can remove pairwise\n  interactions between atoms in the same bond, angle, or dihedral.  This\n  is the default setting for the special_bonds\n  command, and means those pairwise interactions do not appear in the\n  neighbor list.  Because this fix uses a neighbor list, it also means\n  those pairs will not be included in the ADF. This does not apply when\n  using long-range coulomb interactions (coul/long, coul/msm,\n  coul/wolf or similar.  One way to get around this would be to set\n  special_bond scaling factors to very tiny numbers that are not exactly\n  zero (e.g. 1.0e-50). Another workaround is to write a dump file, and\n  use the rerun command to compute the ADF for snapshots in\n  the dump file.  The rerun script can use a\n  special_bonds command that includes all pairs in\n  the neighbor list.\n  \n  \n  Note\n  If you request any outer cutoff Router > force cutoff, or if no\n  pair style is defined,  e.g. the rerun command is being used to\n  post-process a dump file of snapshots you must insure ghost atom information\n  out to the largest value of Router + skin is communicated, via the\n  comm_modify cutoff command, else the ADF computation\n  cannot be performed, and LAMMPS will give an error message.  The skin value\n  is what is specified with the neighbor command.\n  \n  The itypeN,jtypeN,ktypeN settings can be specified in one of two\n  ways.  An explicit numeric value can be used, as in the 1st example\n  above.  Or a wild-card asterisk can be used to specify a range of atom\n  types as in the 2nd example above.\n  This takes the form “*” or “*n” or “n*” or “m*n”.  If N = the\n  number of atom types, then an asterisk with no numeric values means\n  all types from 1 to N.  A leading asterisk means all types from 1 to n\n  (inclusive).  A trailing asterisk means all types from n to N\n  (inclusive).  A middle asterisk means all types from m to n\n  (inclusive).\n  If itypeN, jtypeN, and ktypeN are single values, as in the 1st example\n  above, this means that the ADF is computed where atoms of type itypeN\n  are the central atom, and neighbor atoms of type jtypeN and ktypeN\n  are forming the angle.  If any of itypeN, jtypeN, or ktypeN\n  represent a range of values via\n  the wild-card asterisk, as in the 2nd example above, this means that the\n  ADF is computed where atoms of any of the range of types represented\n  by itypeN are the central atom, and the angle is formed by two neighbors,\n  one neighbor in the range of types represented by jtypeN and another neighbor\n  in the range of types represented by ktypeN.\n  If no itypeN, jtypeN, ktypeN settings are specified, then\n  LAMMPS will generate a single ADF for all atoms in the group.\n  The inner cutoff is set to zero and the outer cutoff is set\n  to the force cutoff. If no pair_style is specified, there is no\n  force cutoff and LAMMPS will give an error message. Note that\n  in most cases, generating an ADF for all atoms is not a good thing.\n  Such an ADF is both uninformative and\n  extremely expensive to compute.  For example, with liquid water\n  with a 10 A force cutoff, there are 80,000 angles per atom.\n  In addition, most of the interesting angular structure occurs for\n  neighbors that are the closest to the central atom, involving\n  just a few dozen angles.\n  Angles for each ADF are generated by double-looping over the list of\n  neighbors of each central atom I,\n  just as they would be in the force calculation for\n  a three-body potential such as Stillinger-Weber.\n  The angle formed by central atom I and neighbor atoms J and K is included in an\n  ADF if the following criteria are met:\n  \n  atoms I,J,K are all in the specified compute group\n  the distance between atoms I,J is between Rjinner and Rjouter\n  the distance between atoms I,K is between Rkinner and Rkouter\n  the type of the I atom matches itypeN (one or a range of types)\n  atoms I,J,K are distinct\n  the type of the J atom matches jtypeN (one or a range of types)\n  the type of the K atom matches ktypeN (one or a range of types)\n  \n  Each unique angle satisfying the above criteria is counted only once, regardless\n  of whether either or both of the neighbor atoms making up the\n  angle appear in both the J and K lists.\n  It is OK if a particular angle is included in more than\n  one individual histogram, due to the way the itypeN, jtypeN, ktypeN\n  arguments are specified.\n  The first ADF value for a bin is calculated from the histogram count by\n  dividing by the total number of triples satisfying the criteria,\n  so that the integral of the ADF w.r.t. angle is 1, i.e. the ADF\n  is a probability density function.\n  The second ADF value is reported as a cumulative sum of\n  all bins up to the current bins, averaged\n  over atoms of type itypeN. It represents the\n  number of angles per central atom with angle less\n  than or equal to the angle of the current bin,\n  analogous to the coordination\n  number radial distribution function.\n  The ordinate optional keyword determines\n  whether the bins are of uniform angular size from zero\n  to 180 (degree), zero to Pi (radian), or the\n  cosine of the angle uniform in the range [-1,1] (cosine).\n  cosine has the advantage of eliminating the acos() function\n  call, which speeds up the compute by 2-3x, and it is also preferred\n  on physical grounds, because the for uniformly distributed particles\n  in 3D, the angular probability density w.r.t dtheta is\n  sin(theta)/2, while for d(cos(theta)), it is 1/2,\n  Regardless of which ordinate is chosen, the first column of ADF\n  values is normalized w.r.t. the range of that ordinate, so that\n  the integral is 1.\n  The simplest way to output the results of the compute adf calculation\n  to a file is to use the fix ave/time command, for\n  example:\n  compute myADF all adf 32 2 2 2 0.5 3.5 0.5 3.5\n  fix 1 all ave/time 100 1 100 c_myADF[*] file tmp.adf mode vector\n  \n  \n  Output info:\n  This compute calculates a global array with the number of rows =\n  Nbins, and the number of columns = 1 + 2*Ntriples, where Ntriples is the\n  number of I,J,K triples specified.  The first column has the bin\n  coordinate (angle-related ordinate at midpoint of bin). Each subsequent column has\n  the two ADF values for a specific set of (itypeN,jtypeN,ktypeN)\n  interactions, as described above.  These values can be used\n  by any command that uses a global values from a compute as input.  See\n  the Howto output doc page for an overview of\n  LAMMPS output options.\n  The array values calculated by this compute are all “intensive”.\n  The first column of array values is the angle-related ordinate, either\n  the angle in degrees or radians, or the cosine of the angle.  Each\n  subsequent pair of columns gives the first and second kinds of ADF\n  for a specific set of (itypeN,jtypeN,ktypeN). The values\n  in the first ADF column are normalized numbers >= 0.0,\n  whose integral w.r.t. the ordinate is 1,\n  i.e. the first ADF is a normalized probability distribution.\n  The values in the second ADF column are also numbers >= 0.0.\n  They are the cumulative density distribution of angles per atom.\n  By definition, this ADF is monotonically increasing from zero to\n  a maximum value equal to the average total number of\n  angles per atom satisfying the ADF criteria.\n  ",
    "syntax": "compute ID group-ID adf Nbin itype1 jtype1 ktype1 Rjinner1 Rjouter1 Rkinner1 Rkouter1 ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  adf = style name of this compute command\n  Nbin = number of ADF bins\n  itypeN = central atom type for Nth ADF histogram (see asterisk form below)\n  jtypeN = J atom type for Nth ADF histogram (see asterisk form below)\n  ktypeN = K atom type for Nth ADF histogram (see asterisk form below)\n  RjinnerN =  inner radius of J atom shell for Nth ADF histogram (distance units)\n  RjouterN =  outer radius of J atom shell for Nth ADF histogram (distance units)\n  RkinnerN = inner radius of K atom shell for Nth ADF histogram (distance units)\n  RkouterN =  outer radius of K atom shell for Nth ADF histogram (distance units)\n  zero or one keyword/value pairs may be appended\n  keyword = ordinate\n  ordinate value = degree or radian or cosine\n    Choose the ordinate parameter for the histogram\n  \n  \n  ",
    "examples": "compute 1 fluid adf 32 1 1 1 0.0 1.2 0.0 1.2 &\n                         1 1 2 0.0 1.2 0.0 1.5 &\n                         1 2 2 0.0 1.5 0.0 1.5 &\n                         2 1 1 0.0 1.2 0.0 1.2 &\n                         2 1 2 0.0 1.5 2.0 3.5 &\n                         2 2 2 2.0 3.5 2.0 3.5\n  compute 1 fluid adf 32 1*2 1*2 1*2 0.5 3.5\n  compute 1 fluid adf 32\n  \n  \n  ",
    "restrictions": "The ADF is not computed for neighbors outside the force cutoff,\n  since processors (in parallel) don’t know about atom coordinates for\n  atoms further away than that distance.  If you want an ADF for larger\n  distances, you can use the rerun command to post-process\n  a dump file and set the cutoff for the potential to be longer in the\n  rerun script.  Note that in the rerun context, the force cutoff is\n  arbitrary, since you are not running dynamics and thus are not changing\n  your model.\n  "
},
{
    "command": "compute angle",
    "description": "Define a computation that extracts the angle energy calculated by each\n  of the angle sub-styles used in the  “angle_style\n  hybrid” angle_hybrid.html command.  These values are made accessible\n  for output or further processing by other commands.  The group\n  specified for this command is ignored.\n  This compute is useful when using angle_style hybrid if you want to know the portion of the total\n  energy contributed by one or more of the hybrid sub-styles.\n  Output info:\n  This compute calculates a global vector of length N where N is the\n  number of sub_styles defined by the angle_style hybrid command, which can be accessed by indices\n  1-N.  These values can be used by any command that uses global scalar\n  or vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The vector values are “extensive” and will be in energy\n  units.\n  ",
    "syntax": "compute ID group-ID angle\n  \n  \n  \n  ID, group-ID are documented in compute command\n  angle = style name of this compute command\n  \n  ",
    "examples": "compute 1 all angle\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute angle/local",
    "description": "Define a computation that calculates properties of individual angle\n  interactions.  The number of datums generated, aggregated across all\n  processors, equals the number of angles in the system, modified by the\n  group parameter as explained below.\n  The value theta is the angle for the 3 atoms in the interaction.\n  The value eng is the interaction energy for the angle.\n  The value v_name can be used together with the set keyword to\n  compute a user-specified function of the angle theta.  The name\n  specified for the v_name value is the name of an equal-style variable which should evaluate a formula based on a\n  variable which will store the angle theta.  This other variable must\n  be an internal-style variable defined in the input\n  script; its initial numeric value can be anything.  It must be an\n  internal-style variable, because this command resets its value\n  directly.  The set keyword is used to identify the name of this\n  other variable associated with theta.\n  Note that the value of theta for each angle which stored in the\n  internal variable is in radians, not degrees.\n  As an example, these commands can be added to the bench/in.rhodo\n  script to compute the cosine and cosine^2 of every angle in the system\n  and output the statistics in various ways:\n  variable t internal 0.0\n  variable cos equal cos(v_t)\n  variable cossq equal cos(v_t)*cos(v_t)\n  \n  compute 1 all property/local aatom1 aatom2 aatom3 atype\n  compute 2 all angle/local eng theta v_cos v_cossq set theta t\n  dump 1 all local 100 tmp.dump c_1[*] c_2[*]\n  \n  compute 3 all reduce ave c_2[*]\n  thermo_style custom step temp press c_3[*]\n  \n  fix 10 all ave/histo 10 10 100 -1 1 20 c_2[3] mode vector file tmp.histo\n  \n  \n  The dump local command will output the energy, angle,\n  cosine(angle), cosine^2(angle) for every angle in the system.  The\n  thermo_style command will print the average of\n  those quantities via the compute reduce command\n  with thermo output.  And the fix ave/histo\n  command will histogram the cosine(angle) values and write them to a\n  file.\n  \n  The local data stored by this command is generated by looping over all\n  the atoms owned on a processor and their angles.  An angle will only\n  be included if all 3 atoms in the angle are in the specified compute\n  group.  Any angles that have been broken (see the\n  angle_style command) by setting their angle type to\n  0 are not included.  Angles that have been turned off (see the fix shake or delete_bonds commands) by\n  setting their angle type negative are written into the file, but their\n  energy will be 0.0.\n  Note that as atoms migrate from processor to processor, there will be\n  no consistent ordering of the entries within the local vector or array\n  from one timestep to the next.  The only consistency that is\n  guaranteed is that the ordering on a particular timestep will be the\n  same for local vectors or arrays generated by other compute commands.\n  For example, angle output from the compute property/local command can be combined\n  with data from this command and output by the dump local\n  command in a consistent way.\n  Here is an example of how to do this:\n  compute 1 all property/local atype aatom1 aatom2 aatom3\n  compute 2 all angle/local theta eng\n  dump 1 all local 1000 tmp.dump index c_1[1] c_1[2] c_1[3] c_1[4] c_2[1] c_2[2]\n  \n  \n  Output info:\n  This compute calculates a local vector or local array depending on the\n  number of values.  The length of the vector or number of rows in the\n  array is the number of angles.  If a single value is specified, a\n  local vector is produced.  If two or more values are specified, a\n  local array is produced where the number of columns = the number of\n  values.  The vector or array can be accessed by any command that uses\n  local values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The output for theta will be in degrees.  The output for eng will\n  be in energy units.\n  ",
    "syntax": "compute ID group-ID angle/local value1 value2 ... keyword args ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  angle/local = style name of this compute command\n  one or more values may be appended\n  value = theta or eng or v_name\n  theta = tabulate angles\n  eng = tabulate angle energies\n  v_name = equal-style variable with name (see below)\n  \n  zero or more keyword/args pairs may be appended\n  keyword = set\n  set args = theta name\n    theta = only currently allowed arg\n    name = name of variable to set with theta\n  \n  \n  ",
    "examples": "compute 1 all angle/local theta\n  compute 1 all angle/local eng theta\n  compute 1 all angle/local theta v_cos set theta t\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute angmom/chunk",
    "description": "Define a computation that calculates the angular momentum of multiple\n  chunks of atoms.\n  In LAMMPS, chunks are collections of atoms defined by a compute chunk/atom command, which assigns each atom\n  to a single chunk (or no chunk).  The ID for this command is specified\n  as chunkID.  For example, a single chunk could be the atoms in a\n  molecule or atoms in a spatial bin.  See the compute chunk/atom and Howto chunk\n  doc pages for details of how chunks can be defined and examples of how\n  they can be used to measure properties of a system.\n  This compute calculates the 3 components of the angular momentum\n  vector for each chunk, due to the velocity/momentum of the individual\n  atoms in the chunk around the center-of-mass of the chunk.  The\n  calculation includes all effects due to atoms passing through periodic\n  boundaries.\n  Note that only atoms in the specified group contribute to the\n  calculation.  The compute chunk/atom command\n  defines its own group; atoms will have a chunk ID = 0 if they are not\n  in that group, signifying they are not assigned to a chunk, and will\n  thus also not contribute to this calculation.  You can specify the\n  “all” group for this command if you simply want to include atoms with\n  non-zero chunk IDs.\n  \n  Note\n  The coordinates of an atom contribute to the chunk’s angular\n  momentum in “unwrapped” form, by using the image flags associated with\n  each atom.  See the dump custom command for a discussion\n  of “unwrapped” coordinates.  See the Atoms section of the\n  read_data command for a discussion of image flags and\n  how they are set for each atom.  You can reset the image flags\n  (e.g. to 0) before invoking this compute by using the set image command.\n  \n  The simplest way to output the results of the compute angmom/chunk\n  calculation to a file is to use the fix ave/time\n  command, for example:\n  compute cc1 all chunk/atom molecule\n  compute myChunk all angmom/chunk cc1\n  fix 1 all ave/time 100 1 100 c_myChunk[*] file tmp.out mode vector\n  \n  \n  Output info:\n  This compute calculates a global array where the number of rows = the\n  number of chunks Nchunk as calculated by the specified compute chunk/atom command.  The number of columns =\n  3 for the 3 xyz components of the angular momentum for each chunk.\n  These values can be accessed by any command that uses global array\n  values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The array values are “intensive”.  The array values will be in\n  mass-velocity-distance units.\n  ",
    "syntax": "compute ID group-ID angmom/chunk chunkID\n  \n  \n  \n  ID, group-ID are documented in compute command\n  angmom/chunk = style name of this compute command\n  chunkID = ID of compute chunk/atom command\n  \n  ",
    "examples": "compute 1 fluid angmom/chunk molchunk\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute basal/atom",
    "description": "Defines a computation that calculates the hexagonal close-packed “c”\n  lattice vector for each atom in the group.  It does this by\n  calculating the normal unit vector to the basal plane for each atom.\n  The results enable efficient identification and characterization of\n  twins and grains in hexagonal close-packed structures.\n  The output of the compute is thus the 3 components of a unit vector\n  associated with each atom.  The components are set to 0.0 for\n  atoms not in the group.\n  Details of the calculation are given in (Barrett).\n  The neighbor list needed to compute this quantity is constructed each\n  time the calculation is performed (i.e. each time a snapshot of atoms\n  is dumped).  Thus it can be inefficient to compute/dump this quantity\n  too frequently or to have multiple compute/dump commands, each of\n  which computes this quantity.\n  An example input script that uses this compute is provided\n  in examples/USER/misc/basal.\n  Output info:\n  This compute calculates a per-atom array with 3 columns, which can be\n  accessed by indices 1-3 by any command that uses per-atom values from\n  a compute as input.  See the Howto output doc page\n  for an overview of LAMMPS output options.\n  The per-atom vector values are unitless since the 3 columns represent\n  components of a unit vector.\n  ",
    "syntax": "compute ID group-ID basal/atom\n  \n  \n  \n  ID, group-ID are documented in compute command\n  basal/atom = style name of this compute command\n  \n  ",
    "examples": "compute 1 all basal/atom\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  The output of this compute will be meaningless unless the atoms are on\n  (or near) hcp lattice sites, since the calculation assumes a\n  well-defined basal plane.\n  "
},
{
    "command": "compute body/local",
    "description": "Define a computation that calculates properties of individual body\n  sub-particles.  The number of datums generated, aggregated across all\n  processors, equals the number of body sub-particles plus the number of\n  non-body particles in the system, modified by the group parameter as\n  explained below.  See the Howto body doc page for\n  more details on using body particles.\n  The local data stored by this command is generated by looping over all\n  the atoms.  An atom will only be included if it is in the group.  If\n  the atom is a body particle, then its N sub-particles will be looped\n  over, and it will contribute N datums to the count of datums.  If it\n  is not a body particle, it will contribute 1 datum.\n  For both body particles and non-body particles, the id keyword\n  will store the ID of the particle.\n  For both body particles and non-body particles, the type keyword\n  will store the type of the particle.\n  The integer keywords mean different things for body and non-body\n  particles.  If the atom is not a body particle, only its x, y, z\n  coordinates can be referenced, using the integer keywords 1,2,3.\n  Note that this means that if you want to access more fields than this\n  for body particles, then you cannot include non-body particles in the\n  group.\n  For a body particle, the integer keywords refer to fields calculated\n  by the body style for each sub-particle.  The body style, as specified\n  by the atom_style body, determines how many fields\n  exist and what they are.  See the Howto_body doc\n  page for details of the different styles.\n  Here is an example of how to output body information using the dump local command with this compute.  If fields 1,2,3 for the\n  body sub-particles are x,y,z coordinates, then the dump file will be\n  formatted similar to the output of a dump atom or custom\n  command.\n  compute 1 all body/local type 1 2 3\n  dump 1 all local 1000 tmp.dump index c_1[1] c_1[2] c_1[3] c_1[4]\n  \n  \n  Output info:\n  This compute calculates a local vector or local array depending on the\n  number of keywords.  The length of the vector or number of rows in the\n  array is the number of datums as described above.  If a single keyword\n  is specified, a local vector is produced.  If two or more keywords are\n  specified, a local array is produced where the number of columns = the\n  number of keywords.  The vector or array can be accessed by any\n  command that uses local values from a compute as input.  See the\n  Howto output doc page for an overview of LAMMPS\n  output options.\n  The units for output values depend on the body style.\n  ",
    "syntax": "compute ID group-ID body/local input1 input2 ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  body/local = style name of this compute command\n  one or more keywords may be appended\n  keyword = id or type or integer\n  id = atom ID of the body particle\n  type = atom type of the body particle\n  integer = 1,2,3,etc = index of fields defined by body style\n  \n  \n  ",
    "examples": "compute 1 all body/local type 1 2 3\n  compute 1 all body/local 3 6\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute bond",
    "description": "Define a computation that extracts the bond energy calculated by each\n  of the bond sub-styles used in the bond_style hybrid command.  These values are made accessible\n  for output or further processing by other commands.  The group\n  specified for this command is ignored.\n  This compute is useful when using bond_style hybrid\n  if you want to know the portion of the total energy contributed by one\n  or more of the hybrid sub-styles.\n  Output info:\n  This compute calculates a global vector of length N where N is the\n  number of sub_styles defined by the bond_style hybrid command, which can be accessed by indices 1-N.\n  These values can be used by any command that uses global scalar or\n  vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The vector values are “extensive” and will be in energy\n  units.\n  ",
    "syntax": "compute ID group-ID bond\n  \n  \n  \n  ID, group-ID are documented in compute command\n  bond = style name of this compute command\n  \n  ",
    "examples": "compute 1 all bond\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute bond/local",
    "description": "Define a computation that calculates properties of individual bond\n  interactions.  The number of datums generated, aggregated across all\n  processors, equals the number of bonds in the system, modified by the\n  group parameter as explained below.\n  All these properties are computed for the pair of atoms in a bond,\n  whether the 2 atoms represent a simple diatomic molecule, or are part\n  of some larger molecule.\n  The value dist is the current length of the bond.\n  The value engpot is the potential energy for the bond,\n  based on the current separation of the pair of atoms in the bond.\n  The value force is the magnitude of the force acting between the\n  pair of atoms in the bond.\n  The values fx, fy, and fz are the xyz components of\n  force between the pair of atoms in the bond.\n  The remaining properties are all computed for motion of the two atoms\n  relative to the center of mass (COM) velocity of the 2 atoms in the\n  bond.\n  The value engvib is the vibrational kinetic energy of the two atoms\n  in the bond, which is simply 1/2 m1 v1^2 + 1/2 m2 v2^2, where v1 and\n  v2 are the magnitude of the velocity of the 2 atoms along the bond\n  direction, after the COM velocity has been subtracted from each.\n  The value engrot is the rotational kinetic energy of the two atoms\n  in the bond, which is simply 1/2 m1 v1^2 + 1/2 m2 v2^2, where v1 and\n  v2 are the magnitude of the velocity of the 2 atoms perpendicular to\n  the bond direction, after the COM velocity has been subtracted from\n  each.\n  The value engtrans is the translational kinetic energy associated\n  with the motion of the COM of the system itself, namely 1/2 (m1+m2)\n  Vcm^2 where Vcm = magnitude of the velocity of the COM.\n  Note that these 3 kinetic energy terms are simply a partitioning of\n  the summed kinetic energy of the 2 atoms themselves.  I.e. total KE =\n  1/2 m1 v1^2 + 1/2 m2 v2^2 = engvib + engrot + engtrans, where v1,v2\n  are the magnitude of the velocities of the 2 atoms, without any\n  adjustment for the COM velocity.\n  The value omega is the magnitude of the angular velocity of the\n  two atoms around their COM position.\n  The value velvib is the magnitude of the relative velocity of the\n  two atoms in the bond towards each other.  A negative value means the\n  2 atoms are moving toward each other; a positive value means they are\n  moving apart.\n  The value v_name can be used together with the set keyword to\n  compute a user-specified function of the bond distance.  The name\n  specified for the v_name value is the name of an equal-style variable which should evaluate a formula based on a\n  variable which will store the bond distance.  This other variable must\n  be an internal-style variable defined in the input\n  script; its initial numeric value can be anything.  It must be an\n  internal-style variable, because this command resets its value\n  directly.  The set keyword is used to identify the name of this\n  other variable associated with theta.\n  As an example, these commands can be added to the bench/in.rhodo\n  script to compute the distance^2 of every bond in the system and\n  output the statistics in various ways:\n  variable d internal 0.0\n  variable dsq equal v_d*v_d\n  \n  compute 1 all property/local batom1 batom2 btype\n  compute 2 all bond/local engpot dist v_dsq set dist d\n  dump 1 all local 100 tmp.dump c_1[*] c_2[*]\n  \n  compute 3 all reduce ave c_2[*]\n  thermo_style custom step temp press c_3[*]\n  \n  fix 10 all ave/histo 10 10 100 0 6 20 c_2[3] mode vector file tmp.histo\n  \n  \n  The dump local command will output the energy, distance,\n  distance^2 for every bond in the system.  The\n  thermo_style command will print the average of\n  those quantities via the compute reduce command\n  with thermo output.  And the fix ave/histo\n  command will histogram the distance^2 values and write them to a file.\n  \n  The local data stored by this command is generated by looping over all\n  the atoms owned on a processor and their bonds.  A bond will only be\n  included if both atoms in the bond are in the specified compute group.\n  Any bonds that have been broken (see the bond_style\n  command) by setting their bond type to 0 are not included.  Bonds that\n  have been turned off (see the fix shake or\n  delete_bonds commands) by setting their bond type\n  negative are written into the file, but their energy will be 0.0.\n  Note that as atoms migrate from processor to processor, there will be\n  no consistent ordering of the entries within the local vector or array\n  from one timestep to the next.  The only consistency that is\n  guaranteed is that the ordering on a particular timestep will be the\n  same for local vectors or arrays generated by other compute commands.\n  For example, bond output from the compute property/local command can be combined\n  with data from this command and output by the dump local\n  command in a consistent way.\n  Here is an example of how to do this:\n  compute 1 all property/local btype batom1 batom2\n  compute 2 all bond/local dist engpot\n  dump 1 all local 1000 tmp.dump index c_1[*] c_2[*]\n  \n  \n  Output info:\n  This compute calculates a local vector or local array depending on the\n  number of values.  The length of the vector or number of rows in the\n  array is the number of bonds.  If a single value is specified, a local\n  vector is produced.  If two or more values are specified, a local\n  array is produced where the number of columns = the number of values.\n  The vector or array can be accessed by any command that uses local\n  values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The output for dist will be in distance units. The\n  output for velvib will be in velocity units. The output\n  for omega will be in velocity/distance units. The\n  output for engtrans, engvib, engrot, and engpot will be in\n  energy units. The output for force will be in force\n  units.\n  ",
    "syntax": "compute ID group-ID bond/local value1 value2 ... keyword args ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  bond/local = style name of this compute command\n  one or more values may be appended\n  value = dist or engpot or force or fx or fy or fz or engvib or engrot or engtrans or omega or velvib or v_name\n  \n  dist = bond distance\n  engpot = bond potential energy\n  force = bond force\n  \n  fx,fy,fz = components of bond force\n  engvib = bond kinetic energy of vibration\n  engrot = bond kinetic energy of rotation\n  engtrans = bond kinetic energy of translation\n  omega = magnitude of bond angular velocity\n  velvib = vibrational velocity along the bond length\n  v_name = equal-style variable with name (see below)\n  \n  zero or more keyword/args pairs may be appended\n  keyword = set\n  \n  set args = dist name\n    dist = only currently allowed arg\n    name = name of variable to set with distance (dist)\n  ",
    "examples": "compute 1 all bond/local engpot\n  compute 1 all bond/local dist engpot force\n  \n  compute 1 all bond/local dist fx fy fz\n  \n  compute 1 all angle/local dist v_distsq set dist d\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute centro/atom",
    "description": "Define a computation that calculates the centro-symmetry parameter for\n  each atom in the group, for either FCC or BCC lattices, depending on\n  the choice of the lattice argument.  In solid-state systems the\n  centro-symmetry parameter is a useful measure of the local lattice\n  disorder around an atom and can be used to characterize whether the\n  atom is part of a perfect lattice, a local defect (e.g. a dislocation\n  or stacking fault), or at a surface.\n  The value of the centro-symmetry parameter will be 0.0 for atoms not\n  in the specified compute group.\n  This parameter is computed using the following formula from\n  (Kelchner)\n  \n  \\[CS = \\sum_{i = 1}^{N/2} | \\vec{R}_i + \\vec{R}_{i+N/2} |^2\\]\n  where the \\(N\\) nearest neighbors of each atom are identified and\n  \\(\\vec{R}_i\\) and \\(\\vec{R}_{i+N/2}\\) are vectors from the\n  central atom to a particular pair of nearest neighbors.  There are\n  \\(N (N-1)/2\\) possible neighbor pairs that can contribute to this\n  formula.  The quantity in the sum is computed for each, and the\n  \\(N/2\\) smallest are used.  This will typically be for pairs of\n  atoms in symmetrically opposite positions with respect to the central\n  atom; hence the \\(i+N/2\\) notation.\n  \\(N\\) is an input parameter, which should be set to correspond to\n  the number of nearest neighbors in the underlying lattice of atoms.\n  If the keyword fcc or bcc is used, N is set to 12 and 8\n  respectively.  More generally, N can be set to a positive, even\n  integer.\n  For an atom on a lattice site, surrounded by atoms on a perfect\n  lattice, the centro-symmetry parameter will be 0.  It will be near 0\n  for small thermal perturbations of a perfect lattice.  If a point\n  defect exists, the symmetry is broken, and the parameter will be a\n  larger positive value.  An atom at a surface will have a large\n  positive parameter.  If the atom does not have \\(N\\) neighbors\n  (within the potential cutoff), then its centro-symmetry parameter is\n  set to 0.0.\n  If the keyword axes has the setting yes, then this compute also\n  estimates three symmetry axes for each atom’s local neighborhood.  The\n  first two of these are the vectors joining the two pairs of neighbor\n  atoms with smallest contributions to the centrosymmetry parameter,\n  i.e. the two most symmetric pairs of atoms.  The third vector is\n  normal to the first two by the right-hand rule.  All three vectors are\n  normalized to unit length.  For FCC crystals, the first two vectors\n  will lie along a <110> direction, while the third vector will lie\n  along either a <100> or <111> direction.  For HCP crystals, the first\n  two vectors will lie along <1000> directions, while the third vector\n  will lie along <0001>.  This provides a simple way to measure local\n  orientation in HCP structures.  In general, the axes keyword can be\n  used to estimate the orientation of symmetry axes in the neighborhood\n  of any atom.\n  Only atoms within the cutoff of the pairwise neighbor list are\n  considered as possible neighbors.  Atoms not in the compute group are\n  included in the \\(N\\) neighbors used in this calculation.\n  The neighbor list needed to compute this quantity is constructed each\n  time the calculation is performed (e.g. each time a snapshot of atoms\n  is dumped).  Thus it can be inefficient to compute/dump this quantity\n  too frequently or to have multiple compute/dump commands, each with a\n  centro/atom style.\n  Output info:\n  By default, this compute calculates the centrosymmetry value for each\n  atom as a per-atom vector, which can be accessed by any command that\n  uses per-atom values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  If the axes keyword setting is yes, then a per-atom array is\n  calculated. The first column is the centrosymmetry parameter.  The\n  next three columns are the x, y, and z components of the first\n  symmetry axis, followed by the second, and third symmetry axes in\n  columns 5-7 and 8-10.\n  The centrosymmetry values are unitless values >= 0.0.  Their magnitude\n  depends on the lattice style due to the number of contributing neighbor\n  pairs in the summation in the formula above.  And it depends on the\n  local defects surrounding the central atom, as described above.  For\n  the axes yes case, the vector components are also unitless, since\n  they represent spatial directions.\n  Here are typical centro-symmetry values, from a nanoindentation\n  simulation into gold (FCC).  These were provided by Jon Zimmerman\n  (Sandia):\n  Bulk lattice = 0\n  Dislocation core ~ 1.0 (0.5 to 1.25)\n  Stacking faults ~ 5.0 (4.0 to 6.0)\n  Free surface ~ 23.0\n  \n  \n  These values are *not* normalized by the square of the lattice\n  parameter.  If they were, normalized values would be:\n  Bulk lattice = 0\n  Dislocation core ~ 0.06 (0.03 to 0.075)\n  Stacking faults ~ 0.3 (0.24 to 0.36)\n  Free surface ~ 1.38\n  \n  \n  For BCC materials, the values for dislocation cores and free surfaces\n  would be somewhat different, due to their being only 8 neighbors instead\n  of 12.\n  ",
    "syntax": "compute ID group-ID centro/atom lattice keyword value ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  centro/atom = style name of this compute command\n  lattice = fcc or bcc or N = # of neighbors per atom to include\n  zero or more keyword/value pairs may be appended\n  keyword = axes\n  \n  axes value = no or yes\n    no = do not calculate 3 symmetry axes\n    yes = calculate 3 symmetry axes\n  ",
    "examples": "compute 1 all centro/atom fcc\n  \n  compute 1 all centro/atom 8\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute chunk/atom",
    "description": "Define a computation that calculates an integer chunk ID from 1 to\n  Nchunk for each atom in the group.  Values of chunk IDs are determined\n  by the style of chunk, which can be based on atom type or molecule\n  ID or spatial binning or a per-atom property or value calculated by\n  another compute, fix, or atom-style variable.  Per-atom chunk IDs can be used by other\n  computes with “chunk” in their style name, such as compute com/chunk or compute msd/chunk.  Or they can be used by the fix ave/chunk command to sum and time average a\n  variety of per-atom properties over the atoms in each chunk.  Or they\n  can simply be accessed by any command that uses per-atom values from a\n  compute as input, as discussed on the Howto output\n  doc page.\n  See the Howto chunk doc page for an overview of how\n  this compute can be used with a variety of other commands to tabulate\n  properties of a simulation.  The page gives several examples of input\n  script commands that can be used to calculate interesting properties.\n  Conceptually it is important to realize that this compute does two\n  simple things.  First, it sets the value of Nchunk = the number of\n  chunks, which can be a constant value or change over time.  Second, it\n  assigns each atom to a chunk via a chunk ID.  Chunk IDs range from 1\n  to Nchunk inclusive; some chunks may have no atoms assigned to them.\n  Atoms that do not belong to any chunk are assigned a value of 0.  Note\n  that the two operations are not always performed together.  For\n  example, spatial bins can be setup once (which sets Nchunk), and\n  atoms assigned to those bins many times thereafter (setting their\n  chunk IDs).\n  All other commands in LAMMPS that use chunk IDs assume there are\n  Nchunk number of chunks, and that every atom is assigned to one of\n  those chunks, or not assigned to any chunk.\n  There are many options for specifying for how and when Nchunk is\n  calculated, and how and when chunk IDs are assigned to atoms.  The\n  details depend on the chunk style and its args, as well as\n  optional keyword settings.  They can also depend on whether a fix ave/chunk command is using this compute, since\n  that command requires Nchunk to remain static across windows of\n  timesteps it specifies, while it accumulates per-chunk averages.\n  The details are described below.\n  \n  The different chunk styles operate as follows.  For each style, how it\n  calculates Nchunk and assigns chunk IDs to atoms is explained.  Note\n  that using the optional keywords can change both of those actions, as\n  described further below where the keywords are discussed.\n  \n  The binning styles perform a spatial binning of atoms, and assign an\n  atom the chunk ID corresponding to the bin number it is in.  Nchunk\n  is set to the number of bins, which can change if the simulation box\n  size changes.  This also depends on the setting of the units\n  keyword; e.g. for reduced units the number of chunks may not change\n  even if the box size does.\n  The bin/1d, bin/2d, and bin/3d styles define bins as 1d layers\n  (slabs), 2d pencils, or 3d boxes.  The dim, origin, and delta\n  settings are specified 1, 2, or 3 times.  For 2d or 3d bins, there is\n  no restriction on specifying dim = x before dim = y or z, or dim = y\n  before dim = z.  Bins in a particular dim have a bin size in that\n  dimension given by delta.  In each dimension, bins are defined\n  relative to a specified origin, which may be the lower/upper edge of\n  the simulation box (in that dimension), or its center point, or a\n  specified coordinate value.  Starting at the origin, sufficient bins\n  are created in both directions to completely span the simulation box\n  or the bounds specified by the optional bounds keyword.\n  For orthogonal simulation boxes, the bins are layers, pencils, or\n  boxes aligned with the xyz coordinate axes.  For triclinic\n  (non-orthogonal) simulation boxes, the bin faces are parallel to the\n  tilted faces of the simulation box.  See the Howto triclinic doc page for a discussion of the\n  geometry of triclinic boxes in LAMMPS.  As described there, a tilted\n  simulation box has edge vectors a,b,c.  In that nomenclature, bins in\n  the x dimension have faces with normals in the “b” cross “c”\n  direction.  Bins in y have faces normal to the “a” cross “c”\n  direction.  And bins in z have faces normal to the “a” cross “b”\n  direction.  Note that in order to define the size and position of\n  these bins in an unambiguous fashion, the units option must be set\n  to reduced when using a triclinic simulation box, as noted below.\n  The meaning of origin and delta for triclinic boxes is as follows.\n  Consider a triclinic box with bins that are 1d layers or slabs in the\n  x dimension.  No matter how the box is tilted, an origin of 0.0\n  means start layers at the lower “b” cross “c” plane of the simulation\n  box and an origin of 1.0 means to start layers at the upper “b”\n  cross “c” face of the box.  A delta value of 0.1 in reduced units\n  means there will be 10 layers from 0.0 to 1.0, regardless of the\n  current size or shape of the simulation box.\n  The bin/sphere style defines a set of spherical shell bins around\n  the origin (xorig,yorig,zorig), using nsbin bins with radii\n  equally spaced between srmin and srmax.  This is effectively a 1d\n  vector of bins.  For example, if srmin = 1.0 and srmax = 10.0 and\n  nsbin = 9, then the first bin spans 1.0 < r < 2.0, and the last bin\n  spans 9.0 < r 10.0.  The geometry of the bins is the same whether the\n  simulation box is orthogonal or triclinic; i.e. the spherical shells\n  are not tilted or scaled differently in different dimensions to\n  transform them into ellipsoidal shells.\n  The bin/cylinder style defines bins for a cylinder oriented along\n  the axis dim with the axis coordinates in the other two radial\n  dimensions at (c1,c2).  For dim = x, c1/c2 = y/z; for dim = y,\n  c1/c2 = x/z; for dim = z, c1/c2 = x/y.  This is effectively a 2d array\n  of bins.  The first dimension is along the cylinder axis, the second\n  dimension is radially outward from the cylinder axis.  The bin size\n  and positions along the cylinder axis are specified by the origin\n  and delta values, the same as for the bin/1d, bin/2d, and\n  bin/3d styles.  There are ncbin concentric circle bins in the\n  radial direction from the cylinder axis with radii equally spaced\n  between crmin and crmax.  For example, if crmin = 1.0 and\n  crmax = 10.0 and ncbin = 9, then the first bin spans 1.0 < r <\n  2.0, and the last bin spans 9.0 < r 10.0.  The geometry of the bins in\n  the radial dimensions is the same whether the simulation box is\n  orthogonal or triclinic; i.e. the concentric circles are not tilted or\n  scaled differently in the two different dimensions to transform them\n  into ellipses.\n  The created bins (and hence the chunk IDs) are numbered consecutively\n  from 1 to the number of bins = Nchunk.  For bin2d and bin3d, the\n  numbering varies most rapidly in the first dimension (which could be\n  x, y, or z), next rapidly in the 2nd dimension, and most slowly in the\n  3rd dimension.  For bin/sphere, the bin with smallest radii is chunk\n  1 and the bni with largest radii is chunk Nchunk = ncbin.  For\n  bin/cylinder, the numbering varies most rapidly in the dimension\n  along the cylinder axis and most slowly in the radial direction.\n  Each time this compute is invoked, each atom is mapped to a bin based\n  on its current position.  Note that between reneighboring timesteps,\n  atoms can move outside the current simulation box.  If the box is\n  periodic (in that dimension) the atom is remapping into the periodic\n  box for purposes of binning.  If the box in not periodic, the atom may\n  have moved outside the bounds of all bins.  If an atom is not inside\n  any bin, the discard keyword is used to determine how a chunk ID is\n  assigned to the atom.\n  \n  The type style uses the atom type as the chunk ID.  Nchunk is set\n  to the number of atom types defined for the simulation, e.g. via the\n  create_box or read_data commands.\n  \n  The molecule style uses the molecule ID of each atom as its chunk\n  ID.  Nchunk is set to the largest chunk ID.  Note that this excludes\n  molecule IDs for atoms which are not in the specified group or\n  optional region.\n  There is no requirement that all atoms in a particular molecule are\n  assigned the same chunk ID (zero or non-zero), though you probably\n  want that to be the case, if you wish to compute a per-molecule\n  property.  LAMMPS will issue a warning if that is not the case, but\n  only the first time that Nchunk is calculated.\n  Note that atoms with a molecule ID = 0, which may be non-molecular\n  solvent atoms, have an out-of-range chunk ID.  These atoms are\n  discarded (not assigned to any chunk) or assigned to Nchunk,\n  depending on the value of the discard keyword.\n  \n  The compute/fix/variable styles set the chunk ID of each atom based\n  on a quantity calculated and stored by a compute, fix, or variable.\n  In each case, it must be a per-atom quantity.  In each case the\n  referenced floating point values are converted to an integer chunk ID\n  as follows.  The floating point value is truncated (rounded down) to\n  an integer value.  If the integer value is <= 0, then a chunk ID of 0\n  is assigned to the atom.  If the integer value is > 0, it becomes the\n  chunk ID to the atom.  Nchunk is set to the largest chunk ID.  Note\n  that this excludes atoms which are not in the specified group or\n  optional region.\n  If the style begins with “c_”, a compute ID must follow which has been\n  previously defined in the input script.  If no bracketed integer is\n  appended, the per-atom vector calculated by the compute is used.  If a\n  bracketed integer is appended, the Ith column of the per-atom array\n  calculated by the compute is used.  Users can also write code for\n  their own compute styles and add them to LAMMPS.\n  If the style begins with “f_”, a fix ID must follow which has been\n  previously defined in the input script.  If no bracketed integer is\n  appended, the per-atom vector calculated by the fix is used.  If a\n  bracketed integer is appended, the Ith column of the per-atom array\n  calculated by the fix is used.  Note that some fixes only produce\n  their values on certain timesteps, which must be compatible with the\n  timestep on which this compute accesses the fix, else an error\n  results.  Users can also write code for their own fix styles and add them to LAMMPS.\n  If a value begins with “v_”, a variable name for an atom or\n  atomfile style variable must follow which has been\n  previously defined in the input script.  Variables of style atom can\n  reference thermodynamic keywords and various per-atom attributes, or\n  invoke other computes, fixes, or variables when they are evaluated, so\n  this is a very general means of generating per-atom quantities to\n  treat as a chunk ID.\n  \n  Normally, Nchunk = the number of chunks, is re-calculated every time\n  this fix is invoked, though the value may or may not change.  As\n  explained below, the nchunk keyword can be set to once which means\n  Nchunk will never change.\n  If a fix ave/chunk command uses this compute, it\n  can also turn off the re-calculation of Nchunk for one or more\n  windows of timesteps.  The extent of the windows, during which Nchunk\n  is held constant, are determined by the Nevery, Nrepeat, Nfreq\n  values and the ave keyword setting that are used by the fix ave/chunk command.\n  Specifically, if ave = one, then for each span of Nfreq\n  timesteps, Nchunk is held constant between the first timestep when\n  averaging is done (within the Nfreq-length window), and the last\n  timestep when averaging is done (multiple of Nfreq).  If ave =\n  running or window, then Nchunk is held constant forever,\n  starting on the first timestep when the fix ave/chunk command invokes this compute.\n  Note that multiple fix ave/chunk commands can use\n  the same compute chunk/atom compute.  However, the time windows they\n  induce for holding Nchunk constant must be identical, else an error\n  will be generated.\n  \n  The various optional keywords operate as follows.  Note that some of\n  them function differently or are ignored by different chunk styles.\n  Some of them also have different default values, depending on\n  the chunk style, as listed below.\n  The region keyword applies to all chunk styles.  If used, an atom\n  must be in both the specified group and the specified geometric\n  region to be assigned to a chunk.\n  \n  The nchunk keyword applies to all chunk styles.  It specifies how\n  often Nchunk is recalculated, which in turn can affect the chunk IDs\n  assigned to individual atoms.\n  If nchunk is set to once, then Nchunk is only calculated once,\n  the first time this compute is invoked.  If nchunk is set to\n  every, then Nchunk is re-calculated every time the compute is\n  invoked.  Note that, as described above, the use of this compute\n  by the fix ave/chunk command can override\n  the every setting.\n  The default values for nchunk are listed below and depend on the\n  chunk style and other system and keyword settings.  They attempt to\n  represent typical use cases for the various chunk styles.  The\n  nchunk value can always be set explicitly if desired.\n  \n  The limit keyword can be used to limit the calculated value of\n  Nchunk = the number of chunks.  The limit is applied each time\n  Nchunk is calculated, which also limits the chunk IDs assigned to\n  any atom.  The limit keyword is used by all chunk styles except the\n  binning styles, which ignore it.  This is because the number of bins\n  can be tailored using the bound keyword (described below) which\n  effectively limits the size of Nchunk.\n  If limit is set to Nc = 0, then no limit is imposed on Nchunk,\n  though the compress keyword can still be used to reduce Nchunk, as\n  described below.\n  If Nc > 0, then the effect of the limit keyword depends on whether\n  the compress keyword is also used with a setting of yes, and\n  whether the compress keyword is specified before the limit keyword\n  or after.\n  In all cases, Nchunk is first calculated in the usual way for each\n  chunk style, as described above.\n  First, here is what occurs if compress yes is not set.  If limit\n  is set to Nc max, then Nchunk is reset to the smaller of Nchunk\n  and Nc.  If limit is set to Nc exact, then Nchunk is reset to\n  Nc, whether the original Nchunk was larger or smaller than Nc.\n  If Nchunk shrank due to the limit setting, then atom chunk IDs >\n  Nchunk will be reset to 0 or Nchunk, depending on the setting of\n  the discard keyword.  If Nchunk grew, there will simply be some\n  chunks with no atoms assigned to them.\n  If compress yes is set, and the compress keyword comes before the\n  limit keyword, the compression operation is performed first, as\n  described below, which resets Nchunk.  The limit keyword is then\n  applied to the new Nchunk value, exactly as described in the\n  preceding paragraph.  Note that in this case, all atoms will end up\n  with chunk IDs <= Nc, but their original values (e.g. molecule ID or\n  compute/fix/variable) may have been > Nc, because of the compression\n  operation.\n  If compress yes is set, and the compress keyword comes after the\n  limit keyword, then the limit value of Nc is applied first to\n  the uncompressed value of Nchunk, but only if Nc < Nchunk\n  (whether Nc max or Nc exact is used).  This effectively means all\n  atoms with chunk IDs > Nc have their chunk IDs reset to 0 or Nc,\n  depending on the setting of the discard keyword.  The compression\n  operation is then performed, which may shrink Nchunk further.  If\n  the new Nchunk < Nc and limit = Nc exact is specified, then\n  Nchunk is reset to Nc, which results in extra chunks with no atoms\n  assigned to them.  Note that in this case, all atoms will end up with\n  chunk IDs <= Nc, and their original values (e.g. molecule ID or\n  compute/fix/variable value) will also have been <= Nc.\n  \n  The ids keyword applies to all chunk styles.  If the setting is\n  once then the chunk IDs assigned to atoms the first time this\n  compute is invoked will be permanent, and never be re-computed.\n  If the setting is nfreq and if a fix ave/chunk\n  command is using this compute, then in each of the Nchunk = constant\n  time windows (discussed above), the chunk ID’s assigned to atoms on\n  the first step of the time window will persist until the end of the\n  time window.\n  If the setting is every, which is the default, then chunk IDs are\n  re-calculated on any timestep this compute is invoked.\n  \n  Note\n  If you want the persistent chunk-IDs calculated by this compute\n  to be continuous when running from a restart file,\n  then you should use the same ID for this compute, as in the original\n  run.  This is so that the fix this compute creates to store per-atom\n  quantities will also have the same ID, and thus be initialized\n  correctly with chunk IDs from the restart file.\n  \n  \n  The compress keyword applies to all chunk styles and affects how\n  Nchunk is calculated, which in turn affects the chunk IDs assigned\n  to each atom.  It is useful for converting a “sparse” set of chunk IDs\n  (with many IDs that have no atoms assigned to them), into a “dense”\n  set of IDs, where every chunk has one or more atoms assigned to it.\n  Two possible use cases are as follows.  If a large simulation box is\n  mostly empty space, then the binning style may produce many bins\n  with no atoms.  If compress is set to yes, only bins with atoms\n  will be contribute to Nchunk.  Likewise, the molecule or\n  compute/fix/variable styles may produce large Nchunk values.  For\n  example, the compute cluster/atom command\n  assigns every atom an atom ID for one of the atoms it is clustered\n  with.  For a million-atom system with 5 clusters, there would only be\n  5 unique chunk IDs, but the largest chunk ID might be 1 million,\n  resulting in Nchunk = 1 million.  If compress is set to yes,\n  Nchunk will be reset to 5.\n  If compress is set to no, which is the default, no compression is\n  done.  If it is set to yes, all chunk IDs with no atoms are removed\n  from the list of chunk IDs, and the list is sorted.  The remaining\n  chunk IDs are renumbered from 1 to Nchunk where Nchunk is the new\n  length of the list.  The chunk IDs assigned to each atom reflect\n  the new renumbering from 1 to Nchunk.\n  The original chunk IDs (before renumbering) can be accessed by the\n  compute property/chunk command and its\n  id keyword, or by the fix ave/chunk command\n  which outputs the original IDs as one of the columns in its global\n  output array.  For example, using the “compute cluster/atom” command\n  discussed above, the original 5 unique chunk IDs might be atom IDs\n  (27,4982,58374,857838,1000000).  After compression, these will be\n  renumbered to (1,2,3,4,5).  The original values (27,…,1000000) can\n  be output to a file by the fix ave/chunk command,\n  or by using the fix ave/time command in\n  conjunction with the compute property/chunk command.\n  \n  Note\n  The compression operation requires global communication across\n  all processors to share their chunk ID values.  It can require large\n  memory on every processor to store them, even after they are\n  compressed, if there are a large number of unique chunk IDs with\n  atoms assigned to them.  It uses a STL map to find unique chunk IDs\n  and store them in sorted order.  Each time an atom is assigned a\n  compressed chunk ID, it must access the STL map.  All of this means\n  that compression can be expensive, both in memory and CPU time.  The\n  use of the limit keyword in conjunction with the compress keyword\n  can affect these costs, depending on which keyword is used first.  So\n  use this option with care.\n  \n  \n  The discard keyword applies to all chunk styles.  It affects what\n  chunk IDs are assigned to atoms that do not match one of the valid\n  chunk IDs from 1 to Nchunk.  Note that it does not apply to atoms\n  that are not in the specified group or optionally specified region.\n  Those atoms are always assigned a chunk ID = 0.\n  If the calculated chunk ID for an atom is not within the range 1 to\n  Nchunk then it is a “discard” atom.  Note that Nchunk may have\n  been shrunk by the limit keyword.  Or the compress keyword may\n  have eliminated chunk IDs that were valid before the compression took\n  place, and are now not in the compressed list.  Also note that for the\n  molecule chunk style, if new molecules are added to the system,\n  their chunk IDs may exceed a previously calculated Nchunk.\n  Likewise, evaluation of a compute/fix/variable on a later timestep may\n  return chunk IDs that are invalid for the previously calculated\n  Nchunk.\n  All the chunk styles except the binning styles, must use discard\n  set to either yes or no.  If discard is set to yes, which is\n  the default, then every “discard” atom has its chunk ID set to 0.  If\n  discard is set to no, every “discard” atom has its chunk ID set to\n  Nchunk.  I.e. it becomes part of the last chunk.\n  The binning styles use the discard keyword to decide whether to\n  discard atoms outside the spatial domain covered by bins, or to assign\n  them to the bin they are nearest to.\n  For the bin/1d, bin/2d, bin/3d styles the details are as\n  follows.  If discard is set to yes, an out-of-domain atom will\n  have its chunk ID set to 0.  If discard is set to no, the atom\n  will have its chunk ID set to the first or last bin in that dimension.\n  If discard is set to mixed, which is the default, it will only\n  have its chunk ID set to the first or last bin if bins extend to the\n  simulation box boundary in that dimension.  This is the case if the\n  bound keyword settings are lower and upper, which is the\n  default.  If the bound keyword settings are numeric values, then the\n  atom will have its chunk ID set to 0 if it is outside the bounds of\n  any bin.  Note that in this case, it is possible that the first or\n  last bin extends beyond the numeric bounds settings, depending on\n  the specified origin.  If this is the case, the chunk ID of the atom\n  is only set to 0 if it is outside the first or last bin, not if it is\n  simply outside the numeric bounds setting.\n  For the bin/sphere style the details are as follows.  If discard\n  is set to yes, an out-of-domain atom will have its chunk ID set to\n  0.  If discard is set to no or mixed, the atom will have its\n  chunk ID set to the first or last bin, i.e. the innermost or outermost\n  spherical shell.  If the distance of the atom from the origin is less\n  than rmin, it will be assigned to the first bin.  If the distance of\n  the atom from the origin is greater than rmax, it will be assigned\n  to the last bin.\n  For the bin/cylinder style the details are as follows.  If discard\n  is set to yes, an out-of-domain atom will have its chunk ID set to\n  0.  If discard is set to no, the atom will have its chunk ID set\n  to the first or last bin in both the radial and axis dimensions.  If\n  discard is set to mixed, which is the default, the radial\n  dimension is treated the same as for discard = no.  But for the axis\n  dimension, it will only have its chunk ID set to the first or last\n  bin if bins extend to the simulation box boundary in the axis\n  dimension.  This is the case if the bound keyword settings are\n  lower and upper, which is the default.  If the bound keyword\n  settings are numeric values, then the atom will have its chunk ID set\n  to 0 if it is outside the bounds of any bin.  Note that in this case,\n  it is possible that the first or last bin extends beyond the numeric\n  bounds settings, depending on the specified origin.  If this is\n  the case, the chunk ID of the atom is only set to 0 if it is outside\n  the first or last bin, not if it is simply outside the numeric\n  bounds setting.\n  If discard is set to no or mixed, the atom will have its\n  chunk ID set to the first or last bin, i.e. the innermost or outermost\n  spherical shell.  If the distance of the atom from the origin is less\n  than rmin, it will be assigned to the first bin.  If the distance of\n  the atom from the origin is greater than rmax, it will be assigned\n  to the last bin.\n  \n  The bound keyword only applies to the bin/1d, bin/2d, bin/3d\n  styles and to the axis dimension of the bin/cylinder style;\n  otherwise it is ignored.  It can be used one or more times to limit\n  the extent of bin coverage in a specified dimension, i.e. to only bin\n  a portion of the box.  If the lo setting is lower or the hi\n  setting is upper, the bin extent in that direction extends to the\n  box boundary.  If a numeric value is used for lo and/or hi, then\n  the bin extent in the lo or hi direction extends only to that\n  value, which is assumed to be inside (or at least near) the simulation\n  box boundaries, though LAMMPS does not check for this.  Note that\n  using the bound keyword typically reduces the total number of bins\n  and thus the number of chunks Nchunk.\n  The pbc keyword only applies to the bin/sphere and bin/cylinder\n  styles.  If set to yes, the distance an atom is from the sphere\n  origin or cylinder axis is calculated in a minimum image sense with\n  respect to periodic dimensions, when determining which bin the atom is\n  in.  I.e. if x is a periodic dimension and the distance between the\n  atom and the sphere center in the x dimension is greater than 0.5 *\n  simulation box length in x, then a box length is subtracted to give a\n  distance < 0.5 * simulation box length.  This allosws the sphere or\n  cylinder center to be near a box edge, and atoms on the other side of\n  the periodic box will still be close to the center point/axis.  Note\n  that with a setting of yes, the outer sphere or cylinder radius must\n  also be <= 0.5 * simulation box length in any periodic dimension\n  except for the cylinder axis dimension, or an error is generated.\n  The units keyword only applies to the binning styles; otherwise it\n  is ignored.  For the bin/1d, bin/2d, bin/3d styles, it\n  determines the meaning of the distance units used for the bin sizes\n  delta and for origin and bounds values if they are coordinate\n  values.  For the bin/sphere style it determines the meaning of the\n  distance units used for xorig,yorig,zorig and the radii srmin\n  and srmax.  For the bin/cylinder style it determines the meaning\n  of the distance units used for delta,c1,c2 and the radii crmin\n  and crmax.\n  For orthogonal simulation boxes, any of the 3 options may\n  be used.  For non-orthogonal (triclinic) simulation boxes, only the\n  reduced option may be used.\n  A box value selects standard distance units as defined by the\n  units command, e.g. Angstroms for units = real or metal.\n  A lattice value means the distance units are in lattice spacings.\n  The lattice command must have been previously used to\n  define the lattice spacing.  A reduced value means normalized\n  unitless values between 0 and 1, which represent the lower and upper\n  faces of the simulation box respectively.  Thus an origin value of\n  0.5 means the center of the box in any dimension.  A delta value of\n  0.1 means 10 bins span the box in that dimension.\n  Note that for the bin/sphere style, the radii srmin and srmax are\n  scaled by the lattice spacing or reduced value of the x dimension.\n  Note that for the bin/cylinder style, the radii crmin and crmax\n  are scaled by the lattice spacing or reduced value of the 1st\n  dimension perpendicular to the cylinder axis.  E.g. y for an x-axis\n  cylinder, x for a y-axis cylinder, and x for a z-axis cylinder.\n  \n  Output info:\n  This compute calculates a per-atom vector, which can be accessed by\n  any command that uses per-atom values from a compute as input.  See\n  the Howto output doc page for an overview of\n  LAMMPS output options.\n  The per-atom vector values are unitless chunk IDs, ranging from 1 to\n  Nchunk (inclusive) for atoms assigned to chunks, and 0 for atoms not\n  belonging to a chunk.\n  ",
    "syntax": "compute ID group-ID chunk/atom style args keyword values ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  chunk/atom = style name of this compute command\n  style = bin/1d or bin/2d or bin/3d or bin/sphere or type or molecule or c_ID, c_ID[I], f_ID, f_ID[I], v_name\n    bin/1d args = dim origin delta\n      dim = x or y or z\n      origin = lower or center or upper or coordinate value (distance units)\n      delta = thickness of spatial bins in dim (distance units)\n    bin/2d args = dim origin delta dim origin delta\n      dim = x or y or z\n      origin = lower or center or upper or coordinate value (distance units)\n      delta = thickness of spatial bins in dim (distance units)\n    bin/3d args = dim origin delta dim origin delta dim origin delta\n      dim = x or y or z\n      origin = lower or center or upper or coordinate value (distance units)\n      delta = thickness of spatial bins in dim (distance units)\n    bin/sphere args = xorig yorig zorig rmin rmax nsbin\n      xorig,yorig,zorig = center point of sphere\n      srmin,srmax = bin from sphere radius rmin to rmax\n      nsbin = # of spherical shell bins between rmin and rmax\n    bin/cylinder args = dim origin delta c1 c2 rmin rmax ncbin\n      dim = x or y or z = axis of cylinder axis\n      origin = lower or center or upper or coordinate value (distance units)\n      delta = thickness of spatial bins in dim (distance units)\n      c1,c2 = coords of cylinder axis in other 2 dimensions (distance units)\n      crmin,crmax = bin from cylinder radius rmin to rmax (distance units)\n      ncbin = # of concentric circle bins between rmin and rmax\n    type args = none\n    molecule args = none\n    c_ID, c_ID[I], f_ID, f_ID[I], v_name args = none\n      c_ID = per-atom vector calculated by a compute with ID\n      c_ID[I] = Ith column of per-atom array calculated by a compute with ID\n      f_ID = per-atom vector calculated by a fix with ID\n      f_ID[I] = Ith column of per-atom array calculated by a fix with ID\n      v_name = per-atom vector calculated by an atom-style variable with name\n  \n  zero or more keyword/values pairs may be appended\n  keyword = region or nchunk or static or compress or bound or discard or pbc or units\n  region value = region-ID\n    region-ID = ID of region atoms must be in to be part of a chunk\n  nchunk value = once or every\n    once = only compute the number of chunks once\n    every = re-compute the number of chunks whenever invoked\n  limit values = 0 or Nc max or Nc exact\n    0 = no limit on the number of chunks\n    Nc max = limit number of chunks to be <= Nc\n    Nc exact = set number of chunks to exactly Nc\n  ids value = once or nfreq or every\n    once = assign chunk IDs to atoms only once, they persist thereafter\n    nfreq = assign chunk IDs to atoms only once every Nfreq steps (if invoked by fix ave/chunk which sets Nfreq)\n    every = assign chunk IDs to atoms whenever invoked\n  compress value = yes or no\n    yes = compress chunk IDs to eliminate IDs with no atoms\n    no = do not compress chunk IDs even if some IDs have no atoms\n  discard value = yes or no or mixed\n    yes = discard atoms with out-of-range chunk IDs by assigning a chunk ID = 0\n    no = keep atoms with out-of-range chunk IDs by assigning a valid chunk ID\n    mixed = keep or discard such atoms according to spatial binning rule\n  bound values = x/y/z lo hi\n    x/y/z = x or y or z to bound sptial bins in this dimension\n    lo = lower or coordinate value (distance units)\n    hi = upper or coordinate value (distance units)\n  pbc value = no or yes\n    yes = use periodic distance for bin/sphere and bin/cylinder styles\n  units value = box or lattice or reduced\n  \n  \n  ",
    "examples": "compute 1 all chunk/atom type\n  compute 1 all chunk/atom bin/1d z lower 0.02 units reduced\n  compute 1 all chunk/atom bin/2d z lower 1.0 y 0.0 2.5\n  compute 1 all chunk/atom molecule region sphere nchunk once ids once compress yes\n  compute 1 all chunk/atom bin/sphere 5 5 5 2.0 5.0 5 discard yes\n  compute 1 all chunk/atom bin/cylinder z lower 2 10 10 2.0 5.0 3 discard yes\n  compute 1 all chunk/atom c_cluster\n  \n  \n  ",
    "restrictions": "Even if the nchunk keyword is set to once, the chunk IDs assigned\n  to each atom are not stored in a restart files.  This means you cannot\n  expect those assignments to persist in a restarted simulation.\n  Instead you must re-specify this command and assign atoms to chunks when\n  the restarted simulation begins.\n  "
},
{
    "command": "compute chunk/spread/atom",
    "description": "Define a calculation that “spreads” one or more per-chunk values to\n  each atom in the chunk.  This can be useful in several scenarios:\n  \n  For creating a dump file where each atom lists info about\n  the chunk it is in, e.g. for post-processing purposes.\n  To access chunk value in atom-style variables that\n  need info about the chunk each atom is in.\n  To use the fix ave/chunk command to spatially\n  average per-chunk values calculated by a per-chunk compute.\n  \n  Examples are given below.\n  In LAMMPS, chunks are collections of atoms defined by a compute chunk/atom command, which assigns each atom\n  to a single chunk (or no chunk).  The ID for this command is specified\n  as chunkID.  For example, a single chunk could be the atoms in a\n  molecule or atoms in a spatial bin.  See the compute chunk/atom and Howto chunk\n  doc pages for details of how chunks can be defined and examples of how\n  they can be used to measure properties of a system.\n  For inputs that are computes, they must be a compute that calculates\n  per-chunk values.  These are computes whose style names end in\n  “/chunk”.\n  For inputs that are fixes, they should be a fix that calculates\n  per-chunk values.  For example, fix ave/chunk or\n  fix ave/time (assuming it is time-averaging\n  per-chunk data).\n  For each atom, this compute accesses its chunk ID from the specified\n  chunkID compute, then accesses the per-chunk value in each input.\n  Those values are copied to this compute to become the output for that\n  atom.\n  The values generated by this compute will be 0.0 for atoms not in the\n  specified compute group group-ID.  They will also be 0.0 if the atom\n  is not in a chunk, as assigned by the chunkID compute.  They will\n  also be 0.0 if the current chunk ID for the atom is out-of-bounds with\n  respect to the number of chunks stored by a particular input compute\n  or fix.\n  \n  Note\n  LAMMPS does not check that a compute or fix which calculates\n  per-chunk values uses the same definition of chunks as this compute.\n  It’s up to you to be consistent.  Likewise, for a fix input, LAMMPS\n  does not check that it is per-chunk data.  It only checks that the fix\n  produces a global vector or array.\n  \n  \n  Each listed input is operated on independently.\n  If a bracketed index I is used, it can be specified using a wildcard\n  asterisk with the index to effectively specify multiple values.  This\n  takes the form “*” or “*n” or “n*” or “m*n”.  If N = the number of\n  columns in the array, then an asterisk with no numeric values means\n  all indices from 1 to N.  A leading asterisk means all indices from 1\n  to n (inclusive).  A trailing asterisk means all indices from n to N\n  (inclusive).  A middle asterisk means all indices from m to n\n  (inclusive).\n  Using a wildcard is the same as if the individual columns of the array\n  had been listed one by one.  E.g. these 2 compute chunk/spread/atom\n  commands are equivalent, since the compute com/chunk command creates a per-atom array\n  with 3 columns:\n  compute com all com/chunk mychunk\n  compute 10 all chunk/spread/atom mychunk c_com[*]\n  compute 10 all chunk/spread/atom mychunk c_com[1] c_com[2] c_com[3]\n  \n  \n  \n  Here is an example of writing a dump file the with the center-of-mass\n  (COM) for the chunk each atom is in.  The commands below can be added\n  to the bench/in.chain script.\n  compute         cmol all chunk/atom molecule\n  compute         com all com/chunk cmol\n  compute         comchunk all chunk/spread/atom cmol c_com[*]\n  dump            1 all custom 50 tmp.dump id mol type x y z c_comchunk[*]\n  dump_modify     1 sort id\n  \n  \n  The same per-chunk data for each atom could be used to define per-atom\n  forces for the fix addforce command.  In this\n  example the forces act to pull atoms of an extended polymer chain\n  towards its COM in an attractive manner.\n  compute         prop all property/atom xu yu zu\n  variable        k equal 0.1\n  variable        fx atom v_k*(c_comchunk[1]-c_prop[1])\n  variable        fy atom v_k*(c_comchunk[2]-c_prop[2])\n  variable        fz atom v_k*(c_comchunk[3]-c_prop[3])\n  fix             3 all addforce v_fx v_fy v_fz\n  \n  \n  Note that compute property/atom is used\n  to generate unwrapped coordinates for use in the per-atom force\n  calculation, so that the effect of periodic boundaries is accounted\n  for properly.\n  Over time this applied force could shrink each polymer chain’s radius\n  of gyration in a polymer mixture simulation.  Here is output from the\n  bench/in.chain script.  Thermo output is shown for 1000 steps, where\n  the last column is the average radius of gyration over all 320 chains\n  in the 32000 atom system:\n  compute         gyr all gyration/chunk cmol\n  variable        ave equal ave(c_gyr)\n  thermo_style    custom step etotal press v_ave\n  \n         0    22.394765    4.6721833     5.128278\n       100    22.445002    4.8166709    5.0348372\n       200    22.500128    4.8790392    4.9364875\n       300    22.534686    4.9183766    4.8590693\n       400    22.557196    4.9492211    4.7937849\n       500    22.571017    4.9161853    4.7412008\n       600    22.573944    5.0229708    4.6931243\n       700    22.581804    5.0541301    4.6440647\n       800    22.584683    4.9691734    4.6000016\n       900     22.59128    5.0247538    4.5611513\n      1000    22.586832      4.94697    4.5238362\n  \n  \n  \n  Here is an example for using one set of chunks, defined for molecules,\n  to compute the dipole moment vector for each chunk.  E.g. for water\n  molecules. Then spreading those values to each atom in each chunk.\n  Then defining a second set of chunks based on spatial bins.  And\n  finally, using the fix ave/chunk command to\n  calculate an average dipole moment vector per spatial bin.\n  compute       cmol all chunk/atom molecule\n  compute       dipole all dipole/chunk cmol\n  compute       spread all chunk/spread/atom cmol c_dipole[1] c_dipole[2] c_dipole[3]\n  compute       cspatial all chunk/atom bin/1d z lower 0.1 units reduced\n  fix           ave all ave/chunk 100 10 1000 cspatial c_spread[*]\n  \n  \n  Note that the fix ave/chunk command requires\n  per-atom values as input.  That is why the compute chunk/spread/atom\n  command is used to assign per-chunk values to each atom in the chunk.\n  If a molecule straddles bin boundaries, each of its atoms contributes\n  in a weighted manner to the average dipole moment of the spatial bin\n  it is in.\n  \n  Output info:\n  This compute calculates a per-atom vector or array, which can be\n  accessed by any command that uses per-atom values from a compute as\n  input.  See the Howto output doc page for an\n  overview of LAMMPS output options.\n  The output is a per-atom vector if a single input value is specified,\n  otherwise a per-atom array is output.  The number of columns in the\n  array is the number of inputs provided.  The per-atom values for the\n  vector or each column of the array will be in whatever\n  units the corresponding input value is in.\n  The vector or array values are “intensive”.\n  ",
    "syntax": "compute ID group-ID chunk/spread/atom chunkID input1 input2 ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  chunk/spread/atom = style name of this compute command\n  chunkID = ID of compute chunk/atom command\n  one or more inputs can be listed\n  input = c_ID, c_ID[N], f_ID, f_ID[N]\n  c_ID = global vector calculated by a compute with ID\n  c_ID[I] = Ith column of global array calculated by a compute with ID, I can include wildcard (see below)\n  f_ID = global vector calculated by a fix with ID\n  f_ID[I] = Ith column of global array calculated by a fix with ID, I can include wildcard (see below)\n  \n  \n  \n  \n  ",
    "examples": "compute 1 all chunk/spread/atom mychunk c_com[*] c_gyration\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute cluster/atom",
    "description": "Define a computation that assigns each atom a cluster, fragment,\n  or aggregate ID.\n  A cluster is defined as a set of atoms, each of which is within the\n  cutoff distance from one or more other atoms in the cluster.  If an\n  atom has no neighbors within the cutoff distance, then it is a 1-atom\n  cluster.\n  A fragment is similarly defined as a set of atoms, each of\n  which has an explicit bond (i.e. defined via a data file,\n  the create_bonds command, or through fixes like\n  fix bond/create, fix bond/swap,\n  or fix bond/break).  The cluster ID or fragment ID\n  of every atom in the cluster will be set to the smallest atom ID of any atom\n  in the cluster or fragment, respectively.\n  An aggregate is defined by combining the rules for clusters and\n  fragments, i.e. a set of atoms, where each of it is within the cutoff\n  distance from one or more atoms within a fragment that is part of\n  the same cluster. This measure can be used to track molecular assemblies\n  like micelles.\n  Only atoms in the compute group are clustered and assigned cluster\n  IDs. Atoms not in the compute group are assigned a cluster ID = 0.\n  For fragments, only bonds where both atoms of the bond are included\n  in the compute group are assigned to fragments, so that only fragments\n  are detected where all atoms are in the compute group. Thus atoms\n  may be included in the compute group, yes still have a fragment ID of 0.\n  For computes cluster/atom and aggregate/atom the neighbor list needed\n  to compute this quantity is constructed each time the calculation is\n  performed (i.e. each time a snapshot of atoms is dumped).  Thus it can be\n  inefficient to compute/dump this quantity too frequently or to have\n  multiple compute/dump commands, each of a cluster/atom or\n  aggregate/atom style.\n  \n  Note\n  If you have a bonded system, then the settings of\n  special_bonds command can remove pairwise\n  interactions between atoms in the same bond, angle, or dihedral.  This\n  is the default setting for the special_bonds\n  command, and means those pairwise interactions do not appear in the\n  neighbor list.  Because this fix uses the neighbor list, it also means\n  those pairs will not be included when computing the clusters. This\n  does not apply when using long-range coulomb (coul/long, coul/msm,\n  coul/wolf or similar.  One way to get around this would be to set\n  special_bond scaling factors to very tiny numbers that are not exactly\n  zero (e.g. 1.0e-50). Another workaround is to write a dump file, and\n  use the rerun command to compute the clusters for\n  snapshots in the dump file.  The rerun script can use a\n  special_bonds command that includes all pairs in\n  the neighbor list.\n  \n  Output info:\n  This compute calculates a per-atom vector, which can be accessed by\n  any command that uses per-atom values from a compute as input.  See\n  the Howto output doc page for an overview of\n  LAMMPS output options.\n  The per-atom vector values will be an ID > 0, as explained above.\n  ",
    "syntax": "compute ID group-ID cluster/atom cutoff\n  compute ID group-ID fragment/atom\n  compute ID group-ID aggregate/atom cutoff\n  \n  \n  \n  ID, group-ID are documented in compute command\n  cluster/atom or fragment/atom or aggregate/atom = style name of this compute command\n  cutoff = distance within which to label atoms as part of same cluster (distance units)\n  \n  ",
    "examples": "compute 1 all cluster/atom 3.5\n  compute 1 all fragment/atom\n  \n  compute 1 all aggregate/atom 3.5\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute cna/atom",
    "description": "Define a computation that calculates the CNA (Common Neighbor\n  Analysis) pattern for each atom in the group.  In solid-state systems\n  the CNA pattern is a useful measure of the local crystal structure\n  around an atom.  The CNA methodology is described in (Faken)\n  and (Tsuzuki).\n  Currently, there are five kinds of CNA patterns LAMMPS recognizes:\n  \n  fcc = 1\n  hcp = 2\n  bcc = 3\n  icosahedral = 4\n  unknown = 5\n  \n  The value of the CNA pattern will be 0 for atoms not in the specified\n  compute group.  Note that normally a CNA calculation should only be\n  performed on mono-component systems.\n  The CNA calculation can be sensitive to the specified cutoff value.\n  You should insure the appropriate nearest neighbors of an atom are\n  found within the cutoff distance for the presumed crystal structure.\n  E.g. 12 nearest neighbor for perfect FCC and HCP crystals, 14 nearest\n  neighbors for perfect BCC crystals.  These formulas can be used to\n  obtain a good cutoff distance:\n  \n  \\[\\begin{split}r_{c}^{fcc} = & \\frac{1}{2} \\left(\\frac{\\sqrt{2}}{2} + 1\\right) \\mathrm{a} \\simeq 0.8536 \\:\\mathrm{a} \\\\\n  r_{c}^{bcc} = & \\frac{1}{2}(\\sqrt{2} + 1) \\mathrm{a} \\simeq 1.207 \\:\\mathrm{a} \\\\\n  r_{c}^{hcp} = & \\frac{1}{2}\\left(1+\\sqrt{\\frac{4+2x^{2}}{3}}\\right) \\mathrm{a}\\end{split}\\]\n  where a is the lattice constant for the crystal structure concerned\n  and in the HCP case, x = (c/a) / 1.633, where 1.633 is the ideal c/a\n  for HCP crystals.\n  Also note that since the CNA calculation in LAMMPS uses the neighbors\n  of an owned atom to find the nearest neighbors of a ghost atom, the\n  following relation should also be satisfied:\n  \n  \\[r_c + r_s > 2*{\\rm cutoff}\\]\n  where \\(r_c\\) is the cutoff distance of the potential, \\(r_s\\)\n  is the skin\n  distance as specified by the neighbor command, and\n  cutoff is the argument used with the compute cna/atom command.  LAMMPS\n  will issue a warning if this is not the case.\n  The neighbor list needed to compute this quantity is constructed each\n  time the calculation is performed (e.g. each time a snapshot of atoms\n  is dumped).  Thus it can be inefficient to compute/dump this quantity\n  too frequently or to have multiple compute/dump commands, each with a\n  cna/atom style.\n  Output info:\n  This compute calculates a per-atom vector, which can be accessed by\n  any command that uses per-atom values from a compute as input.  See\n  the Howto output doc page for an overview of\n  LAMMPS output options.\n  The per-atom vector values will be a number from 0 to 5, as explained\n  above.\n  ",
    "syntax": "compute ID group-ID cna/atom cutoff\n  \n  \n  \n  ID, group-ID are documented in compute command\n  cna/atom = style name of this compute command\n  cutoff = cutoff distance for nearest neighbors (distance units)\n  \n  ",
    "examples": "compute 1 all cna/atom 3.08\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute cnp/atom",
    "description": "Define a computation that calculates the Common Neighborhood\n  Parameter (CNP) for each atom in the group.  In solid-state systems\n  the CNP is a useful measure of the local crystal structure\n  around an atom and can be used to characterize whether the\n  atom is part of a perfect lattice, a local defect (e.g. a dislocation\n  or stacking fault), or at a surface.\n  The value of the CNP parameter will be 0.0 for atoms not in the\n  specified compute group.  Note that normally a CNP calculation should\n  only be performed on single component systems.\n  This parameter is computed using the following formula from\n  (Tsuzuki)\n  \n  \\[Q_{i} = \\frac{1}{n_i}\\sum_{j = 1}^{n_i} | \\sum_{k = 1}^{n_{ij}}  \\vec{R}_{ik} + \\vec{R}_{jk} |^2\\]\n  where the index j goes over the \\(n_i\\) nearest neighbors of atom\n  i, and the index k goes over the \\(n_{ij}\\) common nearest neighbors\n  between atom i and atom j. \\(\\vec{R}_{ik}\\) and\n  \\(\\vec{R}_{jk}\\) are the vectors connecting atom k to atoms i\n  and j.  The quantity in the double sum is computed\n  for each atom.\n  The CNP calculation is sensitive to the specified cutoff value.\n  You should ensure that the appropriate nearest neighbors of an atom are\n  found within the cutoff distance for the presumed crystal structure.\n  E.g. 12 nearest neighbor for perfect FCC and HCP crystals, 14 nearest\n  neighbors for perfect BCC crystals.  These formulas can be used to\n  obtain a good cutoff distance:\n  \n  \\[\\begin{split}r_{c}^{fcc} = & \\frac{1}{2} \\left(\\frac{\\sqrt{2}}{2} + 1\\right) \\mathrm{a} \\simeq 0.8536 \\:\\mathrm{a} \\\\\n  r_{c}^{bcc} = & \\frac{1}{2}(\\sqrt{2} + 1) \\mathrm{a} \\simeq 1.207 \\:\\mathrm{a} \\\\\n  r_{c}^{hcp} = & \\frac{1}{2}\\left(1+\\sqrt{\\frac{4+2x^{2}}{3}}\\right) \\mathrm{a}\\end{split}\\]\n  where a is the lattice constant for the crystal structure concerned\n  and in the HCP case, x = (c/a) / 1.633, where 1.633 is the ideal c/a\n  for HCP crystals.\n  Also note that since the CNP calculation in LAMMPS uses the neighbors\n  of an owned atom to find the nearest neighbors of a ghost atom, the\n  following relation should also be satisfied:\n  \n  \\[r_c + r_s > 2*{\\rm cutoff}\\]\n  where \\(r_c\\) is the cutoff distance of the potential, \\(r_s\\) is\n  the skin\n  distance as specified by the neighbor command, and\n  cutoff is the argument used with the compute cnp/atom command.  LAMMPS\n  will issue a warning if this is not the case.\n  The neighbor list needed to compute this quantity is constructed each\n  time the calculation is performed (e.g. each time a snapshot of atoms\n  is dumped).  Thus it can be inefficient to compute/dump this quantity\n  too frequently or to have multiple compute/dump commands, each with a\n  cnp/atom style.\n  Output info:\n  This compute calculates a per-atom vector, which can be accessed by\n  any command that uses per-atom values from a compute as input.  See\n  the Howto output doc page for an overview of\n  LAMMPS output options.\n  The per-atom vector values will be real positive numbers. Some typical CNP\n  values:\n  FCC lattice = 0.0\n  BCC lattice = 0.0\n  HCP lattice = 4.4\n  \n  FCC (111) surface ~ 13.0\n  FCC (100) surface ~ 26.5\n  FCC dislocation core ~ 11\n  \n  \n  ",
    "syntax": "compute ID group-ID cnp/atom cutoff\n  \n  \n  \n  ID, group-ID are documented in compute command\n  cnp/atom = style name of this compute command\n  cutoff = cutoff distance for nearest neighbors (distance units)\n  \n  ",
    "examples": "compute 1 all cnp/atom 3.08\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute com",
    "description": "Define a computation that calculates the center-of-mass of the group\n  of atoms, including all effects due to atoms passing through periodic\n  boundaries.\n  A vector of three quantities is calculated by this compute, which\n  are the x,y,z coordinates of the center of mass.\n  \n  Note\n  The coordinates of an atom contribute to the center-of-mass in\n  “unwrapped” form, by using the image flags associated with each atom.\n  See the dump custom command for a discussion of\n  “unwrapped” coordinates.  See the Atoms section of the\n  read_data command for a discussion of image flags and\n  how they are set for each atom.  You can reset the image flags\n  (e.g. to 0) before invoking this compute by using the set image command.\n  \n  Output info:\n  This compute calculates a global vector of length 3, which can be\n  accessed by indices 1-3 by any command that uses global vector values\n  from a compute as input.  See the Howto output doc\n  page for an overview of LAMMPS output options.\n  The vector values are “intensive”.  The vector values will be in\n  distance units.\n  ",
    "syntax": "compute ID group-ID com\n  \n  \n  \n  ID, group-ID are documented in compute command\n  com = style name of this compute command\n  \n  ",
    "examples": "compute 1 all com\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute com/chunk",
    "description": "Define a computation that calculates the center-of-mass for multiple\n  chunks of atoms.\n  In LAMMPS, chunks are collections of atoms defined by a compute chunk/atom command, which assigns each atom\n  to a single chunk (or no chunk).  The ID for this command is specified\n  as chunkID.  For example, a single chunk could be the atoms in a\n  molecule or atoms in a spatial bin.  See the compute chunk/atom and Howto chunk\n  doc pages for details of how chunks can be defined and examples of how\n  they can be used to measure properties of a system.\n  This compute calculates the x,y,z coordinates of the center-of-mass\n  for each chunk, which includes all effects due to atoms passing through\n  periodic boundaries.\n  Note that only atoms in the specified group contribute to the\n  calculation.  The compute chunk/atom command\n  defines its own group; atoms will have a chunk ID = 0 if they are not\n  in that group, signifying they are not assigned to a chunk, and will\n  thus also not contribute to this calculation.  You can specify the\n  “all” group for this command if you simply want to include atoms with\n  non-zero chunk IDs.\n  \n  Note\n  The coordinates of an atom contribute to the chunk’s\n  center-of-mass in “unwrapped” form, by using the image flags\n  associated with each atom.  See the dump custom command\n  for a discussion of “unwrapped” coordinates.  See the Atoms section of\n  the read_data command for a discussion of image flags\n  and how they are set for each atom.  You can reset the image flags\n  (e.g. to 0) before invoking this compute by using the set image command.\n  \n  The simplest way to output the results of the compute com/chunk\n  calculation to a file is to use the fix ave/time\n  command, for example:\n  compute cc1 all chunk/atom molecule\n  compute myChunk all com/chunk cc1\n  fix 1 all ave/time 100 1 100 c_myChunk[*] file tmp.out mode vector\n  \n  \n  Output info:\n  This compute calculates a global array where the number of rows = the\n  number of chunks Nchunk as calculated by the specified compute chunk/atom command.  The number of columns =\n  3 for the x,y,z center-of-mass coordinates of each chunk.  These\n  values can be accessed by any command that uses global array values\n  from a compute as input.  See the Howto output doc\n  page for an overview of LAMMPS output options.\n  The array values are “intensive”.  The array values will be in\n  distance units.\n  ",
    "syntax": "compute ID group-ID com/chunk chunkID\n  \n  \n  \n  ID, group-ID are documented in compute command\n  com/chunk = style name of this compute command\n  chunkID = ID of compute chunk/atom command\n  \n  ",
    "examples": "compute 1 fluid com/chunk molchunk\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute contact/atom",
    "description": "Define a computation that calculates the number of contacts\n  for each atom in a group.\n  The contact number is defined for finite-size spherical particles as\n  the number of neighbor atoms which overlap the central particle,\n  meaning that their distance of separation is less than or equal to the\n  sum of the radii of the two particles.\n  The value of the contact number will be 0.0 for atoms not in the\n  specified compute group.\n  Output info:\n  This compute calculates a per-atom vector, whose values can be\n  accessed by any command that uses per-atom values from a compute as\n  input.  See the Howto output doc page for an\n  overview of LAMMPS output options.\n  The per-atom vector values will be a number >= 0.0, as explained\n  above.\n  ",
    "syntax": "compute ID group-ID contact/atom\n  \n  \n  \n  ID, group-ID are documented in compute command\n  contact/atom = style name of this compute command\n  \n  ",
    "examples": "compute 1 all contact/atom\n  \n  \n  ",
    "restrictions": "This compute requires that atoms store a radius as defined by the\n  atom_style sphere command.\n  "
},
{
    "command": "compute coord/atom",
    "description": "This compute performs calculations between neighboring atoms to\n  determine a coordination value.  The specific calculation and the\n  meaning of the resulting value depend on the cstyle keyword used.\n  The cutoff cstyle calculates one or more traditional coordination\n  numbers for each atom.  A coordination number is defined as the number\n  of neighbor atoms with specified atom type(s), and optionally within\n  the specified group, that are within the specified cutoff distance from\n  the central atom. The compute group selects only the central atoms; all\n  neighboring atoms, unless selected by type, type range, or group option,\n  are included in the coordination number tally.\n  The optional group keyword allows to specify from which group atoms\n  contribute to the coordination number. Default setting is group ‘all’.\n  The typeN keywords allow specification of which atom types\n  contribute to each coordination number.  One coordination number is\n  computed for each of the typeN keywords listed.  If no typeN\n  keywords are listed, a single coordination number is calculated, which\n  includes atoms of all types (same as the “*” format, see below).\n  The typeN keywords can be specified in one of two ways.  An explicit\n  numeric value can be used, as in the 2nd example above.  Or a\n  wild-card asterisk can be used to specify a range of atom types.  This\n  takes the form “*” or “*n” or “n*” or “m*n”.  If N = the number of\n  atom types, then an asterisk with no numeric values means all types\n  from 1 to N.  A leading asterisk means all types from 1 to n\n  (inclusive).  A trailing asterisk means all types from n to N\n  (inclusive).  A middle asterisk means all types from m to n\n  (inclusive).\n  The orientorder cstyle calculates the number of “connected” neighbor\n  atoms J around each central atom I.  For this cstyle, connected is\n  defined by the orientational order parameter calculated by the\n  compute orientorder/atom command.\n  This cstyle thus allows one to apply the ten Wolde’s criterion to\n  identify crystal-like atoms in a system, as discussed in ten Wolde.\n  The ID of the previously specified compute orientorder/atom command is specified as\n  orientorderID.  The compute must invoke its components option to\n  calculate components of the Ybar_lm vector for each atoms, as\n  described in its documentation.  Note that orientorder/atom compute\n  defines its own criteria for identifying neighboring atoms.  If the\n  scalar product (Ybar_lm(i),*Ybar_lm(j)*), calculated by the\n  orientorder/atom compute is larger than the specified threshold,\n  then I and J are connected, and the coordination value of I is\n  incremented by one.\n  For all cstyle settings, all coordination values will be 0.0 for\n  atoms not in the specified compute group.\n  The neighbor list needed to compute this quantity is constructed each\n  time the calculation is performed (i.e. each time a snapshot of atoms\n  is dumped).  Thus it can be inefficient to compute/dump this quantity\n  too frequently.\n  \n  Note\n  If you have a bonded system, then the settings of\n  special_bonds command can remove pairwise\n  interactions between atoms in the same bond, angle, or dihedral.  This\n  is the default setting for the special_bonds\n  command, and means those pairwise interactions do not appear in the\n  neighbor list.  Because this fix uses the neighbor list, it also means\n  those pairs will not be included in the coordination count.  One way\n  to get around this, is to write a dump file, and use the\n  rerun command to compute the coordination for snapshots\n  in the dump file.  The rerun script can use a\n  special_bonds command that includes all pairs in\n  the neighbor list.\n  \n  Output info:\n  For cstyle cutoff, this compute can calculate a per-atom vector or\n  array.  If single type1 keyword is specified (or if none are\n  specified), this compute calculates a per-atom vector.  If multiple\n  typeN keywords are specified, this compute calculates a per-atom\n  array, with N columns.\n  For cstyle orientorder, this compute calculates a per-atom vector.\n  These values can be accessed by any command that uses per-atom values\n  from a compute as input.  See the Howto output doc\n  page for an overview of LAMMPS output options.\n  The per-atom vector or array values will be a number >= 0.0, as\n  explained above.\n  ",
    "syntax": "compute ID group-ID coord/atom cstyle args ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  coord/atom = style name of this compute command\n  cstyle = cutoff or orientorder\n  cutoff args = cutoff [group group2-ID] typeN\n    cutoff = distance within which to count coordination neighbors (distance units)\n    group group2-ID = select group-ID to restrict which atoms to consider for coordination number (optional)\n    typeN = atom type for Nth coordination count (see asterisk form below)\n  orientorder args = orientorderID threshold\n    orientorderID = ID of an orientorder/atom compute\n    threshold = minimum value of the product of two \"connected\" atoms\n  \n  \n  ",
    "examples": "compute 1 all coord/atom cutoff 2.0\n  compute 1 all coord/atom cutoff 6.0 1 2\n  compute 1 all coord/atom cutoff 6.0 2*4 5*8 *\n  compute 1 solute coord/atom cutoff 2.0 group solvent\n  compute 1 all coord/atom orientorder 2 0.5\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute damage/atom",
    "description": "Define a computation that calculates the per-atom damage for each atom\n  in a group.  This is a quantity relevant for Peridynamics models.  See this document\n  for an overview of LAMMPS commands for Peridynamics modeling.\n  The “damage” of a Peridynamics particles is based on the bond breakage\n  between the particle and its neighbors.  If all the bonds are broken\n  the particle is considered to be fully damaged.\n  See the PDLAMMPS user guide for a formal\n  definition of “damage” and more details about Peridynamics as it is\n  implemented in LAMMPS.\n  This command can be used with all the Peridynamic pair styles.\n  The damage value will be 0.0 for atoms not in the specified compute\n  group.\n  Output info:\n  This compute calculates a per-atom vector, which can be accessed by\n  any command that uses per-atom values from a compute as input.  See\n  the Howto output doc page for an overview of\n  LAMMPS output options.\n  The per-atom vector values are unitless numbers (damage) >= 0.0.\n  ",
    "syntax": "compute ID group-ID damage/atom\n  \n  \n  \n  ID, group-ID are documented in compute command\n  damage/atom = style name of this compute command\n  \n  ",
    "examples": "compute 1 all damage/atom\n  \n  \n  ",
    "restrictions": "This compute is part of the PERI package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute dihedral",
    "description": "Define a computation that extracts the dihedral energy calculated by\n  each of the dihedral sub-styles used in the dihedral_style hybrid command.  These values are made\n  accessible for output or further processing by other commands.  The\n  group specified for this command is ignored.\n  This compute is useful when using dihedral_style hybrid if you want to know the portion of the\n  total energy contributed by one or more of the hybrid sub-styles.\n  Output info:\n  This compute calculates a global vector of length N where N is the\n  number of sub_styles defined by the dihedral_style hybrid command.  which can be accessed by indices\n  1-N.  These values can be used by any command that uses global scalar\n  or vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The vector values are “extensive” and will be in energy\n  units.\n  ",
    "syntax": "compute ID group-ID dihedral\n  \n  \n  \n  ID, group-ID are documented in compute command\n  dihedral = style name of this compute command\n  \n  ",
    "examples": "compute 1 all dihedral\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute dihedral/local",
    "description": "Define a computation that calculates properties of individual dihedral\n  interactions.  The number of datums generated, aggregated across all\n  processors, equals the number of dihedral angles in the system, modified\n  by the group parameter as explained below.\n  The value phi is the dihedral angle, as defined in the diagram on\n  the dihedral_style doc page.\n  The value v_name can be used together with the set keyword to\n  compute a user-specified function of the dihedral angle phi.  The\n  name specified for the v_name value is the name of an equal-style variable which should evaluate a formula based on a\n  variable which will store the angle phi.  This other variable must\n  be an internal-style variable defined in the input\n  script; its initial numeric value can be anything.  It must be an\n  internal-style variable, because this command resets its value\n  directly.  The set keyword is used to identify the name of this\n  other variable associated with phi.\n  Note that the value of phi for each angle which stored in the internal\n  variable is in radians, not degrees.\n  As an example, these commands can be added to the bench/in.rhodo\n  script to compute the cosine and cosine^2 of every dihedral angle in\n  the system and output the statistics in various ways:\n  variable p internal 0.0\n  variable cos equal cos(v_p)\n  variable cossq equal cos(v_p)*cos(v_p)\n  \n  compute 1 all property/local datom1 datom2 datom3 datom4 dtype\n  compute 2 all dihedral/local phi v_cos v_cossq set phi p\n  dump 1 all local 100 tmp.dump c_1[*] c_2[*]\n  \n  compute 3 all reduce ave c_2[*]\n  thermo_style custom step temp press c_3[*]\n  \n  fix 10 all ave/histo 10 10 100 -1 1 20 c_2[2] mode vector file tmp.histo\n  \n  \n  The dump local command will output the angle,\n  cosine(angle), cosine^2(angle) for every dihedral in the system.  The\n  thermo_style command will print the average of\n  those quantities via the compute reduce command\n  with thermo output.  And the fix ave/histo\n  command will histogram the cosine(angle) values and write them to a\n  file.\n  \n  The local data stored by this command is generated by looping over all\n  the atoms owned on a processor and their dihedrals.  A dihedral will\n  only be included if all 4 atoms in the dihedral are in the specified\n  compute group.\n  Note that as atoms migrate from processor to processor, there will be\n  no consistent ordering of the entries within the local vector or array\n  from one timestep to the next.  The only consistency that is\n  guaranteed is that the ordering on a particular timestep will be the\n  same for local vectors or arrays generated by other compute commands.\n  For example, dihedral output from the compute property/local command can be combined\n  with data from this command and output by the dump local\n  command in a consistent way.\n  Here is an example of how to do this:\n  compute 1 all property/local dtype datom1 datom2 datom3 datom4\n  compute 2 all dihedral/local phi\n  dump 1 all local 1000 tmp.dump index c_1[1] c_1[2] c_1[3] c_1[4] c_1[5] c_2[1]\n  \n  \n  Output info:\n  This compute calculates a local vector or local array depending on the\n  number of values.  The length of the vector or number of rows in the\n  array is the number of dihedrals.  If a single value is specified, a\n  local vector is produced.  If two or more values are specified, a\n  local array is produced where the number of columns = the number of\n  values.  The vector or array can be accessed by any command that uses\n  local values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The output for phi will be in degrees.\n  ",
    "syntax": "compute ID group-ID dihedral/local value1 value2 ... keyword args ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  dihedral/local = style name of this compute command\n  one or more values may be appended\n  value = phi or v_name\n  phi = tabulate dihedral angles\n  v_name = equal-style variable with name (see below)\n  \n  zero or more keyword/args pairs may be appended\n  keyword = set\n  set args = phi name\n    phi = only currently allowed arg\n    name = name of variable to set with phi\n  \n  \n  ",
    "examples": "compute 1 all dihedral/local phi\n  \n  compute 1 all dihedral/local phi v_cos set phi p\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute dilatation/atom",
    "description": "Define a computation that calculates the per-atom dilatation for each\n  atom in a group.  This is a quantity relevant for Peridynamics models.  See this document\n  for an overview of LAMMPS commands for Peridynamics modeling.\n  For small deformation, dilatation of is the measure of the volumetric\n  strain.\n  The dilatation “theta” for each peridynamic particle I is calculated\n  as a sum over its neighbors with unbroken bonds, where the\n  contribution of the IJ pair is a function of the change in bond length\n  (versus the initial length in the reference state), the volume\n  fraction of the particles and an influence function.  See the\n  PDLAMMPS user guide for a formal\n  definition of dilatation.\n  This command can only be used with a subset of the Peridynamic pair styles: peri/lps, peri/ves and peri/eps.\n  The dilatation value will be 0.0 for atoms not in the specified\n  compute group.\n  Output info:\n  This compute calculates a per-atom vector, which can be accessed by\n  any command that uses per-atom values from a compute as input.  See\n  the Howto output doc page for an overview of\n  LAMMPS output options.\n  The per-atom vector values are unitless numbers (theta) >= 0.0.\n  ",
    "syntax": "compute ID group-ID dilatation/atom\n  \n  \n  \n  ID, group-ID are documented in compute command\n  dilation/atom = style name of this compute command\n  \n  ",
    "examples": "compute 1 all dilatation/atom\n  \n  \n  ",
    "restrictions": "This compute is part of the PERI package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute dipole/chunk",
    "description": "Define a computation that calculates the dipole vector and total dipole\n  for multiple chunks of atoms.\n  In LAMMPS, chunks are collections of atoms defined by a compute chunk/atom command, which assigns each atom\n  to a single chunk (or no chunk).  The ID for this command is specified\n  as chunkID.  For example, a single chunk could be the atoms in a\n  molecule or atoms in a spatial bin.  See the compute chunk/atom and Howto chunk\n  doc pages for details of how chunks can be defined and examples of how\n  they can be used to measure properties of a system.\n  This compute calculates the x,y,z coordinates of the dipole vector\n  and the total dipole moment for each chunk, which includes all effects\n  due to atoms passing through periodic boundaries. For chunks with a net\n  charge the resulting dipole is made position independent by subtracting\n  the position vector of the center of mass or geometric center times the\n  net charge from the computed dipole vector.\n  Note that only atoms in the specified group contribute to the\n  calculation.  The compute chunk/atom command\n  defines its own group; atoms will have a chunk ID = 0 if they are not\n  in that group, signifying they are not assigned to a chunk, and will\n  thus also not contribute to this calculation.  You can specify the\n  “all” group for this command if you simply want to include atoms with\n  non-zero chunk IDs.\n  \n  Note\n  The coordinates of an atom contribute to the chunk’s\n  dipole in “unwrapped” form, by using the image flags\n  associated with each atom.  See the dump custom command\n  for a discussion of “unwrapped” coordinates.  See the Atoms section of\n  the read_data command for a discussion of image flags\n  and how they are set for each atom.  You can reset the image flags\n  (e.g. to 0) before invoking this compute by using the set image command.\n  \n  The simplest way to output the results of the compute com/chunk\n  calculation to a file is to use the fix ave/time\n  command, for example:\n  compute cc1 all chunk/atom molecule\n  compute myChunk all dipole/chunk cc1\n  fix 1 all ave/time 100 1 100 c_myChunk[*] file tmp.out mode vector\n  \n  \n  Output info:\n  This compute calculates a global array where the number of rows = the\n  number of chunks Nchunk as calculated by the specified compute chunk/atom command.  The number of columns =\n  4 for the x,y,z dipole vector components and the total dipole of each\n  chunk. These values can be accessed by any command that uses global\n  array values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The array values are “intensive”.  The array values will be in\n  dipole units, i.e. charge units times distance units.\n  ",
    "syntax": "compute ID group-ID dipole/chunk chunkID charge-correction\n  \n  \n  \n  ID, group-ID are documented in compute command\n  dipole/chunk = style name of this compute command\n  chunkID = ID of compute chunk/atom command\n  charge-correction = mass or geometry, use COM or geometric center for charged chunk correction (optional)\n  \n  ",
    "examples": "compute 1 fluid dipole/chunk molchunk\n  compute dw water dipole/chunk 1 geometry\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute displace/atom",
    "description": "Define a computation that calculates the current displacement of each\n  atom in the group from its original (reference) coordinates, including\n  all effects due to atoms passing through periodic boundaries.\n  A vector of four quantities per atom is calculated by this compute.\n  The first 3 elements of the vector are the dx,dy,dz displacements.\n  The 4th component is the total displacement, i.e. sqrt(dx*dx + dy*dy +\n  dz*dz).\n  The displacement of an atom is from its original position at the time\n  the compute command was issued.  The value of the displacement will be\n  0.0 for atoms not in the specified compute group.\n  \n  Note\n  Initial coordinates are stored in “unwrapped” form, by using the\n  image flags associated with each atom.  See the dump custom command for a discussion of “unwrapped” coordinates.\n  See the Atoms section of the read_data command for a\n  discussion of image flags and how they are set for each atom.  You can\n  reset the image flags (e.g. to 0) before invoking this compute by\n  using the set image command.\n  \n  \n  Note\n  If you want the quantities calculated by this compute to be\n  continuous when running from a restart file, then\n  you should use the same ID for this compute, as in the original run.\n  This is so that the fix this compute creates to store per-atom\n  quantities will also have the same ID, and thus be initialized\n  correctly with time=0 atom coordinates from the restart file.\n  \n  \n  The refresh option can be used in conjunction with the “dump_modify\n  refresh” command to generate incremental dump files.\n  The definition and motivation of an incremental dump file is as\n  follows.  Instead of outputting all atoms at each snapshot (with some\n  associated values), you may only wish to output the subset of atoms\n  with a value that has changed in some way compared to the value the\n  last time that atom was output.  In some scenarios this can result in\n  a dramatically smaller dump file.  If desired, by post-processing the\n  sequence of snapshots, the values for all atoms at all timesteps can\n  be inferred.\n  A concrete example using this compute, is a simulation of atom\n  diffusion in a solid, represented as atoms on a lattice.  Diffusive\n  hops are rare.  Imagine that when a hop occurs an atom moves more than\n  a distance Dhop.  For any snapshot we only want to output atoms that\n  have hopped since the last snapshot.  This can be accomplished with\n  something like the following commands:\n  write_dump      all custom tmp.dump id type x y z    # see comment below\n  \n  variable        Dhop equal 0.6\n  variable        check atom \"c_dsp[4] > v_Dhop\"\n  compute         dsp all displace/atom refresh check\n  dump            1 all custom 100 tmp.dump id type x y z\n  dump_modify     1 append yes thresh c_dsp[4] > ${Dhop} &\n                  refresh c_dsp delay 100\n  \n  \n  The dump_modify thresh command will only output\n  atoms that have displaced more than 0.6 Angstroms on each snapshot\n  (assuming metal units).  The dump_modify refresh option triggers a\n  call to this compute at the end of every dump.\n  The refresh argument for this compute is the ID of an atom-style variable which calculates a Boolean value (0 or 1)\n  based on the same criterion used by dump_modify thresh.  This compute\n  evaluates the atom-style variable.  For each atom that returns 1\n  (true), the original (reference) coordinates of the atom (stored by\n  this compute) are updated.\n  The effect of these commands is that a particular atom will only be\n  output in the dump file on the snapshot after it makes a diffusive\n  hop.  It will not be output again until it makes another hop.\n  Note that in the first snapshot of a subsequent run, no atoms will be\n  typically be output.  That is because the initial displacement for all\n  atoms is 0.0.  If an initial dump snapshot is desired, containing the\n  initial reference positions of all atoms, one way to do this is\n  illustrated above.  An initial write_dump command can be used before\n  the first run.  It will contain the positions of all the atoms,\n  Options in the dump_modify command above will\n  append new output to that same file and delay the output until a later\n  timestep.  The delay setting avoids a second time = 0 snapshot which\n  would be empty.\n  \n  Output info:\n  This compute calculates a per-atom array with 4 columns, which can be\n  accessed by indices 1-4 by any command that uses per-atom values from\n  a compute as input.  See the Howto output doc page\n  for an overview of LAMMPS output options.\n  The per-atom array values will be in distance units.\n  This compute supports the refresh option as explained above, for use\n  in conjunction with dump_modify refresh to generate\n  incremental dump files.\n  ",
    "syntax": "compute ID group-ID displace/atom\n  \n  \n  \n  ID, group-ID are documented in compute command\n  displace/atom = style name of this compute command\n  zero or more keyword/arg pairs may be appended\n  keyword = refresh\n  replace arg = name of per-atom variable\n  \n  \n  ",
    "examples": "compute 1 all displace/atom\n  compute 1 all displace/atom refresh myVar\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute dpd",
    "description": "Define a computation that accumulates the total internal conductive\n  energy (\\(U^{cond}\\)), the total internal mechanical energy\n  (\\(U^{mech}\\)), the total chemical energy (\\(U^{chem}\\))\n  and the harmonic average of the internal temperature (\\(\\theta_{avg}\\))\n  for the entire system of particles.  See the\n  compute dpd/atom command if you want\n  per-particle internal energies and internal temperatures.\n  The system internal properties are computed according to the following\n  relations:\n  \n  \\[\\begin{split}U^{cond} = & \\displaystyle\\sum_{i=1}^{N} u_{i}^{cond} \\\\\n  U^{mech} = & \\displaystyle\\sum_{i=1}^{N} u_{i}^{mech} \\\\\n  U^{chem} = & \\displaystyle\\sum_{i=1}^{N} u_{i}^{chem} \\\\\n         U = & \\displaystyle\\sum_{i=1}^{N} (u_{i}^{cond} + u_{i}^{mech} + u_{i}^{chem}) \\\\\n  \\theta_{avg} = & (\\frac{1}{N}\\displaystyle\\sum_{i=1}^{N} \\frac{1}{\\theta_{i}})^{-1} \\\\\\end{split}\\]\n  where \\(N\\) is the number of particles in the system\n  \n  Output info:\n  This compute calculates a global vector of length 5 (\\(U^{cond}\\),\n  \\(U^{mech}\\), \\(U^{chem}\\), \\(\\theta_{avg}\\), \\(N\\)),\n  which can be accessed by indices 1-5.\n  See the Howto output doc page for an overview of\n  LAMMPS output options.\n  The vector values will be in energy and temperature units.\n  ",
    "syntax": "compute ID group-ID dpd\n  \n  \n  \n  ID, group-ID are documented in compute command\n  dpd = style name of this compute command\n  \n  ",
    "examples": "compute 1 all dpd\n  \n  \n  ",
    "restrictions": "This command is part of the USER-DPD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  This command also requires use of the atom_style dpd\n  command.\n  "
},
{
    "command": "compute dpd/atom",
    "description": "Define a computation that accesses the per-particle internal\n  conductive energy (\\(u^{cond}\\)), internal mechanical\n  energy (\\(u^{mech}\\)), internal chemical energy (\\(u^{chem}\\))\n  and internal temperatures (\\(\\theta\\)) for each particle in a group.\n  See the compute dpd command if you want the total\n  internal conductive energy, the total internal mechanical energy, the\n  total chemical energy and\n  average internal temperature of the entire system or group of dpd\n  particles.\n  Output info:\n  This compute calculates a per-particle array with 4 columns (\\(u^{cond}\\),\n  \\(u^{mech}\\), \\(u^{chem}\\), \\(\\theta\\)), which can be accessed\n  by indices 1-4 by any\n  command that uses per-particle values from a compute as input.  See\n  the Howto output doc page for an overview of\n  LAMMPS output options.\n  The per-particle array values will be in energy (\\(u^{cond}\\),\n  \\(u^{mech}\\), \\(u^{chem}\\))\n  and temperature (\\(theta\\)) units.\n  ",
    "syntax": "compute ID group-ID dpd/atom\n  \n  \n  \n  ID, group-ID are documented in compute command\n  dpd/atom = style name of this compute command\n  \n  ",
    "examples": "compute 1 all dpd/atom\n  \n  \n  ",
    "restrictions": "This command is part of the USER-DPD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  This command also requires use of the atom_style dpd\n  command.\n  "
},
{
    "command": "compute edpd/temp/atom",
    "description": "Define a computation that calculates the per-atom temperature\n  for each eDPD particle in a group.\n  The temperature is a local temperature derived from the internal energy\n  of each eDPD particle based on the local equilibrium hypothesis.\n  For more details please see (Espanol1997) and\n  (Li2014).\n  Output info:\n  This compute calculates a per-atom vector, which can be accessed by\n  any command that uses per-atom values from a compute as input. See the\n  Howto output doc page for an overview of LAMMPS\n  output options.\n  The per-atom vector values will be in temperature units.\n  ",
    "syntax": "compute ID group-ID edpd/temp/atom\n  \n  \n  \n  ID, group-ID are documented in compute command\n  edpd/temp/atom = style name of this compute command\n  \n  ",
    "examples": "compute 1 all edpd/temp/atom\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-MESODPD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute entropy/atom",
    "description": "Define a computation that calculates the pair entropy fingerprint for\n  each atom in the group. The fingerprint is useful to distinguish between\n  ordered and disordered environments, for instance liquid and solid-like\n  environments, or glassy and crystalline-like environments. Some\n  applications could be the identification of grain boundaries, a\n  melt-solid interface, or a solid cluster emerging from the melt.\n  The advantage of this parameter over others is that no a priori\n  information about the solid structure is required.\n  This parameter for atom i is computed using the following formula from\n  (Piaggi) and (Nettleton) ,\n  \n  \\[s_S^i=-2\\pi\\rho k_B \\int\\limits_0^{r_m} \\left [ g(r) \\ln g(r) - g(r) + 1 \\right ] r^2 dr\\]\n  where r is a distance, g(r) is the radial distribution function of atom\n  i and rho is the density of the system. The g(r) computed for each\n  atom i can be noisy and therefore it is smoothed using:\n  \n  \\[g_m^i(r) = \\frac{1}{4 \\pi \\rho r^2} \\sum\\limits_{j} \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} e^{-(r-r_{ij})^2/(2\\sigma^2)}\\]\n  where the sum in j goes through the neighbors of atom i, and \\(\\sigma\\)\n  is a parameter to control the smoothing.\n  The input parameters are sigma the smoothing parameter \\(\\sigma\\),\n  and the cutoff for the calculation of g(r).\n  If the keyword avg has the setting yes, then this compute also\n  averages the parameter over the neighbors  of atom i according to:\n  \n  \\[\\left< s_S^i \\right>  = \\frac{\\sum_j s_S^j + s_S^i}{N + 1}\\]\n  where the sum j goes over the neighbors of atom i and N is the number\n  of neighbors. This procedure provides a sharper distinction between\n  order and disorder environments. In this case the input parameter\n  cutoff2 is the cutoff for the averaging over the neighbors and\n  must also be specified.\n  If the avg yes option is used, the effective cutoff of the neighbor\n  list should be cutoff+cutoff2 and therefore it might be necessary\n  to increase the skin of the neighbor list with:\n  neighbor <skin distance> bin\n  \n  \n  See neighbor for details.\n  If the local yes option is used, the g(r) is normalized by the\n  local density around each atom, that is to say the density around each\n  atom  is the number of neighbors within the neighbor list cutoff divided\n  by the corresponding volume. This option can be useful when dealing with\n  inhomogeneous systems such as those that have surfaces.\n  Here are typical input parameters for fcc aluminum (lattice\n  constant 4.05 Angstroms),\n  compute 1 all entropy/atom 0.25 5.7 avg yes 3.7\n  \n  \n  and for bcc sodium (lattice constant 4.23 Angstroms),\n  compute 1 all entropy/atom 0.25 7.3 avg yes 5.1\n  \n  \n  Output info:\n  By default, this compute calculates the pair entropy value for each\n  atom as a per-atom vector, which can be accessed by any command that\n  uses per-atom values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The pair entropy values have units of the Boltzmann constant. They are\n  always negative, and lower values (lower entropy) correspond to more\n  ordered environments.\n  ",
    "syntax": "compute ID group-ID entropy/atom sigma cutoff keyword value ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  entropy/atom = style name of this compute command\n  sigma = width of gaussians used in the g(r) smoothing\n  cutoff = cutoff for the g(r) calculation\n  one or more keyword/value pairs may be appended\n  \n  keyword = avg or local\n    avg values = yes or no cutoff2\n      yes = average the pair entropy over neighbors\n      no = do not average the pair entropy over neighbors\n      cutoff2 = cutoff for the averaging over neighbors\n    local values = yes or no = use the local density around each atom to normalize the g(r)\n  ",
    "examples": "compute 1 all entropy/atom 0.25 5.\n  compute 1 all entropy/atom 0.25 5. avg yes 5.\n  compute 1 all entropy/atom 0.125 7.3 avg yes 5.1 local yes\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute erotate/asphere",
    "description": "Define a computation that calculates the rotational kinetic energy of\n  a group of aspherical particles.  The aspherical particles can be\n  ellipsoids, or line segments, or triangles.  See the\n  atom_style and read_data commands\n  for descriptions of these options.\n  For all 3 types of particles, the rotational kinetic energy is\n  computed as 1/2 I w^2, where I is the inertia tensor for the\n  aspherical particle and w is its angular velocity, which is computed\n  from its angular momentum if needed.\n  \n  Note\n  For 2d models, ellipsoidal particles are\n  treated as ellipsoids, not ellipses, meaning their moments of inertia\n  will be the same as in 3d.\n  \n  Output info:\n  This compute calculates a global scalar (the KE).  This value can be\n  used by any command that uses a global scalar value from a compute as\n  input.  See the Howto output doc page for an\n  overview of LAMMPS output options.\n  The scalar value calculated by this compute is “extensive”.  The\n  scalar value will be in energy units.\n  ",
    "syntax": "compute ID group-ID erotate/asphere\n  \n  \n  \n  ID, group-ID are documented in compute command\n  erotate/asphere = style name of this compute command\n  \n  ",
    "examples": "compute 1 all erotate/asphere\n  \n  \n  ",
    "restrictions": "This compute requires that ellipsoidal particles atoms store a shape\n  and quaternion orientation and angular momentum as defined by the\n  atom_style ellipsoid command.\n  This compute requires that line segment particles atoms store a length\n  and orientation and angular velocity as defined by the atom_style line command.\n  This compute requires that triangular particles atoms store a size and\n  shape and quaternion orientation and angular momentum as defined by\n  the atom_style tri command.\n  All particles in the group must be finite-size.  They cannot be point\n  particles.\n  Related commands: none\n  compute erotate/sphere\n  Default: none\n  "
},
{
    "command": "compute erotate/rigid",
    "description": "Define a computation that calculates the rotational kinetic energy of\n  a collection of rigid bodies, as defined by one of the fix rigid command variants.\n  The rotational energy of each rigid body is computed as 1/2 I Wbody^2,\n  where I is the inertia tensor for the rigid body, and Wbody is its\n  angular velocity vector.  Both I and Wbody are in the frame of\n  reference of the rigid body, i.e. I is diagonalized.\n  The fix-ID should be the ID of one of the fix rigid\n  commands which defines the rigid bodies.  The group specified in the\n  compute command is ignored.  The rotational energy of all the rigid\n  bodies defined by the fix rigid command in included in the\n  calculation.\n  Output info:\n  This compute calculates a global scalar (the summed rotational energy\n  of all the rigid bodies).  This value can be used by any command that\n  uses a global scalar value from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The scalar value calculated by this compute is “extensive”.  The\n  scalar value will be in energy units.\n  ",
    "syntax": "compute ID group-ID erotate/rigid fix-ID\n  \n  \n  \n  ID, group-ID are documented in compute command\n  erotate/rigid = style name of this compute command\n  fix-ID = ID of rigid body fix\n  \n  ",
    "examples": "compute 1 all erotate/rigid myRigid\n  \n  \n  ",
    "restrictions": "This compute is part of the RIGID package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute erotate/sphere",
    "description": "Define a computation that calculates the rotational kinetic energy of\n  a group of spherical particles.\n  The rotational energy is computed as 1/2 I w^2, where I is the moment\n  of inertia for a sphere and w is the particle’s angular velocity.\n  \n  Note\n  For 2d models, particles are treated as\n  spheres, not disks, meaning their moment of inertia will be the same\n  as in 3d.\n  \n  Output info:\n  This compute calculates a global scalar (the KE).  This value can be\n  used by any command that uses a global scalar value from a compute as\n  input.  See the Howto output doc page for an\n  overview of LAMMPS output options.\n  The scalar value calculated by this compute is “extensive”.  The\n  scalar value will be in energy units.\n  ",
    "syntax": "compute ID group-ID erotate/sphere\n  \n  \n  \n  ID, group-ID are documented in compute command\n  erotate/sphere = style name of this compute command\n  \n  ",
    "examples": "compute 1 all erotate/sphere\n  \n  \n  ",
    "restrictions": "This compute requires that atoms store a radius and angular velocity\n  (omega) as defined by the atom_style sphere command.\n  All particles in the group must be finite-size spheres or point\n  particles.  They cannot be aspherical.  Point particles will not\n  contribute to the rotational energy.\n  "
},
{
    "command": "compute erotate/sphere/atom",
    "description": "Define a computation that calculates the rotational kinetic energy for\n  each particle in a group.\n  The rotational energy is computed as 1/2 I w^2, where I is the moment\n  of inertia for a sphere and w is the particle’s angular velocity.\n  \n  Note\n  For 2d models, particles are treated as\n  spheres, not disks, meaning their moment of inertia will be the same\n  as in 3d.\n  \n  The value of the rotational kinetic energy will be 0.0 for atoms not\n  in the specified compute group or for point particles with a radius =\n  0.0.\n  Output info:\n  This compute calculates a per-atom vector, which can be accessed by\n  any command that uses per-atom values from a compute as input.  See\n  the Howto output doc page for an overview of\n  LAMMPS output options.\n  The per-atom vector values will be in energy units.\n  ",
    "syntax": "compute ID group-ID erotate/sphere/atom\n  \n  \n  \n  ID, group-ID are documented in compute command\n  erotate/sphere/atom = style name of this compute command\n  \n  ",
    "examples": "compute 1 all erotate/sphere/atom\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute event/displace",
    "description": "Define a computation that flags an “event” if any particle in the\n  group has moved a distance greater than the specified threshold\n  distance when compared to a previously stored reference state\n  (i.e. the previous event).  This compute is typically used in\n  conjunction with the prd and tad commands,\n  to detect if a transition\n  to a new minimum energy basin has occurred.\n  This value calculated by the compute is equal to 0 if no particle has\n  moved far enough, and equal to 1 if one or more particles have moved\n  further than the threshold distance.\n  \n  Note\n  If the system is undergoing significant center-of-mass motion,\n  due to thermal motion, an external force, or an initial net momentum,\n  then this compute will not be able to distinguish that motion from\n  local atom displacements and may generate “false positives.”\n  \n  Output info:\n  This compute calculates a global scalar (the flag).  This value can be\n  used by any command that uses a global scalar value from a compute as\n  input.  See the Howto output doc page for an\n  overview of LAMMPS output options.\n  The scalar value calculated by this compute is “intensive”.  The\n  scalar value will be a 0 or 1 as explained above.\n  ",
    "syntax": "compute ID group-ID event/displace threshold\n  \n  \n  \n  ID, group-ID are documented in compute command\n  event/displace = style name of this compute command\n  threshold = minimum distance any particle must move to trigger an event (distance units)\n  \n  ",
    "examples": "compute 1 all event/displace 0.5\n  \n  \n  ",
    "restrictions": "This command can only be used if LAMMPS was built with the REPLICA\n  package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "compute fep",
    "description": "Apply a perturbation to parameters of the interaction potential and\n  recalculate the pair potential energy without changing the atomic\n  coordinates from those of the reference, unperturbed system. This\n  compute can be used to calculate free energy differences using several\n  methods, such as free-energy perturbation (FEP), finite-difference\n  thermodynamic integration (FDTI) or Bennet’s acceptance ratio method\n  (BAR).\n  The potential energy of the system is decomposed in three terms: a\n  background term corresponding to interaction sites whose parameters\n  remain constant, a reference term \\(U_0\\) corresponding to the\n  initial interactions of the atoms that will undergo perturbation, and\n  a term \\(U_1\\) corresponding to the final interactions of\n  these atoms:\n  \n  \\[U(\\lambda) = U_{\\mathrm{bg}} + U_1(\\lambda) + U_0(\\lambda)\\]\n  A coupling parameter \\(\\lambda\\) varying from 0 to 1 connects the\n  reference and perturbed systems:\n  \n  \\[\\begin{split}\\lambda &= 0 \\quad\\Rightarrow\\quad U = U_{\\mathrm{bg}} + U_0 \\\\\n  \\lambda &= 1 \\quad\\Rightarrow\\quad U = U_{\\mathrm{bg}} + U_1\\end{split}\\]\n  It is possible but not necessary that the coupling parameter (or a\n  function thereof) appears as a multiplication factor of the potential\n  energy. Therefore, this compute can apply perturbations to interaction\n  parameters that are not directly proportional to the potential energy\n  (e.g. \\(\\sigma\\) in Lennard-Jones potentials).\n  This command can be combined with fix adapt to\n  perform multistage free-energy perturbation calculations along\n  stepwise alchemical transformations during a simulation run:\n  \n  \\[\\Delta_0^1 A = \\sum_{i=0}^{n-1} \\Delta_{\\lambda_i}^{\\lambda_{i+1}} A = - kT\n  \\sum_{i=0}^{n-1} \\ln \\left< \\exp \\left( - \\frac{U(\\lambda_{i+1}) -\n  U(\\lambda_i)}{kT} \\right) \\right>_{\\lambda_i}\\]\n  This compute is suitable for the finite-difference thermodynamic\n  integration (FDTI) method (Mezei), which is based on an\n  evaluation of the numerical derivative of the free energy by a\n  perturbation method using a very small \\(\\delta\\):\n  \n  \\[\\Delta_0^1 A = \\int_{\\lambda=0}^{\\lambda=1} \\left( \\frac{\\partial\n  A(\\lambda)}{\\partial\\lambda} \\right)_\\lambda \\mathrm{d}\\lambda \\approx\n  \\sum_{i=0}^{n-1} w_i \\frac{A(\\lambda_{i} + \\delta) - A(\\lambda_i)}{\\delta}\\]\n  where \\(w_i\\) are weights of a numerical quadrature. The fix adapt command can be used to define the stages of\n  \\(\\lambda\\) at which the derivative is calculated and averaged.\n  The compute fep calculates the exponential Boltzmann term and also the\n  potential energy difference \\(U_1 -U_0\\). By\n  choosing a very small perturbation \\(\\delta\\) the thermodynamic\n  integration method can be implemented using a numerical evaluation of\n  the derivative of the potential energy with respect to \\(\\lambda\\):\n  \n  \\[\\Delta_0^1 A = \\int_{\\lambda=0}^{\\lambda=1} \\left< \\frac{\\partial\n  U(\\lambda)}{\\partial\\lambda} \\right>_\\lambda \\mathrm{d}\\lambda \\approx\n  \\sum_{i=0}^{n-1} w_i \\left< \\frac{U(\\lambda_{i} + \\delta) -\n  U(\\lambda_i)}{\\delta} \\right>_{\\lambda_i}\\]\n  Another technique to calculate free energy differences is the\n  acceptance ratio method (Bennet), which can be implemented\n  by calculating the potential energy differences with \\(\\delta\\) = 1.0 on\n  both the forward and reverse routes:\n  \n  \\[\\left< \\frac{1}{1 + \\exp\\left[\\left(U_1 - U_0 - \\Delta_0^1A \\right) /kT\n  \\right]} \\right>_0 = \\left< \\frac{1}{1 + \\exp\\left[\\left(U_0 - U_1 +\n  \\Delta_0^1A \\right) /kT \\right]} \\right>_1\\]\n  The value of the free energy difference is determined by numerical\n  root finding to establish the equality.\n  Concerning the choice of how the atomic parameters are perturbed in\n  order to setup an alchemical transformation route, several strategies\n  are available, such as single-topology or double-topology strategies\n  (Pearlman). The latter does not require modification of\n  bond lengths, angles or other internal coordinates.\n  NOTES: This compute command does not take kinetic energy into account,\n  therefore the masses of the particles should not be modified between\n  the reference and perturbed states, or along the alchemical\n  transformation route.  This compute command does not change bond\n  lengths or other internal coordinates (Boresch, Karplus).\n  \n  The pair attribute enables various parameters of potentials defined\n  by the pair_style and pair_coeff\n  commands to be changed, if the pair style supports it.\n  The pstyle argument is the name of the pair style. For example,\n  pstyle could be specified as “lj/cut”.  The pparam argument is the\n  name of the parameter to change.  This is a list of\n  pair styles and parameters that can be used with this compute.  See\n  the doc pages for individual pair styles and their energy formulas for\n  the meaning of these parameters:\n  \n  \n  \n  \n  \n  \n  \n  born\n  a,b,c\n  type pairs\n  \n  buck\n  a,c\n  type pairs\n  \n  buck/mdf\n  a,c\n  type pairs\n  \n  coul/cut\n  scale\n  type pairs\n  \n  coul/cut/soft\n  lambda\n  type pairs\n  \n  coul/long, coul/msm\n  scale\n  type pairs\n  \n  coul/long/soft\n  scale, lambda\n  type pairs\n  \n  eam\n  scale\n  type pairs\n  \n  gauss\n  a\n  type pairs\n  \n  lennard/mdf\n  a,b\n  type pairs\n  \n  lj/class2\n  epsilon,sigma\n  type pairs\n  \n  lj/class2/coul/cut, lj/class2/coul/long\n  epsilon,sigma\n  type pairs\n  \n  lj/cut\n  epsilon,sigma\n  type pairs\n  \n  lj/cut/soft\n  epsilon,sigma,lambda\n  type pairs\n  \n  lj/cut/coul/cut, lj/cut/coul/long, lj/cut/coul/msm\n  epsilon,sigma\n  type pairs\n  \n  lj/cut/coul/cut/soft, lj/cut/coul/long/soft\n  epsilon,sigma,lambda\n  type pairs\n  \n  lj/cut/tip4p/cut, lj/cut/tip4p/long\n  epsilon,sigma\n  type pairs\n  \n  lj/cut/tip4p/long/soft\n  epsilon,sigma,lambda\n  type pairs\n  \n  lj/expand\n  epsilon,sigma,delta\n  type pairs\n  \n  lj/mdf\n  epsilon,sigma\n  type pairs\n  \n  lj/sf/dipole/sf\n  epsilon,sigma,scale\n  type pairs\n  \n  mie/cut\n  epsilon,sigma,gamR,gamA\n  type pairs\n  \n  morse, morse/smooth/linear\n  d0,r0,alpha\n  type pairs\n  \n  morse/soft\n  d0,r0,alpha,lambda\n  type pairs\n  \n  nm/cut\n  e0,r0,nn,mm\n  type pairs\n  \n  nm/cut/coul/cut, nm/cut/coul/long\n  e0,r0,nn,mm\n  type pairs\n  \n  ufm\n  epsilon,sigma,scale\n  type pairs\n  \n  soft\n  a\n  type pairs\n  \n  \n  \n  Note that it is easy to add new potentials and their parameters to\n  this list.  All it typically takes is adding an extract() method to\n  the pair_*.cpp file associated with the potential.\n  Similar to the pair_coeff command, I and J can be\n  specified in one of two ways.  Explicit numeric values can be used for\n  each, as in the 1st example above.  I <= J is required.  LAMMPS sets\n  the coefficients for the symmetric J,I interaction to the same\n  values. A wild-card asterisk can be used in place of or in conjunction\n  with the I,J arguments to set the coefficients for multiple pairs of\n  atom types.  This takes the form “*” or “*n” or “n*” or “m*n”.  If N =\n  the number of atom types, then an asterisk with no numeric values\n  means all types from 1 to N.  A leading asterisk means all types from\n  1 to n (inclusive).  A trailing asterisk means all types from n to N\n  (inclusive).  A middle asterisk means all types from m to n\n  (inclusive).  Note that only type pairs with I <= J are considered; if\n  asterisks imply type pairs where J < I, they are ignored.\n  If pair_style hybrid or hybrid/overlay is being\n  used, then the pstyle will be a sub-style name.  You must specify\n  I,J arguments that correspond to type pair values defined (via the\n  pair_coeff command) for that sub-style.\n  The v_name argument for keyword pair is the name of an\n  equal-style variable which will be evaluated each time\n  this compute is invoked.  It should be specified as v_name, where name\n  is the variable name.\n  \n  The atom attribute enables atom properties to be changed.  The\n  aparam argument is the name of the parameter to change.  This is the\n  current list of atom parameters that can be used with this compute:\n  \n  charge = charge on particle\n  \n  The v_name argument for keyword pair is the name of an\n  equal-style variable which will be evaluated each time\n  this compute is invoked.  It should be specified as v_name, where name\n  is the variable name.\n  \n  The tail keyword controls the calculation of the tail correction to\n  “van der Waals” pair energies beyond the cutoff, if this has been\n  activated via the pair_modify command. If the\n  perturbation is small, the tail contribution to the energy difference\n  between the reference and perturbed systems should be negligible.\n  If the keyword volume = yes, then the Boltzmann term is multiplied\n  by the volume so that correct ensemble averaging can be performed over\n  trajectories during which the volume fluctuates or changes (Allen and Tildesley):\n  \n  \\[\\Delta_0^1 A = - kT \\sum_{i=0}^{n-1} \\ln \\frac{\\left< V \\exp \\left( -\n  \\frac{U(\\lambda_{i+1}) - U(\\lambda_i)}{kT} \\right)\n  \\right>_{\\lambda_i}}{\\left< V \\right>_{\\lambda_i}}\\]\n  \n  Output info:\n  This compute calculates a global vector of length 3 which contains the\n  energy difference ( \\(U_1-U_0\\) ) as c_ID[1], the\n  Boltzmann factor \\(\\exp(-(U_1-U_0)/kT)\\), or\n  \\(V \\exp(-(U_1-U_0)/kT)\\), as c_ID[2] and the\n  volume of the simulation box \\(V\\) as c_ID[3]. \\(U_1\\) is the\n  pair potential energy obtained with the perturbed parameters and\n  \\(U_0\\) is the pair potential energy obtained with the\n  unperturbed parameters. The energies include kspace terms if these\n  are used in the simulation.\n  These output results can be used by any command that uses a global\n  scalar or vector from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options. For example, the computed values can be averaged using fix ave/time.\n  The values calculated by this compute are “extensive”.\n  ",
    "syntax": "compute ID group-ID fep temp attribute args ... keyword value ...\n  \n  \n  \n  ID, group-ID are documented in the compute command\n  fep = name of this compute command\n  temp = external temperature (as specified for constant-temperature run)\n  one or more attributes with args may be appended\n  attribute = pair or atom\n  pair args = pstyle pparam I J v_delta\n    pstyle = pair style name, e.g. lj/cut\n    pparam = parameter to perturb\n    I,J = type pair(s) to set parameter for\n    v_delta = variable with perturbation to apply (in the units of the parameter)\n  atom args = aparam I v_delta\n    aparam = parameter to perturb\n    I = type to set parameter for\n    v_delta = variable with perturbation to apply (in the units of the parameter)\n  \n  zero or more keyword/value pairs may be appended\n  keyword = tail or volume\n  tail value = no or yes\n    no = ignore tail correction to pair energies (usually small in fep)\n    yes = include tail correction to pair energies\n  volume value = no or yes\n    no = ignore volume changes (e.g. in NVE or NVT trajectories)\n    yes = include volume changes (e.g. in NpT trajectories)\n  \n  \n  ",
    "examples": "compute 1 all fep 298 pair lj/cut epsilon 1 * v_delta pair lj/cut sigma 1 * v_delta volume yes\n  compute 1 all fep 300 atom charge 2 v_delta\n  \n  \n  ",
    "restrictions": "This compute is distributed as the USER-FEP package.  It is only\n  enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute global/atom",
    "description": "Define a calculation that assigns global values to each atom from\n  vectors or arrays of global values.  The specified index parameter\n  is used to determine which global value is assigned to each atom.\n  The index parameter must reference a per-atom vector or array from a\n  compute or fix or the evaluation of an\n  atom-style variable.  Each input value must\n  reference a global vector or array from a compute or\n  fix or the evaluation of an vector-style\n  variable.  Details are given below.\n  The index value for an atom is used as a index I (from 1 to N) into\n  the vector associated with each of the input values.  The Ith value\n  from the input vector becomes one output value for that atom.  If the\n  atom is not in the specified group, or the index I < 1 or I > M, where\n  M is the actual length of the input vector, then an output value of\n  0.0 is assigned to the atom.\n  An example of how this command is useful, is in the context of\n  “chunks” which are static or dynamic subsets of atoms.  The compute chunk/atom command assigns unique chunk IDs\n  to each atom.  It’s output can be used as the index parameter for\n  this command.  Various other computes with “chunk” in their style\n  name, such as compute com/chunk or compute msd/chunk, calculate properties for each\n  chunk.  The output of these commands are global vectors or arrays,\n  with one or more values per chunk, and can be used as input values for\n  this command.  This command will then assign the global chunk value to\n  each atom in the chunk, producing a per-atom vector or per-atom array\n  as output.  The per-atom values can then be output to a dump file or\n  used by any command that uses per-atom values from a compute as input,\n  as discussed on the Howto output doc page.\n  As a concrete example, these commands will calculate the displacement\n  of each atom from the center-of-mass of the molecule it is in, and\n  dump those values to a dump file.  In this case, each molecule is a\n  chunk.\n  compute cc1 all chunk/atom molecule\n  compute myChunk all com/chunk cc1\n  compute prop all property/atom xu yu zu\n  compute glob all global/atom c_cc1 c_myChunk[*]\n  variable dx atom c_prop[1]-c_glob[1]\n  variable dy atom c_prop[2]-c_glob[2]\n  variable dz atom c_prop[3]-c_glob[3]\n  variable dist atom sqrt(v_dx*v_dx+v_dy*v_dy+v_dz*v_dz)\n  dump 1 all custom 100 tmp.dump id xu yu zu c_glob[1] c_glob[2] c_glob[3] &\n       v_dx v_dy v_dz v_dist\n  dump_modify 1 sort id\n  \n  \n  You can add these commands to the bench/in.chain script to see how\n  they work.\n  \n  Note that for input values from a compute or fix, the bracketed index\n  I can be specified using a wildcard asterisk with the index to\n  effectively specify multiple values.  This takes the form “*” or “*n”\n  or “n*” or “m*n”.  If N = the size of the vector (for mode = scalar)\n  or the number of columns in the array (for mode = vector), then an\n  asterisk with no numeric values means all indices from 1 to N.  A\n  leading asterisk means all indices from 1 to n (inclusive).  A\n  trailing asterisk means all indices from n to N (inclusive).  A middle\n  asterisk means all indices from m to n (inclusive).\n  Using a wildcard is the same as if the individual columns of the array\n  had been listed one by one.  E.g. these 2 compute global/atom commands\n  are equivalent, since the compute com/chunk\n  command creates a global array with 3 columns:\n  compute cc1 all chunk/atom molecule\n  compute com all com/chunk cc1\n  compute 1 all global/atom c_cc1 c_com[1] c_com[2] c_com[3]\n  compute 1 all global/atom c_cc1 c_com[*]\n  \n  \n  \n  This section explains the index parameter.  Note that it must\n  reference per-atom values, as contrasted with the input values which\n  must reference global values.\n  Note that all of these options generate floating point values.  When\n  they are used as an index into the specified input vectors, they\n  simple rounded down to convert the value to integer indices.  The\n  final values should range from 1 to N (inclusive), since they are used\n  to access values from N-length vectors.\n  If index begins with “c_”, a compute ID must follow which has been\n  previously defined in the input script.  The compute must generate\n  per-atom quantities.  See the individual compute doc\n  page for details.  If no bracketed integer is appended, the per-atom\n  vector calculated by the compute is used.  If a bracketed integer is\n  appended, the Ith column of the per-atom array calculated by the\n  compute is used.  Users can also write code for their own compute\n  styles and add them to LAMMPS.  See the\n  discussion above for how I can be specified with a wildcard asterisk\n  to effectively specify multiple values.\n  If index begins with “f_”, a fix ID must follow which has been\n  previously defined in the input script.  The Fix must generate\n  per-atom quantities.  See the individual fix doc page for\n  details.  Note that some fixes only produce their values on certain\n  timesteps, which must be compatible with when compute global/atom\n  references the values, else an error results.  If no bracketed integer\n  is appended, the per-atom vector calculated by the fix is used.  If a\n  bracketed integer is appended, the Ith column of the per-atom array\n  calculated by the fix is used.  Users can also write code for their\n  own fix style and add them to LAMMPS.  See the\n  discussion above for how I can be specified with a wildcard asterisk\n  to effectively specify multiple values.\n  If index begins with “v_”, a variable name must follow which has\n  been previously defined in the input script.  It must be an\n  atom-style variable.  Atom-style variables can\n  reference thermodynamic keywords and various per-atom attributes, or\n  invoke other computes, fixes, or variables when they are evaluated, so\n  this is a very general means of generating per-atom quantities to use\n  as index.\n  \n  This section explains the kinds of input values that can be used.\n  Note that inputs reference global values, as contrasted with the\n  index parameter which must reference per-atom values.\n  If a value begins with “c_”, a compute ID must follow which has been\n  previously defined in the input script.  The compute must generate a\n  global vector or array.  See the individual compute doc\n  page for details.  If no bracketed integer is appended, the vector\n  calculated by the compute is used.  If a bracketed integer is\n  appended, the Ith column of the array calculated by the compute is\n  used.  Users can also write code for their own compute styles and add them to LAMMPS.  See the discussion above for how\n  I can be specified with a wildcard asterisk to effectively specify\n  multiple values.\n  If a value begins with “f_”, a fix ID must follow which has been\n  previously defined in the input script.  The fix must generate a\n  global vector or array.  See the individual fix doc page\n  for details.  Note that some fixes only produce their values on\n  certain timesteps, which must be compatible with when compute\n  global/atom references the values, else an error results.  If no\n  bracketed integer is appended, the vector calculated by the fix is\n  used.  If a bracketed integer is appended, the Ith column of the array\n  calculated by the fix is used.  Users can also write code for their\n  own fix style and add them to LAMMPS.  See the\n  discussion above for how I can be specified with a wildcard asterisk\n  to effectively specify multiple values.\n  If a value begins with “v_”, a variable name must follow which has\n  been previously defined in the input script.  It must be a\n  vector-style variable.  Vector-style variables can\n  reference thermodynamic keywords and various other attributes of\n  atoms, or invoke other computes, fixes, or variables when they are\n  evaluated, so this is a very general means of generating a vector of\n  global quantities which the index parameter will reference for\n  assignment of global values to atoms.\n  \n  Output info:\n  If a single input is specified this compute produces a per-atom\n  vector.  If multiple inputs are specified, this compute produces a\n  per-atom array values, where the number of columns is equal to the\n  number of inputs specified.  These values can be used by any command\n  that uses per-atom vector or array values from a compute as input.\n  See the Howto output doc page for an overview of\n  LAMMPS output options.\n  The per-atom vector or array values will be in whatever units the\n  corresponding input values are in.\n  ",
    "syntax": "compute ID group-ID style index input1 input2 ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  global/atom = style name of this compute command\n  index = c_ID, c_ID[N], f_ID, f_ID[N], v_name\n  c_ID = per-atom vector calculated by a compute with ID\n  c_ID[I] = Ith column of per-atom array calculated by a compute with ID\n  f_ID = per-atom vector calculated by a fix with ID\n  f_ID[I] = Ith column of per-atom array calculated by a fix with ID\n  v_name = per-atom vector calculated by an atom-style variable with name\n  \n  \n  \n  one or more inputs can be listed\n  input = c_ID, c_ID[N], f_ID, f_ID[N], v_name\n  c_ID = global vector calculated by a compute with ID\n  c_ID[I] = Ith column of global array calculated by a compute with ID, I can include wildcard (see below)\n  f_ID = global vector calculated by a fix with ID\n  f_ID[I] = Ith column of global array calculated by a fix with ID, I can include wildcard (see below)\n  v_name = global vector calculated by a vector-style variable with name\n  \n  \n  \n  \n  ",
    "examples": "compute 1 all global/atom c_chunk c_com[1] c_com[2] c_com[3]\n  compute 1 all global/atom c_chunk c_com[*]\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute group/group",
    "description": "Define a computation that calculates the total energy and force\n  interaction between two groups of atoms: the compute group and the\n  specified group2.  The two groups can be the same.\n  If the pair keyword is set to yes, which is the default, then the\n  the interaction energy will include a pair component which is defined\n  as the pairwise energy between all pairs of atoms where one atom in\n  the pair is in the first group and the other is in the second group.\n  Likewise, the interaction force calculated by this compute will\n  include the force on the compute group atoms due to pairwise\n  interactions with atoms in the specified group2.\n  \n  Note\n  The energies computed by the pair keyword do not include tail\n  corrections, even if they are enabled via the\n  pair_modify command.\n  \n  If the molecule keyword is set to inter or intra than an\n  additional check is made based on the molecule IDs of the two atoms in\n  each pair before including their pairwise interaction energy and\n  force.  For the inter setting, the two atoms must be in different\n  molecules.  For the intra setting, the two atoms must be in the same\n  molecule.\n  If the kspace keyword is set to yes, which is not the default, and\n  if a kspace_style is defined, then the interaction\n  energy will include a Kspace component which is the long-range\n  Coulombic energy between all the atoms in the first group and all the\n  atoms in the 2nd group.  Likewise, the interaction force calculated by\n  this compute will include the force on the compute group atoms due to\n  long-range Coulombic interactions with atoms in the specified group2.\n  Normally the long-range Coulombic energy converges only when the net\n  charge of the unit cell is zero.  However, one can assume the net\n  charge of the system is neutralized by a uniform background plasma,\n  and a correction to the system energy can be applied to reduce\n  artifacts. For more information see (Bogusz).  If the\n  boundary keyword is set to yes, which is the default, and kspace\n  contributions are included, then this energy correction term will be\n  added to the total group-group energy.  This correction term does not\n  affect the force calculation and will be zero if one or both of the\n  groups are charge neutral.  This energy correction term is the same as\n  that included in the regular Ewald and PPPM routines.\n  \n  Note\n  The molecule setting only affects the group/group\n  contributions calculated by the pair keyword.  It does not affect\n  the group/group contributions calculated by the kspace keyword.\n  \n  This compute does not calculate any bond or angle or dihedral or\n  improper interactions between atoms in the two groups.\n  \n  The pairwise contributions to the group-group interactions are\n  calculated by looping over a neighbor list.  The Kspace contribution\n  to the group-group interactions require essentially the same amount of\n  work (FFTs, Ewald summation) as computing long-range forces for the\n  entire system.  Thus it can be costly to invoke this compute too\n  frequently.\n  \n  Note\n  If you have a bonded system, then the settings of\n  special_bonds command can remove pairwise\n  interactions between atoms in the same bond, angle, or dihedral.  This\n  is the default setting for the special_bonds\n  command, and means those pairwise interactions do not appear in the\n  neighbor list.  Because this compute uses a neighbor list, it also\n  means those pairs will not be included in the group/group interaction.\n  This does not apply when using long-range coulomb interactions\n  (coul/long, coul/msm, coul/wolf or similar.  One way to get\n  around this would be to set special_bond scaling factors to very tiny\n  numbers that are not exactly zero (e.g. 1.0e-50). Another workaround\n  is to write a dump file, and use the rerun command to\n  compute the group/group interactions for snapshots in the dump file.\n  The rerun script can use a special_bonds command\n  that includes all pairs in the neighbor list.\n  \n  If you desire a breakdown of the interactions into a pairwise and\n  Kspace component, simply invoke the compute twice with the appropriate\n  yes/no settings for the pair and kspace keywords.  This is no more\n  costly than using a single compute with both keywords set to yes.\n  The individual contributions can be summed in a\n  variable if desired.\n  This document describes how the long-range\n  group-group calculations are performed.\n  \n  Output info:\n  This compute calculates a global scalar (the energy) and a global\n  vector of length 3 (force), which can be accessed by indices 1-3.\n  These values can be used by any command that uses global scalar or\n  vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  Both the scalar and vector values calculated by this compute are\n  “extensive”.  The scalar value will be in energy units.\n  The vector values will be in force units.\n  ",
    "syntax": "compute ID group-ID group/group group2-ID keyword value ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  group/group = style name of this compute command\n  group2-ID = group ID of second (or same) group\n  zero or more keyword/value pairs may be appended\n  keyword = pair or kspace or boundary or molecule\n  pair value = yes or no\n  kspace value = yes or no\n  boundary value = yes or no\n  molecule value = off or inter or intra\n  \n  \n  ",
    "examples": "compute 1 lower group/group upper\n  compute 1 lower group/group upper kspace yes\n  compute mine fluid group/group wall\n  \n  \n  ",
    "restrictions": "Not all pair styles can be evaluated in a pairwise mode as required by\n  this compute.  For example, 3-body and other many-body potentials,\n  such as Tersoff and\n  Stillinger-Weber cannot be used.  EAM\n  potentials will re-use previously computed embedding term contributions,\n  so the computed pairwise forces and energies are based on the whole\n  system and not valid if particles have been moved since.\n  Not all Kspace styles support the calculation of\n  group/group interactions. The regular ewald and pppm styles do.\n  Related commands: none\n  "
},
{
    "command": "compute gyration",
    "description": "Define a computation that calculates the radius of gyration Rg of the\n  group of atoms, including all effects due to atoms passing through\n  periodic boundaries.\n  Rg is a measure of the size of the group of atoms, and is computed as\n  the square root of the Rg^2 value in this formula\n  \n  \\[{R_g}^2 = \\frac{1}{M} \\sum_i m_i (r_i - r_{cm})^2\\]\n  where \\(M\\) is the total mass of the group, \\(r_{cm}\\) is the\n  center-of-mass position of the group, and the sum is over all atoms in\n  the group.\n  A \\({R_g}^2\\) tensor, stored as a 6-element vector, is also calculated\n  by this compute.  The formula for the components of the tensor is the\n  same as the above formula, except that \\((r_i - r_{cm})^2\\) is replaced\n  by \\((r_{i,x} - r_{cm,x}) \\cdot (r_{i,y} - r_{cm,y})\\) for the xy component,\n  and so on.  The 6 components of the vector are ordered xx, yy, zz, xy, xz, yz.\n  Note that unlike the scalar \\(R_g\\), each of the 6 values of the tensor\n  is effectively a “squared” value, since the cross-terms may be negative\n  and taking a sqrt() would be invalid.\n  \n  Note\n  The coordinates of an atom contribute to \\(R_g\\) in “unwrapped” form,\n  by using the image flags associated with each atom.  See the dump custom command for a discussion of “unwrapped” coordinates.\n  See the Atoms section of the read_data command for a\n  discussion of image flags and how they are set for each atom.  You can\n  reset the image flags (e.g. to 0) before invoking this compute by\n  using the set image command.\n  \n  Output info:\n  This compute calculates a global scalar (\\(R_g\\)) and a global vector of\n  length 6 (\\({R_g}^2\\) tensor), which can be accessed by indices 1-6.  These\n  values can be used by any command that uses a global scalar value or\n  vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The scalar and vector values calculated by this compute are\n  “intensive”.  The scalar and vector values will be in distance and\n  distance^2 units respectively.\n  ",
    "syntax": "compute ID group-ID gyration\n  \n  \n  \n  ID, group-ID are documented in compute command\n  gyration = style name of this compute command\n  \n  ",
    "examples": "compute 1 molecule gyration\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute gyration/chunk",
    "description": "Define a computation that calculates the radius of gyration Rg for\n  multiple chunks of atoms.\n  In LAMMPS, chunks are collections of atoms defined by a compute chunk/atom command, which assigns each atom\n  to a single chunk (or no chunk).  The ID for this command is specified\n  as chunkID.  For example, a single chunk could be the atoms in a\n  molecule or atoms in a spatial bin.  See the compute chunk/atom and Howto chunk\n  doc pages for details of how chunks can be defined and examples of how\n  they can be used to measure properties of a system.\n  This compute calculates the radius of gyration Rg for each chunk,\n  which includes all effects due to atoms passing through periodic\n  boundaries.\n  Rg is a measure of the size of a chunk, and is computed by this\n  formula\n  \n  \\[{R_g}^2 = \\frac{1}{M} \\sum_i m_i (r_i - r_{cm})^2\\]\n  where \\(M\\) is the total mass of the chunk, \\(r_{cm}\\) is\n  the center-of-mass position of the chunk, and the sum is over all atoms in the\n  chunk.\n  Note that only atoms in the specified group contribute to the\n  calculation.  The compute chunk/atom command\n  defines its own group; atoms will have a chunk ID = 0 if they are not\n  in that group, signifying they are not assigned to a chunk, and will\n  thus also not contribute to this calculation.  You can specify the\n  “all” group for this command if you simply want to include atoms with\n  non-zero chunk IDs.\n  If the tensor keyword is specified, then the scalar Rg value is not\n  calculated, but an Rg tensor is instead calculated for each chunk.\n  The formula for the components of the tensor is the same as the above\n  formula, except that \\((r_i - r_{cm})^2\\) is replaced by\n  \\((r_{i,x} - r_{cm,x}) \\cdot (r_{i,y} - r_{cm,y})\\) for the xy\n  component, and so on.  The 6 components of the tensor are\n  ordered xx, yy, zz, xy, xz, yz.\n  \n  Note\n  The coordinates of an atom contribute to \\(R_g\\) in “unwrapped” form,\n  by using the image flags associated with each atom.  See the dump custom\n  command for a discussion of “unwrapped” coordinates.\n  See the Atoms section of the read_data command for a\n  discussion of image flags and how they are set for each atom.  You can\n  reset the image flags (e.g. to 0) before invoking this compute by\n  using the set image command.\n  \n  The simplest way to output the results of the compute gyration/chunk\n  calculation to a file is to use the fix ave/time\n  command, for example:\n  compute cc1 all chunk/atom molecule\n  compute myChunk all gyration/chunk cc1\n  fix 1 all ave/time 100 1 100 c_myChunk file tmp.out mode vector\n  \n  \n  Output info:\n  This compute calculates a global vector if the tensor keyword is not\n  specified and a global array if it is.  The length of the vector or\n  number of rows in the array = the number of chunks Nchunk as\n  calculated by the specified compute chunk/atom command.  If the tensor keyword\n  is specified, the global array has 6 columns.  The vector or array can\n  be accessed by any command that uses global values from a compute as\n  input.  See the Howto output doc page for an\n  overview of LAMMPS output options.\n  All the vector or array values calculated by this compute are\n  “intensive”.  The vector or array values will be in distance\n  units, since they are the square root of values\n  represented by the formula above.\n  ",
    "syntax": "compute ID group-ID gyration/chunk chunkID keyword value ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  gyration/chunk = style name of this compute command\n  chunkID = ID of compute chunk/atom command\n  zero or more keyword/value pairs may be appended\n  keyword = tensor\n  tensor value = none\n  \n  \n  ",
    "examples": "compute 1 molecule gyration/chunk molchunk\n  compute 2 molecule gyration/chunk molchunk tensor\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  Related commands: none\n  compute gyration\n  Default: none\n  "
},
{
    "command": "compute gyration/shape",
    "description": "Define a computation that calculates the eigenvalues of the gyration tensor of a\n  group of atoms and three shape parameters. The computation includes all effects\n  due to atoms passing through periodic boundaries.\n  The three computed shape parameters are the asphericity, b, the acylindricity, c,\n  and the relative shape anisotropy, k:\n  \n  \\[\\begin{split}c = & l_z - 0.5(l_y+l_x) \\\\\n  b = & l_y - l_x \\\\\n  k = & \\frac{3}{2} \\frac{l_x^2+l_y^2+l_z^2}{(l_x+l_y+l_z)^2} - \\frac{1}{2}\\end{split}\\]\n  where \\(l_x\\) <= \\(l_y\\) <= \\(l_z\\) are the three eigenvalues of the gyration tensor. A general description\n  of these parameters is provided in (Mattice) while an application to polymer systems\n  can be found in (Theodorou).\n  The asphericity  is always non-negative and zero only when the three principal\n  moments are equal. This zero condition is met when the distribution of particles\n  is spherically symmetric (hence the name asphericity) but also whenever the particle\n  distribution is symmetric with respect to the three coordinate axes, e.g.,\n  when the particles are distributed uniformly on a cube, tetrahedron or other Platonic\n  solid. The acylindricity is always non-negative and zero only when the two principal\n  moments are equal. This zero condition is met when the distribution of particles is\n  cylindrically symmetric (hence the name, acylindricity), but also whenever the particle\n  distribution is symmetric with respect to the two coordinate axes, e.g., when the\n  particles are distributed uniformly on a regular prism. the relative shape anisotropy\n  is bounded between zero (if all points are spherically symmetric) and one\n  (if all points lie on a line).\n  \n  Note\n  The coordinates of an atom contribute to the gyration tensor in\n  “unwrapped” form, by using the image flags associated with each atom.\n  See the dump custom command for a discussion of “unwrapped”\n  coordinates. See the Atoms section of the read_data\n  command for a discussion of image flags and how they are set for each\n  atom.  You can reset the image flags (e.g. to 0) before invoking this\n  compute by using the set image command.\n  \n  Output info:\n  This compute calculates a global vector of\n  length 6, which can be accessed by indices 1-6. The first three values are the\n  eigenvalues of the gyration tensor followed by the asphericity, the acylindricity\n  and the relative shape anisotropy.  The computed values can be used by any command\n  that uses global  vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The vector values calculated by this compute are\n  “intensive”.  The first five vector values will be in\n  distance^2 units while the sixth one is dimensionless.\n  ",
    "syntax": "compute ID group-ID gyration/shape compute-ID\n  \n  \n  \n  ID, group-ID are documented in compute command\n  gyration/shape = style name of this compute command\n  compute-ID = ID of compute gyration command\n  \n  ",
    "examples": "compute 1 molecule gyration/shape pe\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute gyration/shape/chunk",
    "description": "Define a computation that calculates the eigenvalues of the gyration tensor and\n  three shape parameters of multiple chunks of atoms. The computation includes\n  all effects due to atoms passing through periodic boundaries.\n  The three computed shape parameters are the asphericity, b, the acylindricity, c,\n  and the relative shape anisotropy, k:\n  \n  \\[\\begin{split}c = & l_z - 0.5(l_y+l_x) \\\\\n  b = & l_y - l_x \\\\\n  k = & \\frac{3}{2} \\frac{l_x^2+l_y^2+l_z^2}{(l_x+l_y+l_z)^2} - \\frac{1}{2}\\end{split}\\]\n  where \\(l_x\\) <= \\(l_y\\) <= :math`l_z` are the three eigenvalues of the gyration tensor. A general description\n  of these parameters is provided in (Mattice) while an application to polymer systems\n  can be found in (Theodorou). The asphericity  is always non-negative and zero\n  only when the three principal moments are equal. This zero condition is met when the distribution\n  of particles is spherically symmetric (hence the name asphericity) but also whenever the particle\n  distribution is symmetric with respect to the three coordinate axes, e.g.,\n  when the particles are distributed uniformly on a cube, tetrahedron or other Platonic\n  solid. The acylindricity is always non-negative and zero only when the two principal\n  moments are equal. This zero condition is met when the distribution of particles is\n  cylindrically symmetric (hence the name, acylindricity), but also whenever the particle\n  distribution is symmetric with respect to the two coordinate axes, e.g., when the\n  particles are distributed uniformly on a regular prism. the relative shape anisotropy\n  is bounded between zero (if all points are spherically symmetric) and one\n  (if all points lie on a line).\n  The tensor keyword must be specified in the compute gyration/chunk command.\n  \n  Note\n  The coordinates of an atom contribute to the gyration tensor in\n  “unwrapped” form, by using the image flags associated with each atom.\n  See the dump custom command for a discussion of “unwrapped”\n  coordinates. See the Atoms section of the read_data\n  command for a discussion of image flags and how they are set for each\n  atom.  You can reset the image flags (e.g. to 0) before invoking this\n  compute by using the set image command.\n  \n  Output info:\n  This compute calculates a global array with six columns,\n  which can be accessed by indices 1-6. The first three columns are the\n  eigenvalues of the gyration tensor followed by the asphericity, the acylindricity\n  and the relative shape anisotropy.  The computed values can be used by any command\n  that uses global array values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The array calculated by this compute is\n  “intensive”.  The first five columns will be in\n  distance^2 units while the sixth one is dimensionless.\n  ",
    "syntax": "compute ID group-ID gyration/shape/chunk compute-ID\n  \n  \n  \n  ID, group-ID are documented in compute command\n  gyration/shape/chunk = style name of this compute command\n  compute-ID = ID of compute gyration/chunk command\n  \n  ",
    "examples": "compute 1 molecule gyration/shape/chunk pe\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute heat/flux",
    "description": "Define a computation that calculates the heat flux vector based on\n  contributions from atoms in the specified group.  This can be used by\n  itself to measure the heat flux through a set of atoms (e.g. a region\n  between two thermostatted reservoirs held at different temperatures),\n  or to calculate a thermal conductivity using the equilibrium\n  Green-Kubo formalism.\n  For other non-equilibrium ways to compute a thermal conductivity, see\n  the Howto kappa doc page..  These include use of\n  the fix thermal/conductivity command\n  for the Muller-Plathe method.  Or the fix heat command\n  which can add or subtract heat from groups of atoms.\n  The compute takes three arguments which are IDs of other\n  computes.  One calculates per-atom kinetic energy\n  (ke-ID), one calculates per-atom potential energy (pe-ID), and the\n  third calculates per-atom stress (stress-ID).\n  \n  Note\n  These other computes should provide values for all the atoms in\n  the group this compute specifies.  That means the other computes could\n  use the same group as this compute, or they can just use group “all”\n  (or any group whose atoms are superset of the atoms in this compute’s\n  group).  LAMMPS does not check for this.\n  \n  In case of two-body interactions, the heat flux is defined as:\n  \n  \\[\\begin{split}\\mathbf{J} &= \\frac{1}{V} \\left[ \\sum_i e_i \\mathbf{v}_i - \\sum_{i} \\mathbf{S}_{i} \\mathbf{v}_i \\right] \\\\\n  &= \\frac{1}{V} \\left[ \\sum_i e_i \\mathbf{v}_i + \\sum_{i<j} \\left( \\mathbf{F}_{ij} \\cdot \\mathbf{v}_j \\right) \\mathbf{r}_{ij} \\right] \\\\\n  &= \\frac{1}{V} \\left[ \\sum_i e_i \\mathbf{v}_i + \\frac{1}{2} \\sum_{i<j} \\left( \\mathbf{F}_{ij} \\cdot \\left(\\mathbf{v}_i + \\mathbf{v}_j \\right)  \\right) \\mathbf{r}_{ij} \\right]\\end{split}\\]\n  \\(e_i\\) in the first term of the equation\n  is the per-atom energy (potential and kinetic).\n  This is calculated by the computes ke-ID\n  and pe-ID. \\(\\mathbf{S}_i\\) in the second term is the\n  per-atom stress tensor calculated by the compute stress-ID.\n  See compute stress/atom\n  and compute centroid/stress/atom\n  for possible definitions of atomic stress \\(\\mathbf{S}_i\\)\n  in the case of bonded and many-body interactions.\n  The tensor multiplies \\(\\mathbf{v}_i\\) as a 3x3 matrix-vector multiply\n  to yield a vector.\n  Note that as discussed below, the 1/\\({V}\\) scaling factor in the\n  equation for \\(\\mathbf{J}\\) is NOT included in the calculation performed by\n  these computes; you need to add it for a volume appropriate to the atoms\n  included in the calculation.\n  \n  Note\n  The compute pe/atom and\n  compute stress/atom\n  commands have options for which\n  terms to include in their calculation (pair, bond, etc).  The heat\n  flux calculation will thus include exactly the same terms. Normally\n  you should use compute stress/atom virial\n  or compute centroid/stress/atom virial\n  so as not to include a kinetic energy term in the heat flux.\n  \n  \n  Warning\n  The compute heat/flux has been reported to produce unphysical\n  values for angle, dihedral and improper contributions\n  when used with compute stress/atom,\n  as discussed in (Surblys) and (Boone).\n  You are strongly advised to\n  use compute centroid/stress/atom,\n  which has been implemented specifically for such cases.\n  \n  The Green-Kubo formulas relate the ensemble average of the\n  auto-correlation of the heat flux \\(\\mathbf{J}\\)\n  to the thermal conductivity \\(\\kappa\\):\n  \n  \\[\\kappa  = \\frac{V}{k_B T^2} \\int_0^\\infty \\langle J_x(0)  J_x(t) \\rangle \\, \\mathrm{d} t = \\frac{V}{3 k_B T^2} \\int_0^\\infty \\langle \\mathbf{J}(0) \\cdot  \\mathbf{J}(t)  \\rangle \\, \\mathrm{d}t\\]\n  \n  The heat flux can be output every so many timesteps (e.g. via the\n  thermo_style custom command).  Then as a\n  post-processing operation, an auto-correlation can be performed, its\n  integral estimated, and the Green-Kubo formula above evaluated.\n  The fix ave/correlate command can calculate\n  the auto-correlation.  The trap() function in the\n  variable command can calculate the integral.\n  An example LAMMPS input script for solid Ar is appended below.  The\n  result should be: average conductivity ~0.29 in W/mK.\n  \n  Output info:\n  This compute calculates a global vector of length 6.\n  The first 3 components are the \\(x\\), \\(y\\), \\(z\\)\n  components of the full heat flux vector,\n  i.e. (\\(J_x\\), \\(J_y\\), \\(J_z\\)).\n  The next 3 components are the \\(x\\), \\(y\\), \\(z\\) components\n  of just the convective portion of the flux, i.e. the\n  first term in the equation for \\(\\mathbf{J}\\).\n  Each component can be\n  accessed by indices 1-6. These values can be used by any command that\n  uses global vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The vector values calculated by this compute are “extensive”, meaning\n  they scale with the number of atoms in the simulation.  They can be\n  divided by the appropriate volume to get a flux, which would then be\n  an “intensive” value, meaning independent of the number of atoms in\n  the simulation.  Note that if the compute is “all”, then the\n  appropriate volume to divide by is the simulation box volume.\n  However, if a sub-group is used, it should be the volume containing\n  those atoms.\n  The vector values will be in energy*velocity units.  Once\n  divided by a volume the units will be that of flux, namely\n  energy/area/time units\n  ",
    "syntax": "compute ID group-ID heat/flux ke-ID pe-ID stress-ID\n  \n  \n  \n  ID, group-ID are documented in compute command\n  heat/flux = style name of this compute command\n  ke-ID = ID of a compute that calculates per-atom kinetic energy\n  pe-ID = ID of a compute that calculates per-atom potential energy\n  stress-ID = ID of a compute that calculates per-atom stress\n  \n  ",
    "examples": "compute myFlux all heat/flux myKE myPE myStress\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute hexorder/atom",
    "description": "Define a computation that calculates \\(q_n\\) the bond-orientational\n  order parameter for each atom in a group. The hexatic (n = 6) order\n  parameter was introduced by Nelson and Halperin as a way to detect\n  hexagonal symmetry in two-dimensional systems. For each atom, \\(q_n\\)\n  is a complex number (stored as two real numbers) defined as follows:\n  \n  \\[q_n = \\frac{1}{nnn}\\sum_{j = 1}^{nnn} e^{n i \\theta({\\bf r}_{ij})}\\]\n  where the sum is over the nnn nearest neighbors\n  of the central atom. The angle \\(\\theta\\)\n  is formed by the bond vector \\(r_{ij}\\) and the x axis.\n  \\(\\theta\\) is calculated only using the x and y components,\n  whereas the distance from the\n  central atom is calculated using all three\n  x, y, and z components of the bond vector.\n  Neighbor atoms not in the group\n  are included in the order parameter of atoms in the group.\n  The optional keyword cutoff defines the distance cutoff\n  used when searching for neighbors. The default value, also\n  the maximum allowable value, is the cutoff specified\n  by the pair style.\n  The optional keyword nnn defines the number of nearest\n  neighbors used to calculate \\(q_n\\). The default value is 6.\n  If the value is NULL, then all neighbors up to the\n  distance cutoff are used.\n  The optional keyword degree sets the degree n of the order parameter.\n  The default value is 6. For a perfect hexagonal lattice with\n  nnn = 6,\n  \\(q_6 = e^{6 i \\phi}\\) for all atoms, where the constant \\(0 < \\phi < \\frac{\\pi}{3}\\)\n  depends only on the orientation of the lattice relative to the x axis.\n  In an isotropic liquid, local neighborhoods may still exhibit\n  weak hexagonal symmetry, but because the orientational correlation\n  decays quickly with distance, the value of \\(\\phi\\) will be different for\n  different atoms, and so when \\(q_6\\) is averaged over all the atoms\n  in the system, \\(| \\left< q_6 \\right> | << 1\\).\n  The value of \\(q_n\\) is set to zero for atoms not in the\n  specified compute group, as well as for atoms that have less than\n  nnn neighbors within the distance cutoff.\n  The neighbor list needed to compute this quantity is constructed each\n  time the calculation is performed (i.e. each time a snapshot of atoms\n  is dumped).  Thus it can be inefficient to compute/dump this quantity\n  too frequently.\n  \n  Note\n  If you have a bonded system, then the settings of\n  special_bonds command can remove pairwise\n  interactions between atoms in the same bond, angle, or dihedral.  This\n  is the default setting for the special_bonds\n  command, and means those pairwise interactions do not appear in the\n  neighbor list.  Because this fix uses the neighbor list, it also means\n  those pairs will not be included in the order parameter.  This\n  difficulty can be circumvented by writing a dump file, and using the\n  rerun command to compute the order parameter for\n  snapshots in the dump file.  The rerun script can use a\n  special_bonds command that includes all pairs in\n  the neighbor list.\n  \n  Output info:\n  This compute calculates a per-atom array with 2 columns, giving the\n  real and imaginary parts \\(q_n\\), a complex number restricted to the\n  unit disk of the complex plane i.e. \\(Re(q_n)^2 + Im(q_n)^2 <= 1\\).\n  These values can be accessed by any command that uses per-atom values\n  from a compute as input.  See the Howto output doc\n  page for an overview of LAMMPS output options.\n  ",
    "syntax": "compute ID group-ID hexorder/atom keyword values ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  hexorder/atom = style name of this compute command\n  one or more keyword/value pairs may be appended\n  keyword = degree or nnn or cutoff\n    cutoff value = distance cutoff\n    nnn value = number of nearest neighbors\n    degree value = degree n of order parameter\n  \n  \n  ",
    "examples": "compute 1 all hexorder/atom\n  compute 1 all hexorder/atom degree 4 nnn 4 cutoff 1.2\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute hma",
    "description": "Define a computation that calculates the properties of a solid (potential\n  energy, pressure or heat capacity), using the harmonically-mapped averaging\n  (HMA) method.\n  This command yields much higher precision than the equivalent compute commands\n  (compute pe, compute pressure, etc.)\n  commands during a canonical simulation of an atomic crystal. Specifically,\n  near melting HMA can yield averages of a given precision an order of magnitude\n  faster than conventional methods, and this only improves as the temperatures is\n  lowered.  This is particularly important for evaluating the free energy by\n  thermodynamic integration, where the low-temperature contributions are the\n  greatest source of statistical uncertainty.  Moreover, HMA has other\n  advantages, including smaller potential-truncation effects, finite-size\n  effects, smaller timestep inaccuracy, faster equilibration and shorter\n  decorrelation time.\n  HMA should not be used if atoms are expected to diffuse.  It is also\n  restricted to simulations in the NVT ensemble.  While this compute may\n  be used with any potential in LAMMPS, it will provide inaccurate results\n  for potentials that do not go to 0 at the truncation distance;\n  pair_style lj/smooth/linear and Ewald\n  summation should work fine, while pair_style lj/cut\n  will perform poorly unless the potential is shifted (via\n  pair_modify shift) or the cutoff is large.\n  Furthermore, computation of the heat capacity with this compute is\n  restricted to those that implement the single_hessian method in Pair.\n  Implementing single_hessian in additional pair styles is simple.\n  Please contact Andrew Schultz (ajs42 at buffalo.edu) and David Kofke\n  (kofke at buffalo.edu) if your desired pair style does not have this\n  method.  This is the list of pair styles that currently implement\n  single_hessian:\n  \n  pair_style lj/smooth/linear\n  \n  In this method, the analytically known harmonic behavior of a crystal is removed from the traditional ensemble\n  averages, which leads to an accurate and precise measurement of the anharmonic contributions without contamination\n  by noise produced by the already-known harmonic behavior.\n  A detailed description of this method can be found in (Moustafa). The potential energy is computed by the formula:\n  \n  \\[\\left< U\\right>_{HMA} = \\frac{d}{2} (N-1) k_B T  + \\left< U + \\frac{1}{2} F\\bullet\\Delta r \\right>\\]\n  where \\(N\\) is the number of atoms in the system, \\(k_B\\) is Boltzmann’s\n  constant, \\(T\\) is the temperature, \\(d\\) is the\n  dimensionality of the system (2 or 3 for 2d/3d), \\(F\\bullet\\Delta r\\) is the sum of dot products of the\n  atomic force vectors and displacement (from lattice sites) vectors, and \\(U\\) is the sum of\n  pair, bond, angle, dihedral, improper, kspace (long-range), and fix energies.\n  The pressure is computed by the formula:\n  \n  \\[\\left< P\\right>_{HMA} = \\Delta \\hat P + \\left< P_{vir} + \\frac{\\beta \\Delta \\hat P - \\rho}{d(N-1)} F\\bullet\\Delta r \\right>\\]\n  where \\(\\rho\\) is the number density of the system, \\(\\Delta \\hat P\\) is the\n  difference between the harmonic and lattice pressure, \\(P_{vir}\\) is\n  the virial pressure computed as the sum of pair, bond, angle, dihedral,\n  improper, kspace (long-range), and fix contributions to the force on each\n  atom, and \\(k_B=1/k_B T\\).  Although the method will work for any value of \\(\\Delta \\hat P\\)\n  specified (use pressure units), the precision of the resultant\n  pressure is sensitive to \\(\\Delta \\hat P\\); the precision tends to be\n  best when \\(\\Delta \\hat P\\) is the actual the difference between the lattice\n  pressure and harmonic pressure.\n  \n  \\[\\left<C_V \\right>_{HMA} = \\frac{d}{2} (N-1) k_B + \\frac{1}{k_B T^2} \\left( \\left<\n  U_{HMA}^2 \\right> - \\left<U_{HMA}\\right>^2 \\right) + \\frac{1}{4 T}\n  \\left< F\\bullet\\Delta r + \\Delta r \\bullet \\Phi \\bullet \\Delta r \\right>\\]\n  where \\(\\Phi\\) is the Hessian matrix. The compute hma command\n  computes the full expression for \\(C_V\\) except for the\n  \\(\\left<U_{HMA}^2\\right>^2\\) in the variance term, which can be obtained by\n  passing the u keyword; you must add this extra contribution to the \\(C_V\\)\n  value reported by this compute.  The variance term can cause significant\n  round-off error when computing \\(C_V\\).  To address this, the anharmonic\n  keyword can be passed and/or the output format can be specified with more\n  digits.\n  thermo_modify format float '%22.15e'\n  \n  \n  The anharmonic keyword will instruct the compute to return anharmonic\n  properties rather than the full properties, which include lattice, harmonic\n  and anharmonic contributions.\n  When using this keyword, the compute must be first active (it must be included\n  via a thermo_style custom command) while the atoms are\n  still at their lattice sites (before equilibration).\n  The temp-ID specified with compute hma command should be same as the fix-ID of Nose-Hoover (fix nvt) or\n  Berendsen (fix temp/berendsen) thermostat used for the simulation. While using this command, Langevin thermostat\n  (fix langevin)\n  should be avoided as its extra forces interfere with the HMA implementation.\n  \n  Note\n  Compute hma command should be used right after the energy minimization, when the atoms are at their lattice sites.\n  The simulation should not be started before this command has been used in the input script.\n  \n  The following example illustrates the placement of this command in the input script:\n  min_style cg\n  minimize 1e-35 1e-15 50000 500000\n  compute 1 all hma thermostatid u\n  fix thermostatid all nvt temp 600.0 600.0 100.0\n  \n  \n  \n  Note\n  Compute hma should be used when the atoms of the solid do not diffuse. Diffusion will reduce the precision in the potential energy computation.\n  \n  \n  Note\n  The fix_modify energy yes command must also be specified if a fix is to contribute potential energy to this command.\n  \n  An example input script that uses this compute is included in\n  examples/USER/hma/ along with corresponding LAMMPS output showing that the HMA\n  properties fluctuate less than the corresponding conventional properties.\n  Output info:\n  This compute calculates a global vector that includes the n properties\n  requested as arguments to the command (the potential energy, pressure and/or heat\n  capacity).  The elements of the vector can be accessed by indices 1-n by any\n  command that uses global vector values as input.  See the Howto output doc page for an overview of LAMMPS output options.\n  The vector values calculated by this compute are “extensive”.  The\n  scalar value will be in energy units.\n  ",
    "syntax": "compute ID group-ID hma temp-ID keyword ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  hma = style name of this compute command\n  temp-ID = ID of fix that specifies the set temperature during canonical simulation\n  keyword = anharmonic u p Pharm cv\n  \n  anharmonic = compute will return anharmonic property values\n  u = compute will return potential energy\n  p = compute will return pressure.  the following keyword must be the difference between the harmonic pressure and lattice pressure as described below\n  cv = compute will return the heat capacity\n  ",
    "examples": "compute 2 all hma 1 u\n  compute 2 all hma 1 anharmonic u p 0.9\n  compute 2 all hma 1 u cv\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-MISC package.  It is enabled only\n  if LAMMPS was built with that package.  See the Build package doc page for more info.\n  Usage restricted to canonical (NVT) ensemble simulation only.\n  "
},
{
    "command": "compute improper",
    "description": "Define a computation that extracts the improper energy calculated by\n  each of the improper sub-styles used in the improper_style hybrid command.  These values are made\n  accessible for output or further processing by other commands.  The\n  group specified for this command is ignored.\n  This compute is useful when using improper_style hybrid if you want to know the portion of the\n  total energy contributed by one or more of the hybrid sub-styles.\n  Output info:\n  This compute calculates a global vector of length N where N is the\n  number of sub_styles defined by the improper_style hybrid command.  which can be accessed by indices\n  1-N.  These values can be used by any command that uses global scalar\n  or vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The vector values are “extensive” and will be in energy\n  units.\n  ",
    "syntax": "compute ID group-ID improper\n  \n  \n  \n  ID, group-ID are documented in compute command\n  improper = style name of this compute command\n  \n  ",
    "examples": "compute 1 all improper\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute improper/local",
    "description": "Define a computation that calculates properties of individual improper\n  interactions.  The number of datums generated, aggregated across all\n  processors, equals the number of impropers in the system, modified by\n  the group parameter as explained below.\n  The value chi is the improper angle, as defined in the doc pages for\n  the individual improper styles listed on\n  improper_style doc page.\n  The local data stored by this command is generated by looping over all\n  the atoms owned on a processor and their impropers.  An improper will\n  only be included if all 4 atoms in the improper are in the specified\n  compute group.\n  Note that as atoms migrate from processor to processor, there will be\n  no consistent ordering of the entries within the local vector or array\n  from one timestep to the next.  The only consistency that is\n  guaranteed is that the ordering on a particular timestep will be the\n  same for local vectors or arrays generated by other compute commands.\n  For example, improper output from the compute property/local command can be combined\n  with data from this command and output by the dump local\n  command in a consistent way.\n  Here is an example of how to do this:\n  compute 1 all property/local itype iatom1 iatom2 iatom3 iatom4\n  compute 2 all improper/local chi\n  dump 1 all local 1000 tmp.dump index c_1[1] c_1[2] c_1[3] c_1[4] c_1[5] c_2[1]\n  \n  \n  Output info:\n  This compute calculates a local vector or local array depending on the\n  number of keywords.  The length of the vector or number of rows in the\n  array is the number of impropers.  If a single keyword is specified, a\n  local vector is produced.  If two or more keywords are specified, a\n  local array is produced where the number of columns = the number of\n  keywords.  The vector or array can be accessed by any command that\n  uses local values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The output for chi will be in degrees.\n  ",
    "syntax": "compute ID group-ID improper/local value1 value2 ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  improper/local = style name of this compute command\n  one or more values may be appended\n  value = chi\n  chi = tabulate improper angles\n  \n  \n  ",
    "examples": "compute 1 all improper/local chi\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute inertia/chunk",
    "description": "Define a computation that calculates the inertia tensor for multiple\n  chunks of atoms.\n  In LAMMPS, chunks are collections of atoms defined by a compute chunk/atom command, which assigns each atom\n  to a single chunk (or no chunk).  The ID for this command is specified\n  as chunkID.  For example, a single chunk could be the atoms in a\n  molecule or atoms in a spatial bin.  See the compute chunk/atom and Howto chunk\n  doc pages for details of how chunks can be defined and examples of how\n  they can be used to measure properties of a system.\n  This compute calculates the 6 components of the symmetric inertia\n  tensor for each chunk, ordered Ixx,Iyy,Izz,Ixy,Iyz,Ixz.  The\n  calculation includes all effects due to atoms passing through periodic\n  boundaries.\n  Note that only atoms in the specified group contribute to the\n  calculation.  The compute chunk/atom command\n  defines its own group; atoms will have a chunk ID = 0 if they are not\n  in that group, signifying they are not assigned to a chunk, and will\n  thus also not contribute to this calculation.  You can specify the\n  “all” group for this command if you simply want to include atoms with\n  non-zero chunk IDs.\n  \n  Note\n  The coordinates of an atom contribute to the chunk’s inertia\n  tensor in “unwrapped” form, by using the image flags associated with\n  each atom.  See the dump custom command for a discussion\n  of “unwrapped” coordinates.  See the Atoms section of the\n  read_data command for a discussion of image flags and\n  how they are set for each atom.  You can reset the image flags\n  (e.g. to 0) before invoking this compute by using the set image command.\n  \n  The simplest way to output the results of the compute inertia/chunk\n  calculation to a file is to use the fix ave/time\n  command, for example:\n  compute cc1 all chunk/atom molecule\n  compute myChunk all inertia/chunk cc1\n  fix 1 all ave/time 100 1 100 c_myChunk[*] file tmp.out mode vector\n  \n  \n  Output info:\n  This compute calculates a global array where the number of rows = the\n  number of chunks Nchunk as calculated by the specified compute chunk/atom command.  The number of columns =\n  6 for the 6 components of the inertia tensor for each chunk, ordered\n  as listed above.  These values can be accessed by any command that\n  uses global array values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The array values are “intensive”.  The array values will be in\n  mass*distance^2 units.\n  ",
    "syntax": "compute ID group-ID inertia/chunk chunkID\n  \n  \n  \n  ID, group-ID are documented in compute command\n  inertia/chunk = style name of this compute command\n  chunkID = ID of compute chunk/atom command\n  \n  ",
    "examples": "compute 1 fluid inertia/chunk molchunk\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute ke",
    "description": "Define a computation that calculates the translational kinetic energy\n  of a group of particles.\n  The kinetic energy of each particle is computed as \\(\\frac{1}{2} m\n  v^2\\), where m and v are the mass and velocity of the particle.\n  There is a subtle difference between the quantity calculated by this\n  compute and the kinetic energy calculated by the ke or etotal\n  keyword used in thermodynamic output, as specified by the\n  thermo_style command.  For this compute, kinetic\n  energy is “translational” kinetic energy, calculated by the simple\n  formula above.  For thermodynamic output, the ke keyword infers\n  kinetic energy from the temperature of the system with\n  \\(\\frac{1}{2} k_B T\\) of energy for each degree of freedom.  For the\n  default temperature computation via the compute temp command, these are the same.  But different computes\n  that calculate temperature can subtract out different non-thermal\n  components of velocity and/or include different degrees of freedom\n  (translational, rotational, etc).\n  Output info:\n  This compute calculates a global scalar (the summed KE).  This value\n  can be used by any command that uses a global scalar value from a\n  compute as input.  See the Howto output doc page\n  for an overview of LAMMPS output options.\n  The scalar value calculated by this compute is “extensive”.  The\n  scalar value will be in energy units.\n  ",
    "syntax": "compute ID group-ID ke\n  \n  \n  \n  ID, group-ID are documented in compute command\n  ke = style name of this compute command\n  \n  ",
    "examples": "compute 1 all ke\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute ke/atom",
    "description": "Define a computation that calculates the per-atom translational\n  kinetic energy for each atom in a group.\n  The kinetic energy is simply 1/2 m v^2, where m is the mass and v is\n  the velocity of each atom.\n  The value of the kinetic energy will be 0.0 for atoms not in the\n  specified compute group.\n  Output info:\n  This compute calculates a per-atom vector, which can be accessed by\n  any command that uses per-atom values from a compute as input.  See\n  the Howto output doc page for an overview of\n  LAMMPS output options.\n  The per-atom vector values will be in energy units.\n  ",
    "syntax": "compute ID group-ID ke/atom\n  \n  \n  \n  ID, group-ID are documented in compute command\n  ke/atom = style name of this compute command\n  \n  ",
    "examples": "compute 1 all ke/atom\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute ke/atom/eff",
    "description": "Define a computation that calculates the per-atom translational\n  (nuclei and electrons) and radial kinetic energy (electron only) in a\n  group.  The particles are assumed to be nuclei and electrons modeled\n  with the electronic force field.\n  The kinetic energy for each nucleus is computed as \\(\\frac{1}{2} m\n  v^2\\), where m corresponds to the corresponding nuclear mass, and the\n  kinetic energy for each electron is computed as \\(\\frac{1}{2} (m_e\n  v^2 + \\frac{3}{4} m_e s^2)\\), where \\(m_e\\) and v correspond to the mass\n  and translational velocity of each electron, and s to its radial\n  velocity, respectively.\n  There is a subtle difference between the quantity calculated by this\n  compute and the kinetic energy calculated by the ke or etotal\n  keyword used in thermodynamic output, as specified by the\n  thermo_style command. For this compute, kinetic\n  energy is “translational” plus electronic “radial” kinetic energy,\n  calculated by the simple formula above. For thermodynamic output, the\n  ke keyword infers kinetic energy from the temperature of the system\n  with \\(\\frac{1}{2} k_B T\\) of energy for each (nuclear-only) degree\n  of freedom in eFF.\n  \n  Note\n  The temperature in eFF should be monitored via the compute temp/eff command, which can be printed with\n  thermodynamic output by using the thermo_modify\n  command, as shown in the following example:\n  \n  compute         effTemp all temp/eff\n  thermo_style    custom step etotal pe ke temp press\n  thermo_modify   temp effTemp\n  \n  \n  The value of the kinetic energy will be 0.0 for atoms (nuclei or\n  electrons) not in the specified compute group.\n  Output info:\n  This compute calculates a scalar quantity for each atom, which can be\n  accessed by any command that uses per-atom computes as input.  See the\n  Howto output doc page for an overview of LAMMPS\n  output options.\n  The per-atom vector values will be in energy units.\n  ",
    "syntax": "compute ID group-ID ke/atom/eff\n  \n  \n  \n  ID, group-ID are documented in compute command\n  ke/atom/eff = style name of this compute command\n  \n  ",
    "examples": "compute 1 all ke/atom/eff\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-EFF package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute ke/eff",
    "description": "Define a computation that calculates the kinetic energy of motion of a\n  group of eFF particles (nuclei and electrons), as modeled with the\n  electronic force field.\n  The kinetic energy for each nucleus is computed as \\(\\frac{1}{2} m\n  v^2\\) and the kinetic energy for each electron is computed as\n  \\(\\frac{1}{2}(m_e v^2 + \\frac{3}{4} m_e s^2)\\), where m\n  corresponds to the nuclear mass, \\(m_e\\) to the electron mass, v\n  to the translational velocity of each particle, and s to the radial\n  velocity of the electron, respectively.\n  There is a subtle difference between the quantity calculated by this\n  compute and the kinetic energy calculated by the ke or etotal\n  keyword used in thermodynamic output, as specified by the\n  thermo_style command.  For this compute, kinetic\n  energy is “translational” and “radial” (only for electrons) kinetic\n  energy, calculated by the simple formula above.  For thermodynamic\n  output, the ke keyword infers kinetic energy from the temperature of\n  the system with \\(\\frac{1}{2} k_B T\\) of energy for each degree of\n  freedom.  For the eFF temperature computation via the compute\n  temp_eff command, these are the same.  But\n  different computes that calculate temperature can subtract out different\n  non-thermal components of velocity and/or include other degrees of\n  freedom.\n  \n  Warning\n  The temperature in eFF models should be monitored via\n  the compute temp/eff command, which can be\n  printed with thermodynamic output by using the\n  thermo_modify command, as shown in the following\n  example:\n  \n  compute         effTemp all temp/eff\n  thermo_style    custom step etotal pe ke temp press\n  thermo_modify   temp effTemp\n  \n  \n  See compute temp/eff.\n  Output info:\n  This compute calculates a global scalar (the KE).  This value can be\n  used by any command that uses a global scalar value from a compute as\n  input.  See the Howto output doc page for an\n  overview of LAMMPS output options.\n  The scalar value calculated by this compute is “extensive”.  The\n  scalar value will be in energy units.\n  ",
    "syntax": "compute ID group-ID ke/eff\n  \n  \n  \n  ID, group-ID are documented in compute command\n  ke/eff = style name of this compute command\n  \n  ",
    "examples": "compute 1 all ke/eff\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-EFF package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  Related commands: none\n  Default: none\n  "
},
{
    "command": "compute ke/rigid",
    "description": "Define a computation that calculates the translational kinetic energy\n  of a collection of rigid bodies, as defined by one of the fix rigid command variants.\n  The kinetic energy of each rigid body is computed as 1/2 M Vcm^2,\n  where M is the total mass of the rigid body, and Vcm is its\n  center-of-mass velocity.\n  The fix-ID should be the ID of one of the fix rigid\n  commands which defines the rigid bodies.  The group specified in the\n  compute command is ignored.  The kinetic energy of all the rigid\n  bodies defined by the fix rigid command in included in the\n  calculation.\n  Output info:\n  This compute calculates a global scalar (the summed KE of all the\n  rigid bodies).  This value can be used by any command that uses a\n  global scalar value from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The scalar value calculated by this compute is “extensive”.  The\n  scalar value will be in energy units.\n  ",
    "syntax": "compute ID group-ID ke/rigid fix-ID\n  \n  \n  \n  ID, group-ID are documented in compute command\n  ke = style name of this compute command\n  fix-ID = ID of rigid body fix\n  \n  ",
    "examples": "compute 1 all ke/rigid myRigid\n  \n  \n  ",
    "restrictions": "This compute is part of the RIGID package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute meso/e/atom",
    "description": "Define a computation that calculates the per-atom internal energy\n  for each atom in a group.\n  The internal energy is the energy associated with the internal degrees\n  of freedom of a mesoscopic particles, e.g. a Smooth-Particle\n  Hydrodynamics particle.\n  See this PDF guide to using SPH in\n  LAMMPS.\n  The value of the internal energy will be 0.0 for atoms not in the\n  specified compute group.\n  Output info:\n  This compute calculates a per-atom vector, which can be accessed by\n  any command that uses per-atom values from a compute as input.  See\n  the Howto output doc page for an overview of\n  LAMMPS output options.\n  The per-atom vector values will be in energy units.\n  ",
    "syntax": "compute ID group-ID meso/e/atom\n  \n  \n  \n  ID, group-ID are documented in compute command\n  meso/e/atom = style name of this compute command\n  \n  ",
    "examples": "compute 1 all meso/e/atom\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-SPH package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute meso/rho/atom",
    "description": "Define a computation that calculates the per-atom mesoscopic density\n  for each atom in a group.\n  The mesoscopic density is the mass density of a mesoscopic particle,\n  calculated by kernel function interpolation using “pair style\n  sph/rhosum”.\n  See this PDF guide to using SPH in\n  LAMMPS.\n  The value of the mesoscopic density will be 0.0 for atoms not in the\n  specified compute group.\n  Output info:\n  This compute calculates a per-atom vector, which can be accessed by\n  any command that uses per-atom values from a compute as input.  See\n  the Howto output doc page for an overview of\n  LAMMPS output options.\n  The per-atom vector values will be in mass/volume units.\n  ",
    "syntax": "compute ID group-ID meso/rho/atom\n  \n  \n  \n  ID, group-ID are documented in compute command\n  meso/rho/atom = style name of this compute command\n  \n  ",
    "examples": "compute 1 all meso/rho/atom\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-SPH package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute meso/t/atom",
    "description": "Define a computation that calculates the per-atom internal temperature\n  for each atom in a group.\n  The internal temperature is the ratio of internal energy over the heat\n  capacity associated with the internal degrees of freedom of a mesoscopic\n  particles, e.g. a Smooth-Particle Hydrodynamics particle.\n  \n  \\[T_{int} = E_{int} / C_{V,int}\\]\n  See this PDF guide to using SPH in\n  LAMMPS.\n  The value of the internal energy will be 0.0 for atoms not in the\n  specified compute group.\n  Output info:\n  This compute calculates a per-atom vector, which can be accessed by\n  any command that uses per-atom values from a compute as input.  See\n  the Howto output doc page for an overview of\n  LAMMPS output options.\n  The per-atom vector values will be in temperature units.\n  ",
    "syntax": "compute ID group-ID meso/t/atom\n  \n  \n  \n  ID, group-ID are documented in compute command\n  meso/t/atom = style name of this compute command\n  \n  ",
    "examples": "compute 1 all meso/t/atom\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-SPH package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute_modify",
    "description": "Modify one or more parameters of a previously defined compute.  Not\n  all compute styles support all parameters.\n  The extra/dof or extra keyword refers to how many\n  degrees-of-freedom are subtracted (typically from 3N) as a normalizing\n  factor in a temperature computation.  Only computes that compute a\n  temperature use this option.  The default is 2 or 3 for 2d or 3d systems which is a correction factor for an ensemble\n  of velocities with zero total linear momentum. For compute\n  temp/partial, if one or more velocity components are excluded, the\n  value used for extra is scaled accordingly. You can use a negative\n  number for the extra parameter if you need to add\n  degrees-of-freedom.  See the compute temp/asphere command for an example.\n  The dynamic/dof or dynamic keyword determines whether the number\n  of atoms N in the compute group and their associated degrees of\n  freedom are re-computed each time a temperature is computed.  Only\n  compute styles that calculate a temperature use this option.  By\n  default, N and their DOF are assumed to be constant.  If you are\n  adding atoms or molecules to the system (see the fix pour, fix deposit, and fix gcmc commands) or expect atoms or molecules to be lost\n  (e.g. due to exiting the simulation box or via fix evaporate), then this option should be used to\n  insure the temperature is correctly normalized.\n  \n  Note\n  The extra and dynamic keywords should not be used as they\n  are deprecated (March 2017) and will eventually be disabled.  Instead,\n  use the equivalent extra/dof and dynamic/dof keywords.\n  \n  ",
    "syntax": "compute_modify compute-ID keyword value ...\n  \n  \n  \n  compute-ID = ID of the compute to modify\n  one or more keyword/value pairs may be listed\n  keyword = extra/dof or extra or dynamic/dof or dynamic\n  extra/dof value = N\n    N = # of extra degrees of freedom to subtract\n  extra syntax is identical to extra/dof, will be disabled at some point\n  dynamic/dof value = yes or no\n    yes/no = do or do not re-compute the number of degrees of freedom (DOF) contributing to the temperature\n  dynamic syntax is identical to dynamic/dof, will be disabled at some point\n  \n  \n  ",
    "examples": "compute_modify myTemp extra/dof 0\n  compute_modify newtemp dynamic/dof yes extra/dof 600\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute momentum",
    "description": "Define a computation that calculates the translational momentum\n  of a group of particles.\n  The momentum of each particles is computed as m v, where m and v are\n  the mass and velocity of the particle.\n  Output info:\n  This compute calculates a global vector (the summed momentum) of\n  length 3. This value can be used by any command that uses a global\n  vector value from a compute as input. See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The vector value calculated by this compute is “extensive”. The vector\n  value will be in mass*velocity units.\n  ",
    "syntax": "compute ID group-ID momentum\n  \n  \n  \n  ID, group-ID are documented in compute command\n  momentum = style name of this compute command\n  \n  ",
    "examples": "compute 1 all momentum\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute msd",
    "description": "Define a computation that calculates the mean-squared displacement\n  (MSD) of the group of atoms, including all effects due to atoms\n  passing through periodic boundaries.  For computation of the non-Gaussian\n  parameter of mean-squared displacement, see the compute msd/nongauss command.\n  A vector of four quantities is calculated by this compute.  The first 3\n  elements of the vector are the squared dx,dy,dz displacements, summed\n  and averaged over atoms in the group.  The 4th element is the total\n  squared displacement, i.e. (dx*dx + dy*dy + dz*dz), summed and\n  averaged over atoms in the group.\n  The slope of the mean-squared displacement (MSD) versus time is\n  proportional to the diffusion coefficient of the diffusing atoms.\n  The displacement of an atom is from its reference position. This is\n  normally the original position at the time\n  the compute command was issued, unless the average keyword is set to yes.\n  The value of the displacement will be\n  0.0 for atoms not in the specified compute group.\n  If the com option is set to yes then the effect of any drift in\n  the center-of-mass of the group of atoms is subtracted out before the\n  displacement of each atom is calculated.\n  If the average option is set to yes then the reference position of\n  an atom is based on the average position of that atom, corrected for\n  center-of-mass motion if requested.  The average position is a running\n  average over all previous calls to the compute, including the current\n  call. So on the first call it is current position, on the second call\n  it is the arithmetic average of the current position and the position\n  on the first call, and so on.  Note that when using this option, the\n  precise value of the mean square displacement will depend on the\n  number of times the compute is called. So, for example, changing the\n  frequency of thermo output may change the computed displacement. Also,\n  the precise values will be changed if a single simulation is broken up\n  into two parts, using either multiple run commands or a restart\n  file. It only makes sense to use this option if the atoms are not\n  diffusing, so that their average positions relative to the center of\n  mass of the system are stationary. The most common case is crystalline\n  solids undergoing thermal motion.\n  \n  Note\n  Initial coordinates are stored in “unwrapped” form, by using the\n  image flags associated with each atom.  See the dump custom command for a discussion of “unwrapped” coordinates.\n  See the Atoms section of the read_data command for a\n  discussion of image flags and how they are set for each atom.  You can\n  reset the image flags (e.g. to 0) before invoking this compute by\n  using the set image command.\n  \n  \n  Note\n  If you want the quantities calculated by this compute to be\n  continuous when running from a restart file, then\n  you should use the same ID for this compute, as in the original run.\n  This is so that the fix this compute creates to store per-atom\n  quantities will also have the same ID, and thus be initialized\n  correctly with atom reference positions from the restart file.  When\n  average is set to yes, then the atom reference positions are\n  restored correctly, but not the number of samples used obtain them. As\n  a result, the reference positions from the restart file are combined\n  with subsequent positions as if they were from a single sample,\n  instead of many, which will change the values of msd somewhat.\n  \n  Output info:\n  This compute calculates a global vector of length 4, which can be\n  accessed by indices 1-4 by any command that uses global vector values\n  from a compute as input.  See the Howto output doc\n  page for an overview of LAMMPS output options.\n  The vector values are “intensive”.  The vector values will be in\n  distance^2 units.\n  ",
    "syntax": "compute ID group-ID msd keyword values ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  msd = style name of this compute command\n  zero or more keyword/value pairs may be appended\n  keyword = com or average\n  com value = yes or no\n  average value = yes or no\n  \n  \n  ",
    "examples": "compute 1 all msd\n  compute 1 upper msd com yes average yes\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute msd/chunk",
    "description": "Define a computation that calculates the mean-squared displacement\n  (MSD) for multiple chunks of atoms.\n  In LAMMPS, chunks are collections of atoms defined by a compute chunk/atom command, which assigns each atom\n  to a single chunk (or no chunk).  The ID for this command is specified\n  as chunkID.  For example, a single chunk could be the atoms in a\n  molecule or atoms in a spatial bin.  See the compute chunk/atom and Howto chunk\n  doc pages for details of how chunks can be defined and examples of how\n  they can be used to measure properties of a system.\n  Four quantities are calculated by this compute for each chunk.  The\n  first 3 quantities are the squared dx,dy,dz displacements of the\n  center-of-mass.  The 4th component is the total squared displacement,\n  i.e. (dx*dx + dy*dy + dz*dz) of the center-of-mass.  These\n  calculations include all effects due to atoms passing through periodic\n  boundaries.\n  Note that only atoms in the specified group contribute to the\n  calculation.  The compute chunk/atom command\n  defines its own group; atoms will have a chunk ID = 0 if they are not\n  in that group, signifying they are not assigned to a chunk, and will\n  thus also not contribute to this calculation.  You can specify the\n  “all” group for this command if you simply want to include atoms with\n  non-zero chunk IDs.\n  The slope of the mean-squared displacement (MSD) versus time is\n  proportional to the diffusion coefficient of the diffusing chunks.\n  The displacement of the center-of-mass of the chunk is from its\n  original center-of-mass position, calculated on the timestep this\n  compute command was first invoked.\n  \n  Note\n  The number of chunks Nchunk calculated by the compute chunk/atom command must remain constant each\n  time this compute is invoked, so that the displacement for each chunk\n  from its original position can be computed consistently.  If Nchunk\n  does not remain constant, an error will be generated.  If needed, you\n  can enforce a constant Nchunk by using the nchunk once or ids\n  once options when specifying the compute chunk/atom command.\n  \n  \n  Note\n  This compute stores the original position (of the\n  center-of-mass) of each chunk.  When a displacement is calculated on a\n  later timestep, it is assumed that the same atoms are assigned to the\n  same chunk ID.  However LAMMPS has no simple way to insure this is the\n  case, though you can use the ids once option when specifying the\n  compute chunk/atom command.  Note that if\n  this is not the case, the MSD calculation does not have a sensible\n  meaning.\n  \n  \n  Note\n  The initial coordinates of the atoms in each chunk are stored in\n  “unwrapped” form, by using the image flags associated with each atom.\n  See the dump custom command for a discussion of\n  “unwrapped” coordinates.  See the Atoms section of the\n  read_data command for a discussion of image flags and\n  how they are set for each atom.  You can reset the image flags\n  (e.g. to 0) before invoking this compute by using the set image command.\n  \n  \n  Note\n  If you want the quantities calculated by this compute to be\n  continuous when running from a restart file, then\n  you should use the same ID for this compute, as in the original run.\n  This is so that the fix this compute creates to store per-chunk\n  quantities will also have the same ID, and thus be initialized\n  correctly with chunk reference positions from the restart file.\n  \n  The simplest way to output the results of the compute msd/chunk\n  calculation to a file is to use the fix ave/time\n  command, for example:\n  compute cc1 all chunk/atom molecule\n  compute myChunk all msd/chunk cc1\n  fix 1 all ave/time 100 1 100 c_myChunk[*] file tmp.out mode vector\n  \n  \n  Output info:\n  This compute calculates a global array where the number of rows = the\n  number of chunks Nchunk as calculated by the specified compute chunk/atom command.  The number of columns =\n  4 for dx,dy,dz and the total displacement.  These values can be\n  accessed by any command that uses global array values from a compute\n  as input.  See the Howto output doc page for an\n  overview of LAMMPS output options.\n  The array values are “intensive”.  The array values will be in\n  distance^2 units.\n  ",
    "syntax": "compute ID group-ID msd/chunk chunkID\n  \n  \n  \n  ID, group-ID are documented in compute command\n  msd/chunk = style name of this compute command\n  chunkID = ID of compute chunk/atom command\n  \n  ",
    "examples": "compute 1 all msd/chunk molchunk\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute msd/nongauss",
    "description": "Define a computation that calculates the mean-squared displacement\n  (MSD) and non-Gaussian parameter (NGP) of the group of atoms,\n  including all effects due to atoms passing through periodic boundaries.\n  A vector of three quantities is calculated by this compute.  The first\n  element of the vector is the total squared dx,dy,dz displacements\n  drsquared = (dx*dx + dy*dy + dz*dz) of atoms, and the second is the\n  fourth power of these displacements drfourth = (dx*dx + dy*dy +\n  dz*dz)*(dx*dx + dy*dy + dz*dz), summed and averaged over atoms in the\n  group.  The 3rd component is the nonGaussian diffusion parameter NGP =\n  3*drfourth/(5*drsquared*drsquared), i.e.\n  \n  \\[NGP(t) = 3<(r(t)-r(0))^4>/(5<(r(t)-r(0))^2>^2) - 1\\]\n  The NGP is a commonly used quantity in studies of dynamical\n  heterogeneity.  Its minimum theoretical value (-0.4) occurs when all\n  atoms have the same displacement magnitude.  NGP=0 for Brownian\n  diffusion, while NGP > 0 when some mobile atoms move faster than\n  others.\n  If the com option is set to yes then the effect of any drift in\n  the center-of-mass of the group of atoms is subtracted out before the\n  displacement of each atom is calculated.\n  See the compute msd doc page for further important\n  NOTEs, which also apply to this compute.\n  Output info:\n  This compute calculates a global vector of length 3, which can be\n  accessed by indices 1-3 by any command that uses global vector values\n  from a compute as input.  See the Howto output doc\n  page for an overview of LAMMPS output options.\n  The vector values are “intensive”.  The first vector value will be in\n  distance^2 units, the second is in distance^4 units, and\n  the 3rd is dimensionless.\n  ",
    "syntax": "compute ID group-ID msd/nongauss keyword values ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  msd/nongauss = style name of this compute command\n  zero or more keyword/value pairs may be appended\n  keyword = com\n  com value = yes or no\n  \n  \n  ",
    "examples": "compute 1 all msd/nongauss\n  compute 1 upper msd/nongauss com yes\n  \n  \n  ",
    "restrictions": "This compute is part of the MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute omega/chunk",
    "description": "Define a computation that calculates the angular velocity (omega) of\n  multiple chunks of atoms.\n  In LAMMPS, chunks are collections of atoms defined by a compute chunk/atom command, which assigns each atom\n  to a single chunk (or no chunk).  The ID for this command is specified\n  as chunkID.  For example, a single chunk could be the atoms in a\n  molecule or atoms in a spatial bin.  See the compute chunk/atom and Howto chunk\n  doc pages for details of how chunks can be defined and examples of how\n  they can be used to measure properties of a system.\n  This compute calculates the 3 components of the angular velocity\n  vector for each chunk, via the formula L = Iw where L is the angular\n  momentum vector of the chunk, I is its moment of inertia tensor, and w\n  is omega = angular velocity of the chunk.  The calculation includes\n  all effects due to atoms passing through periodic boundaries.\n  Note that only atoms in the specified group contribute to the\n  calculation.  The compute chunk/atom command\n  defines its own group; atoms will have a chunk ID = 0 if they are not\n  in that group, signifying they are not assigned to a chunk, and will\n  thus also not contribute to this calculation.  You can specify the\n  “all” group for this command if you simply want to include atoms with\n  non-zero chunk IDs.\n  \n  Note\n  The coordinates of an atom contribute to the chunk’s angular\n  velocity in “unwrapped” form, by using the image flags associated with\n  each atom.  See the dump custom command for a discussion\n  of “unwrapped” coordinates.  See the Atoms section of the\n  read_data command for a discussion of image flags and\n  how they are set for each atom.  You can reset the image flags\n  (e.g. to 0) before invoking this compute by using the set image command.\n  \n  The simplest way to output the results of the compute omega/chunk\n  calculation to a file is to use the fix ave/time\n  command, for example:\n  compute cc1 all chunk/atom molecule\n  compute myChunk all omega/chunk cc1\n  fix 1 all ave/time 100 1 100 c_myChunk[*] file tmp.out mode vector\n  \n  \n  Output info:\n  This compute calculates a global array where the number of rows = the\n  number of chunks Nchunk as calculated by the specified compute chunk/atom command.  The number of columns =\n  3 for the 3 xyz components of the angular velocity for each chunk.\n  These values can be accessed by any command that uses global array\n  values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The array values are “intensive”.  The array values will be in\n  velocity/distance units.\n  ",
    "syntax": "compute ID group-ID omega/chunk chunkID\n  \n  \n  \n  ID, group-ID are documented in compute command\n  omega/chunk = style name of this compute command\n  chunkID = ID of compute chunk/atom command\n  \n  ",
    "examples": "compute 1 fluid omega/chunk molchunk\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute orientorder/atom",
    "description": "Define a computation that calculates a set of bond-orientational\n  order parameters \\(Q_l\\) for each atom in a group. These order parameters\n  were introduced by Steinhardt et al. as a way to\n  characterize the local orientational order in atomic structures.\n  For each atom, \\(Q_l\\) is a real number defined as follows:\n  \n  \\[\\begin{split}\\bar{Y}_{lm} = & \\frac{1}{nnn}\\sum_{j = 1}^{nnn} Y_{lm}( \\theta( {\\bf r}_{ij} ), \\phi( {\\bf r}_{ij} ) ) \\\\\n  Q_l = & \\sqrt{\\frac{4 \\pi}{2 l + 1} \\sum_{m = -l}^{m = l} \\bar{Y}_{lm} \\bar{Y}^*_{lm}}\\end{split}\\]\n  The first equation defines the spherical harmonic order parameters.\n  These are complex number components of the 3D analog of the 2D order\n  parameter \\(q_n\\), which is implemented as LAMMPS compute\n  hexorder/atom.\n  The summation is over the nnn nearest\n  neighbors of the central atom.\n  The angles theta and phi are the standard spherical polar angles\n  defining the direction of the bond vector \\(r_{ij}\\).\n  The second equation defines \\(Q_l\\), which is a\n  rotationally invariant non-negative amplitude obtained by summing\n  over all the components of degree l.\n  The optional keyword cutoff defines the distance cutoff\n  used when searching for neighbors. The default value, also\n  the maximum allowable value, is the cutoff specified\n  by the pair style.\n  The optional keyword nnn defines the number of nearest\n  neighbors used to calculate \\(Q_l\\). The default value is 12.\n  If the value is NULL, then all neighbors up to the\n  specified distance cutoff are used.\n  The optional keyword degrees defines the list of order parameters to\n  be computed.  The first argument nlvalues is the number of order\n  parameters. This is followed by that number of non-negative integers giving the\n  degree of each order parameter. Because \\(Q_2\\) and all odd-degree order\n  parameters are zero for atoms in cubic crystals (see\n  Steinhardt), the default order parameters are \\(Q_4\\),\n  \\(Q_6\\), \\(Q_8\\), \\(Q_{10}\\), and \\(Q_{12}\\). For the FCC\n  crystal with nnn =12, \\(Q_4 = \\sqrt{\\frac{7}{192}} = 0.19094...\\).\n  The numerical values of all order\n  parameters up to \\(Q_12\\) for a range of commonly encountered\n  high-symmetry structures are given in Table I of Mickel et al.,\n  and these can be reproduced with this compute.\n  The optional keyword wl will output the third-order invariants \\(W_l\\)\n  (see Eq. 1.4 in Steinhardt) for the same degrees as\n  for the \\(Q_l\\) parameters. For the FCC crystal with nnn =12,\n  \\(W_4\\) = -sqrt(14/143).(49/4096)/Pi^1.5 = -0.0006722136…\n  The optional keyword wl/hat will output the normalized third-order\n  invariants \\(\\hat{W}_l\\) (see Eq. 2.2 in Steinhardt)\n  for the same degrees as for the \\(Q_l\\) parameters. For the FCC crystal\n  with nnn =12, \\(\\hat{W}_4 = -\\frac{7}{3} \\sqrt{\\frac{2}{429}} = -0.159317...\\)\n  The numerical\n  values of \\(\\hat{W}_l\\) for a range of commonly encountered high-symmetry\n  structures are given in Table I of Steinhardt, and these\n  can be reproduced with this keyword.\n  The optional keyword components will output the components of the\n  normalized complex vector \\(\\bar{Y}_{lm}\\) of degree ldegree, which must be\n  explicitly included in the keyword degrees. This option can be used\n  in conjunction with compute coord_atom to\n  calculate the ten Wolde’s criterion to identify crystal-like\n  particles, as discussed in ten Wolde.\n  The value of \\(Q_l\\) is set to zero for atoms not in the\n  specified compute group, as well as for atoms that have less than\n  nnn neighbors within the distance cutoff, unless nnn is NULL.\n  The neighbor list needed to compute this quantity is constructed each\n  time the calculation is performed (i.e. each time a snapshot of atoms\n  is dumped).  Thus it can be inefficient to compute/dump this quantity\n  too frequently.\n  \n  Note\n  If you have a bonded system, then the settings of\n  special_bonds command can remove pairwise\n  interactions between atoms in the same bond, angle, or dihedral.  This\n  is the default setting for the special_bonds\n  command, and means those pairwise interactions do not appear in the\n  neighbor list.  Because this fix uses the neighbor list, it also means\n  those pairs will not be included in the order parameter.  This\n  difficulty can be circumvented by writing a dump file, and using the\n  rerun command to compute the order parameter for\n  snapshots in the dump file.  The rerun script can use a\n  special_bonds command that includes all pairs in\n  the neighbor list.\n  \n  Output info:\n  This compute calculates a per-atom array with nlvalues columns,\n  giving the \\(Q_l\\) values for each atom, which are real numbers on the\n  range \\(0 <= Q_l <= 1\\).\n  If the keyword wl is set to yes, then the \\(W_l\\) values for each\n  atom will be added to the output array, which are real numbers.\n  If the keyword wl/hat is set to yes, then the \\(\\hat{W}_l\\)\n  values for each atom will be added to the output array, which are real numbers.\n  If the keyword components is set, then the real and imaginary parts\n  of each component of (normalized) \\(\\bar{Y}_{lm}\\) will be added to the\n  output array in the following order: \\(Re(\\bar{Y}_{-m}) Im(\\bar{Y}_{-m})\n  Re(\\bar{Y}_{-m+1}) Im(\\bar{Y}_{-m+1}) ... Re(\\bar{Y}_m) Im(\\bar{Y}_m)\\).  This\n  way, the per-atom array will have a total of nlvalues+2*(2l+1)\n  columns.\n  These values can be accessed by any command that uses per-atom values\n  from a compute as input.  See the Howto output doc\n  page for an overview of LAMMPS output options.\n  ",
    "syntax": "compute ID group-ID orientorder/atom keyword values ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  orientorder/atom = style name of this compute command\n  one or more keyword/value pairs may be appended\n  keyword = cutoff or nnn or degrees or components\n    cutoff value = distance cutoff\n    nnn value = number of nearest neighbors\n    degrees values = nlvalues, l1, l2,...\n    wl value = yes or no\n    wl/hat value = yes or no\n    components value = ldegree\n  \n  \n  ",
    "examples": "compute 1 all orientorder/atom\n  compute 1 all orientorder/atom degrees 5 4 6 8 10 12 nnn NULL cutoff 1.5\n  compute 1 all orientorder/atom wl/hat yes\n  compute 1 all orientorder/atom components 6\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute pair",
    "description": "Define a computation that extracts additional values calculated by a\n  pair style, and makes them accessible for output or further processing\n  by other commands.\n  \n  Note\n  The group specified for this command is ignored.\n  \n  The specified pstyle must be a pair style used in your simulation\n  either by itself or as a sub-style in a pair_style hybrid or hybrid/overlay command. If the sub-style is\n  used more than once, an additional number nsub has to be specified\n  in order to choose which instance of the sub-style will be used by\n  the compute. Not specifying the number in this case will cause the\n  compute to fail.\n  The evalue setting is optional.  All\n  pair styles tally a potential energy epair which may be broken into\n  two parts: evdwl and ecoul such that epair = evdwl + ecoul.\n  If the pair style calculates Coulombic interactions, their energy will\n  be tallied in ecoul.  Everything else (whether it is a Lennard-Jones\n  style van der Waals interaction or not) is tallied in evdwl.  If\n  evalue is blank or specified as epair, then epair is stored\n  as a global scalar by this compute.  This is useful when using\n  pair_style hybrid if you want to know the portion\n  of the total energy contributed by one sub-style.  If evalue is\n  specified as evdwl or ecoul, then just that portion of the energy\n  is stored as a global scalar.\n  \n  Note\n  The energy returned by the evdwl keyword does not include tail\n  corrections, even if they are enabled via the\n  pair_modify command.\n  \n  Some pair styles tally additional quantities, e.g. a breakdown of\n  potential energy into 14 components is tallied by the pair_style reax/c command.  These values (1 or more)\n  are stored as a global vector by this compute.  See the doc page for\n  individual pair styles for info on these values.\n  Output info:\n  This compute calculates a global scalar which is epair or evdwl or\n  ecoul.  If the pair style supports it, it also calculates a global\n  vector of length >= 1, as determined by the pair style.  These values\n  can be used by any command that uses global scalar or vector values\n  from a compute as input.  See the Howto output doc\n  page for an overview of LAMMPS output options.\n  The scalar and vector values calculated by this compute are\n  “extensive”.\n  The scalar value will be in energy units.  The vector\n  values will typically also be in energy units, but see\n  the doc page for the pair style for details.\n  ",
    "syntax": "compute ID group-ID pair pstyle [nstyle] [evalue]\n  \n  \n  \n  ID, group-ID are documented in compute command\n  pair = style name of this compute command\n  pstyle = style name of a pair style that calculates additional values\n  nsub = n-instance of a sub-style, if a pair style is used multiple times in a hybrid style\n  evalue = epair or evdwl or ecoul or blank (optional)\n  \n  ",
    "examples": "compute 1 all pair gauss\n  compute 1 all pair lj/cut/coul/cut ecoul\n  compute 1 all pair tersoff 2 epair\n  compute 1 all pair reax/c\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute pair/local",
    "description": "Define a computation that calculates properties of individual pairwise\n  interactions.  The number of datums generated, aggregated across all\n  processors, equals the number of pairwise interactions in the system.\n  The local data stored by this command is generated by looping over the\n  pairwise neighbor list.  Info about an individual pairwise interaction\n  will only be included if both atoms in the pair are in the specified\n  compute group, and if the current pairwise distance is less than the\n  force cutoff distance for that interaction, as defined by the\n  pair_style and pair_coeff\n  commands.\n  The value dist is the distance between the pair of atoms.\n  The value eng is the interaction energy for the pair of atoms.\n  The value force is the force acting between the pair of atoms, which\n  is positive for a repulsive force and negative for an attractive\n  force.  The values fx, fy, and fz are the xyz components of\n  force on atom I.\n  A pair style may define additional pairwise quantities which can be\n  accessed as p1 to pN, where N is defined by the pair style.  Most\n  pair styles do not define any additional quantities, so N = 0.  An\n  example of ones that do are the granular pair styles\n  which calculate the tangential force between two particles and return\n  its components and magnitude acting on atom I for N = 1,2,3,4.  See\n  individual pair styles for details.\n  When using pN with pair style hybrid, the output will be the Nth\n  quantity from the sub-style that computes the pairwise interaction\n  (based on atom types).  If that sub-style does not define a pN,\n  the output will be 0.0.  The maximum allowed N is the maximum number\n  of quantities provided by any sub-style.\n  When using pN with pair style hybrid/overlay the quantities\n  from all sub-styles that provide them are concatenated together\n  into one long list. For example, if there are 3 sub-styles and\n  2 of them have additional output (with 3 and 4 quantities,\n  respectively), then 7 values (p1 up to p7) are defined.\n  The values p1 to p3 refer to quantities defined by the first\n  of the two sub-styles.  Values p4 to p7 refer to quantities\n  from the second of the two sub-styles.  If the referenced pN\n  is not computed for the specific pairwise interaction (based on\n  atom types), then the output will be 0.0.\n  The value dist will be in distance units.  The value\n  eng will be in energy units.  The values force, fx,\n  fy, and fz will be in force units.  The values pN\n  will be in whatever units the pair style defines.\n  The optional cutoff keyword determines how the force cutoff distance\n  for an interaction is determined.  For the default setting of type,\n  the pairwise cutoff defined by the pair_style\n  command for the types of the two atoms is used.  For the radius\n  setting, the sum of the radii of the two particles is used as a\n  cutoff.  For example, this is appropriate for granular particles which\n  only interact when they are overlapping, as computed by granular pair styles.  Note that if a granular model defines atom\n  types such that all particles of a specific type are monodisperse\n  (same diameter), then the two settings are effectively identical.\n  Note that as atoms migrate from processor to processor, there will be\n  no consistent ordering of the entries within the local vector or array\n  from one timestep to the next.  The only consistency that is\n  guaranteed is that the ordering on a particular timestep will be the\n  same for local vectors or arrays generated by other compute commands.\n  For example, pair output from the compute property/local command can be combined\n  with data from this command and output by the dump local\n  command in a consistent way.\n  Here is an example of how to do this:\n  compute 1 all property/local patom1 patom2\n  compute 2 all pair/local dist eng force\n  dump 1 all local 1000 tmp.dump index c_1[1] c_1[2] c_2[1] c_2[2] c_2[3]\n  \n  \n  \n  Note\n  For pairs, if two atoms I,J are involved in 1-2, 1-3, 1-4\n  interactions within the molecular topology, their pairwise interaction\n  may be turned off, and thus they may not appear in the neighbor list,\n  and will not be part of the local data created by this command.  More\n  specifically, this will be true of I,J pairs with a weighting factor\n  of 0.0; pairs with a non-zero weighting factor are included.  The\n  weighting factors for 1-2, 1-3, and 1-4 pairwise interactions are set\n  by the special_bonds command.  An exception is if\n  long-range Coulombics are being computed via the\n  kspace_style command, then atom pairs with\n  weighting factors of zero are still included in the neighbor list, so\n  that a portion of the long-range interaction contribution can be\n  computed in the pair style.  Hence in that case, those atom pairs will\n  be part of the local data created by this command.\n  \n  Output info:\n  This compute calculates a local vector or local array depending on the\n  number of keywords.  The length of the vector or number of rows in the\n  array is the number of pairs.  If a single keyword is specified, a\n  local vector is produced.  If two or more keywords are specified, a\n  local array is produced where the number of columns = the number of\n  keywords.  The vector or array can be accessed by any command that\n  uses local values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The output for dist will be in distance units.  The\n  output for eng will be in energy units.  The output for\n  force, fx, fy, and fz will be in force units.\n  The output for pN will be in whatever units the pair style defines.\n  ",
    "syntax": "compute ID group-ID pair/local value1 value2 ... keyword args ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  pair/local = style name of this compute command\n  one or more values may be appended\n  value = dist or eng or force or fx or fy or fz or pN\n  dist = pairwise distance\n  eng = pairwise energy\n  force = pairwise force\n  fx,fy,fz = components of pairwise force\n  pN = pair style specific quantities for allowed N values\n  \n  zero or more keyword/arg pairs may be appended\n  keyword = cutoff\n  cutoff arg = type or radius\n  \n  \n  ",
    "examples": "compute 1 all pair/local eng\n  compute 1 all pair/local dist eng force\n  compute 1 all pair/local dist eng fx fy fz\n  compute 1 all pair/local dist fx fy fz p1 p2 p3\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute pe",
    "description": "Define a computation that calculates the potential energy of the\n  entire system of atoms.  The specified group must be “all”.  See the\n  compute pe/atom command if you want per-atom\n  energies.  These per-atom values could be summed for a group of atoms\n  via the compute reduce command.\n  The energy is calculated by the various pair, bond, etc potentials\n  defined for the simulation.  If no extra keywords are listed, then the\n  potential energy is the sum of pair, bond, angle, dihedral, improper,\n  kspace (long-range), and fix energy.  I.e. it is as if all the\n  keywords were listed.  If any extra keywords are listed, then only\n  those components are summed to compute the potential energy.\n  The Kspace contribution requires 1 extra FFT each timestep the energy\n  is calculated, if using the PPPM solver via the kspace_style pppm command.  Thus it can increase the cost of the\n  PPPM calculation if it is needed on a large fraction of the simulation\n  timesteps.\n  Various fixes can contribute to the total potential energy of the\n  system if the fix contribution is included.  See the doc pages for\n  individual fixes for details of which ones compute a\n  potential energy.\n  \n  Note\n  The fix_modify energy yes command must also be\n  specified if a fix is to contribute potential energy to this command.\n  \n  A compute of this style with the ID of “thermo_pe” is created when\n  LAMMPS starts up, as if this command were in the input script:\n  compute thermo_pe all pe\n  \n  \n  See the “thermo_style” command for more details.\n  \n  Output info:\n  This compute calculates a global scalar (the potential energy).  This\n  value can be used by any command that uses a global scalar value from\n  a compute as input.  See the Howto output doc page\n  for an overview of LAMMPS output options.\n  The scalar value calculated by this compute is “extensive”.  The\n  scalar value will be in energy units.\n  ",
    "syntax": "compute ID group-ID pe keyword ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  pe = style name of this compute command\n  zero or more keywords may be appended\n  keyword = pair or bond or angle or dihedral or improper or kspace or fix\n  \n  ",
    "examples": "compute 1 all pe\n  compute molPE all pe bond angle dihedral improper\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute pe/atom",
    "description": "Define a computation that computes the per-atom potential energy for\n  each atom in a group.  See the compute pe command if\n  you want the potential energy of the entire system.\n  The per-atom energy is calculated by the various pair, bond, etc\n  potentials defined for the simulation.  If no extra keywords are\n  listed, then the potential energy is the sum of pair, bond, angle,\n  dihedral,improper, kspace (long-range), and fix energy.  I.e. it is as\n  if all the keywords were listed.  If any extra keywords are listed,\n  then only those components are summed to compute the potential energy.\n  Note that the energy of each atom is due to its interaction with all\n  other atoms in the simulation, not just with other atoms in the group.\n  For an energy contribution produced by a small set of atoms (e.g. 4\n  atoms in a dihedral or 3 atoms in a Tersoff 3-body interaction), that\n  energy is assigned in equal portions to each atom in the set.\n  E.g. 1/4 of the dihedral energy to each of the 4 atoms.\n  The dihedral_style charmm style calculates\n  pairwise interactions between 1-4 atoms.  The energy contribution of\n  these terms is included in the pair energy, not the dihedral energy.\n  The KSpace contribution is calculated using the method in\n  (Heyes) for the Ewald method and a related method for PPPM,\n  as specified by the kspace_style pppm command.\n  For PPPM, the calculation requires 1 extra FFT each timestep that\n  per-atom energy is calculated.  This document\n  describes how the long-range per-atom energy calculation is performed.\n  Various fixes can contribute to the per-atom potential energy of the\n  system if the fix contribution is included.  See the doc pages for\n  individual fixes for details of which ones compute a\n  per-atom potential energy.\n  \n  Note\n  The fix_modify energy yes command must also be\n  specified if a fix is to contribute per-atom potential energy to this\n  command.\n  \n  As an example of per-atom potential energy compared to total potential\n  energy, these lines in an input script should yield the same result\n  in the last 2 columns of thermo output:\n  compute        peratom all pe/atom\n  compute        pe all reduce sum c_peratom\n  thermo_style   custom step temp etotal press pe c_pe\n  \n  \n  \n  Note\n  The per-atom energy does not include any Lennard-Jones tail\n  corrections to the energy added by the pair_modify tail yes command, since those are contributions to the\n  global system energy.\n  \n  Output info:\n  This compute calculates a per-atom vector, which can be accessed by\n  any command that uses per-atom values from a compute as input.  See\n  the Howto output doc page for an overview of\n  LAMMPS output options.\n  The per-atom vector values will be in energy units.\n  ",
    "syntax": "compute ID group-ID pe/atom keyword ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  pe/atom = style name of this compute command\n  zero or more keywords may be appended\n  keyword = pair or bond or angle or dihedral or improper or kspace or fix\n  \n  ",
    "examples": "compute 1 all pe/atom\n  compute 1 all pe/atom pair\n  compute 1 all pe/atom pair bond\n  \n  \n  ",
    "restrictions": ""
},
{
    "command": "compute plasticity/atom",
    "description": "Define a computation that calculates the per-atom plasticity for each\n  atom in a group.  This is a quantity relevant for Peridynamics models.  See this document\n  for an overview of LAMMPS commands for Peridynamics modeling.\n  The plasticity for a Peridynamic particle is the so-called consistency\n  parameter (lambda).  For elastic deformation lambda = 0, otherwise\n  lambda > 0 for plastic deformation.  For details, see\n  (Mitchell) and the PDF doc included in the LAMMPS\n  distribution in doc/PDF/PDLammps_EPS.pdf.\n  This command can be invoked for one of the Peridynamic pair styles: peri/eps.\n  The plasticity value will be 0.0 for atoms not in the specified\n  compute group.\n  Output info:\n  This compute calculates a per-atom vector, which can be accessed by\n  any command that uses per-atom values from a compute as input.  See\n  the Howto output doc page for an overview of\n  LAMMPS output options.\n  The per-atom vector values are unitless numbers (lambda) >= 0.0.\n  ",
    "syntax": "compute ID group-ID plasticity/atom\n  \n  \n  \n  ID, group-ID are documented in compute command\n  plasticity/atom = style name of this compute command\n  \n  ",
    "examples": "compute 1 all plasticity/atom\n  \n  \n  ",
    "restrictions": "This compute is part of the PERI package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute pressure",
    "description": "Define a computation that calculates the pressure of the entire system\n  of atoms.  The specified group must be “all”.  See the compute stress/atom command if you want per-atom\n  pressure (stress).  These per-atom values could be summed for a group\n  of atoms via the compute reduce command.\n  The pressure is computed by the formula\n  \n  \\[P = \\frac{N k_B T}{V} + \\frac{\\sum_{i}^{N'} r_i \\bullet f_i}{dV}\\]\n  where N is the number of atoms in the system (see discussion of DOF\n  below), \\(k_B\\) is the Boltzmann constant, T is the temperature, d\n  is the dimensionality of the system (2 or 3 for 2d/3d), and V is the\n  system volume (or area in 2d).  The second term is the virial, equal to\n  -dU/dV, computed for all pairwise as well as 2-body, 3-body, 4-body,\n  many-body, and long-range interactions, where \\(r_i\\) and\n  \\(f_i\\) are the position and force vector of atom i, and the black\n  dot indicates a dot product.  When periodic boundary conditions are\n  used, N’ necessarily includes periodic image (ghost) atoms outside the\n  central box, and the position and force vectors of ghost atoms are thus\n  included in the summation.  When periodic boundary conditions are not\n  used, N’ = N = the number of atoms in the system.  Fixes\n  that impose constraints (e.g. the fix shake command)\n  also contribute to the virial term.\n  A symmetric pressure tensor, stored as a 6-element vector, is also\n  calculated by this compute.  The 6 components of the vector are\n  ordered xx, yy, zz, xy, xz, yz.  The equation for the I,J components\n  (where I and J = x,y,z) is similar to the above formula, except that\n  the first term uses components of the kinetic energy tensor and the\n  second term uses components of the virial tensor:\n  \n  \\[P_{IJ} = \\frac{\\sum_{k}^{N} m_k v_{k_I} v_{k_J}}{V} +\n  \\frac{\\sum_{k}^{N'} r_{k_I} f_{k_J}}{V}\\]\n  If no extra keywords are listed, the entire equations above are\n  calculated.  This includes a kinetic energy (temperature) term and the\n  virial as the sum of pair, bond, angle, dihedral, improper, kspace\n  (long-range), and fix contributions to the force on each atom.  If any\n  extra keywords are listed, then only those components are summed to\n  compute temperature or ke and/or the virial.  The virial keyword\n  means include all terms except the kinetic energy ke.\n  The pair/hybrid keyword means to only include contribution\n  from a sub-style in a hybrid or hybrid/overlay pair style.\n  Details of how LAMMPS computes the virial efficiently for the entire\n  system, including for many-body potentials and accounting for the\n  effects of periodic boundary conditions are discussed in\n  (Thompson).\n  The temperature and kinetic energy tensor is not calculated by this\n  compute, but rather by the temperature compute specified with the\n  command.  If the kinetic energy is not included in the pressure, than\n  the temperature compute is not used and can be specified as NULL.\n  Normally the temperature compute used by compute pressure should\n  calculate the temperature of all atoms for consistency with the virial\n  term, but any compute style that calculates temperature can be used,\n  e.g. one that excludes frozen atoms or other degrees of freedom.\n  Note that if desired the specified temperature compute can be one that\n  subtracts off a bias to calculate a temperature using only the thermal\n  velocity of the atoms, e.g. by subtracting a background streaming\n  velocity.  See the doc pages for individual compute commands to determine which ones include a bias.\n  Also note that the N in the first formula above is really\n  degrees-of-freedom divided by d = dimensionality, where the DOF value\n  is calculated by the temperature compute.  See the various compute temperature styles for details.\n  A compute of this style with the ID of “thermo_press” is created when\n  LAMMPS starts up, as if this command were in the input script:\n  compute thermo_press all pressure thermo_temp\n  \n  \n  where “thermo_temp” is the ID of a similarly defined compute of style\n  “temp”.  See the “thermo_style” command for more details.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Output info:\n  This compute calculates a global scalar (the pressure) and a global\n  vector of length 6 (pressure tensor), which can be accessed by indices\n  1-6.  These values can be used by any command that uses global scalar\n  or vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The scalar and vector values calculated by this compute are\n  “intensive”.  The scalar and vector values will be in pressure\n  units.\n  ",
    "syntax": "compute ID group-ID pressure temp-ID keyword ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  pressure = style name of this compute command\n  temp-ID = ID of compute that calculates temperature, can be NULL if not needed\n  zero or more keywords may be appended\n  keyword = ke or pair or bond or angle or dihedral or improper or kspace or fix or virial or pair/hybrid\n  \n  ",
    "examples": "compute 1 all pressure thermo_temp\n  compute 1 all pressure NULL pair bond\n  compute 1 all pressure NULL pair/hybrid lj/cut\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute pressure/cylinder",
    "description": "Define a computation that calculates the pressure tensor of a system in\n  cylindrical coordinates, as discussed in (Addington).\n  This is useful for systems with a single axis of rotational symmetry,\n  such as cylindrical micelles or carbon nanotubes. The compute splits the\n  system into radial, cylindrical-shell-type bins of width bin_width,\n  centered at x=0,y=0, and calculates the radial (P_rhorho), azimuthal\n  (P_phiphi), and axial (P_zz) components of the configurational pressure\n  tensor. The local density is also calculated for each bin, so that the\n  true pressure can be recovered as P_kin+P_conf=density*k*T+P_conf.  The\n  output is a global array with 5 columns; one each for bin radius, local\n  number density, P_rhorho, P_phiphi, and P_zz. The number of rows is\n  governed by the values of Rmax and bin_width. Pressure tensor values are\n  output in pressure units.\n  Output info:\n  This compute calculates a global array with 5 columns and Rmax/bin_width\n  rows. The output columns are: R (distance units), number density (inverse\n  volume units), configurational radial pressure (pressure units),\n  configurational azimuthal pressure (pressure units), and configurational\n  axial pressure (pressure units).\n  The values calculated by this compute are\n  “intensive”.  The pressure values will be in pressure\n  units. The number density values will be in\n  inverse volume units.\n  ",
    "syntax": "compute ID group-ID pressure/cylinder zlo zhi Rmax bin_width\n  \n  \n  \n  ID, group-ID are documented in compute command\n  pressure/cylinder = style name of this compute command\n  zlo = minimum z-boundary for cylinder\n  zhi = maximum z-boundary for cylinder\n  Rmax = maximum radius to perform calculation to\n  bin_width = width of radial bins to use for calculation\n  \n  ",
    "examples": "compute 1 all pressure/cylinder -10.0 10.0 15.0 0.25\n  \n  \n  ",
    "restrictions": "This compute currently calculates the pressure tensor contributions\n  for pair styles only (i.e. no bond, angle, dihedral, etc. contributions\n  and in the presence of bonded interactions, the result will be incorrect\n  due to exclusions for special bonds)  and requires pair-wise force\n  calculations not available for most many-body pair styles. K-space\n  calculations are also excluded. Note that this pressure compute outputs\n  the configurational terms only; the kinetic contribution is not included\n  and may be calculated from the number density output by P_kin=density*k*T.\n  This compute is part of the USER-MISC package.  It is only enabled\n  if LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute pressure/uef",
    "description": "This command is used to compute the pressure tensor in\n  the reference frame of the applied flow field when\n  fix nvt/uef or\n  fix npt/uef is used.\n  It is not necessary to use this command to compute the scalar\n  value of the pressure. A compute pressure\n  may be used for that purpose.\n  The keywords and output information are documented in\n  compute_pressure.\n  ",
    "syntax": "compute ID group-ID pressure/uef temp-ID keyword ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  pressure/uef = style name of this compute command\n  temp-ID = ID of compute that calculates temperature, can be NULL if not needed\n  zero or more keywords may be appended\n  keyword = ke or pair or bond or angle or dihedral or improper or kspace or fix or virial\n  \n  ",
    "examples": "compute 1 all pressure/uef my_temp_uef\n  compute 2 all pressure/uef my_temp_uef virial\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-UEF package. It is only enabled if LAMMPS\n  was built with that package. See the Build package doc page for more info.\n  This command can only be used when fix nvt/uef\n  or fix npt/uef is active.\n  The kinetic contribution to the pressure tensor\n  will be accurate only when\n  the compute specified by temp-ID is a\n  compute temp/uef.\n  "
},
{
    "command": "compute property/atom",
    "description": "Define a computation that simply stores atom attributes for each atom\n  in the group.  This is useful so that the values can be used by other\n  output commands that take computes as inputs.  See\n  for example, the compute reduce, fix ave/atom, fix ave/histo, fix ave/chunk, and atom-style variable\n  commands.\n  The list of possible attributes is the same as that used by the dump custom command, which describes their meaning, with some\n  additional quantities that are only defined for certain atom styles.  Basically, this augmented list gives an\n  input script access to any per-atom quantity stored by LAMMPS.\n  The values are stored in a per-atom vector or array as discussed\n  below.  Zeroes are stored for atoms not in the specified group or for\n  quantities that are not defined for a particular particle in the group\n  (e.g. shapex if the particle is not an ellipsoid).\n  The additional quantities only accessible via this command, and not\n  directly via the dump custom command, are as follows.\n  Shapex, shapey, and shapez are defined for ellipsoidal particles\n  and define the 3d shape of each particle.\n  Quatw, quati, quatj, and quatk are defined for ellipsoidal\n  particles and body particles and store the 4-vector quaternion\n  representing the orientation of each particle.  See the set\n  command for an explanation of the quaternion vector.\n  End1x, end1y, end1z, end2x, end2y, end2z, are defined for\n  line segment particles and define the end points of each line segment.\n  Corner1x, corner1y, corner1z, corner2x, corner2y,\n  corner2z, corner3x, corner3y, corner3z, are defined for\n  triangular particles and define the corner points of each triangle.\n  Nbonds is available for all molecular atom styles and refers to the\n  number of explicit bonds assigned to an atom.  Note that if the\n  newton bond command is set to on, which is the\n  default, then every bond in the system is assigned to only one of the\n  two atoms in the bond.  Thus a bond between atoms I,J may be tallied\n  for either atom I or atom J.  If newton bond off is set,\n  it will be tallied with both atom I and atom J.\n  The i_name and d_name attributes refer to custom integer and\n  floating-point properties that have been added to each atom via the\n  fix property/atom command.  When that command\n  is used specific names are given to each attribute which are what is\n  specified as the “name” portion of i_name or d_name.\n  Output info:\n  This compute calculates a per-atom vector or per-atom array depending\n  on the number of input values.  If a single input is specified, a\n  per-atom vector is produced.  If two or more inputs are specified, a\n  per-atom array is produced where the number of columns = the number of\n  inputs.  The vector or array can be accessed by any command that uses\n  per-atom values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The vector or array values will be in whatever units the\n  corresponding attribute is in, e.g. velocity units for vx, charge\n  units for q, etc.\n  For the spin quantities, sp is in the units of the Bohr magneton, spx,\n  spy, and spz are unitless quantities, and fmx, fmy and fmz are given\n  in rad/THz.\n  ",
    "syntax": "compute ID group-ID property/atom input1 input2 ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  property/atom = style name of this compute command\n  input = one or more atom attributes\n  possible attributes = id, mol, proc, type, mass,\n                        x, y, z, xs, ys, zs, xu, yu, zu, ix, iy, iz,\n                        vx, vy, vz, fx, fy, fz,\n                        q, mux, muy, muz, mu,\n                        sp, spx, spy, spz, fmx, fmy, fmz,\n                        radius, diameter, omegax, omegay, omegaz,\n                        angmomx, angmomy, angmomz,\n                        shapex,shapey, shapez,\n                        quatw, quati, quatj, quatk, tqx, tqy, tqz,\n                        end1x, end1y, end1z, end2x, end2y, end2z,\n                        corner1x, corner1y, corner1z,\n                        corner2x, corner2y, corner2z,\n                        corner3x, corner3y, corner3z,\n                        nbonds,\n                        vfrac, s0,\n                        spin, eradius, ervel, erforce,\n                        rho, drho, e, de, cv,\n                        i_name, d_name\n  \n  \n  id = atom ID\n  mol = molecule ID\n  proc = ID of processor that owns atom\n  type = atom type\n  mass = atom mass\n  x,y,z = unscaled atom coordinates\n  xs,ys,zs = scaled atom coordinates\n  xu,yu,zu = unwrapped atom coordinates\n  ix,iy,iz = box image that the atom is in\n  vx,vy,vz = atom velocities\n  fx,fy,fz = forces on atoms\n  q = atom charge\n  mux,muy,muz = orientation of dipole moment of atom\n  mu = magnitude of dipole moment of atom\n  sp = atomic magnetic spin moment\n  spx, spy, spz = direction of the atomic magnetic spin\n  fmx, fmy, fmz = magnetic force\n  radius,diameter = radius,diameter of spherical particle\n  omegax,omegay,omegaz = angular velocity of spherical particle\n  angmomx,angmomy,angmomz = angular momentum of aspherical particle\n  shapex,shapey,shapez = 3 diameters of aspherical particle\n  quatw,quati,quatj,quatk = quaternion components for aspherical or body particles\n  tqx,tqy,tqz = torque on finite-size particles\n  end12x, end12y, end12z = end points of line segment\n  corner123x, corner123y, corner123z = corner points of triangle\n  nbonds = number of bonds assigned to an atom\n  \n  \n  PERI package per-atom properties:\n  vfrac = ???\n  s0 = ???\n  \n  \n  USER-EFF and USER-AWPMD package per-atom properties:\n  spin = electron spin\n  eradius = electron radius\n  ervel = electron radial velocity\n  erforce = electron radial force\n  \n  \n  USER-SPH package per-atom properties:\n  rho = ???\n  drho = ???\n  e = ???\n  de = ???\n  cv = ???\n  \n  \n  fix property/atom per-atom properties:\n  i_name = custom integer vector with name\n  d_name = custom integer vector with name\n  \n  \n  ",
    "examples": "compute 1 all property/atom xs vx fx mux\n  compute 2 all property/atom type\n  compute 1 all property/atom ix iy iz\n  compute 3 all property/atom sp spx spy spz\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute property/chunk",
    "description": "Define a computation that stores the specified attributes of chunks of\n  atoms.\n  In LAMMPS, chunks are collections of atoms defined by a compute chunk/atom command, which assigns each atom\n  to a single chunk (or no chunk).  The ID for this command is specified\n  as chunkID.  For example, a single chunk could be the atoms in a\n  molecule or atoms in a spatial bin.  See the compute chunk/atom and Howto chunk\n  doc pages for details of how chunks can be defined and examples of how\n  they can be used to measure properties of a system.\n  This compute calculates and stores the specified attributes of chunks\n  as global data so they can be accessed by other output commands and used in conjunction with other\n  commands that generate per-chunk data, such as compute com/chunk or compute msd/chunk.\n  Note that only atoms in the specified group contribute to the\n  calculation of the count attribute.  The compute chunk/atom command defines its own group;\n  atoms will have a chunk ID = 0 if they are not in that group,\n  signifying they are not assigned to a chunk, and will thus also not\n  contribute to this calculation.  You can specify the “all” group for\n  this command if you simply want to include atoms with non-zero chunk\n  IDs.\n  The count attribute is the number of atoms in the chunk.\n  The id attribute stores the original chunk ID for each chunk.  It\n  can only be used if the compress keyword was set to yes for the\n  compute chunk/atom command referenced by\n  chunkID.  This means that the original chunk IDs (e.g. molecule IDs)\n  will have been compressed to remove chunk IDs with no atoms assigned\n  to them.  Thus a compressed chunk ID of 3 may correspond to an original\n  chunk ID (molecule ID in this case) of 415.  The id attribute will\n  then be 415 for the 3rd chunk.\n  The coordN attributes can only be used if a binning style was used\n  in the compute chunk/atom command referenced\n  by chunkID.  For bin/1d, bin/2d, and bin/3d styles the attribute\n  is the center point of the bin in the corresponding dimension.  Style\n  bin/1d only defines a coord1 attribute.  Style bin/2d adds a\n  coord2 attribute.  Style bin/3d adds a coord3 attribute.\n  Note that if the value of the units keyword used in the compute chunk/atom command is box or lattice, the\n  coordN attributes will be in distance units.  If the\n  value of the units keyword is reduced, the coordN attributes\n  will be in unitless reduced units (0-1).\n  The simplest way to output the results of the compute property/chunk\n  calculation to a file is to use the fix ave/time\n  command, for example:\n  compute cc1 all chunk/atom molecule\n  compute myChunk1 all property/chunk cc1 count\n  compute myChunk2 all com/chunk cc1\n  fix 1 all ave/time 100 1 100 c_myChunk1 c_myChunk2[*] file tmp.out mode vector\n  \n  \n  Output info:\n  This compute calculates a global vector or global array depending on\n  the number of input values.  The length of the vector or number of\n  rows in the array is the number of chunks.\n  This compute calculates a global vector or global array where the\n  number of rows = the number of chunks Nchunk as calculated by the\n  specified compute chunk/atom command.  If a\n  single input is specified, a global vector is produced.  If two or\n  more inputs are specified, a global array is produced where the number\n  of columns = the number of inputs.  The vector or array can be\n  accessed by any command that uses global values from a compute as\n  input.  See the Howto output doc page for an\n  overview of LAMMPS output options.\n  The vector or array values are “intensive”.  The values will be\n  unitless or in the units discussed above.\n  ",
    "syntax": "compute ID group-ID property/chunk chunkID input1 input2 ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  property/chunk = style name of this compute command\n  input = one or more attributes\n  attributes = count, id, coord1, coord2, coord3\n    count = # of atoms in chunk\n    id = original chunk IDs before compression by compute chunk/atom\n    coord123 = coordinates for spatial bins calculated by compute chunk/atom\n  \n  \n  ",
    "examples": "compute 1 all property/chunk count\n  compute 1 all property/chunk ID coord1\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute property/local",
    "description": "Define a computation that stores the specified attributes as local\n  data so it can be accessed by other output commands.  If the input attributes refer to bond\n  information, then the number of datums generated, aggregated across\n  all processors, equals the number of bonds in the system.  Ditto for\n  pairs, angles, etc.\n  If multiple attributes are specified then they must all generate the\n  same amount of information, so that the resulting local array has the\n  same number of rows for each column.  This means that only bond\n  attributes can be specified together, or angle attributes, etc.  Bond\n  and angle attributes can not be mixed in the same compute\n  property/local command.\n  If the inputs are pair attributes, the local data is generated by\n  looping over the pairwise neighbor list.  Info about an individual\n  pairwise interaction will only be included if both atoms in the pair\n  are in the specified compute group.  For natom1 and natom2, all\n  atom pairs in the neighbor list are considered (out to the neighbor\n  cutoff = force cutoff + neighbor skin).  For patom1\n  and patom2, the distance between the atoms must be less than the\n  force cutoff distance for that pair to be included, as defined by the\n  pair_style and pair_coeff\n  commands.\n  The optional cutoff keyword determines how the force cutoff distance\n  for an interaction is determined for the patom1 and patom2\n  attributes.  For the default setting of type, the pairwise cutoff\n  defined by the pair_style command for the types of\n  the two atoms is used.  For the radius setting, the sum of the radii\n  of the two particles is used as a cutoff.  For example, this is\n  appropriate for granular particles which only interact when they are\n  overlapping, as computed by granular pair styles.\n  Note that if a granular model defines atom types such that all\n  particles of a specific type are monodisperse (same diameter), then\n  the two settings are effectively identical.\n  If the inputs are bond, angle, etc attributes, the local data is\n  generated by looping over all the atoms owned on a processor and\n  extracting bond, angle, etc info.  For bonds, info about an individual\n  bond will only be included if both atoms in the bond are in the\n  specified compute group.  Likewise for angles, dihedrals, etc.\n  For bonds and angles, a bonds/angles that have been broken by setting\n  their bond/angle type to 0 will not be included.  Bonds/angles that\n  have been turned off (see the fix shake or\n  delete_bonds commands) by setting their bond/angle\n  type negative are written into the file.  This is consistent with the\n  compute bond/local and compute angle/local commands\n  Note that as atoms migrate from processor to processor, there will be\n  no consistent ordering of the entries within the local vector or array\n  from one timestep to the next.  The only consistency that is\n  guaranteed is that the ordering on a particular timestep will be the\n  same for local vectors or arrays generated by other compute commands.\n  For example, output from the compute bond/local command can be combined with bond\n  atom indices from this command and output by the dump local command in a consistent way.\n  The natom1 and natom2, or patom1 and patom2 attributes refer\n  to the atom IDs of the 2 atoms in each pairwise interaction computed\n  by the pair_style command.  The ntype1 and\n  ntype2, or ptype1 and ptype2 attributes refer to the atom types\n  of the 2 atoms in each pairwise interaction.\n  \n  Note\n  For pairs, if two atoms I,J are involved in 1-2, 1-3, 1-4\n  interactions within the molecular topology, their pairwise interaction\n  may be turned off, and thus they may not appear in the neighbor list,\n  and will not be part of the local data created by this command.  More\n  specifically, this may be true of I,J pairs with a weighting factor of\n  0.0; pairs with a non-zero weighting factor are included.  The\n  weighting factors for 1-2, 1-3, and 1-4 pairwise interactions are set\n  by the special_bonds command.\n  \n  The batom1 and batom2 attributes refer to the atom IDs of the 2\n  atoms in each bond.  The btype attribute refers to\n  the type of the bond, from 1 to Nbtypes = # of bond types.  The number\n  of bond types is defined in the data file read by the\n  read_data command.\n  The attributes that start with “a”, “d”, “i”, refer to similar values\n  for angles, dihedrals, and\n  impropers.\n  Output info:\n  This compute calculates a local vector or local array depending on the\n  number of input values.  The length of the vector or number of rows in\n  the array is the number of bonds, angles, etc.  If a single input is\n  specified, a local vector is produced.  If two or more inputs are\n  specified, a local array is produced where the number of columns = the\n  number of inputs.  The vector or array can be accessed by any command\n  that uses local values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The vector or array values will be integers that correspond to the\n  specified attribute.\n  ",
    "syntax": "compute ID group-ID property/local attribute1 attribute2 ... keyword args ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  property/local = style name of this compute command\n  one or more attributes may be appended\n  possible attributes = natom1 natom2 ntype1 ntype2\n                        patom1 patom2 ptype1 ptype2\n                        batom1 batom2 btype\n                        aatom1 aatom2 aatom3 atype\n                        datom1 datom2 datom3 datom4 dtype\n                        iatom1 iatom2 iatom3 iatom4 itype\n  \n  \n  natom1, natom2 = IDs of 2 atoms in each pair (within neighbor cutoff)\n  ntype1, ntype2 = type of 2 atoms in each pair (within neighbor cutoff)\n  patom1, patom2 = IDs of 2 atoms in each pair (within force cutoff)\n  ptype1, ptype2 = type of 2 atoms in each pair (within force cutoff)\n  batom1, batom2 = IDs of 2 atoms in each bond\n  btype = bond type of each bond\n  aatom1, aatom2, aatom3 = IDs of 3 atoms in each angle\n  atype = angle type of each angle\n  datom1, datom2, datom3, datom4 = IDs of 4 atoms in each dihedral\n  dtype = dihedral type of each dihedral\n  iatom1, iatom2, iatom3, iatom4 = IDs of 4 atoms in each improper\n  itype = improper type of each improper\n  \n  \n  \n  zero or more keyword/arg pairs may be appended\n  keyword = cutoff\n  cutoff arg = type or radius\n  \n  \n  ",
    "examples": "compute 1 all property/local btype batom1 batom2\n  compute 1 all property/local atype aatom2\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute ptm/atom",
    "description": "Define a computation that determines the local lattice structure\n  around an atom using the PTM (Polyhedral Template Matching) method.\n  The PTM method is described in (Larsen).\n  Currently, there are seven lattice structures PTM recognizes:\n  \n  fcc = 1\n  hcp = 2\n  bcc = 3\n  ico (icosahedral) = 4\n  sc (simple cubic) = 5\n  dcub (diamond cubic) = 6\n  dhex (diamond hexagonal) = 7\n  graphene = 8\n  \n  The value of the PTM structure will be 0 for unknown types and -1 for atoms not in the specified\n  compute group.  The choice of structures to search for can be specified using the “structures”\n  argument, which is a hyphen-separated list of structure keywords.\n  Two convenient pre-set options are provided:\n  \n  default: fcc-hcp-bcc-ico\n  all: fcc-hcp-bcc-ico-sc-dcub-dhex-graphene\n  \n  The ‘default’ setting detects the same structures as the Common Neighbor Analysis method.\n  The ‘all’ setting searches for all structure types.  A performance penalty is\n  incurred for the diamond and graphene structures, so it is not recommended to use this option if\n  it is known that the simulation does not contain these structures.\n  PTM identifies structures using two steps.  First, a graph isomorphism test is used\n  to identify potential structure matches.  Next, the deviation is computed between the\n  local structure (in the simulation) and a template of the ideal lattice structure.\n  The deviation is calculated as:\n  \n  \\[\\text{RMSD}(\\mathbf{u}, \\mathbf{v}) = \\min_{s, \\mathbf{Q}} \\sqrt{\\frac{1}{N} \\sum\\limits_{i=1}^{N}\n  {\\left|\\left| s[\\vec{u_i} - \\overline{\\mathbf{u}}] - \\mathbf{Q} \\vec{v_i} \\right|\\right|}^2}\\]\n  Here, u and v contain the coordinates of the local and ideal structures respectively,\n  s is a scale factor, and Q is a rotation.  The best match is identified by the\n  lowest RMSD value, using the optimal scaling, rotation, and correspondence between the\n  points.\n  The ‘threshold’ keyword sets an upper limit on the maximum permitted deviation before\n  a local structure is identified as disordered.  Typical values are in the range 0.1-0.15,\n  but larger values may be desirable at higher temperatures.\n  A value of 0 is equivalent to infinity and can be used if no threshold is desired.\n  The neighbor list needed to compute this quantity is constructed each\n  time the calculation is performed (e.g. each time a snapshot of atoms\n  is dumped).  Thus it can be inefficient to compute/dump this quantity\n  too frequently or to have multiple compute/dump commands, each with a\n  ptm/atom style. By default the compute processes all neighbors\n  unless the optional group2-ID argument is given, then only members\n  of that group are considered as neighbors.\n  Output info:\n  This compute calculates a per-atom array, which can be accessed by\n  any command that uses per-atom values from a compute as input.  See\n  the Howto output doc page for an overview of\n  LAMMPS output options.\n  Results are stored in the per-atom array in the following order:\n  \n  type\n  rmsd\n  interatomic distance\n  qw\n  qx\n  qy\n  qz\n  \n  The type is a number from -1 to 8.  The rmsd is a positive real number.\n  The interatomic distance is computed from the scale factor in the RMSD equation.\n  The (qw,qx,qy,qz) parameters represent the orientation of the local structure\n  in quaternion form.  The reference coordinates for each template (from which the\n  orientation is determined) can be found in the ptm_constants.h file in the PTM source directory.\n  For atoms that are not within the compute group-ID, all values are set to zero.\n  ",
    "syntax": "compute ID group-ID ptm/atom structures threshold group2-ID\n  \n  \n  \n  ID, group-ID are documented in compute command\n  ptm/atom = style name of this compute command\n  structures = structure types to search for\n  threshold = lattice distortion threshold (RMSD)\n  group2-ID determines which group is used for neighbor selection (optional, default “all”)\n  \n  ",
    "examples": "compute 1 all ptm/atom default 0.1 all\n  compute 1 all ptm/atom fcc-hcp-dcub-dhex 0.15 all\n  compute 1 all ptm/atom all 0\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-PTM package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute rdf",
    "description": "Define a computation that calculates the radial distribution function\n  (RDF), also called g(r), and the coordination number for a group of\n  particles.  Both are calculated in histogram form by binning pairwise\n  distances into Nbin bins from 0.0 to the maximum force cutoff\n  defined by the pair_style command or the cutoff\n  distance Rcut specified via the cutoff keyword.  The bins are of\n  uniform size in radial distance.  Thus a single bin encompasses a thin\n  shell of distances in 3d and a thin ring of distances in 2d.\n  \n  Note\n  If you have a bonded system, then the settings of\n  special_bonds command can remove pairwise\n  interactions between atoms in the same bond, angle, or dihedral.  This\n  is the default setting for the special_bonds\n  command, and means those pairwise interactions do not appear in the\n  neighbor list.  Because this fix uses a neighbor list, it also means\n  those pairs will not be included in the RDF. This does not apply when\n  using long-range coulomb interactions (coul/long, coul/msm,\n  coul/wolf or similar.  One way to get around this would be to set\n  special_bond scaling factors to very tiny numbers that are not exactly\n  zero (e.g. 1.0e-50). Another workaround is to write a dump file, and\n  use the rerun command to compute the RDF for snapshots in\n  the dump file.  The rerun script can use a\n  special_bonds command that includes all pairs in\n  the neighbor list.\n  \n  By default the RDF is computed out to the maximum force cutoff defined\n  by the pair_style command.  If the cutoff keyword\n  is used, then the RDF is computed accurately out to the Rcut > 0.0\n  distance specified.\n  \n  Note\n  Normally, you should only use the cutoff keyword if no pair\n  style is defined, e.g. the rerun command is being used to\n  post-process a dump file of snapshots.  Or if you really want the RDF\n  for distances beyond the pair_style force cutoff and cannot easily\n  post-process a dump file to calculate it.  This is because using the\n  cutoff keyword incurs extra computation and possibly communication,\n  which may slow down your simulation.  If you specify a Rcut <= force\n  cutoff, you will force an additional neighbor list to be built at\n  every timestep this command is invoked (or every reneighboring\n  timestep, whichever is less frequent), which is inefficient.  LAMMPS\n  will warn you if this is the case.  If you specify a Rcut > force\n  cutoff, you must insure ghost atom information out to Rcut + skin\n  is communicated, via the comm_modify cutoff\n  command, else the RDF computation cannot be performed, and LAMMPS will\n  give an error message.  The skin value is what is specified with the\n  neighbor command.  In this case, you are forcing a\n  large neighbor list to be built just for the RDF computation, and\n  extra communication to be performed every timestep.\n  \n  The itypeN and jtypeN arguments are optional.  These arguments\n  must come in pairs.  If no pairs are listed, then a single histogram\n  is computed for g(r) between all atom types.  If one or more pairs are\n  listed, then a separate histogram is generated for each\n  itype,jtype pair.\n  The itypeN and jtypeN settings can be specified in one of two\n  ways.  An explicit numeric value can be used, as in the 4th example\n  above.  Or a wild-card asterisk can be used to specify a range of atom\n  types.  This takes the form “*” or “*n” or “n*” or “m*n”.  If N = the\n  number of atom types, then an asterisk with no numeric values means\n  all types from 1 to N.  A leading asterisk means all types from 1 to n\n  (inclusive).  A trailing asterisk means all types from n to N\n  (inclusive).  A middle asterisk means all types from m to n\n  (inclusive).\n  If both itypeN and jtypeN are single values, as in the 4th example\n  above, this means that a g(r) is computed where atoms of type itypeN\n  are the central atom, and atoms of type jtypeN are the distribution\n  atom.  If either itypeN and jtypeN represent a range of values via\n  the wild-card asterisk, as in the 5th example above, this means that a\n  g(r) is computed where atoms of any of the range of types represented\n  by itypeN are the central atom, and atoms of any of the range of\n  types represented by jtypeN are the distribution atom.\n  Pairwise distances are generated by looping over a pairwise neighbor\n  list, just as they would be in a pair_style\n  computation.  The distance between two atoms I and J is included in a\n  specific histogram if the following criteria are met:\n  \n  atoms I,J are both in the specified compute group\n  the distance between atoms I,J is less than the maximum force cutoff\n  the type of the I atom matches itypeN (one or a range of types)\n  the type of the J atom matches jtypeN (one or a range of types)\n  \n  It is OK if a particular pairwise distance is included in more than\n  one individual histogram, due to the way the itypeN and jtypeN\n  arguments are specified.\n  The g(r) value for a bin is calculated from the histogram count by\n  scaling it by the idealized number of how many counts there would be\n  if atoms of type jtypeN were uniformly distributed.  Thus it\n  involves the count of itypeN atoms, the count of jtypeN atoms, the\n  volume of the entire simulation box, and the volume of the bin’s thin\n  shell in 3d (or the area of the bin’s thin ring in 2d).\n  A coordination number coord(r) is also calculated, which is the number\n  of atoms of type jtypeN within the current bin or closer, averaged\n  over atoms of type itypeN.  This is calculated as the area- or\n  volume-weighted sum of g(r) values over all bins up to and including\n  the current bin, multiplied by the global average volume density of\n  atoms of type jtypeN.\n  The simplest way to output the results of the compute rdf calculation\n  to a file is to use the fix ave/time command, for\n  example:\n  compute myRDF all rdf 50\n  fix 1 all ave/time 100 1 100 c_myRDF[*] file tmp.rdf mode vector\n  \n  \n  Output info:\n  This compute calculates a global array with the number of rows =\n  Nbins, and the number of columns = 1 + 2*Npairs, where Npairs is the\n  number of I,J pairings specified.  The first column has the bin\n  coordinate (center of the bin), Each successive set of 2 columns has\n  the g(r) and coord(r) values for a specific set of itypeN versus\n  jtypeN interactions, as described above.  These values can be used\n  by any command that uses a global values from a compute as input.  See\n  the Howto output doc page for an overview of\n  LAMMPS output options.\n  The array values calculated by this compute are all “intensive”.\n  The first column of array values will be in distance\n  units.  The g(r) columns of array values are normalized\n  numbers >= 0.0.  The coordination number columns of array values are\n  also numbers >= 0.0.\n  ",
    "syntax": "compute ID group-ID rdf Nbin itype1 jtype1 itype2 jtype2 ... keyword/value ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  rdf = style name of this compute command\n  Nbin = number of RDF bins\n  itypeN = central atom type for Nth RDF histogram (see asterisk form below)\n  jtypeN = distribution atom type for Nth RDF histogram (see asterisk form below)\n  zero or more keyword/value pairs may be appended\n  keyword = cutoff\n  cutoff value = Rcut\n    Rcut = cutoff distance for RDF computation (distance units)\n  \n  \n  ",
    "examples": "compute 1 all rdf 100\n  compute 1 all rdf 100 1 1\n  compute 1 all rdf 100 * 3 cutoff 5.0\n  compute 1 fluid rdf 500 1 1 1 2 2 1 2 2\n  compute 1 fluid rdf 500 1*3 2 5 *10 cutoff 3.5\n  \n  \n  ",
    "restrictions": "The RDF is not computed for distances longer than the force cutoff,\n  since processors (in parallel) don’t know about atom coordinates for\n  atoms further away than that distance.  If you want an RDF for larger\n  distances, you can use the rerun command to post-process\n  a dump file and set the cutoff for the potential to be longer in the\n  rerun script.  Note that in the rerun context, the force cutoff is\n  arbitrary, since you are not running dynamics and thus are not changing\n  your model.  The definition of g(r) used by LAMMPS is only appropriate\n  for characterizing atoms that are uniformly distributed throughout the\n  simulation cell. In such cases, the coordination number is still\n  correct and meaningful.  As an example, if a large simulation cell\n  contains only one atom of type itypeN and one of jtypeN, then g(r)\n  will register an arbitrarily large spike at whatever distance they\n  happen to be at, and zero everywhere else.  Coord(r) will show a step\n  change from zero to one at the location of the spike in g(r).\n  \n  Note\n  compute rdf can handle dynamic groups and systems where atoms\n  are added or removed, but this causes that certain normalization\n  parameters need to be re-computed in every step and include collective\n  communication operations. This will reduce performance and limit\n  parallel efficiency and scaling. For systems, where only the type\n  of atoms changes (e.g. when using fix atom/swap),\n  you need to explicitly request the dynamic normalization updates\n  via compute_modify dynamic yes\n  \n  "
},
{
    "command": "compute reduce",
    "description": "Define a calculation that “reduces” one or more vector inputs into\n  scalar values, one per listed input.  The inputs can be per-atom or\n  local quantities; they cannot be global quantities.  Atom attributes\n  are per-atom quantities, computes and fixes\n  may generate any of the three kinds of quantities, and atom-style variables generate per-atom quantities.  See the\n  variable command and its special functions which can\n  perform the same operations as the compute reduce command on global\n  vectors.\n  The reduction operation is specified by the mode setting.  The sum\n  option adds the values in the vector into a global total.  The min\n  or max options find the minimum or maximum value across all vector\n  values.  The ave setting adds the vector values into a global total,\n  then divides by the number of values in the vector.  The sumsq\n  option sums the square of the values in the vector into a global\n  total.  The avesq setting does the same as sumsq, then divides the\n  sum of squares by the number of values.  The last two options can be\n  useful for calculating the variance of some quantity, e.g. variance =\n  sumsq - ave^2.\n  Each listed input is operated on independently.  For per-atom inputs,\n  the group specified with this command means only atoms within the\n  group contribute to the result.  For per-atom inputs, if the compute\n  reduce/region command is used, the atoms must also currently be within\n  the region.  Note that an input that produces per-atom quantities may\n  define its own group which affects the quantities it returns.  For\n  example, if a compute is used as an input which generates a per-atom\n  vector, it will generate values of 0.0 for atoms that are not in the\n  group specified for that compute.\n  Each listed input can be an atom attribute (position, velocity, force\n  component) or can be the result of a compute or\n  fix or the evaluation of an atom-style\n  variable.\n  Note that for values from a compute or fix, the bracketed index I can\n  be specified using a wildcard asterisk with the index to effectively\n  specify multiple values.  This takes the form “*” or “*n” or “n*” or\n  “m*n”.  If N = the size of the vector (for mode = scalar) or the\n  number of columns in the array (for mode = vector), then an asterisk\n  with no numeric values means all indices from 1 to N.  A leading\n  asterisk means all indices from 1 to n (inclusive).  A trailing\n  asterisk means all indices from n to N (inclusive).  A middle asterisk\n  means all indices from m to n (inclusive).\n  Using a wildcard is the same as if the individual columns of the array\n  had been listed one by one.  E.g. these 2 compute reduce commands are\n  equivalent, since the compute stress/atom\n  command creates a per-atom array with 6 columns:\n  compute myPress all stress/atom NULL\n  compute 2 all reduce min c_myPress[*]\n  compute 2 all reduce min c_myPress[1] c_myPress[2] c_myPress[3] &\n                           c_myPress[4] c_myPress[5] c_myPress[6]\n  \n  \n  \n  The atom attribute values (x,y,z,vx,vy,vz,fx,fy,fz) are\n  self-explanatory.  Note that other atom attributes can be used as\n  inputs to this fix by using the compute property/atom command and then specifying\n  an input value from that compute.\n  If a value begins with “c_”, a compute ID must follow which has been\n  previously defined in the input script.  Computes can generate\n  per-atom or local quantities.  See the individual\n  compute doc page for details.  If no bracketed integer\n  is appended, the vector calculated by the compute is used.  If a\n  bracketed integer is appended, the Ith column of the array calculated\n  by the compute is used.  Users can also write code for their own\n  compute styles and add them to LAMMPS.  See the\n  discussion above for how I can be specified with a wildcard asterisk\n  to effectively specify multiple values.\n  If a value begins with “f_”, a fix ID must follow which has been\n  previously defined in the input script.  Fixes can generate per-atom\n  or local quantities.  See the individual fix doc page for\n  details.  Note that some fixes only produce their values on certain\n  timesteps, which must be compatible with when compute reduce\n  references the values, else an error results.  If no bracketed integer\n  is appended, the vector calculated by the fix is used.  If a bracketed\n  integer is appended, the Ith column of the array calculated by the fix\n  is used.  Users can also write code for their own fix style and add them to LAMMPS.  See the discussion above for how I can\n  be specified with a wildcard asterisk to effectively specify multiple\n  values.\n  If a value begins with “v_”, a variable name must follow which has\n  been previously defined in the input script.  It must be an\n  atom-style variable.  Atom-style variables can\n  reference thermodynamic keywords and various per-atom attributes, or\n  invoke other computes, fixes, or variables when they are evaluated, so\n  this is a very general means of generating per-atom quantities to\n  reduce.\n  \n  If the replace keyword is used, two indices vec1 and vec2 are\n  specified, where each index ranges from 1 to the # of input values.\n  The replace keyword can only be used if the mode is min or max.\n  It works as follows.  A min/max is computed as usual on the vec2\n  input vector.  The index N of that value within vec2 is also stored.\n  Then, instead of performing a min/max on the vec1 input vector, the\n  stored index is used to select the Nth element of the vec1 vector.\n  Thus, for example, if you wish to use this compute to find the bond\n  with maximum stretch, you can do it as follows:\n  compute 1 all property/local batom1 batom2\n  compute 2 all bond/local dist\n  compute 3 all reduce max c_1[1] c_1[2] c_2 replace 1 3 replace 2 3\n  thermo_style custom step temp c_3[1] c_3[2] c_3[3]\n  \n  \n  The first two input values in the compute reduce command are vectors\n  with the IDs of the 2 atoms in each bond, using the compute property/local command.  The last input\n  value is bond distance, using the compute bond/local command.  Instead of taking the\n  max of the two atom ID vectors, which does not yield useful\n  information in this context, the replace keywords will extract the\n  atom IDs for the two atoms in the bond of maximum stretch.  These atom\n  IDs and the bond stretch will be printed with thermodynamic output.\n  \n  If a single input is specified this compute produces a global scalar\n  value.  If multiple inputs are specified, this compute produces a\n  global vector of values, the length of which is equal to the number of\n  inputs specified.\n  As discussed below, for the sum and sumsq modes, the value(s)\n  produced by this compute are all “extensive”, meaning their value\n  scales linearly with the number of atoms involved.  If normalized\n  values are desired, this compute can be accessed by the thermo_style custom command with thermo_modify norm yes set as an option.  Or it can be accessed by a\n  variable that divides by the appropriate atom count.\n  \n  Output info:\n  This compute calculates a global scalar if a single input value is\n  specified or a global vector of length N where N is the number of\n  inputs, and which can be accessed by indices 1 to N.  These values can\n  be used by any command that uses global scalar or vector values from a\n  compute as input.  See the Howto output doc page\n  for an overview of LAMMPS output options.\n  All the scalar or vector values calculated by this compute are\n  “intensive”, except when the sum or sumsq modes are used on\n  per-atom or local vectors, in which case the calculated values are\n  “extensive”.\n  The scalar or vector values will be in whatever units the\n  quantities being reduced are in.\n  ",
    "syntax": "compute ID group-ID style arg mode input1 input2 ... keyword args ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  style = reduce or reduce/region\n  reduce arg = none\n  reduce/region arg = region-ID\n    region-ID = ID of region to use for choosing atoms\n  \n  mode = sum or min or max or ave or sumsq or avesq\n  one or more inputs can be listed\n  input = x, y, z, vx, vy, vz, fx, fy, fz, c_ID, c_ID[N], f_ID, f_ID[N], v_name\n  x,y,z,vx,vy,vz,fx,fy,fz = atom attribute (position, velocity, force component)\n  c_ID = per-atom or local vector calculated by a compute with ID\n  c_ID[I] = Ith column of per-atom or local array calculated by a compute with ID, I can include wildcard (see below)\n  f_ID = per-atom or local vector calculated by a fix with ID\n  f_ID[I] = Ith column of per-atom or local array calculated by a fix with ID, I can include wildcard (see below)\n  v_name = per-atom vector calculated by an atom-style variable with name\n  \n  \n  \n  zero or more keyword/args pairs may be appended\n  keyword = replace\n  replace args = vec1 vec2\n    vec1 = reduced value from this input vector will be replaced\n    vec2 = replace it with vec1[N] where N is index of max/min value from vec2\n  \n  \n  ",
    "examples": "compute 1 all reduce sum c_force\n  compute 1 all reduce/region subbox sum c_force\n  compute 2 all reduce min c_press[2] f_ave v_myKE\n  compute 2 all reduce min c_press[\\*] f_ave v_myKE\n  compute 3 fluid reduce max c_index[1] c_index[2] c_dist replace 1 3 replace 2 3\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute reduce/chunk",
    "description": "Define a calculation that reduces one or more per-atom vectors into\n  per-chunk values.  This can be useful for diagnostic output.  Or when\n  used in conjunction with the compute chunk/spread/atom command it can be\n  used ot create per-atom values that induce a new set of chunks with a\n  second compute chunk/atom command.  An\n  example is given below.\n  In LAMMPS, chunks are collections of atoms defined by a compute chunk/atom command, which assigns each atom\n  to a single chunk (or no chunk).  The ID for this command is specified\n  as chunkID.  For example, a single chunk could be the atoms in a\n  molecule or atoms in a spatial bin.  See the compute chunk/atom and Howto chunk\n  doc pages for details of how chunks can be defined and examples of how\n  they can be used to measure properties of a system.\n  For each atom, this compute accesses its chunk ID from the specified\n  chunkID compute.  The per-atom value from an input contributes\n  to a per-chunk value corresponding the the chunk ID.\n  The reduction operation is specified by the mode setting and is\n  performed over all the per-atom values from the atoms in each chunk.\n  The sum option adds the pre-atom values to a per-chunk total.  The\n  min or max options find the minimum or maximum value of the\n  per-atom values for each chunk.\n  Note that only atoms in the specified group contribute to the\n  reduction operation.  If the chunkID compute returns a 0 for the\n  chunk ID of an atom (i.e. the atom is not in a chunk defined by the\n  compute chunk/atom command), that atom will\n  also not contribute to the reduction operation.  An input that is a\n  compute or fix may define its own group which affects the quantities\n  it returns.  For example, a compute with return a zero value for atoms\n  that are not in the group specified for that compute.\n  Each listed input is operated on independently.  Each input can be the\n  result of a compute or fix or the evaluation\n  of an atom-style variable.\n  Note that for values from a compute or fix, the bracketed index I can\n  be specified using a wildcard asterisk with the index to effectively\n  specify multiple values.  This takes the form “*” or “*n” or “n*” or\n  “m*n”.  If N = the size of the vector (for mode = scalar) or the\n  number of columns in the array (for mode = vector), then an asterisk\n  with no numeric values means all indices from 1 to N.  A leading\n  asterisk means all indices from 1 to n (inclusive).  A trailing\n  asterisk means all indices from n to N (inclusive).  A middle asterisk\n  means all indices from m to n (inclusive).\n  Using a wildcard is the same as if the individual columns of the array\n  had been listed one by one.  E.g. these 2 compute reduce/chunk\n  commands are equivalent, since the compute property/chunk command creates a per-atom\n  array with 3 columns:\n  compute prop all property/atom vx vy vz\n  compute 10 all reduce/chunk mychunk max c_prop[*]\n  compute 10 all reduce/chunk mychunk max c_prop[1] c_prop[2] c_prop[3]\n  \n  \n  \n  Here is an example of using this compute, in conjunction with the\n  compute chunk/spread/atom command to identify self-assembled micelles.\n  The commands below can be added to the examples/in.micelle script.\n  Imagine a collection of polymer chains or small molecules with\n  hydrophobic end groups.  All the hydrophobic (HP) atoms are assigned\n  to a group called “phobic”.\n  These commands will assign a unique cluster ID to all HP atoms within\n  a specified distance of each other.  A cluster will contain all HP\n  atoms in a single molecule, but also the HP atoms in nearby molecules,\n  e.g. molecules that have clumped to form a micelle due to the\n  attraction induced by the hydrophobicity.  The output of the\n  chunk/reduce command will be a cluster ID per chunk (molecule).\n  Molecules with the same cluster ID are in the same micelle.\n  group phobic type 4     # specific to in.micelle model\n  compute cluster phobic cluster/atom 2.0\n  compute cmol all chunk/atom molecule\n  compute reduce phobic reduce/chunk cmol min c_cluster\n  \n  \n  This per-chunk info could be output in at least two ways:\n  fix 10 all ave/time 1000 1 1000 c_reduce file tmp.phobic mode vector\n  \n  compute spread all chunk/spread/atom cmol c_reduce\n  dump 1 all custom 1000 tmp.dump id type mol x y z c_cluster c_spread\n  dump_modify 1 sort id\n  \n  \n  In the first case, each snapshot in the tmp.phobic file will contain\n  one line per molecule.  Molecules with the same value are in the same\n  micelle.  In the second case each dump snapshot contains all atoms,\n  each with a final field with the cluster ID of the micelle that the HP\n  atoms of that atom’s molecule belong to.\n  The result from compute chunk/spread/atom can be used to define a new\n  set of chunks, where all the atoms in all the molecules in the same\n  micelle are assigned to the same chunk, i.e. one chunk per micelle.\n  compute micelle all chunk/atom c_spread compress yes\n  \n  \n  Further analysis on a per-micelle basis can now be performed using any\n  of the per-chunk computes listed on the Howto chunk\n  doc page.  E.g. count the number of atoms in each micelle, calculate\n  its center or mass, shape (moments of inertia), radius of gyration,\n  etc.\n  compute prop all property/chunk micelle count\n  fix 20 all ave/time 1000 1 1000 c_prop file tmp.micelle mode vector\n  \n  \n  Each snapshot in the tmp.micelle file will have one line per micelle\n  with its count of atoms, plus a first line for a chunk with all the\n  solvent atoms.  By the time 50000 steps have elapsed there are a\n  handful of large micelles.\n  \n  Output info:\n  This compute calculates a global vector if a single input value is\n  specified, otherwise a global array is output.  The number of columns\n  in the array is the number of inputs provided.  The length of the\n  vector or the number of vector elements or array rows = the number of\n  chunks Nchunk as calculated by the specified compute chunk/atom command.  The vector or array can\n  be accessed by any command that uses global values from a compute as\n  input.  See the Howto output doc page for an\n  overview of LAMMPS output options.\n  The per-atom values for the vector or each column of the array will be\n  in whatever units the corresponding input value is in.\n  The vector or array values are “intensive”.\n  ",
    "syntax": "compute ID group-ID reduce/chunk chunkID mode input1 input2 ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  reduce/chunk = style name of this compute command\n  chunkID = ID of compute chunk/atom command\n  mode = sum or min or max\n  one or more inputs can be listed\n  input = c_ID, c_ID[N], f_ID, f_ID[N], v_ID\n  c_ID = per-atom vector calculated by a compute with ID\n  c_ID[I] = Ith column of per-atom array calculated by a compute with ID, I can include wildcard (see below)\n  f_ID = per-atom vector calculated by a fix with ID\n  f_ID[I] = Ith column of per-atom array calculated by a fix with ID, I can include wildcard (see below)\n  v_name = per-atom vector calculated by an atom-style variable with name\n  \n  \n  \n  \n  ",
    "examples": "compute 1 all reduce/chunk/atom mychunk min c_cluster\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute rigid/local",
    "description": "Define a computation that simply stores rigid body attributes for\n  rigid bodies defined by the fix rigid/small command\n  or one of its NVE, NVT, NPT, NPH variants.  The data is stored as\n  local data so it can be accessed by other output commands that process local data, such as the\n  compute reduce or dump local\n  commands.\n  Note that this command only works with the fix rigid/small command or its variants, not the fix rigid\n  command and its variants.  The ID of the fix rigid/small command used to define rigid bodies must\n  be specified as rigidID.  The fix rigid command is\n  typically used to define a handful of (potentially very large) rigid\n  bodies.  It outputs similar per-body information as this command\n  directly from the fix as global data; see the fix rigid doc page for details\n  The local data stored by this command is generated by looping over all\n  the atoms owned on a processor.  If the atom is not in the specified\n  group-ID or is not part of a rigid body it is skipped.  If it is not\n  the atom within a body that is assigned to store the body information\n  it is skipped (only one atom per body is so assigned).  If it is the\n  assigned atom, then the info for that body is output.  This means that\n  information for N bodies is generated.  N may be less than the # of\n  bodies defined by the fix rigid command, if the atoms in some bodies\n  are not in the group-ID.\n  \n  Note\n  Which atom in a body owns the body info is determined internal\n  to LAMMPS; it’s the one nearest the geometric center of the body.\n  Typically you should avoid this complication, by defining the group\n  associated with this fix to include/exclude entire bodies.\n  \n  Note that as atoms and bodies migrate from processor to processor,\n  there will be no consistent ordering of the entries within the local\n  vector or array from one timestep to the next.\n  Here is an example of how to use this compute to dump rigid body info\n  to a file:\n  compute 1 all rigid/local myRigid mol x y z fx fy fz\n  dump 1 all local 1000 tmp.dump index c_1[1] c_1[2] c_1[3] c_1[4] c_1[5] c_1[6] c_1[7]\n  \n  \n  \n  This section explains the rigid body attributes that can be specified.\n  The id attribute is the atom-ID of the atom which owns the rigid body, which is\n  assigned by the fix rigid/small command.\n  The mol attribute is the molecule ID of the rigid body.  It should\n  be the molecule ID which all of the atoms in the body belong to, since\n  that is how the fix rigid/small command defines its\n  rigid bodies.\n  The mass attribute is the total mass of the rigid body.\n  There are two options for outputting the coordinates of the center of\n  mass (COM) of the body.  The x, y, z attributes write the COM\n  “unscaled”, in the appropriate distance units (Angstroms,\n  sigma, etc).  Use xu, yu, zu if you want the COM “unwrapped” by\n  the image flags for each body.  Unwrapped means that if the body\n  COM has passed through a periodic boundary one or more times, the value\n  is generated what the COM coordinate would be if it had not been\n  wrapped back into the periodic box.\n  The image flags for the body can be generated directly using the ix,\n  iy, iz attributes.  For periodic dimensions, they specify which\n  image of the simulation box the COM is considered to be in.  An image\n  of 0 means it is inside the box as defined.  A value of 2 means add 2\n  box lengths to get the true value.  A value of -1 means subtract 1 box\n  length to get the true value.  LAMMPS updates these flags as the rigid\n  body COMs cross periodic boundaries during the simulation.\n  The vx, vy, vz, fx, fy, fz attributes are components of\n  the COM velocity and force on the COM of the body.\n  The omegax, omegay, and omegaz attributes are the angular\n  velocity components of the body around its COM.\n  The angmomx, angmomy, and angmomz attributes are the angular\n  momentum components of the body around its COM.\n  The quatw, quati, quatj, and quatk attributes are the\n  components of the 4-vector quaternion representing the orientation of\n  the rigid body.  See the set command for an explanation of\n  the quaternion vector.\n  The angmomx, angmomy, and angmomz attributes are the angular\n  momentum components of the body around its COM.\n  The tqx, tqy, tqz attributes are components of the torque acting\n  on the body around its COM.\n  The inertiax, inertiay, inertiaz attributes are components of\n  diagonalized inertia tensor for the body, i.e the 3 moments of inertia\n  for the body around its principal axes, as computed internally by\n  LAMMPS.\n  \n  Output info:\n  This compute calculates a local vector or local array depending on the\n  number of keywords.  The length of the vector or number of rows in the\n  array is the number of rigid bodies.  If a single keyword is\n  specified, a local vector is produced.  If two or more keywords are\n  specified, a local array is produced where the number of columns = the\n  number of keywords.  The vector or array can be accessed by any\n  command that uses local values from a compute as input.  See the\n  Howto output doc page for an overview of LAMMPS\n  output options.\n  The vector or array values will be in whatever units the\n  corresponding attribute is in:\n  \n  id,mol = unitless\n  mass = mass units\n  x,y,z and xy,yu,zu = distance units\n  vx,vy,vz = velocity units\n  fx,fy,fz = force units\n  omegax,omegay,omegaz = radians/time units\n  angmomx,angmomy,angmomz = mass*distance^2/time units\n  quatw,quati,quatj,quatk = unitless\n  tqx,tqy,tqz = torque units\n  inertiax,inertiay,inertiaz = mass*distance^2 units\n  \n  ",
    "syntax": "compute ID group-ID rigid/local rigidID input1 input2 ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  rigid/local = style name of this compute command\n  rigidID = ID of fix rigid/small command or one of its variants\n  input = one or more rigid body attributes\n  possible attributes = id, mol, mass,\n                        x, y, z, xu, yu, zu, ix, iy, iz\n                        vx, vy, vz, fx, fy, fz,\n                        omegax, omegay, omegaz,\n                        angmomx, angmomy, angmomz,\n                        quatw, quati, quatj, quatk,\n                        tqx, tqy, tqz,\n                        inertiax, inertiay, inertiaz\n      id = atom ID of atom within body which owns body properties\n      mol = molecule ID used to define body in fix rigid/small command\n      mass = total mass of body\n      x,y,z = center of mass coords of body\n      xu,yu,zu = unwrapped center of mass coords of body\n      ix,iy,iz = box image that the center of mass is in\n      vx,vy,vz = center of mass velocities\n      fx,fy,fz = force of center of mass\n      omegax,omegay,omegaz = angular velocity of body\n      angmomx,angmomy,angmomz = angular momentum of body\n      quatw,quati,quatj,quatk = quaternion components for body\n      tqx,tqy,tqz = torque on body\n      inertiax,inertiay,inertiaz = diagonalized moments of inertia of body\n  \n  \n  ",
    "examples": "compute 1 all rigid/local myRigid mol x y z\n  \n  \n  ",
    "restrictions": "This compute is part of the RIGID package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute saed",
    "description": "Define a computation that calculates electron diffraction intensity as\n  described in (Coleman) on a mesh of reciprocal lattice nodes\n  defined by the entire simulation domain (or manually) using simulated\n  radiation of wavelength lambda.\n  The electron diffraction intensity I at each reciprocal lattice point\n  is computed from the structure factor F using the equations:\n  \n  \\[\\begin{split}I = & \\frac{F^{*}F}{N} \\\\\n  F(\\mathbf{k}) = & \\sum_{j=1}^{N}f_j(\\theta)exp(2\\pi i \\mathbf{k} \\cdot \\mathbf{r}_j)\\end{split}\\]\n  Here, K is the location of the reciprocal lattice node, \\(r_j\\) is the\n  position of each atom, \\(f_j\\) are atomic scattering factors.\n  Diffraction intensities are calculated on a three-dimensional mesh of\n  reciprocal lattice nodes. The mesh spacing is defined either (a)  by\n  the entire simulation domain or (b) manually using selected values as\n  shown in the 2D diagram below.\n  \n  For a mesh defined by the simulation domain, a rectilinear grid is\n  constructed with spacing c*inv(A) along each reciprocal lattice\n  axis. Where A are the vectors corresponding to the edges of the\n  simulation cell. If one or two directions has non-periodic boundary\n  conditions, then the spacing in these directions is defined from the\n  average of the (inversed) box lengths with periodic boundary conditions.\n  Meshes defined by the simulation domain must contain at least one periodic\n  boundary.\n  If the manual flag is included, the mesh of reciprocal lattice nodes\n  will defined using the c values for the spacing along each reciprocal\n  lattice axis. Note that manual mapping of the reciprocal space mesh is\n  good for comparing diffraction results from  multiple simulations; however\n  it can reduce the likelihood that Bragg reflections will be satisfied\n  unless small spacing parameters <0.05 Angstrom^(-1) are implemented.\n  Meshes with manual spacing do not require a periodic boundary.\n  The limits of the reciprocal lattice mesh are determined by the use of\n  the Kmax, Zone, and dR_Ewald parameters.  The rectilinear mesh\n  created about the origin of reciprocal space is terminated at the\n  boundary of a sphere of radius Kmax centered at the origin.  If\n  Zone parameters z1=z2=z3=0 are used, diffraction intensities are\n  computed throughout the entire spherical volume - note this can\n  greatly increase the cost of computation.  Otherwise, Zone\n  parameters will denote the z1=h, z2=k, and z3=l (in a global since)\n  zone axis of an intersecting Ewald sphere.  Diffraction intensities\n  will only be computed at the intersection of the reciprocal lattice\n  mesh and a dR_Ewald thick surface of the Ewald sphere.  See the\n  example 3D intensity data and the intersection of a [010] zone axis\n  in the below image.\n  \n  The atomic scattering factors, fj, accounts for the reduction in\n  diffraction intensity due to Compton scattering.  Compute saed uses\n  analytical approximations of the atomic scattering factors that vary\n  for each atom type (type1 type2 … typeN) and angle of diffraction.\n  The analytic approximation is computed using the formula\n  (Brown):\n  \n  \\[f_j\\left ( \\frac{sin(\\theta)}{\\lambda} \\right )=\\sum_{i}^{5}\n  a_i exp\\left ( -b_i \\frac{sin^{2}(\\theta)}{\\lambda^{2}} \\right )\\]\n  Coefficients parameterized by (Fox) are assigned for each\n  atom type designating the chemical symbol and charge of each atom\n  type. Valid chemical symbols for compute saed are:\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  H\n  He\n  Li\n  Be\n  B\n  C\n  N\n  O\n  F\n  Ne\n  Na\n  Mg\n  Al\n  Si\n  P\n  S\n  Cl\n  Ar\n  K\n  Ca\n  \n  Sc\n  Ti\n  V\n  Cr\n  Mn\n  Fe\n  Co\n  Ni\n  Cu\n  Zn\n  Ga\n  Ge\n  As\n  Se\n  Br\n  Kr\n  Rb\n  Sr\n  Y\n  Zr\n  \n  Nb\n  Mo\n  Tc\n  Ru\n  Rh\n  Pd\n  Ag\n  Cd\n  In\n  Sn\n  Sb\n  Te\n  I\n  Xe\n  Cs\n  Ba\n  La\n  Ce\n  Pr\n  Nd\n  \n  Pm\n  Sm\n  Eu\n  Gd\n  Tb\n  Dy\n  Ho\n  Er\n  Tm\n  Yb\n  Lu\n  Hf\n  Ta\n  W\n  Re\n  Os\n  Ir\n  Pt\n  Au\n  Hg\n  \n  Tl\n  Pb\n  Bi\n  Po\n  At\n  Rn\n  Fr\n  Ra\n  Ac\n  Th\n  Pa\n  U\n  Np\n  Pu\n  Am\n  Cm\n  Bk\n  Cf\n  \n  \n  \n  \n  \n  If the echo keyword is specified, compute saed will provide extra\n  reporting information to the screen.\n  Output info:\n  This compute calculates a global vector.  The length of the vector is\n  the number of reciprocal lattice nodes that are explored by the mesh.\n  The entries of the global vector are the computed diffraction\n  intensities as described above.\n  The vector can be accessed by any command that uses global values from\n  a compute as input.  See the Howto output doc page\n  for an overview of LAMMPS output options.\n  All array values calculated by this compute are “intensive”.\n  ",
    "syntax": "compute ID group-ID saed lambda type1 type2 ... typeN keyword value ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  saed = style name of this compute command\n  lambda = wavelength of incident radiation (length units)\n  type1 type2 … typeN = chemical symbol of each atom type (see valid options below)\n  zero or more keyword/value pairs may be appended\n  keyword = Kmax or Zone or dR_Ewald or c or manual or echo\n  Kmax value = Maximum distance explored from reciprocal space origin\n                 (inverse length units)\n  Zone values = z1 z2 z3\n    z1,z2,z3 = Zone axis of incident radiation. If z1=z2=z3=0 all\n               reciprocal space will be meshed up to Kmax\n  dR_Ewald value = Thickness of Ewald sphere slice intercepting\n                     reciprocal space (inverse length units)\n  c values = c1 c2 c3\n    c1,c2,c3 = parameters to adjust the spacing of the reciprocal\n               lattice nodes in the h, k, and l directions respectively\n  manual = flag to use manual spacing of reciprocal lattice points\n             based on the values of the c parameters\n  echo = flag to provide extra output for debugging purposes\n  \n  \n  ",
    "examples": "compute 1 all saed 0.0251 Al O Kmax 1.70 Zone 0 0 1 dR_Ewald 0.01 c 0.5 0.5 0.5\n  compute 2 all saed 0.0251 Ni Kmax 1.70 Zone 0 0 0 c 0.05 0.05 0.05 manual echo\n  \n  fix saed/vtk 1 1 1 c_1 file Al2O3_001.saed\n  fix saed/vtk 1 1 1 c_2 file Ni_000.saed\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-DIFFRACTION package.  It is only\n  enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\n  The compute_saed command does not work for triclinic cells.\n  "
},
{
    "command": "compute slice",
    "description": "Define a calculation that “slices” one or more vector inputs into\n  smaller vectors, one per listed input.  The inputs can be global\n  quantities; they cannot be per-atom or local quantities.\n  Computes and fixes and vector-style\n  variables can generate such global quantities.  The\n  group specified with this command is ignored.\n  The values extracted from the input vector(s) are determined by the\n  Nstart, Nstop, and Nskip parameters.  The elements of an input\n  vector of length N are indexed from 1 to N.  Starting at element\n  Nstart, every Mth element is extracted, where M = Nskip, until\n  element Nstop is reached.  The extracted quantities are stored as a\n  vector, which is typically shorter than the input vector.\n  Each listed input is operated on independently to produce one output\n  vector.  Each listed input must be a global vector or column of a\n  global array calculated by another compute or\n  fix.\n  If an input value begins with “c_”, a compute ID must follow which has\n  been previously defined in the input script and which generates a\n  global vector or array.  See the individual compute doc\n  page for details.  If no bracketed integer is appended, the vector\n  calculated by the compute is used.  If a bracketed integer is\n  appended, the Ith column of the array calculated by the compute is\n  used.  Users can also write code for their own compute styles and add them to LAMMPS.\n  If a value begins with “f_”, a fix ID must follow which has been\n  previously defined in the input script and which generates a global\n  vector or array.  See the individual fix doc page for\n  details.  Note that some fixes only produce their values on certain\n  timesteps, which must be compatible with when compute slice references\n  the values, else an error results.  If no bracketed integer is\n  appended, the vector calculated by the fix is used.  If a bracketed\n  integer is appended, the Ith column of the array calculated by the fix\n  is used.  Users can also write code for their own fix style and add them to LAMMPS.\n  If an input value begins with “v_”, a variable name must follow which\n  has been previously defined in the input script.  Only vector-style\n  variables can be referenced.  See the variable command\n  for details.  Note that variables of style vector define a formula\n  which can reference individual atom properties or thermodynamic\n  keywords, or they can invoke other computes, fixes, or variables when\n  they are evaluated, so this is a very general means of specifying\n  quantities to slice.\n  If a single input is specified this compute produces a global vector,\n  even if the length of the vector is 1.  If multiple inputs are\n  specified, then a global array of values is produced, with the number\n  of columns equal to the number of inputs specified.\n  \n  Output info:\n  This compute calculates a global vector if a single input value is\n  specified or a global array with N columns where N is the number of\n  inputs.  The length of the vector or the number of rows in the array\n  is equal to the number of values extracted from each input vector.\n  These values can be used by any command that uses global vector or\n  array values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The vector or array values calculated by this compute are simply\n  copies of values generated by computes or fixes or variables that are\n  input vectors to this compute.  If there is a single input vector of\n  intensive and/or extensive values, then each value in the vector of\n  values calculated by this compute will be “intensive” or “extensive”,\n  depending on the corresponding input value.  If there are multiple\n  input vectors, and all the values in them are intensive, then the\n  array values calculated by this compute are “intensive”.  If there are\n  multiple input vectors, and any value in them is extensive, then the\n  array values calculated by this compute are “extensive”.  Values\n  produced by a variable are treated as intensive.\n  The vector or array values will be in whatever units the\n  input quantities are in.\n  ",
    "syntax": "compute ID group-ID slice Nstart Nstop Nskip input1 input2 ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  slice = style name of this compute command\n  Nstart = starting index within input vector(s)\n  Nstop = stopping index within input vector(s)\n  Nskip = extract every Nskip elements from input vector(s)\n  input = c_ID, c_ID[N], f_ID, f_ID[N]\n  c_ID = global vector calculated by a compute with ID\n  c_ID[I] = Ith column of global array calculated by a compute with ID\n  f_ID = global vector calculated by a fix with ID\n  f_ID[I] = Ith column of global array calculated by a fix with ID\n  v_name = vector calculated by an vector-style variable with name\n  \n  \n  \n  \n  ",
    "examples": "compute 1 all slice 1 100 10 c_msdmol[4]\n  compute 1 all slice 301 400 1 c_msdmol[4] v_myVec\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute smd/contact/radius",
    "description": "Define a computation which outputs the contact radius, i.e., the\n  radius used to prevent particles from penetrating each other.  The\n  contact radius is used only to prevent particles belonging to\n  different physical bodies from penetrating each other. It is used by\n  the contact pair styles, e.g., smd/hertz and smd/tri_surface.\n  See this PDF guide to using Smooth\n  Mach Dynamics in LAMMPS.\n  The value of the contact radius will be 0.0 for particles not in the\n  specified compute group.\n  Output info:\n  This compute calculates a per-particle vector, which can be accessed\n  by any command that uses per-particle values from a compute as input.\n  See the Howto output doc page for an overview of\n  LAMMPS output options.\n  The per-particle vector values will be in distance units.\n  ",
    "syntax": "compute ID group-ID smd/contact/radius\n  \n  \n  \n  ID, group-ID are documented in compute command\n  smd/contact/radius = style name of this compute command\n  \n  ",
    "examples": "compute 1 all smd/contact/radius\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute smd/damage",
    "description": "Define a computation that calculates the damage status of SPH particles\n  according to the damage model which is defined via the SMD SPH pair styles, e.g., the maximum plastic strain failure criterion.\n  See this PDF guide to use Smooth Mach Dynamics in LAMMPS.\n  Output Info:\n  This compute calculates a per-particle vector, which can be accessed\n  by any command that uses per-particle values from a compute as input.\n  See the Howto output doc page for an overview of\n  LAMMPS output options.\n  The per-particle values are dimensionless an in the range of zero to one.\n  ",
    "syntax": "compute ID group-ID smd/damage\n  \n  \n  \n  ID, group-ID are documented in compute command\n  smd/damage = style name of this compute command\n  \n  ",
    "examples": "compute 1 all smd/damage\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package.  See the “Build\n  "
},
{
    "command": "compute smd/hourglass/error",
    "description": "Define a computation which outputs the error of the approximated\n  relative separation with respect to the actual relative separation of\n  the particles i and j. Ideally, if the deformation gradient is exact,\n  and there exists a unique mapping between all particles’ positions\n  within the neighborhood of the central node and the deformation\n  gradient, the approximated relative separation will coincide with the\n  actual relative separation of the particles i and j in the deformed\n  configuration.  This compute is only really useful for debugging the\n  hourglass control mechanism which is part of the Total-Lagrangian SPH\n  pair style.\n  See this PDF guide to use Smooth\n  Mach Dynamics in LAMMPS.\n  Output Info:\n  This compute calculates a per-particle vector, which can be accessed\n  by any command that uses per-particle values from a compute as input.\n  See the Howto output doc page for an overview of\n  LAMMPS output options.\n  The per-particle vector values will are dimensionless. See\n  units.\n  ",
    "syntax": "compute ID group-ID smd/hourglass/error\n  \n  \n  \n  ID, group-ID are documented in compute command\n  smd/hourglass/error = style name of this compute command\n  \n  ",
    "examples": "compute 1 all smd/hourglass/error\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  This quantity will be computed only for particles which interact with\n  tlsph pair style.\n  Related Commands:\n  smd/tlsph_defgrad\n  "
},
{
    "command": "compute smd/internal/energy",
    "description": "Define a computation which outputs the per-particle enthalpy, i.e.,\n  the sum of potential energy and heat.\n  See this PDF guide to use Smooth\n  Mach Dynamics in LAMMPS.\n  Output Info:\n  This compute calculates a per-particle vector, which can be accessed\n  by any command that uses per-particle values from a compute as input.\n  See the Howto output doc page for an overview of\n  LAMMPS output options.\n  The per-particle vector values will be given in units of energy.\n  ",
    "syntax": "compute ID group-ID smd/internal/energy\n  \n  \n  \n  ID, group-ID are documented in compute command\n  smd/smd/internal/energy = style name of this compute command\n  \n  ",
    "examples": "compute 1 all smd/internal/energy\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info. This compute can\n  only be used for particles which interact via the updated Lagrangian\n  or total Lagrangian SPH pair styles.\n  Related Commands:\n  "
},
{
    "command": "compute smd/plastic/strain",
    "description": "Define a computation that outputs the equivalent plastic strain per\n  particle.  This command is only meaningful if a material model with\n  plasticity is defined.\n  See this PDF guide to use Smooth\n  Mach Dynamics in LAMMPS.\n  Output Info:\n  This compute calculates a per-particle vector, which can be accessed\n  by any command that uses per-particle values from a compute as input.\n  See the Howto output doc page for an overview of\n  LAMMPS output options.\n  The per-particle values will be given dimensionless. See units.\n  ",
    "syntax": "compute ID group-ID smd/plastic/strain\n  \n  \n  \n  ID, group-ID are documented in compute command\n  smd/plastic/strain = style name of this compute command\n  \n  ",
    "examples": "compute 1 all smd/plastic/strain\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info. This compute can\n  only be used for particles which interact via the updated Lagrangian\n  or total Lagrangian SPH pair styles.\n  "
},
{
    "command": "compute smd/plastic/strain/rate",
    "description": "Define a computation that outputs the time rate of the equivalent\n  plastic strain.  This command is only meaningful if a material model\n  with plasticity is defined.\n  See this PDF guide to use Smooth\n  Mach Dynamics in LAMMPS.\n  Output Info:\n  This compute calculates a per-particle vector, which can be accessed\n  by any command that uses per-particle values from a compute as input.\n  See the Howto output doc page for an overview of\n  LAMMPS output options.\n  The per-particle values will be given in units of one over time.\n  ",
    "syntax": "compute ID group-ID smd/plastic/strain/rate\n  \n  \n  \n  ID, group-ID are documented in compute command\n  smd/plastic/strain/rate = style name of this compute command\n  \n  ",
    "examples": "compute 1 all smd/plastic/strain/rate\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info. This compute can\n  only be used for particles which interact via the updated Lagrangian\n  or total Lagrangian SPH pair styles.\n  "
},
{
    "command": "compute smd/rho",
    "description": "Define a computation that calculates the per-particle mass density.\n  The mass density is the mass of a particle which is constant during\n  the course of a simulation, divided by its volume, which can change\n  due to mechanical deformation.\n  See this PDF guide to use Smooth\n  Mach Dynamics in LAMMPS.\n  Output info:\n  This compute calculates a per-particle vector, which can be accessed\n  by any command that uses per-particle values from a compute as input.\n  See the Howto output doc page for an overview of\n  LAMMPS output options.\n  The per-particle values will be in units of mass over volume.\n  ",
    "syntax": "compute ID group-ID smd/rho\n  \n  \n  \n  ID, group-ID are documented in compute command\n  smd/rho = style name of this compute command\n  \n  ",
    "examples": "compute 1 all smd/rho\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-SMD package. It is only enabled if\n  LAMMPS was built with that package. See the Build package doc page for more info.\n  "
},
{
    "command": "compute smd/tlsph/defgrad",
    "description": "Define a computation that calculates the deformation gradient.  It is\n  only meaningful for particles which interact according to the\n  Total-Lagrangian SPH pair style.\n  See this PDF guide to use Smooth\n  Mach Dynamics in LAMMPS.\n  Output info:\n  This compute outputs a per-particle vector of vectors (tensors),\n  which can be accessed by any command that uses per-particle values\n  from a compute as input. See the Howto output doc\n  page for an overview of LAMMPS output options.\n  The per-particle vector values will be given dimensionless. See\n  units.  The per-particle vector has 10 entries. The first\n  nine entries correspond to the xx, xy, xz, yx, yy, yz, zx, zy, zz\n  components of the asymmetric deformation gradient tensor. The tenth\n  entry is the determinant of the deformation gradient.\n  ",
    "syntax": "compute ID group-ID smd/tlsph/defgrad\n  \n  \n  \n  ID, group-ID are documented in compute command\n  smd/tlsph/defgrad = style name of this compute command\n  \n  ",
    "examples": "compute 1 all smd/tlsph/defgrad\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package. See the Build package doc page for more info. TThis compute can\n  only be used for particles which interact via the total Lagrangian SPH\n  pair style.\n  "
},
{
    "command": "compute smd/tlsph/dt",
    "description": "Define a computation that outputs the CFL-stable time increment per\n  particle.  This time increment is essentially given by the speed of\n  sound, divided by the SPH smoothing length.  Because both the speed of\n  sound and the smoothing length typically change during the course of a\n  simulation, the stable time increment needs to be re-computed every\n  time step.  This calculation is performed automatically in the\n  relevant SPH pair styles and this compute only serves to make the\n  stable time increment accessible for output purposes.\n  See this PDF guide to using Smooth\n  Mach Dynamics in LAMMPS.\n  Output info:\n  This compute calculates a per-particle vector, which can be accessed\n  by any command that uses per-particle values from a compute as input.\n  See the Howto output doc page for an overview of\n  LAMMPS output options.\n  The per-particle values will be given in units of time.\n  ",
    "syntax": "compute ID group-ID smd/tlsph/dt\n  \n  \n  \n  ID, group-ID are documented in compute command\n  smd/tlsph/dt = style name of this compute command\n  \n  ",
    "examples": "compute 1 all smd/tlsph/dt\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  This compute can only be used for particles interacting with the\n  Total-Lagrangian SPH pair style.\n  "
},
{
    "command": "compute smd/tlsph/num/neighs",
    "description": "Define a computation that calculates the number of particles inside of\n  the smoothing kernel radius for particles interacting via the\n  Total-Lagrangian SPH pair style.\n  See this PDF guide to using Smooth\n  Mach Dynamics in LAMMPS.\n  Output info:\n  This compute calculates a per-particle vector, which can be accessed\n  by any command that uses per-particle values from a compute as input.\n  See the Howto output doc page for an overview of\n  LAMMPS output options.\n  The per-particle values are dimensionless. See units.\n  ",
    "syntax": "compute ID group-ID smd/tlsph/num/neighs\n  \n  \n  \n  ID, group-ID are documented in compute command\n  smd/tlsph/num/neighs = style name of this compute command\n  \n  ",
    "examples": "compute 1 all smd/tlsph/num/neighs\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  This quantity will be computed only for particles which interact with\n  the Total-Lagrangian pair style.\n  "
},
{
    "command": "compute smd/tlsph/shape",
    "description": "Define a computation that outputs the current shape of the volume\n  associated with a particle as a rotated ellipsoid.  It is only\n  meaningful for particles which interact according to the\n  Total-Lagrangian SPH pair style.\n  See this PDF guide to use Smooth\n  Mach Dynamics in LAMMPS.\n  Output info:\n  This compute calculates a per-particle vector of vectors, which can be\n  accessed by any command that uses per-particle values from a compute\n  as input. See the Howto output doc page for an\n  overview of LAMMPS output options.\n  The per-particle vector has 7 entries. The first three entries\n  correspond to the lengths of the ellipsoid’s axes and have units of\n  length.  These axis values are computed as the contact radius times the\n  xx, yy, or zz components of the Green-Lagrange strain tensor\n  associated with the particle.  The next 4 values are quaternions\n  (order: q, x, y, z) which describe the spatial rotation of the\n  particle relative to its initial state.\n  ",
    "syntax": "compute ID group-ID smd/tlsph/shape\n  \n  \n  \n  ID, group-ID are documented in compute command\n  smd/tlsph/shape = style name of this compute command\n  \n  ",
    "examples": "compute 1 all smd/tlsph/shape\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package. See the Build package doc page for more info.\n  This quantity will be computed only for particles which interact with\n  the Total-Lagrangian SPH pair style.\n  "
},
{
    "command": "compute smd/tlsph/strain",
    "description": "Define a computation that calculates the Green-Lagrange strain tensor\n  for particles interacting via the Total-Lagrangian SPH pair style.\n  See this PDF guide to using Smooth\n  Mach Dynamics in LAMMPS.\n  Output info:\n  This compute calculates a per-particle vector of vectors (tensors),\n  which can be accessed by any command that uses per-particle values\n  from a compute as input.  See the Howto output doc\n  page for an overview of LAMMPS output options.\n  The per-particle tensor values will be given dimensionless. See\n  units.\n  The per-particle vector has 6 entries, corresponding to the xx, yy,\n  zz, xy, xz, yz components of the symmetric strain tensor.\n  ",
    "syntax": "compute ID group-ID smd/tlsph/strain\n  \n  \n  \n  ID, group-ID are documented in compute command\n  smd/tlsph/strain = style name of this compute command\n  \n  ",
    "examples": "compute 1 all smd/tlsph/strain\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  This quantity will be computed only for particles which interact with\n  the Total-Lagrangian SPH pair style.\n  "
},
{
    "command": "compute smd/tlsph/strain/rate",
    "description": "Define a computation that calculates the rate of the strain tensor for\n  particles interacting via the Total-Lagrangian SPH pair style.\n  See this PDF guide to using Smooth\n  Mach Dynamics in LAMMPS.\n  Output info:\n  This compute calculates a per-particle vector of vectors (tensors),\n  which can be accessed by any command that uses per-particle values\n  from a compute as input. See the Howto output doc\n  page for an overview of LAMMPS output options.\n  The values will be given in units of one over time.\n  The per-particle vector has 6 entries, corresponding to the xx, yy,\n  zz, xy, xz, yz components of the symmetric strain rate tensor.\n  ",
    "syntax": "compute ID group-ID smd/tlsph/strain/rate\n  \n  \n  \n  ID, group-ID are documented in compute command\n  smd/tlsph/strain/rate = style name of this compute command\n  \n  ",
    "examples": "compute 1 all smd/tlsph/strain/rate\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  This quantity will be computed only for particles which interact with\n  Total-Lagrangian SPH pair style.\n  "
},
{
    "command": "compute smd/tlsph/stress",
    "description": "Define a computation that outputs the Cauchy stress tensor for\n  particles interacting via the Total-Lagrangian SPH pair style.\n  See this PDF guide to using Smooth\n  Mach Dynamics in LAMMPS.\n  Output info:\n  This compute calculates a per-particle vector of vectors (tensors),\n  which can be accessed by any command that uses per-particle values\n  from a compute as input. See the Howto output doc\n  page for an overview of LAMMPS output options.\n  The values will be given in units of pressure.\n  The per-particle vector has 7 entries. The first six entries\n  correspond to the xx, yy, zz, xy, xz and yz components of the\n  symmetric Cauchy stress tensor. The seventh entry is the second\n  invariant of the stress tensor, i.e., the von Mises equivalent stress.\n  ",
    "syntax": "compute ID group-ID smd/tlsph/stress\n  \n  \n  \n  ID, group-ID are documented in compute command\n  smd/tlsph/stress = style name of this compute command\n  \n  ",
    "examples": "compute 1 all smd/tlsph/stress\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  This quantity will be computed only for particles which interact with\n  the Total-Lagrangian SPH pair style.\n  "
},
{
    "command": "compute smd/triangle/vertices",
    "description": "Define a computation that returns the coordinates of the vertices\n  corresponding to the triangle-elements of a mesh created by the fix smd/wall_surface.\n  See this PDF guide to using Smooth\n  Mach Dynamics in LAMMPS.\n  Output info:\n  This compute returns a per-particle vector of vectors, which can be\n  accessed by any command that uses per-particle values from a compute\n  as input. See the Howto output doc page for an\n  overview of LAMMPS output options.\n  The per-particle vector has nine entries, (x1/y1/z1), (x2/y2/z2), and\n  (x3/y3/z3) corresponding to the first, second, and third vertex of\n  each triangle.\n  It is only meaningful to use this compute for a group of particles\n  which is created via the fix smd/wall_surface command.\n  The output of this compute can be used with the dump2vtk_tris tool to\n  generate a VTK representation of the smd/wall_surface mesh for\n  visualization purposes.\n  The values will be given in units of distance.\n  ",
    "syntax": "compute ID group-ID smd/triangle/vertices\n  \n  \n  \n  ID, group-ID are documented in compute command\n  smd/triangle/vertices = style name of this compute command\n  \n  ",
    "examples": "compute 1 all smd/triangle/mesh/vertices\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute smd/ulsph/num/neighs",
    "description": "Define a computation that returns the number of neighbor particles\n  inside of the smoothing kernel radius for particles interacting via\n  the updated Lagrangian SPH pair style.\n  See this PDF guide to using Smooth\n  Mach Dynamics in LAMMPS.\n  Output info:\n  This compute returns a per-particle vector, which can be accessed by\n  any command that uses per-particle values from a compute as input.\n  See the Howto output doc page for an overview of\n  LAMMPS output options.\n  The per-particle values will be given dimensionless, see units.\n  ",
    "syntax": "compute ID group-ID smd/ulsph/num/neighs\n  \n  \n  \n  ID, group-ID are documented in compute command\n  smd/ulsph/num/neighs = style name of this compute command\n  \n  ",
    "examples": "compute 1 all smd/ulsph/num/neighs\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.  This compute can\n  only be used for particles which interact with the updated Lagrangian\n  SPH pair style.\n  "
},
{
    "command": "compute smd/ulsph/strain",
    "description": "Define a computation that outputs the logarithmic strain tensor.  for\n  particles interacting via the updated Lagrangian SPH pair style.\n  See this PDF guide to using Smooth\n  Mach Dynamics in LAMMPS.\n  Output info:\n  This compute calculates a per-particle tensor, which can be accessed\n  by any command that uses per-particle values from a compute as input.\n  See the Howto output doc page for an overview of\n  LAMMPS output options.\n  The per-particle vector has 6 entries, corresponding to the xx, yy,\n  zz, xy, xz, yz components of the symmetric strain rate tensor.\n  The per-particle tensor values will be given dimensionless, see\n  units.\n  ",
    "syntax": "compute ID group-ID smd/ulsph/strain\n  \n  \n  \n  ID, group-ID are documented in compute command\n  smd/ulsph/strain = style name of this compute command\n  \n  ",
    "examples": "compute 1 all smd/ulsph/strain\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package. See the Build package doc page for more info. This compute can\n  only be used for particles which interact with the updated Lagrangian\n  SPH pair style.\n  "
},
{
    "command": "compute smd/ulsph/strain/rate",
    "description": "Define a computation that outputs the rate of the logarithmic strain\n  tensor for particles interacting via the updated Lagrangian SPH pair\n  style.\n  See this PDF guide to using Smooth\n  Mach Dynamics in LAMMPS.\n  Output info:\n  This compute calculates a per-particle vector of vectors (tensors),\n  which can be accessed by any command that uses per-particle values\n  from a compute as input. See the Howto output doc\n  page for an overview of LAMMPS output options.\n  The values will be given in units of one over time.\n  The per-particle vector has 6 entries, corresponding to the xx, yy,\n  zz, xy, xz, yz components of the symmetric strain rate tensor.\n  ",
    "syntax": "compute ID group-ID smd/ulsph/strain/rate\n  \n  \n  \n  ID, group-ID are documented in compute command\n  smd/ulsph/strain/rate = style name of this compute command\n  \n  ",
    "examples": "compute 1 all smd/ulsph/strain/rate\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  This compute can only be used for particles which interact with the\n  updated Lagrangian SPH pair style.\n  "
},
{
    "command": "compute smd/ulsph/stress",
    "description": "Define a computation that outputs the Cauchy stress tensor.\n  See this PDF guide to using Smooth\n  Mach Dynamics in LAMMPS.\n  Output info:\n  This compute calculates a per-particle vector of vectors (tensors),\n  which can be accessed by any command that uses per-particle values\n  from a compute as input. See the Howto output doc\n  page for an overview of LAMMPS output options.\n  The values will be given in units of pressure.\n  The per-particle vector has 7 entries. The first six entries\n  correspond to the xx, yy, zz, xy, xz, yz components of the symmetric\n  Cauchy stress tensor. The seventh entry is the second invariant of the\n  stress tensor, i.e., the von Mises equivalent stress.\n  ",
    "syntax": "compute ID group-ID smd/ulsph/stress\n  \n  \n  \n  ID, group-ID are documented in compute command\n  smd/ulsph/stress = style name of this compute command\n  \n  ",
    "examples": "compute 1 all smd/ulsph/stress\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package. See the Build package doc page for more info. This compute can\n  only be used for particles which interact with the updated Lagrangian\n  SPH pair style.\n  "
},
{
    "command": "compute smd/vol",
    "description": "Define a computation that provides the per-particle volume and the sum\n  of the per-particle volumes of the group for which the fix is defined.\n  See this PDF guide to using Smooth\n  Mach Dynamics in LAMMPS.\n  Output info:\n  This compute calculates a per-particle vector, which can be accessed\n  by any command that uses per-particle values from a compute as input.\n  See the Howto output doc page for an overview of\n  LAMMPS output options.\n  The per-particle vector values will be given in units of\n  volume.\n  Additionally, the compute returns a scalar, which is the sum of the\n  per-particle volumes of the group for which the fix is defined.\n  ",
    "syntax": "compute ID group-ID smd/vol\n  \n  \n  \n  ID, group-ID are documented in compute command\n  smd/vol = style name of this compute command\n  \n  ",
    "examples": "compute 1 all smd/vol\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package. See the Build package doc page for more info.\n  "
},
{
    "command": "compute sna/atom",
    "description": "Define a computation that calculates a set of quantities related to the\n  bispectrum components of the atoms in a group. These computes are\n  used primarily for calculating the dependence of energy, force, and\n  stress components on the linear coefficients in the\n  snap pair_style, which is useful when training a\n  SNAP potential to match target data.\n  Bispectrum components of an atom are order parameters characterizing\n  the radial and angular distribution of neighbor atoms. The detailed\n  mathematical definition is given in the paper by Thompson et\n  al. (Thompson)\n  The position of a neighbor atom i’ relative to a central atom i is\n  a point within the 3D ball of radius R_ii’ = rcutfac*(R_i + R_i’)\n  Bartok et al. (Bartok), proposed mapping this 3D ball\n  onto the 3-sphere, the surface of the unit ball in a four-dimensional\n  space.  The radial distance r within R_ii’ is mapped on to a third\n  polar angle theta0 defined by,\n  \n  \\[\\theta_0 = {\\tt rfac0} \\frac{r-r_{min0}}{R_{ii'}-r_{min0}} \\pi\\]\n  In this way, all possible neighbor positions are mapped on to a subset\n  of the 3-sphere.  Points south of the latitude theta0max=rfac0*Pi\n  are excluded.\n  The natural basis for functions on the 3-sphere is formed by the 4D\n  hyperspherical harmonics U^j_m,m’(theta, phi, theta0).  These\n  functions are better known as D^j_m,m’, the elements of the Wigner\n  D-matrices (Meremianin,\n  Varshalovich).\n  The density of neighbors on the 3-sphere can be written as a sum of\n  Dirac-delta functions, one for each neighbor, weighted by species and\n  radial distance. Expanding this density function as a generalized\n  Fourier series in the basis functions, we can write each Fourier\n  coefficient as\n  \n  \\[u^j_{m,m'} = U^j_{m,m'}(0,0,0) + \\sum_{r_{ii'} < R_{ii'}}{f_c(r_{ii'}) w_{i'} U^j_{m,m'}(\\theta_0,\\theta,\\phi)}\\]\n  The w_i’ neighbor weights are dimensionless numbers that are chosen\n  to distinguish atoms of different types, while the central atom is\n  arbitrarily assigned a unit weight.  The function fc(r) ensures that\n  the contribution of each neighbor atom goes smoothly to zero at\n  R_ii’:\n  \n  \\[\\begin{split}f_c(r)   = & \\frac{1}{2}(\\cos(\\pi \\frac{r-r_{min0}}{R_{ii'}-r_{min0}}) + 1), r \\leq R_{ii'} \\\\\n           = & 0,  r > R_{ii'}\\end{split}\\]\n  The expansion coefficients u^j_m,m’ are complex-valued and they are\n  not directly useful as descriptors, because they are not invariant\n  under rotation of the polar coordinate frame. However, the following\n  scalar triple products of expansion coefficients can be shown to be\n  real-valued and invariant under rotation (Bartok).\n  \n  \\[\\begin{split}B_{j_1,j_2,j}  =\n  \\sum_{m_1,m'_1=-j_1}^{j_1}\\sum_{m_2,m'_2=-j_2}^{j_2}\\sum_{m,m'=-j}^{j} (u^j_{m,m'})^*\n  H {\\scriptscriptstyle \\begin{array}{l} {j} {m} {m'} \\\\\n       {j_1} {m_1} {m'_1} \\\\\n       {j_2} {m_2} {m'_2} \\end{array}}\n       u^{j_1}_{m_1,m'_1} u^{j_2}_{m_2,m'_2}\\end{split}\\]\n  The constants H^jmm’_j1m1m1’_j2m2m2’ are coupling coefficients,\n  analogous to Clebsch-Gordan coefficients for rotations on the\n  2-sphere. These invariants are the components of the bispectrum and\n  these are the quantities calculated by the compute sna/atom. They\n  characterize the strength of density correlations at three points on\n  the 3-sphere. The j2=0 subset form the power spectrum, which\n  characterizes the correlations of two points. The lowest-order\n  components describe the coarsest features of the density function,\n  while higher-order components reflect finer detail.  Note that the\n  central atom is included in the expansion, so three point-correlations\n  can be either due to three neighbors, or two neighbors and the central\n  atom.\n  Compute snad/atom calculates the derivative of the bispectrum components\n  summed separately for each atom type:\n  \n  \\[-\\sum_{i' \\in I} \\frac{\\partial {B^{i'}_{j_1,j_2,j}  }}{\\partial {\\bf r}_i}\\]\n  The sum is over all atoms i’ of atom type I.  For each atom i,\n  this compute evaluates the above expression for each direction, each\n  atom type, and each bispectrum component.  See section below on output\n  for a detailed explanation.\n  Compute snav/atom calculates the virial contribution due to the\n  derivatives:\n  \n  \\[-{\\bf r}_i \\otimes \\sum_{i' \\in I} \\frac{\\partial {B^{i'}_{j_1,j_2,j}}}{\\partial {\\bf r}_i}\\]\n  Again, the sum is over all atoms i’ of atom type I.  For each atom\n  i, this compute evaluates the above expression for each of the six\n  virial components, each atom type, and each bispectrum component.  See\n  section below on output for a detailed explanation.\n  Compute snap calculates a global array contains information related\n  to all three of the above per-atom computes sna/atom, snad/atom,\n  and snav/atom. The first row of the array contains the summation of\n  sna/atom over all atoms, but broken out by type. The last six rows\n  of the array contain the summation of snav/atom over all atoms, broken\n  out by type. In between these are 3*N rows containing the same values\n  computed by snad/atom (these are already summed over all atoms and\n  broken out by type). The element in the last column of each row contains\n  the potential energy, force, or stress, according to the row.\n  These quantities correspond to the user-specified reference potential\n  that must be subtracted from the target data when fitting SNAP.\n  The potential energy calculation uses the built in compute thermo_pe.\n  The stress calculation uses a compute called snap_press that is\n  automatically created behind the scenes, according to the following\n  command:\n  compute snap_press all pressure NULL virial\n  \n  \n  See section below on output for a detailed explanation of the data\n  layout in the global array.\n  The value of all bispectrum components will be zero for atoms not in\n  the group. Neighbor atoms not in the group do not contribute to the\n  bispectrum of atoms in the group.\n  The neighbor list needed to compute this quantity is constructed each\n  time the calculation is performed (i.e. each time a snapshot of atoms\n  is dumped).  Thus it can be inefficient to compute/dump this quantity\n  too frequently.\n  The argument rcutfac is a scale factor that controls the ratio of\n  atomic radius to radial cutoff distance.\n  The argument rfac0 and the optional keyword rmin0 define the\n  linear mapping from radial distance to polar angle theta0 on the\n  3-sphere.\n  The argument twojmax defines which\n  bispectrum components are generated. See section below on output for a\n  detailed explanation of the number of bispectrum components and the\n  ordered in which they are listed.\n  The keyword switchflag can be used to turn off the switching\n  function.\n  The keyword bzeroflag determines whether or not B0, the bispectrum\n  components of an atom with no neighbors, are subtracted from\n  the calculated bispectrum components. This optional keyword\n  normally only affects compute sna/atom. However, when\n  quadraticflag is on, it also affects snad/atom and snav/atom.\n  The keyword quadraticflag determines whether or not the\n  quadratic analogs to the bispectrum quantities are generated.\n  These are formed by taking the outer product of the vector\n  of bispectrum components with itself.\n  See section below on output for a\n  detailed explanation of the number of quadratic terms and the\n  ordered in which they are listed.\n  \n  Note\n  If you have a bonded system, then the settings of\n  special_bonds command can remove pairwise\n  interactions between atoms in the same bond, angle, or dihedral.  This\n  is the default setting for the special_bonds\n  command, and means those pairwise interactions do not appear in the\n  neighbor list.  Because this fix uses the neighbor list, it also means\n  those pairs will not be included in the calculation.  One way to get\n  around this, is to write a dump file, and use the rerun\n  command to compute the bispectrum components for snapshots in the dump\n  file.  The rerun script can use a special_bonds\n  command that includes all pairs in the neighbor list.\n  \n  \n  Output info:\n  Compute sna/atom calculates a per-atom array, each column\n  corresponding to a particular bispectrum component.  The total number\n  of columns and the identity of the bispectrum component contained in\n  each column depend of the value of twojmax, as\n  described by the following piece of python code:\n  for j1 in range(0,twojmax+1):\n      for j2 in range(0,j1+1):\n          for j in range(j1-j2,min(twojmax,j1+j2)+1,2):\n              if (j>=j1): print j1/2.,j2/2.,j/2.\n  \n  \n  \n  Note\n  the diagonal keyword allowing other possible choices\n  for the number of bispectrum components was removed in 2019,\n  since all potentials use the value of 3, corresponding to the\n  above set of bispectrum components.\n  \n  Compute snad/atom evaluates a per-atom array. The columns are\n  arranged into ntypes blocks, listed in order of atom type I.  Each\n  block contains three sub-blocks corresponding to the x, y, and z\n  components of the atom position.  Each of these sub-blocks contains\n  one column for each bispectrum component, the same as for compute\n  sna/atom\n  Compute snav/atom evaluates a per-atom array. The columns are\n  arranged into ntypes blocks, listed in order of atom type I.  Each\n  block contains six sub-blocks corresponding to the xx, yy, zz,\n  yz, xz, and xy components of the virial tensor in Voigt\n  notation.  Each of these sub-blocks contains one column for each\n  bispectrum component, the same as for compute sna/atom\n  Compute snap evaluates a global array.\n  The columns are arranged into\n  ntypes blocks, listed in order of atom type I. Each block\n  contains one column for each bispectrum component, the same as for compute\n  sna/atom. A final column contains the corresponding energy, force component\n  on an atom, or virial stress component. The rows of the array appear\n  in the following order:\n  \n  1 row: sna/atom quantities summed for all atoms of type I\n  3*N rows: snad/atom quantities, with derivatives w.r.t. x, y, and z coordinate of atom i appearing in consecutive rows. The atoms are sorted based on atom ID.\n  6 rows: snav/atom quantities summed for all atoms of type I\n  \n  For example, if K =30 and ntypes=1, the number of columns in the per-atom\n  arrays generated by sna/atom, snad/atom, and snav/atom\n  are 30, 90, and 180, respectively. With quadratic value=1,\n  the numbers of columns are 930, 2790, and 5580, respectively.\n  The number of columns in the global array generated by snap\n  are 31, and 931, respectively, while the number of rows is\n  1+3*N+6, where N is the total number of atoms.\n  If the quadratic keyword value is set to 1, then additional\n  columns are generated, corresponding to\n  the products of all distinct pairs of  bispectrum components. If the\n  number of bispectrum components is K, then the number of distinct pairs\n  is  K(K+1)/2.\n  For compute sna/atom these columns are appended to existing K columns.\n  The ordering of quadratic terms is upper-triangular,\n  (1,1),(1,2)…(1,K),(2,1)…(K-1,K-1),(K-1,K),(K,K).\n  For computes snad/atom and snav/atom each set of K(K+1)/2\n  additional columns is inserted directly after each of sub-block\n  of linear terms i.e. linear and quadratic terms are contiguous.\n  So the nesting order from inside to outside is bispectrum component,\n  linear then quadratic, vector/tensor component, type.\n  These values can be accessed by any command that uses per-atom values\n  from a compute as input.  See the Howto output doc\n  page for an overview of LAMMPS output options.\n  ",
    "syntax": "compute ID group-ID sna/atom rcutfac rfac0 twojmax R_1 R_2 ... w_1 w_2 ... keyword values ...\n  compute ID group-ID snad/atom rcutfac rfac0 twojmax R_1 R_2 ... w_1 w_2 ... keyword values ...\n  compute ID group-ID snav/atom rcutfac rfac0 twojmax R_1 R_2 ... w_1 w_2 ... keyword values ...\n  compute ID group-ID snap rcutfac rfac0 twojmax R_1 R_2 ... w_1 w_2 ... keyword values ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  sna/atom = style name of this compute command\n  rcutfac = scale factor applied to all cutoff radii (positive real)\n  rfac0 = parameter in distance to angle conversion (0 < rcutfac < 1)\n  twojmax = band limit for bispectrum components (non-negative integer)\n  R_1, R_2,… = list of cutoff radii, one for each type (distance units)\n  w_1, w_2,… = list of neighbor weights, one for each type\n  zero or more keyword/value pairs may be appended\n  keyword = rmin0 or switchflag or bzeroflag or quadraticflag\n  rmin0 value = parameter in distance to angle conversion (distance units)\n  switchflag value = 0 or 1\n     0 = do not use switching function\n     1 = use switching function\n  bzeroflag value = 0 or 1\n     0 = do not subtract B0\n     1 = subtract B0\n  quadraticflag value = 0 or 1\n     0 = do not generate quadratic terms\n     1 = generate quadratic terms\n  \n  \n  ",
    "examples": "compute b all sna/atom 1.4 0.99363 6 2.0 2.4 0.75 1.0 rmin0 0.0\n  compute db all sna/atom 1.4 0.95 6 2.0 1.0\n  compute vb all sna/atom 1.4 0.95 6 2.0 1.0\n  compute snap all snap 1.4 0.95 6 2.0 1.0\n  \n  \n  ",
    "restrictions": "These computes are part of the SNAP package.  They are only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute spin",
    "description": "Define a computation that calculates magnetic quantities for a system\n  of atoms having spins.\n  This compute calculates the following 6 magnetic quantities:\n  \n  the three first quantities are the x,y and z coordinates of the total\n  magnetization,\n  the fourth quantity is the norm of the total magnetization,\n  The fifth quantity is the magnetic energy (in eV),\n  The sixth one is referred to as the spin temperature, according\n  to the work of (Nurdin).\n  \n  The simplest way to output the results of the compute spin calculation\n  is to define some of the quantities as variables, and to use the thermo and\n  thermo_style commands, for example:\n  compute out_mag         all spin\n  \n  variable mag_z          equal c_out_mag[3]\n  variable mag_norm       equal c_out_mag[4]\n  variable temp_mag       equal c_out_mag[6]\n  \n  thermo                  10\n  thermo_style            custom step v_mag_z v_mag_norm v_temp_mag\n  \n  \n  This series of commands evaluates the total magnetization along z, the norm of\n  the total magnetization, and the magnetic temperature. Three variables are\n  assigned to those quantities. The thermo and thermo_style commands print them\n  every 10 timesteps.\n  Output info:\n  The array values are “intensive”.  The array values will be in\n  metal units (units).\n  ",
    "syntax": "compute ID group-ID spin\n  \n  \n  \n  ID, group-ID are documented in compute command\n  spin = style name of this compute command\n  \n  ",
    "examples": "compute out_mag all spin\n  \n  \n  ",
    "restrictions": "The spin compute is part of the SPIN package.  This compute is only\n  enabled if LAMMPS was built with this package.  See the Build package doc page for more info.  The atom_style\n  has to be “spin” for this compute to be valid.\n  Related commands:\n  none\n  Default:\n  none\n  \n  (Nurdin) Nurdin and Schotte Phys Rev E, 61(4), 3579 (2000)\n  "
},
{
    "command": "compute stress/atom",
    "description": "Define a computation that computes per-atom stress\n  tensor for each atom in a group.  In case of compute stress/atom,\n  the tensor for each atom is symmetric with 6\n  components and is stored as a 6-element vector in the following order:\n  \\(xx\\), \\(yy\\), \\(zz\\), \\(xy\\), \\(xz\\), \\(yz\\).\n  In case of compute centroid/stress/atom,\n  the tensor for each atom is asymmetric with 9 components\n  and is stored as a 9-element vector in the following order:\n  \\(xx\\), \\(yy\\), \\(zz\\), \\(xy\\), \\(xz\\), \\(yz\\),\n  \\(yx\\), \\(zx\\), \\(zy\\).\n  See the compute pressure command if you want the stress tensor\n  (pressure) of the entire system.\n  The stress tensor for atom \\(I\\) is given by the following formula,\n  where \\(a\\) and \\(b\\) take on values \\(x\\), \\(y\\), \\(z\\)\n  to generate the components of the tensor:\n  \n  \\[S_{ab}  =  - m v_a v_b - W_{ab}\\]\n  The first term is a kinetic energy contribution for atom \\(I\\).  See\n  details below on how the specified temp-ID can affect the velocities\n  used in this calculation. The second term is the virial\n  contribution due to intra and intermolecular interactions,\n  where the exact computation details are determined by the compute style.\n  In case of compute stress/atom, the virial contribution is:\n  \n  \\[\\begin{split} W_{ab} & = \\frac{1}{2} \\sum_{n = 1}^{N_p} (r_{1_a} F_{1_b} + r_{2_a} F_{2_b}) + \\frac{1}{2} \\sum_{n = 1}^{N_b} (r_{1_a} F_{1_b} + r_{2_a} F_{2_b})  \\\\\n  & + \\frac{1}{3} \\sum_{n = 1}^{N_a} (r_{1_a} F_{1_b} + r_{2_a} F_{2_b} + r_{3_a} F_{3_b}) + \\frac{1}{4} \\sum_{n = 1}^{N_d} (r_{1_a} F_{1_b} + r_{2_a} F_{2_b} + r_{3_a} F_{3_b} + r_{4_a} F_{4_b}) \\\\\n  & + \\frac{1}{4} \\sum_{n = 1}^{N_i} (r_{1_a} F_{1_b} + r_{2_a} F_{2_b} + r_{3_a} F_{3_b} + r_{4_a} F_{4_b}) + {\\rm Kspace}(r_{i_a},F_{i_b}) + \\sum_{n = 1}^{N_f} r_{i_a} F_{i_b}\\end{split}\\]\n  The first term is a pairwise energy\n  contribution where \\(n\\) loops over the \\(N_p\\)\n  neighbors of atom \\(I\\), \\(\\mathbf{r}_1\\) and \\(\\mathbf{r}_2\\)\n  are the positions of the 2 atoms in the pairwise interaction,\n  and \\(\\mathbf{F}_1\\) and \\(\\mathbf{F}_2\\) are the forces\n  on the 2 atoms resulting from the pairwise interaction.\n  The second term is a bond contribution of\n  similar form for the \\(N_b\\) bonds which atom \\(I\\) is part of.\n  There are similar terms for the \\(N_a\\) angle, \\(N_d\\) dihedral,\n  and \\(N_i\\) improper interactions atom \\(I\\) is part of.\n  There is also a term for the KSpace\n  contribution from long-range Coulombic interactions, if defined.\n  Finally, there is a term for the \\(N_f\\) fixes that apply\n  internal constraint forces to atom \\(I\\). Currently, only the\n  fix shake and fix rigid commands\n  contribute to this term.\n  As the coefficients in the formula imply, a virial contribution\n  produced by a small set of atoms (e.g. 4 atoms in a dihedral or 3\n  atoms in a Tersoff 3-body interaction) is assigned in equal portions\n  to each atom in the set.  E.g. 1/4 of the dihedral virial to each of\n  the 4 atoms, or 1/3 of the fix virial due to SHAKE constraints applied\n  to atoms in a water molecule via the fix shake\n  command.\n  In case of compute centroid/stress/atom, the virial contribution is:\n  \n  \\[\\begin{split} W_{ab} & = \\sum_{n = 1}^{N_p} r_{I0_a} F_{I_b} + \\sum_{n = 1}^{N_b} r_{I0_a} F_{I_b} + \\sum_{n = 1}^{N_a} r_{I0_a}  F_{I_b} + \\sum_{n = 1}^{N_d} r_{I0_a} F_{I_b} + \\sum_{n = 1}^{N_i} r_{I0_a} F_{I_b} \\\\\n  & + {\\rm Kspace}(r_{i_a},F_{i_b}) + \\sum_{n = 1}^{N_f} r_{i_a} F_{i_b}\\end{split}\\]\n  As with compute stress/atom, the first, second, third, fourth and fifth terms\n  are pairwise, bond, angle, dihedral and improper contributions,\n  but instead of assigning the virial contribution equally to each atom,\n  only the force \\(\\mathbf{F}_I\\) acting on atom \\(I\\)\n  due to the interaction and the relative\n  position \\(\\mathbf{r}_{I0}\\) of the atom \\(I\\) to the geometric center\n  of the interacting atoms, i.e. centroid, is used.\n  As the geometric center is different\n  for each interaction, the \\(\\mathbf{r}_{I0}\\) also differs.\n  The sixth and seventh terms, Kspace and fix contribution\n  respectively, are computed identical to compute stress/atom.\n  Although the total system virial is the same as compute stress/atom,\n  compute centroid/stress/atom is know to result in more consistent\n  heat flux values for angle, dihedrals and improper contributions\n  when computed via compute heat/flux.\n  If no extra keywords are listed, the kinetic contribution\n  all of the virial contribution terms are\n  included in the per-atom stress tensor.  If any extra keywords are\n  listed, only those terms are summed to compute the tensor.  The\n  virial keyword means include all terms except the kinetic energy\n  ke.\n  Note that the stress for each atom is due to its interaction with all\n  other atoms in the simulation, not just with other atoms in the group.\n  Details of how compute stress/atom obtains the virial for individual atoms for\n  either pairwise or many-body potentials, and including the effects of\n  periodic boundary conditions is discussed in (Thompson).\n  The basic idea for many-body potentials is to treat each component of\n  the force computation between a small cluster of atoms in the same\n  manner as in the formula above for bond, angle, dihedral, etc\n  interactions.  Namely the quantity \\(\\mathbf{r} \\cdot \\mathbf{F}\\)\n  is summed over the atoms in\n  the interaction, with the \\(r\\) vectors unwrapped by periodic boundaries\n  so that the cluster of atoms is close together.  The total\n  contribution for the cluster interaction is divided evenly among those\n  atoms. Details of how compute centroid/stress/atom obtains\n  the virial for individual atoms\n  is given in (Surblys),\n  where the idea is that the virial of the atom \\(I\\)\n  is the result of only the force \\(\\mathbf{F}_I\\) on the atom due\n  to the interaction\n  and its positional vector \\(\\mathbf{r}_{I0}\\),\n  relative to the geometric center of the\n  interacting atoms, regardless of the number of participating atoms.\n  The periodic boundary treatment is identical to\n  that of compute stress/atom, and both of them reduce to identical\n  expressions for two-body interactions,\n  i.e. computed values for contributions from bonds and two-body pair styles,\n  such as Lennard-Jones, will be the same,\n  while contributions from angles, dihedrals and impropers will be different.\n  The dihedral_style charmm style calculates\n  pairwise interactions between 1-4 atoms.  The virial contribution of\n  these terms is included in the pair virial, not the dihedral virial.\n  The KSpace contribution is calculated using the method in\n  (Heyes) for the Ewald method and by the methodology described\n  in (Sirk) for PPPM.  The choice of KSpace solver is specified\n  by the kspace_style pppm command.  Note that for\n  PPPM, the calculation requires 6 extra FFTs each timestep that\n  per-atom stress is calculated.  Thus it can significantly increase the\n  cost of the PPPM calculation if it is needed on a large fraction of\n  the simulation timesteps.\n  The temp-ID argument can be used to affect the per-atom velocities\n  used in the kinetic energy contribution to the total stress.  If the\n  kinetic energy is not included in the stress, than the temperature\n  compute is not used and can be specified as NULL.  If the kinetic\n  energy is included and you wish to use atom velocities as-is, then\n  temp-ID can also be specified as NULL.  If desired, the specified\n  temperature compute can be one that subtracts off a bias to leave each\n  atom with only a thermal velocity to use in the formula above, e.g. by\n  subtracting a background streaming velocity.  See the doc pages for\n  individual compute commands to determine which ones\n  include a bias.\n  \n  Note that as defined in the formula, per-atom stress is the negative\n  of the per-atom pressure tensor.  It is also really a stress*volume\n  formulation, meaning the computed quantity is in units of\n  pressure*volume.  It would need to be divided by a per-atom volume to\n  have units of stress (pressure), but an individual atom’s volume is\n  not well defined or easy to compute in a deformed solid or a liquid.\n  See the compute voronoi/atom command for\n  one possible way to estimate a per-atom volume.\n  Thus, if the diagonal components of the per-atom stress tensor are\n  summed for all atoms in the system and the sum is divided by \\(dV\\), where\n  \\(d\\) = dimension and \\(V\\) is the volume of the system,\n  the result should be \\(-P\\), where \\(P\\)\n  is the total pressure of the system.\n  These lines in an input script for a 3d system should yield that\n  result. I.e. the last 2 columns of thermo output will be the same:\n  compute        peratom all stress/atom NULL\n  compute        p all reduce sum c_peratom[1] c_peratom[2] c_peratom[3]\n  variable       press equal -(c_p[1]+c_p[2]+c_p[3])/(3*vol)\n  thermo_style   custom step temp etotal press v_press\n  \n  \n  \n  Note\n  The per-atom stress does not include any Lennard-Jones tail\n  corrections to the pressure added by the pair_modify tail yes command, since those are contributions to the\n  global system pressure.\n  \n  Output info:\n  This compute stress/atom calculates a per-atom array with 6 columns, which can be\n  accessed by indices 1-6 by any command that uses per-atom values from\n  a compute as input.\n  The compute centroid/stress/atom produces a per-atom array with 9 columns,\n  but otherwise can be used in an identical manner to compute stress/atom.\n  See the Howto output doc page\n  for an overview of LAMMPS output options.\n  The per-atom array values will be in pressure*volume\n  units as discussed above.\n  ",
    "syntax": "compute ID group-ID style temp-ID keyword ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  style = stress/atom or centroid/stress/atom\n  temp-ID = ID of compute that calculates temperature, can be NULL if not needed\n  zero or more keywords may be appended\n  keyword = ke or pair or bond or angle or dihedral or improper or kspace or fix or virial\n  \n  ",
    "examples": "compute 1 mobile stress/atom NULL\n  compute 1 mobile stress/atom myRamp\n  compute 1 all stress/atom NULL pair bond\n  compute 1 all centroid/stress/atom NULL bond dihedral improper\n  \n  \n  ",
    "restrictions": "Currently, compute centroid/stress/atom does not support\n  pair styles with many-body interactions,\n  such as Tersoff,\n  and LAMMPS will generate an error in such cases.\n  In principal, equivalent formulation\n  to that of angle, dihedral and improper contributions\n  in the virial \\(W_{ab}\\) formula\n  can also be applied to the many-body pair styles,\n  and is planned in the future.\n  "
},
{
    "command": "compute stress/mop",
    "description": "Compute stress/mop and compute stress/mop/profile define computations that\n  calculate components of the local stress tensor using the method of\n  planes (Todd).  Specifically in compute stress/mop calculates 3\n  components are computed in directions dir,x; dir,y; and\n  dir,z; where dir is the direction normal to the plane, while\n  in compute stress/mop/profile the profile of the stress is computed.\n  Contrary to methods based on histograms of atomic stress (i.e. using\n  compute stress/atom), the method of planes is\n  compatible with mechanical balance in heterogeneous systems and at\n  interfaces (Todd).\n  The stress tensor is the sum of a kinetic term and a configurational\n  term, which are given respectively by Eq. (21) and Eq. (16) in\n  (Todd). For the kinetic part, the algorithm considers that\n  atoms have crossed the plane if their positions at times t-dt and t are\n  one on either side of the plane, and uses the velocity at time t-dt/2\n  given by the velocity-Verlet algorithm.\n  Between one and three keywords can be used to indicate which\n  contributions to the stress must be computed: kinetic stress (kin),\n  configurational stress (conf), and/or total stress (total).\n  NOTE 1: The configurational stress is computed considering all pairs of atoms where at least one atom belongs to group group-ID.\n  NOTE 2: The local stress does not include any Lennard-Jones tail\n  corrections to the pressure added by the pair_modify tail yes command, since those are contributions to the global system pressure.\n  Output info:\n  Compute stress/mop calculates a global vector (indices starting at 1), with 3\n  values for each declared keyword (in the order the keywords have been\n  declared). For each keyword, the stress tensor components are ordered as\n  follows: stress_dir,x, stress_dir,y, and stress_dir,z.\n  Compute stress/mop/profile instead calculates a global array, with 1 column\n  giving the position of the planes where the stress tensor was computed,\n  and with 3 columns of values for each declared keyword (in the order the\n  keywords have been declared). For each keyword, the profiles of stress\n  tensor components are ordered as follows: stress_dir,x; stress_dir,y;\n  and stress_dir,z.\n  The values are in pressure units.\n  The values produced by this compute can be accessed by various output commands. For instance, the results can be written to a file using the fix ave/time command. Please see the example in the examples/USER/mop folder.\n  ",
    "syntax": "compute ID group-ID style dir args keywords ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  style = stress/mop or stress/mop/profile\n  dir = x or y or z is the direction normal to the plane\n  args = argument specific to the compute style\n  keywords = kin or conf or total (one of more can be specified)\n  \n    stress/mop args = pos\n      pos = lower or center or upper or coordinate value (distance units) is the position of the plane\n    stress/mop/profile args = origin delta\n      origin = lower or center or upper or coordinate value (distance units) is the position of the first plane\n      delta = value (distance units) is the distance between planes\n  \n  compute 1 all stress/mop x lower total\n  compute 1 liquid stress/mop z 0.0 kin conf\n  fix 1 all ave/time 10 1000 10000 c_1[*] file mop.time\n  fix 1 all ave/time 10 1000 10000 c_1[2] file mop.time\n  \n  compute 1 all stress/mop/profile x lower 0.1 total\n  compute 1 liquid stress/mop/profile z 0.0 0.25 kin conf\n  fix 1 all ave/time 500 20 10000 c_1[*] ave running overwrite file mopp.time mode vector\n  ",
    "examples": "compute 1 mobile stress/atom NULL\n  compute 1 mobile stress/atom myRamp\n  compute 1 all stress/atom NULL pair bond\n  compute 1 all centroid/stress/atom NULL bond dihedral improper\n  \n  \n  ",
    "restrictions": "These styles are part of the USER-MISC package. They are only enabled if\n  LAMMPS is built with that package. See the Build package\n  doc page on for more info.\n  The method is only implemented for 3d orthogonal simulation boxes whose\n  size does not change in time, and axis-aligned planes.\n  The method only works with two-body pair interactions, because it\n  requires the class method pair->single() to be implemented. In\n  particular, it does not work with more than two-body pair interactions,\n  intra-molecular interactions, and long range (kspace) interactions.\n  "
},
{
    "command": "compute force/tally",
    "description": "Define a computation that calculates properties between two groups of\n  atoms by accumulating them from pairwise non-bonded computations.  The\n  two groups can be the same. This is similar to compute group/group only that the data is\n  accumulated directly during the non-bonded force computation. The\n  computes force/tally, pe/tally, stress/tally, and\n  heat/flux/tally are primarily provided as example how to program\n  additional, more sophisticated computes using the tally callback\n  mechanism. Compute pe/mol/tally is one such style, that can\n  - through using this mechanism - separately tally intermolecular\n  and intramolecular energies. Something that would otherwise be\n  impossible without integrating this as a core functionality into\n  the based classes of LAMMPS.\n  \n  The pairwise contributions are computing via a callback that the\n  compute registers with the non-bonded pairwise force computation.\n  This limits the use to systems that have no bonds, no Kspace, and no\n  many-body interactions. On the other hand, the computation does not\n  have to compute forces or energies a second time and thus can be much\n  more efficient. The callback mechanism allows to write more complex\n  pairwise property computations.\n  \n  Output info:\n  Compute pe/tally calculates a global scalar (the energy) and a per\n  atom scalar (the contributions of the single atom to the global\n  scalar). Compute pe/mol/tally calculates a global 4-element vector\n  containing (in this order): evdwl and ecoul for intramolecular pairs\n  and evdwl and ecoul for intermolecular pairs. Since molecules are\n  identified by their molecule IDs, the partitioning does not have to be\n  related to molecules, but the energies are tallied into the respective\n  slots depending on whether the molecule IDs of a pair are the same or\n  different. Compute force/tally calculates a global scalar (the force\n  magnitude) and a per atom 3-element vector (force contribution from\n  each atom).  Compute stress/tally calculates a global scalar\n  (average of the diagonal elements of the stress tensor) and a per atom\n  vector (the 6 elements of stress tensor contributions from the\n  individual atom).\n  Both the scalar and vector values calculated by this compute are\n  “extensive”.\n  ",
    "syntax": "compute ID group-ID style group2-ID\n  \n  \n  \n  ID, group-ID are documented in compute command\n  style = force/tally or pe/tally or pe/mol/tally or stress/tally\n  group2-ID = group ID of second (or same) group\n  \n  ",
    "examples": "compute 1 lower force/tally upper\n  compute 1 left pe/tally right\n  compute 1 lower stress/tally lower\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-TALLY package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  Not all pair styles can be evaluated in a pairwise mode as required by\n  this compute.  For example, 3-body and other many-body potentials,\n  such as Tersoff and\n  Stillinger-Weber cannot be used.  EAM\n  potentials only include the pair potential portion of the EAM\n  interaction when used by this compute, not the embedding term.  Also\n  bonded or Kspace interactions do not contribute to this compute.\n  The computes in this package are not compatible with dynamic groups.\n  "
},
{
    "command": "compute tdpd/cc/atom",
    "description": "Define a computation that calculates the per-atom chemical\n  concentration of a specified species for each tDPD particle in a\n  group.\n  The chemical concentration of each species is defined as the number of\n  molecules carried by a tDPD particle for dilute solution.  For more\n  details see (Li2015).\n  Output info:\n  This compute calculates a per-atom vector, which can be accessed by\n  any command that uses per-atom values from a compute as input. See the\n  Howto output doc page for an overview of LAMMPS\n  output options.\n  The per-atom vector values will be in the units of chemical species\n  per unit mass.\n  ",
    "syntax": "compute ID group-ID tdpd/cc/atom index\n  \n  \n  \n  ID, group-ID are documented in compute command\n  tdpd/cc/atom = style name of this compute command\n  index = index of chemical species (1 to Nspecies)\n  \n  ",
    "examples": "compute 1 all tdpd/cc/atom 2\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-MESODPD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute temp",
    "description": "Define a computation that calculates the temperature of a group of\n  atoms.  A compute of this style can be used by any command that\n  computes a temperature, e.g. thermo_modify, fix temp/rescale, fix npt, etc.\n  The temperature is calculated by the formula KE = dim/2 N k T, where\n  KE = total kinetic energy of the group of atoms (sum of 1/2 m v^2),\n  dim = 2 or 3 = dimensionality of the simulation, N = number of atoms\n  in the group, k = Boltzmann constant, and T = temperature.\n  A kinetic energy tensor, stored as a 6-element vector, is also\n  calculated by this compute for use in the computation of a pressure\n  tensor.  The formula for the components of the tensor is the same as\n  the above formula, except that v^2 is replaced by vx*vy for the xy\n  component, etc.  The 6 components of the vector are ordered xx, yy,\n  zz, xy, xz, yz.\n  The number of atoms contributing to the temperature is assumed to be\n  constant for the duration of the run; use the dynamic option of the\n  compute_modify command if this is not the case.\n  This compute subtracts out degrees-of-freedom due to fixes that\n  constrain molecular motion, such as fix shake and\n  fix rigid.  This means the temperature of groups of\n  atoms that include these constraints will be computed correctly.  If\n  needed, the subtracted degrees-of-freedom can be altered using the\n  extra option of the compute_modify command.\n  A compute of this style with the ID of “thermo_temp” is created when\n  LAMMPS starts up, as if this command were in the input script:\n  compute thermo_temp all temp\n  \n  \n  See the “thermo_style” command for more details.\n  See the Howto thermostat doc page for a\n  discussion of different ways to compute temperature and perform\n  thermostatting.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Output info:\n  This compute calculates a global scalar (the temperature) and a global\n  vector of length 6 (KE tensor), which can be accessed by indices 1-6.\n  These values can be used by any command that uses global scalar or\n  vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The scalar value calculated by this compute is “intensive”.  The\n  vector values are “extensive”.\n  The scalar value will be in temperature units.  The\n  vector values will be in energy units.\n  ",
    "syntax": "compute ID group-ID temp\n  \n  \n  \n  ID, group-ID are documented in compute command\n  temp = style name of this compute command\n  \n  ",
    "examples": "compute 1 all temp\n  compute myTemp mobile temp\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute temp/asphere",
    "description": "Define a computation that calculates the temperature of a group of\n  aspherical particles, including a contribution from both their\n  translational and rotational kinetic energy.  This differs from the\n  usual compute temp command, which assumes point\n  particles with only translational kinetic energy.\n  Only finite-size particles (aspherical or spherical) can be included\n  in the group.  For 3d finite-size particles, each has 6 degrees of\n  freedom (3 translational, 3 rotational).  For 2d finite-size\n  particles, each has 3 degrees of freedom (2 translational, 1\n  rotational).\n  \n  Note\n  This choice for degrees of freedom (dof) assumes that all\n  finite-size aspherical or spherical particles in your model will\n  freely rotate, sampling all their rotational dof.  It is possible to\n  use a combination of interaction potentials and fixes that induce no\n  torque or otherwise constrain some of all of your particles so that\n  this is not the case.  Then there are less dof and you should use the\n  compute_modify extra command to adjust the dof\n  accordingly.\n  \n  For example, an aspherical particle with all three of its shape\n  parameters the same is a sphere.  If it does not rotate, then it\n  should have 3 dof instead of 6 in 3d (or 2 instead of 3 in 2d).  A\n  uniaxial aspherical particle has two of its three shape parameters the\n  same.  If it does not rotate around the axis perpendicular to its\n  circular cross section, then it should have 5 dof instead of 6 in 3d.\n  The latter is the case for uniaxial ellipsoids in a GayBerne model since there is no induced torque around the\n  optical axis.  It will also be the case for bi-axial ellipsoids when\n  exactly two of the semiaxes have the same length and the corresponding\n  relative well depths are equal.\n  The translational kinetic energy is computed the same as is described\n  by the compute temp command.  The rotational\n  kinetic energy is computed as 1/2 I w^2, where I is the inertia tensor\n  for the aspherical particle and w is its angular velocity, which is\n  computed from its angular momentum.\n  \n  Note\n  For 2d models, particles are treated as\n  ellipsoids, not ellipses, meaning their moments of inertia will be the\n  same as in 3d.\n  \n  A kinetic energy tensor, stored as a 6-element vector, is also\n  calculated by this compute.  The formula for the components of the\n  tensor is the same as the above formula, except that v^2 and w^2 are\n  replaced by vx*vy and wx*wy for the xy component, and the appropriate\n  elements of the inertia tensor are used.  The 6 components of the\n  vector are ordered xx, yy, zz, xy, xz, yz.\n  The number of atoms contributing to the temperature is assumed to be\n  constant for the duration of the run; use the dynamic option of the\n  compute_modify command if this is not the case.\n  This compute subtracts out translational degrees-of-freedom due to\n  fixes that constrain molecular motion, such as fix shake and fix rigid.  This means the\n  temperature of groups of atoms that include these constraints will be\n  computed correctly.  If needed, the subtracted degrees-of-freedom can\n  be altered using the extra option of the\n  compute_modify command.\n  See the Howto thermostat doc page for a\n  discussion of different ways to compute temperature and perform\n  thermostatting.\n  \n  The keyword/value option pairs are used in the following ways.\n  For the bias keyword, bias-ID refers to the ID of a temperature\n  compute that removes a “bias” velocity from each atom.  This allows\n  compute temp/sphere to compute its thermal temperature after the\n  translational kinetic energy components have been altered in a\n  prescribed way, e.g. to remove a flow velocity profile.  Thermostats\n  that use this compute will work with this bias term.  See the doc\n  pages for individual computes that calculate a temperature and the doc\n  pages for fixes that perform thermostatting for more details.\n  For the dof keyword, a setting of all calculates a temperature\n  that includes both translational and rotational degrees of freedom.  A\n  setting of rotate calculates a temperature that includes only\n  rotational degrees of freedom.\n  \n  Output info:\n  This compute calculates a global scalar (the temperature) and a global\n  vector of length 6 (KE tensor), which can be accessed by indices 1-6.\n  These values can be used by any command that uses global scalar or\n  vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The scalar value calculated by this compute is “intensive”.  The\n  vector values are “extensive”.\n  The scalar value will be in temperature units.  The\n  vector values will be in energy units.\n  ",
    "syntax": "compute ID group-ID temp/asphere keyword value ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  temp/asphere = style name of this compute command\n  zero or more keyword/value pairs may be appended\n  keyword = bias or dof\n  bias value = bias-ID\n    bias-ID = ID of a temperature compute that removes a velocity bias\n  dof value = all or rotate\n    all = compute temperature of translational and rotational degrees of freedom\n    rotate = compute temperature of just rotational degrees of freedom\n  \n  \n  ",
    "examples": "compute 1 all temp/asphere\n  compute myTemp mobile temp/asphere bias tempCOM\n  compute myTemp mobile temp/asphere dof rotate\n  \n  \n  ",
    "restrictions": "This compute is part of the ASPHERE package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  This compute requires that atoms store angular momentum and a\n  quaternion as defined by the atom_style ellipsoid\n  command.\n  All particles in the group must be finite-size.  They cannot be point\n  particles, but they can be aspherical or spherical as defined by their\n  shape attribute.\n  "
},
{
    "command": "compute temp/body",
    "description": "Define a computation that calculates the temperature of a group of\n  body particles, including a contribution from both their\n  translational and rotational kinetic energy.  This differs from the\n  usual compute temp command, which assumes point\n  particles with only translational kinetic energy.\n  Only body particles can be included in the group.  For 3d particles,\n  each has 6 degrees of freedom (3 translational, 3 rotational).  For 2d\n  body particles, each has 3 degrees of freedom (2 translational, 1\n  rotational).\n  \n  Note\n  This choice for degrees of freedom (dof) assumes that all body\n  particles in your model will freely rotate, sampling all their\n  rotational dof.  It is possible to use a combination of interaction\n  potentials and fixes that induce no torque or otherwise constrain some\n  of all of your particles so that this is not the case.  Then there are\n  less dof and you should use the compute_modify extra command to adjust the dof accordingly.\n  \n  The translational kinetic energy is computed the same as is described\n  by the compute temp command.  The rotational\n  kinetic energy is computed as 1/2 I w^2, where I is the inertia tensor\n  for the aspherical particle and w is its angular velocity, which is\n  computed from its angular momentum.\n  A kinetic energy tensor, stored as a 6-element vector, is also\n  calculated by this compute.  The formula for the components of the\n  tensor is the same as the above formula, except that v^2 and w^2 are\n  replaced by vx*vy and wx*wy for the xy component, and the appropriate\n  elements of the inertia tensor are used.  The 6 components of the\n  vector are ordered xx, yy, zz, xy, xz, yz.\n  The number of atoms contributing to the temperature is assumed to be\n  constant for the duration of the run; use the dynamic option of the\n  compute_modify command if this is not the case.\n  This compute subtracts out translational degrees-of-freedom due to\n  fixes that constrain molecular motion, such as fix shake and fix rigid.  This means the\n  temperature of groups of atoms that include these constraints will be\n  computed correctly.  If needed, the subtracted degrees-of-freedom can\n  be altered using the extra option of the\n  compute_modify command.\n  See the Howto thermostat doc page for a\n  discussion of different ways to compute temperature and perform\n  thermostatting.\n  \n  The keyword/value option pairs are used in the following ways.\n  For the bias keyword, bias-ID refers to the ID of a temperature\n  compute that removes a “bias” velocity from each atom.  This allows\n  compute temp/sphere to compute its thermal temperature after the\n  translational kinetic energy components have been altered in a\n  prescribed way, e.g. to remove a flow velocity profile.  Thermostats\n  that use this compute will work with this bias term.  See the doc\n  pages for individual computes that calculate a temperature and the doc\n  pages for fixes that perform thermostatting for more details.\n  For the dof keyword, a setting of all calculates a temperature\n  that includes both translational and rotational degrees of freedom.  A\n  setting of rotate calculates a temperature that includes only\n  rotational degrees of freedom.\n  \n  Output info:\n  This compute calculates a global scalar (the temperature) and a global\n  vector of length 6 (KE tensor), which can be accessed by indices 1-6.\n  These values can be used by any command that uses global scalar or\n  vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The scalar value calculated by this compute is “intensive”.  The\n  vector values are “extensive”.\n  The scalar value will be in temperature units.  The\n  vector values will be in energy units.\n  ",
    "syntax": "compute ID group-ID temp/body keyword value ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  temp/body = style name of this compute command\n  zero or more keyword/value pairs may be appended\n  keyword = bias or dof\n  bias value = bias-ID\n    bias-ID = ID of a temperature compute that removes a velocity bias\n  dof value = all or rotate\n    all = compute temperature of translational and rotational degrees of freedom\n    rotate = compute temperature of just rotational degrees of freedom\n  \n  \n  ",
    "examples": "compute 1 all temp/body\n  compute myTemp mobile temp/body bias tempCOM\n  compute myTemp mobile temp/body dof rotate\n  \n  \n  ",
    "restrictions": "This compute is part of the BODY package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  This compute requires that atoms store angular momentum and a\n  quaternion as defined by the atom_style body\n  command.\n  "
},
{
    "command": "compute temp/chunk",
    "description": "Define a computation that calculates the temperature of a group of\n  atoms that are also in chunks, after optionally subtracting out the\n  center-of-mass velocity of each chunk.  By specifying optional values,\n  it can also calculate the per-chunk temperature or energies of the\n  multiple chunks of atoms.\n  In LAMMPS, chunks are collections of atoms defined by a compute chunk/atom command, which assigns each atom\n  to a single chunk (or no chunk).  The ID for this command is specified\n  as chunkID.  For example, a single chunk could be the atoms in a\n  molecule or atoms in a spatial bin.  See the compute chunk/atom and Howto chunk\n  doc pages for details of how chunks can be defined and examples of how\n  they can be used to measure properties of a system.\n  The temperature is calculated by the formula KE = DOF/2 k T, where KE =\n  total kinetic energy of all atoms assigned to chunks (sum of 1/2 m\n  v^2), DOF = the total number of degrees of freedom for those atoms, k\n  = Boltzmann constant, and T = temperature.\n  The DOF is calculated as N*adof + Nchunk*cdof, where N = number of\n  atoms contributing to the KE, adof = degrees of freedom per atom, and\n  cdof = degrees of freedom per chunk.  By default adof = 2 or 3 =\n  dimensionality of system, as set via the dimension\n  command, and cdof = 0.0.  This gives the usual formula for\n  temperature.\n  A kinetic energy tensor, stored as a 6-element vector, is also\n  calculated by this compute for use in the computation of a pressure\n  tensor.  The formula for the components of the tensor is the same as\n  the above formula, except that v^2 is replaced by vx*vy for the xy\n  component, etc.  The 6 components of the vector are ordered xx, yy,\n  zz, xy, xz, yz.\n  Note that the number of atoms contributing to the temperature is\n  calculated each time the temperature is evaluated since it is assumed\n  the atoms may be dynamically assigned to chunks.  Thus there is no\n  need to use the dynamic option of the\n  compute_modify command for this compute style.\n  If any optional values are specified, then per-chunk quantities are\n  also calculated and stored in a global array, as described below.\n  The temp value calculates the temperature for each chunk by the\n  formula KE = DOF/2 k T, where KE = total kinetic energy of the chunk\n  of atoms (sum of 1/2 m v^2), DOF = the total number of degrees of\n  freedom for all atoms in the chunk, k = Boltzmann constant, and T =\n  temperature.\n  The DOF in this case is calculated as N*adof + cdof, where N = number\n  of atoms in the chunk, adof = degrees of freedom per atom, and cdof =\n  degrees of freedom per chunk.  By default adof = 2 or 3 =\n  dimensionality of system, as set via the dimension\n  command, and cdof = 0.0.  This gives the usual formula for\n  temperature.\n  The kecom value calculates the kinetic energy of each chunk as if\n  all its atoms were moving with the velocity of the center-of-mass of\n  the chunk.\n  The internal value calculates the internal kinetic energy of each\n  chunk.  The interal KE is summed over the atoms in the chunk using an\n  internal “thermal” velocity for each atom, which is its velocity minus\n  the center-of-mass velocity of the chunk.\n  \n  Note that currently the global and per-chunk temperatures calculated\n  by this compute only include translational degrees of freedom for each\n  atom.  No rotational degrees of freedom are included for finite-size\n  particles.  Also no degrees of freedom are subtracted for any velocity\n  bias or constraints that are applied, such as compute temp/partial, or fix shake\n  or fix rigid.  This is because those degrees of\n  freedom (e.g. a constrained bond) could apply to sets of atoms that\n  are both included and excluded from a specific chunk, and hence the\n  concept is somewhat ill-defined.  In some cases, you can use the\n  adof and cdof keywords to adjust the calculated degrees of freedom\n  appropriately, as explained below.\n  Note that the per-chunk temperature calculated by this compute and the\n  fix ave/chunk temp command can be different.\n  This compute calculates the temperature for each chunk for a single\n  snapshot.  Fix ave/chunk can do that but can also time average those\n  values over many snapshots, or it can compute a temperature as if the\n  atoms in the chunk on different timesteps were collected together as\n  one set of atoms to calculate their temperature.  This compute allows\n  the center-of-mass velocity of each chunk to be subtracted before\n  calculating the temperature; fix ave/chunk does not.\n  \n  Note\n  Only atoms in the specified group contribute to the calculations\n  performed by this compute.  The compute chunk/atom command defines its own group;\n  atoms will have a chunk ID = 0 if they are not in that group,\n  signifying they are not assigned to a chunk, and will thus also not\n  contribute to this calculation.  You can specify the “all” group for\n  this command if you simply want to include atoms with non-zero chunk\n  IDs.\n  \n  The simplest way to output the per-chunk results of the compute\n  temp/chunk calculation to a file is to use the fix ave/time command, for example:\n  compute cc1 all chunk/atom molecule\n  compute myChunk all temp/chunk cc1 temp\n  fix 1 all ave/time 100 1 100 c_myChunk file tmp.out mode vector\n  \n  \n  \n  The keyword/value option pairs are used in the following ways.\n  The com keyword can be used with a value of yes to subtract the\n  velocity of the center-of-mass for each chunk from the velocity of the\n  atoms in that chunk, before calculating either the global or per-chunk\n  temperature.  This can be useful if the atoms are streaming or\n  otherwise moving collectively, and you wish to calculate only the\n  thermal temperature.\n  For the bias keyword, bias-ID refers to the ID of a temperature\n  compute that removes a “bias” velocity from each atom.  This also\n  allows calculation of the global or per-chunk temperature using only\n  the thermal temperature of atoms in each chunk after the translational\n  kinetic energy components have been altered in a prescribed way,\n  e.g. to remove a velocity profile.  It also applies to the calculation\n  of the other per-chunk values, such as kecom or internal, which\n  involve the center-of-mass velocity of each chunk, which is calculated\n  after the velocity bias is removed from each atom.  Note that the\n  temperature compute will apply its bias globally to the entire system,\n  not on a per-chunk basis.\n  The adof and cdof keywords define the values used in the degree of\n  freedom (DOF) formulas used for the global or per-chunk temperature,\n  as described above.  They can be used to calculate a more appropriate\n  temperature for some kinds of chunks.  Here are 3 examples:\n  If spatially binned chunks contain some number of water molecules and\n  fix shake is used to make each molecule rigid, then\n  you could calculate a temperature with 6 degrees of freedom (DOF) (3\n  translational, 3 rotational) per molecule by setting adof to 2.0.\n  If compute temp/partial is used with the\n  bias keyword to only allow the x component of velocity to contribute\n  to the temperature, then adof = 1.0 would be appropriate.\n  If each chunk consists of a large molecule, with some number of its\n  bonds constrained by fix shake or the entire molecule\n  by fix rigid/small, adof = 0.0 and cdof could be\n  set to the remaining degrees of freedom for the entire molecule\n  (entire chunk in this case), e.g. 6 for 3d, or 3 for 2d, for a rigid\n  molecule.\n  \n  Output info:\n  This compute calculates a global scalar (the temperature) and a global\n  vector of length 6 (KE tensor), which can be accessed by indices 1-6.\n  These values can be used by any command that uses global scalar or\n  vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  This compute also optionally calculates a global array, if one or more\n  of the optional values are specified.  The number of rows in the array\n  = the number of chunks Nchunk as calculated by the specified\n  compute chunk/atom command.  The number of\n  columns is the number of specified values (1 or more).  These values\n  can be accessed by any command that uses global array values from a\n  compute as input.  Again, see the Howto output doc\n  page for an overview of LAMMPS output options.\n  The scalar value calculated by this compute is “intensive”.  The\n  vector values are “extensive”.  The array values are “intensive”.\n  The scalar value will be in temperature units.  The\n  vector values will be in energy units.  The array values\n  will be in temperature units for the temp value, and in\n  energy units for the kecom and internal values.\n  ",
    "syntax": "compute ID group-ID temp/chunk chunkID value1 value2 ... keyword value ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  temp/chunk = style name of this compute command\n  chunkID = ID of compute chunk/atom command\n  zero or more values can be listed as value1,value2,etc\n  value = temp or kecom or internal\n  temp = temperature of each chunk\n  kecom = kinetic energy of each chunk based on velocity of center of mass\n  internal = internal kinetic energy of each chunk\n  \n  \n  \n  zero or more keyword/value pairs may be appended\n  keyword = com or bias or adof or cdof\n  com value = yes or no\n    yes = subtract center-of-mass velocity from each chunk before calculating temperature\n    no = do not subtract center-of-mass velocity\n  bias value = bias-ID\n    bias-ID = ID of a temperature compute that removes a velocity bias\n  adof value = dof_per_atom\n    dof_per_atom = define this many degrees-of-freedom per atom\n  cdof value = dof_per_chunk\n    dof_per_chunk = define this many degrees-of-freedom per chunk\n  \n  \n  ",
    "examples": "compute 1 fluid temp/chunk molchunk\n  compute 1 fluid temp/chunk molchunk temp internal\n  compute 1 fluid temp/chunk molchunk bias tpartial adof 2.0\n  \n  \n  ",
    "restrictions": "The com and bias keywords cannot be used together.\n  "
},
{
    "command": "compute temp/com",
    "description": "Define a computation that calculates the temperature of a group of\n  atoms, after subtracting out the center-of-mass velocity of the group.\n  This is useful if the group is expected to have a non-zero net\n  velocity for some reason.  A compute of this style can be used by any\n  command that computes a temperature,\n  e.g. thermo_modify, fix temp/rescale, fix npt, etc.\n  After the center-of-mass velocity has been subtracted from each atom,\n  the temperature is calculated by the formula KE = dim/2 N k T, where\n  KE = total kinetic energy of the group of atoms (sum of 1/2 m v^2),\n  dim = 2 or 3 = dimensionality of the simulation, N = number of atoms\n  in the group, k = Boltzmann constant, and T = temperature.\n  A kinetic energy tensor, stored as a 6-element vector, is also\n  calculated by this compute for use in the computation of a pressure\n  tensor.  The formula for the components of the tensor is the same as\n  the above formula, except that v^2 is replaced by vx*vy for the xy\n  component, etc.  The 6 components of the vector are ordered xx, yy,\n  zz, xy, xz, yz.\n  The number of atoms contributing to the temperature is assumed to be\n  constant for the duration of the run; use the dynamic option of the\n  compute_modify command if this is not the case.\n  The removal of the center-of-mass velocity by this fix is essentially\n  computing the temperature after a “bias” has been removed from the\n  velocity of the atoms.  If this compute is used with a fix command\n  that performs thermostatting then this bias will be subtracted from\n  each atom, thermostatting of the remaining thermal velocity will be\n  performed, and the bias will be added back in.  Thermostatting fixes\n  that work in this way include fix nvt, fix temp/rescale, fix temp/berendsen, and fix langevin.\n  This compute subtracts out degrees-of-freedom due to fixes that\n  constrain molecular motion, such as fix shake and\n  fix rigid.  This means the temperature of groups of\n  atoms that include these constraints will be computed correctly.  If\n  needed, the subtracted degrees-of-freedom can be altered using the\n  extra option of the compute_modify command.\n  See the Howto thermostat doc page for a\n  discussion of different ways to compute temperature and perform\n  thermostatting.\n  Output info:\n  This compute calculates a global scalar (the temperature) and a global\n  vector of length 6 (KE tensor), which can be accessed by indices 1-6.\n  These values can be used by any command that uses global scalar or\n  vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The scalar value calculated by this compute is “intensive”.  The\n  vector values are “extensive”.\n  The scalar value will be in temperature units.  The\n  vector values will be in energy units.\n  ",
    "syntax": "compute ID group-ID temp/com\n  \n  \n  \n  ID, group-ID are documented in compute command\n  temp/com = style name of this compute command\n  \n  ",
    "examples": "compute 1 all temp/com\n  compute myTemp mobile temp/com\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute temp/cs",
    "description": "Define a computation that calculates the temperature of a system based\n  on the center-of-mass velocity of atom pairs that are bonded to each\n  other.  This compute is designed to be used with the adiabatic\n  core/shell model of (Mitchell and Finchham).  See\n  the Howto coreshell doc page for an overview of\n  the model as implemented in LAMMPS.  Specifically, this compute\n  enables correct temperature calculation and thermostatting of\n  core/shell pairs where it is desirable for the internal degrees of\n  freedom of the core/shell pairs to not be influenced by a thermostat.\n  A compute of this style can be used by any command that computes a\n  temperature via fix_modify e.g. fix temp/rescale, fix npt, etc.\n  Note that this compute does not require all ions to be polarized,\n  hence defined as core/shell pairs.  One can mix core/shell pairs and\n  ions without a satellite particle if desired. The compute will\n  consider the non-polarized ions according to the physical system.\n  For this compute, core and shell particles are specified by two\n  respective group IDs, which can be defined using the\n  group command.  The number of atoms in the two groups\n  must be the same and there should be one bond defined between a pair\n  of atoms in the two groups.  Non-polarized ions which might also be\n  included in the treated system should not be included into either of\n  these groups, they are taken into account by the group-ID (2nd\n  argument) of the compute.\n  The temperature is calculated by the formula KE = dim/2 N k T, where\n  KE = total kinetic energy of the group of atoms (sum of 1/2 m v^2),\n  dim = 2 or 3 = dimensionality of the simulation, N = number of atoms\n  in the group, k = Boltzmann constant, and T = temperature.  Note that\n  the velocity of each core or shell atom used in the KE calculation is\n  the velocity of the center-of-mass (COM) of the core/shell pair the\n  atom is part of.\n  A kinetic energy tensor, stored as a 6-element vector, is also\n  calculated by this compute for use in the computation of a pressure\n  tensor.  The formula for the components of the tensor is the same as\n  the above formula, except that v^2 is replaced by vx*vy for the xy\n  component, etc.  The 6 components of the vector are ordered xx, yy,\n  zz, xy, xz, yz.  In contrast to the temperature, the velocity of\n  each core or shell atom is taken individually.\n  The change this fix makes to core/shell atom velocities is essentially\n  computing the temperature after a “bias” has been removed from the\n  velocity of the atoms.  This “bias” is the velocity of the atom\n  relative to the COM velocity of the core/shell pair.  If this compute\n  is used with a fix command that performs thermostatting then this bias\n  will be subtracted from each atom, thermostatting of the remaining COM\n  velocity will be performed, and the bias will be added back in.  This\n  means the thermostatting will effectively be performed on the\n  core/shell pairs, instead of on the individual core and shell atoms.\n  Thermostatting fixes that work in this way include fix nvt, fix temp/rescale, fix temp/berendsen, and fix langevin.\n  The internal energy of core/shell pairs can be calculated by the\n  compute temp/chunk command, if chunks are\n  defined as core/shell pairs.  See the Howto coreshell doc page doc page for more discussion\n  on how to do this.\n  Output info:\n  This compute calculates a global scalar (the temperature) and a global\n  vector of length 6 (KE tensor), which can be accessed by indices 1-6.\n  These values can be used by any command that uses global scalar or\n  vector values from a compute as input.\n  The scalar value calculated by this compute is “intensive”.  The\n  vector values are “extensive”.\n  The scalar value will be in temperature units.  The\n  vector values will be in energy units.\n  ",
    "syntax": "compute ID group-ID temp/cs group1 group2\n  \n  \n  \n  ID, group-ID are documented in compute command\n  temp/cs = style name of this compute command\n  group1 = group-ID of either cores or shells\n  group2 = group-ID of either shells or cores\n  \n  ",
    "examples": "compute oxygen_c-s all temp/cs O_core O_shell\n  compute core_shells all temp/cs cores shells\n  \n  \n  ",
    "restrictions": "The number of core/shell pairs contributing to the temperature is\n  assumed to be constant for the duration of the run.  No fixes should\n  be used which generate new molecules or atoms during a simulation.\n  "
},
{
    "command": "compute temp/deform",
    "description": "Define a computation that calculates the temperature of a group of\n  atoms, after subtracting out a streaming velocity induced by the\n  simulation box changing size and/or shape, for example in a\n  non-equilibrium MD (NEMD) simulation.  The size/shape change is\n  induced by use of the fix deform command.  A compute\n  of this style is created by the fix nvt/sllod\n  command to compute the thermal temperature of atoms for thermostatting\n  purposes.  A compute of this style can also be used by any command\n  that computes a temperature, e.g. thermo_modify,\n  fix temp/rescale, fix npt, etc.\n  The deformation fix changes the box size and/or shape over time, so\n  each atom in the simulation box can be thought of as having a\n  “streaming” velocity.  For example, if the box is being sheared in x,\n  relative to y, then atoms at the bottom of the box (low y) have a\n  small x velocity, while atoms at the top of the box (hi y) have a\n  large x velocity.  This position-dependent streaming velocity is\n  subtracted from each atom’s actual velocity to yield a thermal\n  velocity which is used to compute the temperature.\n  \n  Note\n  Fix deform has an option for remapping either\n  atom coordinates or velocities to the changing simulation box.  When\n  using this compute in conjunction with a deforming box, fix deform\n  should NOT remap atom positions, but rather should let atoms respond\n  to the changing box by adjusting their own velocities (or let fix deform remap the atom velocities, see it’s remap\n  option).  If fix deform does remap atom positions, then they appear to\n  move with the box but their velocity is not changed, and thus they do\n  NOT have the streaming velocity assumed by this compute.  LAMMPS will\n  warn you if fix deform is defined and its remap setting is not\n  consistent with this compute.\n  \n  After the streaming velocity has been subtracted from each atom, the\n  temperature is calculated by the formula KE = dim/2 N k T, where KE =\n  total kinetic energy of the group of atoms (sum of 1/2 m v^2), dim = 2\n  or 3 = dimensionality of the simulation, N = number of atoms in the\n  group, k = Boltzmann constant, and T = temperature.  Note that v in\n  the kinetic energy formula is the atom’s thermal velocity.\n  A kinetic energy tensor, stored as a 6-element vector, is also\n  calculated by this compute for use in the computation of a pressure\n  tensor.  The formula for the components of the tensor is the same as\n  the above formula, except that v^2 is replaced by vx*vy for the xy\n  component, etc.  The 6 components of the vector are ordered xx, yy,\n  zz, xy, xz, yz.\n  The number of atoms contributing to the temperature is assumed to be\n  constant for the duration of the run; use the dynamic option of the\n  compute_modify command if this is not the case.\n  The removal of the box deformation velocity component by this fix is\n  essentially computing the temperature after a “bias” has been removed\n  from the velocity of the atoms.  If this compute is used with a fix\n  command that performs thermostatting then this bias will be subtracted\n  from each atom, thermostatting of the remaining thermal velocity will\n  be performed, and the bias will be added back in.  Thermostatting\n  fixes that work in this way include fix nvt, fix temp/rescale, fix temp/berendsen, and fix langevin.\n  \n  Note\n  The temperature calculated by this compute is only accurate if\n  the atoms are indeed moving with a stream velocity profile that\n  matches the box deformation.  If not, then the compute will subtract\n  off an incorrect stream velocity, yielding a bogus thermal\n  temperature.  You should NOT assume that your atoms are streaming at\n  the same rate the box is deforming.  Rather, you should monitor their\n  velocity profile, e.g. via the fix ave/chunk\n  command.  And you can compare the results of this compute to compute temp/profile, which actually calculates the\n  stream profile before subtracting it.  If the two computes do not give\n  roughly the same temperature, then your atoms are not streaming\n  consistent with the box deformation.  See the fix deform command for more details on ways to get atoms\n  to stream consistently with the box deformation.\n  \n  This compute subtracts out degrees-of-freedom due to fixes that\n  constrain molecular motion, such as fix shake and\n  fix rigid.  This means the temperature of groups of\n  atoms that include these constraints will be computed correctly.  If\n  needed, the subtracted degrees-of-freedom can be altered using the\n  extra option of the compute_modify command.\n  See the Howto thermostat doc page for a\n  discussion of different ways to compute temperature and perform\n  thermostatting.\n  Output info:\n  This compute calculates a global scalar (the temperature) and a global\n  vector of length 6 (KE tensor), which can be accessed by indices 1-6.\n  These values can be used by any command that uses global scalar or\n  vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The scalar value calculated by this compute is “intensive”.  The\n  vector values are “extensive”.\n  The scalar value will be in temperature units.  The\n  vector values will be in energy units.\n  ",
    "syntax": "compute ID group-ID temp/deform\n  \n  \n  \n  ID, group-ID are documented in compute command\n  temp/deform = style name of this compute command\n  \n  ",
    "examples": "compute myTemp all temp/deform\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute temp/deform/eff",
    "description": "Define a computation that calculates the temperature of a group of\n  nuclei and electrons in the electron force field\n  model, after subtracting out a streaming velocity induced by the\n  simulation box changing size and/or shape, for example in a\n  non-equilibrium MD (NEMD) simulation.  The size/shape change is\n  induced by use of the fix deform command.  A\n  compute of this style is created by the fix nvt/sllod/eff command to compute the thermal\n  temperature of atoms for thermostatting purposes.  A compute of this\n  style can also be used by any command that computes a temperature,\n  e.g. thermo_modify, fix npt/eff,\n  etc.\n  The calculation performed by this compute is exactly like that\n  described by the compute temp/deform\n  command, except that the formula for the temperature includes the\n  radial electron velocity contributions, as discussed by the compute temp/eff command.  Note that only the\n  translational degrees of freedom for each nuclei or electron are\n  affected by the streaming velocity adjustment.  The radial velocity\n  component of the electrons is not affected.\n  Output info:\n  This compute calculates a global scalar (the temperature) and a global\n  vector of length 6 (KE tensor), which can be accessed by indices 1-6.\n  These values can be used by any command that uses global scalar or\n  vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The scalar value calculated by this compute is “intensive”.  The\n  vector values are “extensive”.\n  The scalar value will be in temperature units.  The\n  vector values will be in energy units.\n  ",
    "syntax": "compute ID group-ID temp/deform/eff\n  \n  \n  \n  ID, group-ID are documented in compute command\n  temp/deform/eff = style name of this compute command\n  \n  ",
    "examples": "compute myTemp all temp/deform/eff\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-EFF package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute temp/drude",
    "description": "Define a computation that calculates the temperatures of core-Drude\n  pairs. This compute is designed to be used with the thermalized Drude oscillator model.  Polarizable models in LAMMPS\n  are described on the Howto polarizable doc\n  page.\n  Drude oscillators consist of a core particle and a Drude particle\n  connected by a harmonic bond, and the relative motion of these Drude\n  oscillators is usually maintained cold by a specific thermostat that\n  acts on the relative motion of the core-Drude particle\n  pairs. Therefore, because LAMMPS considers Drude particles as normal\n  atoms in its default temperature compute (compute temp command), the reduced temperature of the\n  core-Drude particle pairs is not calculated correctly.\n  By contrast, this compute calculates the temperature of the cores\n  using center-of-mass velocities of the core-Drude pairs, and the\n  reduced temperature of the Drude particles using the relative\n  velocities of the Drude particles with respect to their cores.\n  Non-polarizable atoms are considered as cores.  Their velocities\n  contribute to the temperature of the cores.\n  Output info:\n  This compute calculates a global scalar (the temperature) and a global\n  vector of length 6, which can be accessed by indices 1-6, whose components\n  are\n  \n  temperature of the centers of mass (temperature units)\n  temperature of the dipoles (temperature units)\n  number of degrees of freedom of the centers of mass\n  number of degrees of freedom of the dipoles\n  kinetic energy of the centers of mass (energy units)\n  kinetic energy of the dipoles (energy units)\n  \n  These values can be used by any command that uses global scalar or\n  vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  Both the scalar value and the first two values of the vector\n  calculated by this compute are “intensive”.  The other 4 vector values\n  are “extensive”.\n  ",
    "syntax": "compute ID group-ID temp/drude\n  \n  \n  \n  ID, group-ID are documented in compute command\n  temp/drude = style name of this compute command\n  \n  ",
    "examples": "compute TDRUDE all temp/drude\n  \n  \n  ",
    "restrictions": "The number of degrees of freedom contributing to the temperature is\n  assumed to be constant for the duration of the run unless the\n  fix_modify command sets the option dynamic yes.\n  "
},
{
    "command": "compute temp/eff",
    "description": "Define a computation that calculates the temperature of a group of\n  nuclei and electrons in the electron force field\n  model.  A compute of this style can be used by commands that compute a\n  temperature, e.g. thermo_modify, fix npt/eff, etc.\n  The temperature is calculated by the formula KE = dim/2 N k T, where\n  KE = total kinetic energy of the group of atoms (sum of 1/2 m v^2 for\n  nuclei and sum of 1/2 (m v^2 + 3/4 m s^2) for electrons, where s\n  includes the radial electron velocity contributions), dim = 2 or 3 =\n  dimensionality of the simulation, N = number of atoms (only total\n  number of nuclei in the eFF (see the pair_eff\n  command) in the group, k = Boltzmann constant, and T = temperature.\n  This expression is summed over all nuclear and electronic degrees of\n  freedom, essentially by setting the kinetic contribution to the heat\n  capacity to 3/2k (where only nuclei contribute). This subtlety is\n  valid for temperatures well below the Fermi temperature, which for\n  densities two to five times the density of liquid H2 ranges from\n  86,000 to 170,000 K.\n  \n  Note\n  For eFF models, in order to override the default temperature\n  reported by LAMMPS in the thermodynamic quantities reported via the\n  thermo command, the user should apply a\n  thermo_modify command, as shown in the following\n  example:\n  \n  compute         effTemp all temp/eff\n  thermo_style    custom step etotal pe ke temp press\n  thermo_modify   temp effTemp\n  \n  \n  A 6-component kinetic energy tensor is also calculated by this compute\n  for use in the computation of a pressure tensor.  The formula for the\n  components of the tensor is the same as the above formula, except that\n  v^2 is replaced by vx * vy for the xy component, etc.  For the eFF,\n  again, the radial electronic velocities are also considered.\n  The number of atoms contributing to the temperature is assumed to be\n  constant for the duration of the run; use the dynamic option of the\n  compute_modify command if this is not the case.\n  This compute subtracts out degrees-of-freedom due to fixes that\n  constrain molecular motion, such as fix shake and\n  fix rigid.  This means the temperature of groups of\n  atoms that include these constraints will be computed correctly.  If\n  needed, the subtracted degrees-of-freedom can be altered using the\n  extra option of the compute_modify command.\n  See the Howto thermostat doc page for a\n  discussion of different ways to compute temperature and perform\n  thermostatting.\n  Output info:\n  The scalar value calculated by this compute is “intensive”, meaning it\n  is independent of the number of atoms in the simulation.  The vector\n  values are “extensive”, meaning they scale with the number of atoms in\n  the simulation.\n  ",
    "syntax": "compute ID group-ID temp/eff\n  \n  \n  \n  ID, group-ID are documented in compute command\n  temp/eff = style name of this compute command\n  \n  ",
    "examples": "compute 1 all temp/eff\n  compute myTemp mobile temp/eff\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-EFF package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute temp/partial",
    "description": "Define a computation that calculates the temperature of a group of\n  atoms, after excluding one or more velocity components.  A compute of\n  this style can be used by any command that computes a temperature,\n  e.g. thermo_modify, fix temp/rescale, fix npt, etc.\n  The temperature is calculated by the formula KE = dim/2 N k T, where\n  KE = total kinetic energy of the group of atoms (sum of 1/2 m v^2),\n  dim = dimensionality of the simulation, N = number of atoms in the\n  group, k = Boltzmann constant, and T = temperature.  The calculation\n  of KE excludes the x, y, or z dimensions if xflag, yflag, or zflag =\n  0.  The dim parameter is adjusted to give the correct number of\n  degrees of freedom.\n  A kinetic energy tensor, stored as a 6-element vector, is also\n  calculated by this compute for use in the calculation of a pressure\n  tensor.  The formula for the components of the tensor is the same as\n  the above formula, except that v^2 is replaced by vx*vy for the xy\n  component, etc.  The 6 components of the vector are ordered xx, yy,\n  zz, xy, xz, yz.\n  The number of atoms contributing to the temperature is assumed to be\n  constant for the duration of the run; use the dynamic option of the\n  compute_modify command if this is not the case.\n  The removal of velocity components by this fix is essentially\n  computing the temperature after a “bias” has been removed from the\n  velocity of the atoms.  If this compute is used with a fix command\n  that performs thermostatting then this bias will be subtracted from\n  each atom, thermostatting of the remaining thermal velocity will be\n  performed, and the bias will be added back in.  Thermostatting fixes\n  that work in this way include fix nvt, fix temp/rescale, fix temp/berendsen, and fix langevin.\n  This compute subtracts out degrees-of-freedom due to fixes that\n  constrain molecular motion, such as fix shake and\n  fix rigid.  This means the temperature of groups of\n  atoms that include these constraints will be computed correctly.  If\n  needed, the subtracted degrees-of-freedom can be altered using the\n  extra option of the compute_modify command.\n  See the Howto thermostat doc page for a\n  discussion of different ways to compute temperature and perform\n  thermostatting.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Output info:\n  This compute calculates a global scalar (the temperature) and a global\n  vector of length 6 (KE tensor), which can be accessed by indices 1-6.\n  These values can be used by any command that uses global scalar or\n  vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The scalar value calculated by this compute is “intensive”.  The\n  vector values are “extensive”.\n  The scalar value will be in temperature units.  The\n  vector values will be in energy units.\n  ",
    "syntax": "compute ID group-ID temp/partial xflag yflag zflag\n  \n  \n  \n  ID, group-ID are documented in compute command\n  temp/partial = style name of this compute command\n  xflag,yflag,zflag = 0/1 for whether to exclude/include this dimension\n  \n  ",
    "examples": "compute newT flow temp/partial 1 1 0\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute temp/profile",
    "description": "Define a computation that calculates the temperature of a group of\n  atoms, after subtracting out a spatially-averaged center-of-mass\n  velocity field, before computing the kinetic energy.  This can be\n  useful for thermostatting a collection of atoms undergoing a complex\n  flow, e.g. via a profile-unbiased thermostat (PUT) as described in\n  (Evans).  A compute of this style can be used by any command\n  that computes a temperature, e.g. thermo_modify,\n  fix temp/rescale, fix npt, etc.\n  The xflag, yflag, zflag settings determine which components of\n  average velocity are subtracted out.\n  The binstyle setting and its Nx, Ny, Nz arguments determine\n  how bins are setup to perform spatial averaging.  “Bins” can be 1d\n  slabs, 2d pencils, or 3d bricks depending on which binstyle is used.\n  The simulation box is partitioned conceptually into Nx by Ny by\n  Nz bins.  Depending on the binstyle, you may only specify one or\n  two of these values; the others are effectively set to 1 (no binning\n  in that dimension).  For non-orthogonal (triclinic) simulation boxes,\n  the bins are “tilted” slabs or pencils or bricks that are parallel to\n  the tilted faces of the box.  See the region prism\n  command for a discussion of the geometry of tilted boxes in LAMMPS.\n  When a temperature is computed, the center-of-mass velocity for the\n  set of atoms that are both in the compute group and in the same\n  spatial bin is calculated.  This bias velocity is then subtracted from\n  the velocities of individual atoms in the bin to yield a thermal\n  velocity for each atom.  Note that if there is only one atom in the\n  bin, its thermal velocity will thus be 0.0.\n  After the spatially-averaged velocity field has been subtracted from\n  each atom, the temperature is calculated by the formula KE = (dim*N\n  - dim*Nx*Ny*Nz) k T/2, where KE = total kinetic energy of the group of\n  atoms (sum of 1/2 m v^2), dim = 2 or 3 = dimensionality of the\n  simulation, N = number of atoms in the group, k = Boltzmann constant,\n  and T = temperature.  The dim*Nx*Ny*Nz term are degrees of freedom\n  subtracted to adjust for the removal of the center-of-mass velocity in\n  each of Nx*Ny*Nz bins, as discussed in the (Evans) paper.\n  If the out keyword is used with a tensor value, which is the\n  default, a kinetic energy tensor, stored as a 6-element vector, is\n  also calculated by this compute for use in the computation of a\n  pressure tensor.  The formula for the components of the tensor is the\n  same as the above formula, except that v^2 is replaced by vx*vy for\n  the xy component, etc.  The 6 components of the vector are ordered xx,\n  yy, zz, xy, xz, yz.\n  If the out keyword is used with a bin value, the count of atoms\n  and computed temperature for each bin are stored for output, as an\n  array of values, as described below.  The temperature of each bin is\n  calculated as described above, where the bias velocity is subtracted\n  and only the remaining thermal velocity of atoms in the bin\n  contributes to the temperature.  See the note below for how the\n  temperature is normalized by the degrees-of-freedom of atoms in the\n  bin.\n  The number of atoms contributing to the temperature is assumed to be\n  constant for the duration of the run; use the dynamic option of the\n  compute_modify command if this is not the case.\n  The removal of the spatially-averaged velocity field by this fix is\n  essentially computing the temperature after a “bias” has been removed\n  from the velocity of the atoms.  If this compute is used with a fix\n  command that performs thermostatting then this bias will be subtracted\n  from each atom, thermostatting of the remaining thermal velocity will\n  be performed, and the bias will be added back in.  Thermostatting\n  fixes that work in this way include fix nvt, fix temp/rescale, fix temp/berendsen, and fix langevin.\n  This compute subtracts out degrees-of-freedom due to fixes that\n  constrain molecular motion, such as fix shake and\n  fix rigid.  This means the temperature of groups of\n  atoms that include these constraints will be computed correctly.  If\n  needed, the subtracted degrees-of-freedom can be altered using the\n  extra option of the compute_modify command.\n  \n  Note\n  When using the out keyword with a value of bin, the\n  calculated temperature for each bin does not include the\n  degrees-of-freedom adjustment described in the preceding paragraph,\n  for fixes that constrain molecular motion.  It does include the\n  adjustment due to the extra option, which is applied to each bin.\n  \n  See the Howto thermostat doc page for a\n  discussion of different ways to compute temperature and perform\n  thermostatting.  Using this compute in conjunction with a\n  thermostatting fix, as explained there, will effectively implement a\n  profile-unbiased thermostat (PUT), as described in (Evans).\n  Output info:\n  This compute calculates a global scalar (the temperature).  Depending\n  on the setting of the out keyword, it also calculates a global\n  vector or array.  For out = tensor, it calculates a vector of\n  length 6 (KE tensor), which can be accessed by indices 1-6.  For out\n  = bin it calculates a global array which has 2 columns and N rows,\n  where N is the number of bins.  The first column contains the number\n  of atoms in that bin.  The second contains the temperature of that\n  bin, calculated as described above.  The ordering of rows in the array\n  is as follows.  Bins in x vary fastest, then y, then z.  Thus for a\n  10x10x10 3d array of bins, there will be 1000 rows.  The bin with\n  indices ix,iy,iz = 2,3,4 would map to row M = (iz-1)*10*10 + (iy-1)*10\n  + ix = 322, where the rows are numbered from 1 to 1000 and the bin\n  indices are numbered from 1 to 10 in each dimension.\n  These values can be used by any command that uses global scalar or\n  vector or array values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The scalar value calculated by this compute is “intensive”.  The\n  vector values are “extensive”.  The array values are “intensive”.\n  The scalar value will be in temperature units.  The\n  vector values will be in energy units.  The first column\n  of array values are counts; the values in the second column will be in\n  temperature units.\n  ",
    "syntax": "compute ID group-ID temp/profile xflag yflag zflag binstyle args\n  \n  \n  \n  ID, group-ID are documented in compute command\n  temp/profile = style name of this compute command\n  xflag,yflag,zflag = 0/1 for whether to exclude/include this dimension\n  binstyle = x or y or z or xy or yz or xz or xyz\n  x arg = Nx\n  y arg = Ny\n  z arg = Nz\n  xy args = Nx Ny\n  yz args = Ny Nz\n  xz args = Nx Nz\n  xyz args = Nx Ny Nz\n    Nx,Ny,Nz = number of velocity bins in x,y,z dimensions\n  \n  zero or more keyword/value pairs may be appended\n  keyword = out\n  out value = tensor or bin\n  \n  \n  ",
    "examples": "compute myTemp flow temp/profile 1 1 1 x 10\n  compute myTemp flow temp/profile 1 1 1 x 10 out bin\n  compute myTemp flow temp/profile 0 1 1 xyz 20 20 20\n  \n  \n  ",
    "restrictions": "You should not use too large a velocity-binning grid, especially in\n  3d.  In the current implementation, the binned velocity averages are\n  summed across all processors, so this will be inefficient if the grid\n  is too large, and the operation is performed every timestep, as it\n  will be for most thermostats.\n  "
},
{
    "command": "compute temp/region",
    "description": "Define a computation that calculates the temperature of a group of\n  atoms in a geometric region.  This can be useful for thermostatting\n  one portion of the simulation box.  E.g. a McDLT simulation where one\n  side is cooled, and the other side is heated.  A compute of this style\n  can be used by any command that computes a temperature,\n  e.g. thermo_modify, fix temp/rescale, etc.\n  Note that a region-style temperature can be used to thermostat with\n  fix temp/rescale or fix langevin, but should probably not be used with\n  Nose/Hoover style fixes (fix nvt, fix npt, or fix nph), if the\n  degrees-of-freedom included in the computed T varies with time.\n  The temperature is calculated by the formula KE = dim/2 N k T, where\n  KE = total kinetic energy of the group of atoms (sum of 1/2 m v^2),\n  dim = 2 or 3 = dimensionality of the simulation, N = number of atoms\n  in both the group and region, k = Boltzmann constant, and T =\n  temperature.\n  A kinetic energy tensor, stored as a 6-element vector, is also\n  calculated by this compute for use in the computation of a pressure\n  tensor.  The formula for the components of the tensor is the same as\n  the above formula, except that v^2 is replaced by vx*vy for the xy\n  component, etc.  The 6 components of the vector are ordered xx, yy,\n  zz, xy, xz, yz.\n  The number of atoms contributing to the temperature is calculated each\n  time the temperature is evaluated since it is assumed atoms can\n  enter/leave the region.  Thus there is no need to use the dynamic\n  option of the compute_modify command for this\n  compute style.\n  The removal of atoms outside the region by this fix is essentially\n  computing the temperature after a “bias” has been removed, which in\n  this case is the velocity of any atoms outside the region.  If this\n  compute is used with a fix command that performs thermostatting then\n  this bias will be subtracted from each atom, thermostatting of the\n  remaining thermal velocity will be performed, and the bias will be\n  added back in.  Thermostatting fixes that work in this way include\n  fix nvt, fix temp/rescale, fix temp/berendsen, and fix langevin.  This means that when this compute\n  is used to calculate the temperature for any of the thermostatting\n  fixes via the fix modify temp command, the thermostat\n  will operate only on atoms that are currently in the geometric\n  region.\n  Unlike other compute styles that calculate temperature, this compute\n  does not subtract out degrees-of-freedom due to fixes that constrain\n  motion, such as fix shake and fix rigid.  This is because those degrees of freedom\n  (e.g. a constrained bond) could apply to sets of atoms that straddle\n  the region boundary, and hence the concept is somewhat ill-defined.\n  If needed the number of subtracted degrees-of-freedom can be set\n  explicitly using the extra option of the\n  compute_modify command.\n  See the Howto thermostat doc page for a\n  discussion of different ways to compute temperature and perform\n  thermostatting.\n  Output info:\n  This compute calculates a global scalar (the temperature) and a global\n  vector of length 6 (KE tensor), which can be accessed by indices 1-6.\n  These values can be used by any command that uses global scalar or\n  vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The scalar value calculated by this compute is “intensive”.  The\n  vector values are “extensive”.\n  The scalar value will be in temperature units.  The\n  vector values will be in energy units.\n  ",
    "syntax": "compute ID group-ID temp/region region-ID\n  \n  \n  \n  ID, group-ID are documented in compute command\n  temp/region = style name of this compute command\n  region-ID = ID of region to use for choosing atoms\n  \n  ",
    "examples": "compute mine flow temp/region boundary\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute temp/region/eff",
    "description": "Define a computation that calculates the temperature of a group of\n  nuclei and electrons in the electron force field\n  model, within a geometric region using the electron force field.  A\n  compute of this style can be used by commands that compute a\n  temperature, e.g. thermo_modify.\n  The operation of this compute is exactly like that described by the\n  compute temp/region command, except that\n  the formula for the temperature itself includes the radial electron\n  velocity contributions, as discussed by the compute temp/eff command.\n  Output info:\n  This compute calculates a global scalar (the temperature) and a global\n  vector of length 6 (KE tensor), which can be accessed by indices 1-6.\n  These values can be used by any command that uses global scalar or\n  vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The scalar value calculated by this compute is “intensive”.  The\n  vector values are “extensive”.\n  The scalar value will be in temperature units.  The\n  vector values will be in energy units.\n  ",
    "syntax": "compute ID group-ID temp/region/eff region-ID\n  \n  \n  \n  ID, group-ID are documented in compute command\n  temp/region/eff = style name of this compute command\n  region-ID = ID of region to use for choosing atoms\n  \n  ",
    "examples": "compute mine flow temp/region/eff boundary\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-EFF package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute temp/rotate",
    "description": "Define a computation that calculates the temperature of a group of\n  atoms, after subtracting out the center-of-mass velocity and angular velocity of the group.\n  This is useful if the group is expected to have a non-zero net\n  velocity and/or global rotation motion for some reason.  A compute of this style can be used by any\n  command that computes a temperature,\n  e.g. thermo_modify, fix temp/rescale, fix npt, etc.\n  After the center-of-mass velocity and angular velocity has been subtracted from each atom,\n  the temperature is calculated by the formula KE = dim/2 N k T, where\n  KE = total kinetic energy of the group of atoms (sum of 1/2 m v^2),\n  dim = 2 or 3 = dimensionality of the simulation, N = number of atoms\n  in the group, k = Boltzmann constant, and T = temperature.\n  A kinetic energy tensor, stored as a 6-element vector, is also\n  calculated by this compute for use in the computation of a pressure\n  tensor.  The formula for the components of the tensor is the same as\n  the above formula, except that v^2 is replaced by vx*vy for the xy\n  component, etc.  The 6 components of the vector are ordered xx, yy,\n  zz, xy, xz, yz.\n  The number of atoms contributing to the temperature is assumed to be\n  constant for the duration of the run; use the dynamic option of the\n  compute_modify command if this is not the case.\n  The removal of the center-of-mass velocity and angular velocity by this fix is essentially\n  computing the temperature after a “bias” has been removed from the\n  velocity of the atoms.  If this compute is used with a fix command\n  that performs thermostatting then this bias will be subtracted from\n  each atom, thermostatting of the remaining thermal velocity will be\n  performed, and the bias will be added back in.  Thermostatting fixes\n  that work in this way include fix nvt, fix temp/rescale, fix temp/berendsen, and fix langevin.\n  This compute subtracts out degrees-of-freedom due to fixes that\n  constrain molecular motion, such as fix shake and\n  fix rigid.  This means the temperature of groups of\n  atoms that include these constraints will be computed correctly.  If\n  needed, the subtracted degrees-of-freedom can be altered using the\n  extra option of the compute_modify command.\n  See the Howto thermostat doc page for a\n  discussion of different ways to compute temperature and perform\n  thermostatting.\n  Output info:\n  This compute calculates a global scalar (the temperature) and a global\n  vector of length 6 (KE tensor), which can be accessed by indices 1-6.\n  These values can be used by any command that uses global scalar or\n  vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The scalar value calculated by this compute is “intensive”.  The\n  vector values are “extensive”.\n  The scalar value will be in temperature units.  The\n  vector values will be in energy units.\n  ",
    "syntax": "compute ID group-ID temp/rotate\n  \n  \n  \n  ID, group-ID are documented in compute command\n  temp/rotate = style name of this compute command\n  \n  ",
    "examples": "compute Tbead bead temp/rotate\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute temp/sphere",
    "description": "Define a computation that calculates the temperature of a group of\n  spherical particles, including a contribution from both their\n  translational and rotational kinetic energy.  This differs from the\n  usual compute temp command, which assumes point\n  particles with only translational kinetic energy.\n  Both point and finite-size particles can be included in the group.\n  Point particles do not rotate, so they have only 3 translational\n  degrees of freedom.  For 3d spherical particles, each has 6 degrees of\n  freedom (3 translational, 3 rotational).  For 2d spherical particles,\n  each has 3 degrees of freedom (2 translational, 1 rotational).\n  \n  Note\n  This choice for degrees of freedom (dof) assumes that all\n  finite-size spherical particles in your model will freely rotate,\n  sampling all their rotational dof.  It is possible to use a\n  combination of interaction potentials and fixes that induce no torque\n  or otherwise constrain some of all of your particles so that this is\n  not the case.  Then there are less dof and you should use the\n  compute_modify extra command to adjust the dof\n  accordingly.\n  \n  The translational kinetic energy is computed the same as is described\n  by the compute temp command.  The rotational\n  kinetic energy is computed as 1/2 I w^2, where I is the moment of\n  inertia for a sphere and w is the particle’s angular velocity.\n  \n  Note\n  For 2d models, particles are treated as\n  spheres, not disks, meaning their moment of inertia will be the same\n  as in 3d.\n  \n  A kinetic energy tensor, stored as a 6-element vector, is also\n  calculated by this compute.  The formula for the components of the\n  tensor is the same as the above formulas, except that v^2 and w^2 are\n  replaced by vx*vy and wx*wy for the xy component.  The 6 components of\n  the vector are ordered xx, yy, zz, xy, xz, yz.\n  The number of atoms contributing to the temperature is assumed to be\n  constant for the duration of the run; use the dynamic option of the\n  compute_modify command if this is not the case.\n  This compute subtracts out translational degrees-of-freedom due to\n  fixes that constrain molecular motion, such as fix shake and fix rigid.  This means the\n  temperature of groups of atoms that include these constraints will be\n  computed correctly.  If needed, the subtracted degrees-of-freedom can\n  be altered using the extra option of the\n  compute_modify command.\n  See the Howto thermostat doc page for a\n  discussion of different ways to compute temperature and perform\n  thermostatting.\n  \n  The keyword/value option pairs are used in the following ways.\n  For the bias keyword, bias-ID refers to the ID of a temperature\n  compute that removes a “bias” velocity from each atom.  This allows\n  compute temp/sphere to compute its thermal temperature after the\n  translational kinetic energy components have been altered in a\n  prescribed way, e.g. to remove a flow velocity profile.  Thermostats\n  that use this compute will work with this bias term.  See the doc\n  pages for individual computes that calculate a temperature and the doc\n  pages for fixes that perform thermostatting for more details.\n  For the dof keyword, a setting of all calculates a temperature\n  that includes both translational and rotational degrees of freedom.  A\n  setting of rotate calculates a temperature that includes only\n  rotational degrees of freedom.\n  \n  Output info:\n  This compute calculates a global scalar (the temperature) and a global\n  vector of length 6 (KE tensor), which can be accessed by indices 1-6.\n  These values can be used by any command that uses global scalar or\n  vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The scalar value calculated by this compute is “intensive”.  The\n  vector values are “extensive”.\n  The scalar value will be in temperature units.  The\n  vector values will be in energy units.\n  ",
    "syntax": "compute ID group-ID temp/sphere keyword value ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  temp/sphere = style name of this compute command\n  zero or more keyword/value pairs may be appended\n  keyword = bias or dof\n  bias value = bias-ID\n    bias-ID = ID of a temperature compute that removes a velocity bias\n  dof value = all or rotate\n    all = compute temperature of translational and rotational degrees of freedom\n    rotate = compute temperature of just rotational degrees of freedom\n  \n  \n  ",
    "examples": "compute 1 all temp/sphere\n  compute myTemp mobile temp/sphere bias tempCOM\n  compute myTemp mobile temp/sphere dof rotate\n  \n  \n  ",
    "restrictions": "This fix requires that atoms store torque and angular velocity (omega)\n  and a radius as defined by the atom_style sphere\n  command.\n  All particles in the group must be finite-size spheres, or point\n  particles with radius = 0.0.\n  "
},
{
    "command": "compute temp/uef",
    "description": "This command is used to compute the kinetic energy tensor in\n  the reference frame of the applied flow field when\n  fix nvt/uef or\n  fix npt/uef is used.\n  It is not necessary to use this command to compute the scalar\n  value of the temperature. A compute temp\n  may be used for that purpose.\n  Output information for this command can be found in the\n  documentation for compute temp.\n  ",
    "syntax": "compute ID group-ID temp/uef\n  \n  \n  \n  ID, group-ID are documented in compute command\n  temp/uef = style name of this compute command\n  \n  ",
    "examples": "compute 1 all temp/uef\n  compute 2 sel temp/uef\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-UEF package. It is only enabled if LAMMPS\n  was built with that package. See the Build package doc page for more info.\n  This command can only be used when fix nvt/uef\n  or fix npt/uef is active.\n  "
},
{
    "command": "compute ti",
    "description": "Define a computation that calculates the derivative of the interaction\n  potential with respect to lambda, the coupling parameter used in a\n  thermodynamic integration.  This derivative can be used to infer a\n  free energy difference resulting from an alchemical simulation, as\n  described in Eike.\n  Typically this compute will be used in conjunction with the fix adapt command which can perform alchemical\n  transformations by adjusting the strength of an interaction potential\n  as a simulation runs, as defined by one or more\n  pair_style or kspace_style\n  commands.  This scaling is done via a prefactor on the energy, forces,\n  virial calculated by the pair or K-Space style.  The prefactor is\n  often a function of a lambda parameter which may be adjusted from 0\n  to 1 (or vice versa) over the course of a run.  The\n  time-dependent adjustment is what the fix adapt\n  command does.\n  Assume that the unscaled energy of a pair_style or kspace_style is\n  given by U.  Then the scaled energy is\n  Us = f(lambda) U\n  \n  \n  where f() is some function of lambda.  What this compute calculates is\n  dUs / d(lambda) = U df(lambda)/dlambda = Us / f(lambda) df(lambda)/dlambda\n  \n  \n  which is the derivative of the system’s scaled potential energy Us\n  with respect to lambda.\n  To perform this calculation, you provide one or more atom types as\n  atype.  Atype can be specified in one of two ways.  An explicit\n  numeric values can be used, as in the 1st example above.  Or a\n  wildcard asterisk can be used in place of or in conjunction with the\n  atype argument to select multiple atom types.  This takes the form\n  “*” or “*n” or “n*” or “m*n”.  If N = the number of atom types, then\n  an asterisk with no numeric values means all types from 1 to N.  A\n  leading asterisk means all types from 1 to n (inclusive).  A trailing\n  asterisk means all types from n to N (inclusive).  A middle asterisk\n  means all types from m to n (inclusive).\n  You also specify two functions, as equal-style variables.  The first is specified as v_name1, where\n  name1 is the name of the variable, and is f(lambda) in the notation\n  above.  The second is specified as v_name2, where name2 is the\n  name of the variable, and is df(lambda) / dlambda in the notation\n  above.  I.e. it is the analytic derivative of f() with respect to\n  lambda.  Note that the name1 variable is also typically given as an\n  argument to the fix adapt command.\n  An alchemical simulation may use several pair potentials together,\n  invoked via the pair_style hybrid or hybrid/overlay\n  command.  The total dUs/dlambda for the overall system is calculated\n  as the sum of each contributing term as listed by the keywords in the\n  compute ti command.  Individual pair potentials can be listed, which\n  will be sub-styles in the hybrid case.  You can also include a K-space\n  term via the kspace keyword.  You can also include a pairwise\n  long-range tail correction to the energy via the tail keyword.\n  For each term you can specify a different (or the same) scale factor\n  by the two variables that you list.  Again, these will typically\n  correspond toe the scale factors applied to these various potentials\n  and the K-Space contribution via the fix adapt\n  command.\n  More details about the exact functional forms for the computation of\n  du/dl can be found in the paper by Eike.\n  \n  Output info:\n  This compute calculates a global scalar, namely dUs/dlambda.  This\n  value can be used by any command that uses a global scalar value from\n  a compute as input.  See the Howto output doc page\n  for an overview of LAMMPS output options.\n  The scalar value calculated by this compute is “extensive”.\n  The scalar value will be in energy units.\n  ",
    "syntax": "compute ID group ti keyword args ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  ti = style name of this compute command\n  one or more attribute/arg pairs may be appended\n  keyword = pair style (lj/cut, gauss, born, etc) or tail or kspace\n  pair style args = atype v_name1 v_name2\n    atype = atom type (see asterisk form below)\n    v_name1 = variable with name1 that is energy scale factor and function of lambda\n    v_name2 = variable with name2 that is derivative of v_name1 with respect to lambda\n  tail args = atype v_name1 v_name2\n    atype = atom type (see asterisk form below)\n    v_name1 = variable with name1 that is energy tail correction scale factor and function of lambda\n    v_name2 = variable with name2 that is derivative of v_name1 with respect to lambda\n  kspace args = atype v_name1 v_name2\n    atype = atom type (see asterisk form below)\n    v_name1 = variable with name1 that is K-Space scale factor and function of lambda\n    v_name2 = variable with name2 that is derivative of v_name1 with respect to lambda\n  \n  \n  ",
    "examples": "compute 1 all ti lj/cut 1 v_lj v_dlj coul/long 2 v_c v_dc kspace 1 v_ks v_dks\n  compute 1 all ti lj/cut 1*3 v_lj v_dlj coul/long * v_c v_dc kspace * v_ks v_dks\n  \n  \n  ",
    "restrictions": "This compute is part of the MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "compute torque/chunk",
    "description": "Define a computation that calculates the torque on multiple chunks of\n  atoms.\n  In LAMMPS, chunks are collections of atoms defined by a compute chunk/atom command, which assigns each atom\n  to a single chunk (or no chunk).  The ID for this command is specified\n  as chunkID.  For example, a single chunk could be the atoms in a\n  molecule or atoms in a spatial bin.  See the compute chunk/atom and Howto chunk\n  doc pages for details of how chunks can be defined and examples of how\n  they can be used to measure properties of a system.\n  This compute calculates the 3 components of the torque vector for eqch\n  chunk, due to the forces on the individual atoms in the chunk around\n  the center-of-mass of the chunk.  The calculation includes all effects\n  due to atoms passing through periodic boundaries.\n  Note that only atoms in the specified group contribute to the\n  calculation.  The compute chunk/atom command\n  defines its own group; atoms will have a chunk ID = 0 if they are not\n  in that group, signifying they are not assigned to a chunk, and will\n  thus also not contribute to this calculation.  You can specify the\n  “all” group for this command if you simply want to include atoms with\n  non-zero chunk IDs.\n  \n  Note\n  The coordinates of an atom contribute to the chunk’s torque in\n  “unwrapped” form, by using the image flags associated with each atom.\n  See the dump custom command for a discussion of\n  “unwrapped” coordinates.  See the Atoms section of the\n  read_data command for a discussion of image flags and\n  how they are set for each atom.  You can reset the image flags\n  (e.g. to 0) before invoking this compute by using the set image command.\n  \n  The simplest way to output the results of the compute torque/chunk\n  calculation to a file is to use the fix ave/time\n  command, for example:\n  compute cc1 all chunk/atom molecule\n  compute myChunk all torque/chunk cc1\n  fix 1 all ave/time 100 1 100 c_myChunk[*] file tmp.out mode vector\n  \n  \n  Output info:\n  This compute calculates a global array where the number of rows = the\n  number of chunks Nchunk as calculated by the specified compute chunk/atom command.  The number of columns =\n  3 for the 3 xyz components of the torque for each chunk.  These values\n  can be accessed by any command that uses global array values from a\n  compute as input.  See the Howto output doc page\n  for an overview of LAMMPS output options.\n  The array values are “intensive”.  The array values will be in\n  force-distance units.\n  ",
    "syntax": "compute ID group-ID torque/chunk chunkID\n  \n  \n  \n  ID, group-ID are documented in compute command\n  torque/chunk = style name of this compute command\n  chunkID = ID of compute chunk/atom command\n  \n  ",
    "examples": "compute 1 fluid torque/chunk molchunk\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute vacf",
    "description": "Define a computation that calculates the velocity auto-correlation\n  function (VACF), averaged over a group of atoms.  Each atom’s\n  contribution to the VACF is its current velocity vector dotted into\n  its initial velocity vector at the time the compute was specified.\n  A vector of four quantities is calculated by this compute.  The first 3\n  elements of the vector are vx * vx0 (and similarly for the y and z\n  components), summed and averaged over atoms in the group.  Vx is the\n  current x-component of velocity for the atom, vx0 is the initial\n  x-component of velocity for the atom.  The 4th element of the vector\n  is the total VACF, i.e. (vx*vx0 + vy*vy0 + vz*vz0), summed and\n  averaged over atoms in the group.\n  The integral of the VACF versus time is proportional to the diffusion\n  coefficient of the diffusing atoms.  This can be computed in the\n  following manner, using the variable trap() function:\n  compute         2 all vacf\n  fix             5 all vector 1 c_2[4]\n  variable        diff equal dt*trap(f_5)\n  thermo_style    custom step v_diff\n  \n  \n  \n  Note\n  If you want the quantities calculated by this compute to be\n  continuous when running from a restart file, then\n  you should use the same ID for this compute, as in the original run.\n  This is so that the fix this compute creates to store per-atom\n  quantities will also have the same ID, and thus be initialized\n  correctly with time=0 atom velocities from the restart file.\n  \n  Output info:\n  This compute calculates a global vector of length 4, which can be\n  accessed by indices 1-4 by any command that uses global vector values\n  from a compute as input.  See the Howto output doc\n  page for an overview of LAMMPS output options.\n  The vector values are “intensive”.  The vector values will be in\n  velocity^2 units.\n  ",
    "syntax": "compute ID group-ID vacf\n  \n  \n  \n  ID, group-ID are documented in compute command\n  vacf = style name of this compute command\n  \n  ",
    "examples": "compute 1 all vacf\n  compute 1 upper vacf\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "compute vcm/chunk",
    "description": "Define a computation that calculates the center-of-mass velocity for\n  multiple chunks of atoms.\n  In LAMMPS, chunks are collections of atoms defined by a compute chunk/atom command, which assigns each atom\n  to a single chunk (or no chunk).  The ID for this command is specified\n  as chunkID.  For example, a single chunk could be the atoms in a\n  molecule or atoms in a spatial bin.  See the compute chunk/atom and Howto chunk\n  doc pages for details of how chunks can be defined and examples of how\n  they can be used to measure properties of a system.\n  This compute calculates the x,y,z components of the center-of-mass\n  velocity for each chunk.  This is done by summing mass*velocity for\n  each atom in the chunk and dividing the sum by the total mass of the\n  chunk.\n  Note that only atoms in the specified group contribute to the\n  calculation.  The compute chunk/atom command\n  defines its own group; atoms will have a chunk ID = 0 if they are not\n  in that group, signifying they are not assigned to a chunk, and will\n  thus also not contribute to this calculation.  You can specify the\n  “all” group for this command if you simply want to include atoms with\n  non-zero chunk IDs.\n  The simplest way to output the results of the compute vcm/chunk\n  calculation to a file is to use the fix ave/time\n  command, for example:\n  compute cc1 all chunk/atom molecule\n  compute myChunk all vcm/chunk cc1\n  fix 1 all ave/time 100 1 100 c_myChunk[*] file tmp.out mode vector\n  \n  \n  Output info:\n  This compute calculates a global array where the number of rows = the\n  number of chunks Nchunk as calculated by the specified compute chunk/atom command.  The number of columns =\n  3 for the x,y,z center-of-mass velocity coordinates of each chunk.\n  These values can be accessed by any command that uses global array\n  values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The array values are “intensive”.  The array values will be in\n  velocity units.\n  ",
    "syntax": "compute ID group-ID vcm/chunk chunkID\n  \n  \n  \n  ID, group-ID are documented in compute command\n  vcm/chunk = style name of this compute command\n  chunkID = ID of compute chunk/atom command\n  \n  ",
    "examples": "compute 1 fluid vcm/chunk molchunk\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  Related commands: none\n  Default: none\n  "
},
{
    "command": "compute voronoi/atom",
    "description": "Define a computation that calculates the Voronoi tessellation of the\n  atoms in the simulation box.  The tessellation is calculated using all\n  atoms in the simulation, but non-zero values are only stored for atoms\n  in the group.\n  By default two per-atom quantities are calculated by this compute.\n  The first is the volume of the Voronoi cell around each atom.  Any\n  point in an atom’s Voronoi cell is closer to that atom than any other.\n  The second is the number of faces of the Voronoi cell. This is\n  equal to the number of nearest neighbors of the central atom,\n  plus any exterior faces (see note below). If the peratom keyword\n  is set to “no”, the per-atom quantities are still calculated,\n  but they are not accessible.\n  \n  If the only_group keyword is specified the tessellation is performed\n  only with respect to the atoms contained in the compute group. This is\n  equivalent to deleting all atoms not contained in the group prior to\n  evaluating the tessellation.\n  If the surface keyword is specified a third quantity per atom is\n  computed: the Voronoi cell surface of the given atom. surface takes\n  a group ID as an argument. If a group other than all is specified,\n  only the Voronoi cell facets facing a neighbor atom from the specified\n  group are counted towards the surface area.\n  In the example above, a precipitate embedded in a matrix, only atoms\n  at the surface of the precipitate will have non-zero surface area, and\n  only the outward facing facets of the Voronoi cells are counted (the\n  hull of the precipitate). The total surface area of the precipitate\n  can be obtained by running a “reduce sum” compute on c_2[3]\n  If the radius keyword is specified with an atom style variable as\n  the argument, a poly-disperse Voronoi tessellation is\n  performed. Examples for radius variables are\n  variable r1 atom (type==1)*0.1+(type==2)*0.4\n  compute radius all property/atom radius\n  variable r2 atom c_radius\n  \n  \n  Here v_r1 specifies a per-type radius of 0.1 units for type 1 atoms\n  and 0.4 units for type 2 atoms, and v_r2 accesses the radius property\n  present in atom_style sphere for granular models.\n  The edge_histo keyword activates the compilation of a histogram of\n  number of edges on the faces of the Voronoi cells in the compute\n  group. The argument maxedge of the this keyword is the largest number\n  of edges on a single Voronoi cell face expected to occur in the\n  sample. This keyword adds the generation of a global vector with\n  maxedge+1 entries. The last entry in the vector contains the number of\n  faces with more than maxedge edges. Since the polygon with the\n  smallest amount of edges is a triangle, entries 1 and 2 of the vector\n  will always be zero.\n  The edge_threshold and face_threshold keywords allow the\n  suppression of edges below a given minimum length and faces below a\n  given minimum area. Ultra short edges and ultra small faces can occur\n  as artifacts of the Voronoi tessellation. These keywords will affect\n  the neighbor count and edge histogram outputs.\n  If the occupation keyword is specified the tessellation is only\n  performed for the first invocation of the compute and then stored.\n  For all following invocations of the compute the number of atoms in\n  each Voronoi cell in the stored tessellation is counted. In this mode\n  the compute returns a per-atom array with 2 columns. The first column\n  is the number of atoms currently in the Voronoi volume defined by this\n  atom at the time of the first invocation of the compute (note that the\n  atom may have moved significantly). The second column contains the\n  total number of atoms sharing the Voronoi cell of the stored\n  tessellation at the location of the current atom. Numbers in column\n  one can be any positive integer including zero, while column two\n  values will always be greater than zero. Column one data can be used\n  to locate vacancies (the coordinates are given by the atom coordinates\n  at the time step when the compute was first invoked), while column two\n  data can be used to identify interstitial atoms.\n  If the neighbors value is set to yes, then this compute creates a\n  local array with 3 columns. There is one row for each face of each\n  Voronoi cell. The 3 columns are the atom ID of the atom that owns the\n  cell, the atom ID of the atom in the neighboring cell (or zero if the\n  face is external), and the area of the face.  The array can be\n  accessed by any command that uses local values from a compute as\n  input.  See the Howto output doc page for an\n  overview of LAMMPS output options. More specifically, the array can be\n  accessed by a dump local command to write a file\n  containing all the Voronoi neighbors in a system:\n  compute 6 all voronoi/atom neighbors yes\n  dump d2 all local 1 dump.neighbors index c_6[1] c_6[2] c_6[3]\n  \n  \n  If the face_threshold keyword is used, then only faces\n  with areas greater than the threshold are stored.\n  \n  The Voronoi calculation is performed by the freely available Voro++ package, written by Chris Rycroft at UC Berkeley and LBL,\n  which must be installed on your system when building LAMMPS for use\n  with this compute.  See instructions on obtaining and installing the\n  Voro++ software in the src/VORONOI/README file.\n  \n  Note\n  The calculation of Voronoi volumes is performed by each\n  processor for the atoms it owns, and includes the effect of ghost\n  atoms stored by the processor.  This assumes that the Voronoi cells of\n  owned atoms are not affected by atoms beyond the ghost atom cut-off\n  distance.  This is usually a good assumption for liquid and solid\n  systems, but may lead to underestimation of Voronoi volumes in low\n  density systems.  By default, the set of ghost atoms stored by each\n  processor is determined by the cutoff used for\n  pair_style interactions.  The cutoff can be set\n  explicitly via the comm_modify cutoff command.  The\n  Voronoi cells for atoms adjacent to empty regions will extend into\n  those regions up to the communication cutoff in x, y, or z.  In that\n  situation, an exterior face is created at the cutoff distance normal\n  to the x, y, or z direction.  For triclinic systems, the exterior face\n  is parallel to the corresponding reciprocal lattice vector.\n  \n  \n  Note\n  The Voro++ package performs its calculation in 3d.  This will\n  still work for a 2d LAMMPS simulation, provided all the atoms have the\n  same z coordinate. The Voronoi cell of each atom will be a columnar\n  polyhedron with constant cross-sectional area along the z direction\n  and two exterior faces at the top and bottom of the simulation box. If\n  the atoms do not all have the same z coordinate, then the columnar\n  cells will be accordingly distorted. The cross-sectional area of each\n  Voronoi cell can be obtained by dividing its volume by the z extent of\n  the simulation box.  Note that you define the z extent of the\n  simulation box for 2d simulations when using the\n  create_box or read_data commands.\n  \n  Output info:\n  By default, this compute calculates a per-atom array with 2\n  columns. In regular dynamic tessellation mode the first column is the\n  Voronoi volume, the second is the neighbor count, as described above\n  (read above for the output data in case the occupation keyword is\n  specified).  These values can be accessed by any command that uses\n  per-atom values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options. If the peratom keyword is set to “no”, the per-atom array\n  is still created, but it is not accessible.\n  If the edge_histo keyword is used, then this compute generates a\n  global vector of length maxedge+1, containing a histogram of the\n  number of edges per face.\n  If the neighbors value is set to yes, then this compute calculates a\n  local array with 3 columns. There is one row for each face of each\n  Voronoi cell.\n  \n  Note\n  Some LAMMPS commands such as the compute reduce command can accept either a per-atom or\n  local quantity. If this compute produces both quantities, the command\n  may access the per-atom quantity, even if you want to access the local\n  quantity.  This effect can be eliminated by using the peratom\n  keyword to turn off the production of the per-atom quantities.  For\n  the default value yes both quantities are produced.  For the value\n  no, only the local array is produced.\n  \n  The Voronoi cell volume will be in distance units cubed.\n  The Voronoi face area will be in distance units squared.\n  ",
    "syntax": "compute ID group-ID voronoi/atom keyword arg ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  voronoi/atom = style name of this compute command\n  zero or more keyword/value pairs may be appended\n  keyword = only_group or surface or radius or edge_histo or edge_threshold\n  or face_threshold or neighbors or peratom\n  only_group = no arg\n  occupation = no arg\n  surface arg = sgroup-ID\n    sgroup-ID = compute the dividing surface between group-ID and sgroup-ID\n      this keyword adds a third column to the compute output\n  radius arg = v_r\n    v_r = radius atom style variable for a poly-disperse Voronoi tessellation\n  edge_histo arg = maxedge\n    maxedge = maximum number of Voronoi cell edges to be accounted in the histogram\n  edge_threshold arg = minlength\n    minlength = minimum length for an edge to be counted\n  face_threshold arg = minarea\n    minarea = minimum area for a face to be counted\n  neighbors value = yes or no = store list of all neighbors or no\n  peratom value = yes or no = per-atom quantities accessible or no\n  \n  \n  ",
    "examples": "compute 1 all voronoi/atom\n  compute 2 precipitate voronoi/atom surface matrix\n  compute 3b precipitate voronoi/atom radius v_r\n  compute 4 solute voronoi/atom only_group\n  compute 5 defects voronoi/atom occupation\n  compute 6 all voronoi/atom neighbors yes\n  \n  \n  ",
    "restrictions": "This compute is part of the VORONOI package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  It also requires you have a copy of the Voro++ library built and\n  installed on your system.  See instructions on obtaining and\n  installing the Voro++ software in the src/VORONOI/README file.\n  "
},
{
    "command": "compute xrd",
    "description": "Define a computation that calculates x-ray diffraction intensity as described\n  in (Coleman) on a mesh of reciprocal lattice nodes defined\n  by the entire simulation domain (or manually) using a simulated radiation\n  of wavelength lambda.\n  The x-ray diffraction intensity, I, at each reciprocal lattice point, k,\n  is computed from the structure factor, F, using the equations:\n  \n  \\[\\begin{split}I =             & Lp(\\theta)\\frac{F^{*}F}{N} \\\\\n  F(\\mathbf{k}) = & \\sum_{j=1}^{N}f_j(\\theta)exp(2\\pi i \\mathbf{k}\\cdot \\mathbf{r}_j) \\\\\n  Lp(\\theta)    = & \\frac{1+cos^{2}(2\\theta)}{cos(\\theta)sin^{2}(\\theta)} \\\\\n  \\frac{sin(\\theta)}{\\lambda} = & \\frac{\\left | \\mathbf{k} \\right |}{2}\\end{split}\\]\n  Here, K is the location of the reciprocal lattice node, \\(r_j\\) is the\n  position of each atom, \\(f_j\\) are atomic scattering factors, Lp is the\n  Lorentz-polarization factor, and \\(\\theta\\) is the scattering angle of\n  diffraction.  The Lorentz-polarization factor can be turned off using\n  the optional LP keyword.\n  Diffraction intensities are calculated on a three-dimensional mesh of\n  reciprocal lattice nodes. The mesh spacing is defined either (a)\n  by the entire simulation domain or (b) manually using selected values as\n  shown in the 2D diagram below.\n  \n  For a mesh defined by the simulation domain, a rectilinear grid is\n  constructed with spacing c*inv(A) along each reciprocal lattice\n  axis. Where A are the vectors corresponding to the edges of the\n  simulation cell. If one or two directions has non-periodic boundary\n  conditions, then the spacing in these directions is defined from the\n  average of the (inversed) box lengths with periodic boundary conditions.\n  Meshes defined by the simulation domain must contain at least one periodic\n  boundary.\n  If the manual flag is included, the mesh of reciprocal lattice nodes\n  will defined using the c values for the spacing along each\n  reciprocal lattice axis. Note that manual mapping of the reciprocal\n  space mesh is good for comparing diffraction results from multiple\n  simulations; however it can reduce the likelihood that Bragg\n  reflections will be satisfied unless small spacing parameters (< 0.05\n  Angstrom^(-1)) are implemented.  Meshes with manual spacing do not\n  require a periodic boundary.\n  The limits of the reciprocal lattice mesh are determined by range of\n  scattering angles explored.  The 2Theta parameters allows the user\n  to reduce the scattering angle range to only the region of interest\n  which reduces the cost of the computation.\n  The atomic scattering factors, fj, accounts for the reduction in\n  diffraction intensity due to Compton scattering.  Compute xrd uses\n  analytical approximations of the atomic scattering factors that vary\n  for each atom type (type1 type2 … typeN) and angle of diffraction.\n  The analytic approximation is computed using the formula\n  (Colliex):\n  \n  \\[f_j\\left ( \\frac{sin(\\theta)}{\\lambda} \\right )=\\sum_{i}^{4}\n  a_i exp\\left ( -b_i \\frac{sin^{2}(\\theta)}{\\lambda^{2}} \\right )+c\\]\n  Coefficients parameterized by (Peng) are assigned for each\n  atom type designating the chemical symbol and charge of each atom\n  type. Valid chemical symbols for compute xrd are:\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  H\n  He1-\n  He\n  Li\n  Li1+\n  \n  Be\n  Be2+\n  B\n  C\n  Cval\n  \n  N\n  O\n  O1-\n  F\n  F1-\n  \n  Ne\n  Na\n  Na1+\n  Mg\n  Mg2+\n  \n  Al\n  Al3+\n  Si\n  Sival\n  Si4+\n  \n  P\n  S\n  Cl\n  Cl1-\n  Ar\n  \n  K\n  Ca\n  Ca2+\n  Sc\n  Sc3+\n  \n  Ti\n  Ti2+\n  Ti3+\n  Ti4+\n  V\n  \n  V2+\n  V3+\n  V5+\n  Cr\n  Cr2+\n  \n  Cr3+\n  Mn\n  Mn2+\n  Mn3+\n  Mn4+\n  \n  Fe\n  Fe2+\n  Fe3+\n  Co\n  Co2+\n  \n  Co\n  Ni\n  Ni2+\n  Ni3+\n  Cu\n  \n  Cu1+\n  Cu2+\n  Zn\n  Zn2+\n  Ga\n  \n  Ga3+\n  Ge\n  Ge4+\n  As\n  Se\n  \n  Br\n  Br1-\n  Kr\n  Rb\n  Rb1+\n  \n  Sr\n  Sr2+\n  Y\n  Y3+\n  Zr\n  \n  Zr4+\n  Nb\n  Nb3+\n  Nb5+\n  Mo\n  \n  Mo3+\n  Mo5+\n  Mo6+\n  Tc\n  Ru\n  \n  Ru3+\n  Ru4+\n  Rh\n  Rh3+\n  Rh4+\n  \n  Pd\n  Pd2+\n  Pd4+\n  Ag\n  Ag1+\n  \n  Ag2+\n  Cd\n  Cd2+\n  In\n  In3+\n  \n  Sn\n  Sn2+\n  Sn4+\n  Sb\n  Sb3+\n  \n  Sb5+\n  Te\n  I\n  I1-\n  Xe\n  \n  Cs\n  Cs1+\n  Ba\n  Ba2+\n  La\n  \n  La3+\n  Ce\n  Ce3+\n  Ce4+\n  Pr\n  \n  Pr3+\n  Pr4+\n  Nd\n  Nd3+\n  Pm\n  \n  Pm3+\n  Sm\n  Sm3+\n  Eu\n  Eu2+\n  \n  Eu3+\n  Gd\n  Gd3+\n  Tb\n  Tb3+\n  \n  Dy\n  Dy3+\n  Ho\n  Ho3+\n  Er\n  \n  Er3+\n  Tm\n  Tm3+\n  Yb\n  Yb2+\n  \n  Yb3+\n  Lu\n  Lu3+\n  Hf\n  Hf4+\n  \n  Ta\n  Ta5+\n  W\n  W6+\n  Re\n  \n  Os\n  Os4+\n  Ir\n  Ir3+\n  Ir4+\n  \n  Pt\n  Pt2+\n  Pt4+\n  Au\n  Au1+\n  \n  Au3+\n  Hg\n  Hg1+\n  Hg2+\n  Tl\n  \n  Tl1+\n  Tl3+\n  Pb\n  Pb2+\n  Pb4+\n  \n  Bi\n  Bi3+\n  Bi5+\n  Po\n  At\n  \n  Rn\n  Fr\n  Ra\n  Ra2+\n  Ac\n  \n  Ac3+\n  Th\n  Th4+\n  Pa\n  U\n  \n  U3+\n  U4+\n  U6+\n  Np\n  Np3+\n  \n  Np4+\n  Np6+\n  Pu\n  Pu3+\n  Pu4+\n  \n  Pu6+\n  Am\n  Cm\n  Bk\n  Cf\n  \n  \n  \n  If the echo keyword is specified, compute xrd will provide extra\n  reporting information to the screen.\n  Output info:\n  This compute calculates a global array.  The number of rows in the\n  array is the number of reciprocal lattice nodes that are explored\n  which by the mesh.  The global array has 2 columns.\n  The first column contains the diffraction angle in the units (radians\n  or degrees) provided with the 2Theta values. The second column contains\n  the computed diffraction intensities as described above.\n  The array can be accessed by any command that uses global values from\n  a compute as input.  See the Howto output doc page\n  for an overview of LAMMPS output options.\n  All array values calculated by this compute are “intensive”.\n  ",
    "syntax": "compute ID group-ID xrd lambda type1 type2 ... typeN keyword value ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  xrd = style name of this compute command\n  lambda = wavelength of incident radiation (length units)\n  type1 type2 … typeN = chemical symbol of each atom type (see valid options below)\n  zero or more keyword/value pairs may be appended\n  keyword = 2Theta or c or LP or manual or echo\n  2Theta values = Min2Theta Max2Theta\n    Min2Theta,Max2Theta = minimum and maximum 2 theta range to explore\n    (radians or degrees)\n  c values = c1 c2 c3\n    c1,c2,c3 = parameters to adjust the spacing of the reciprocal\n               lattice nodes in the h, k, and l directions respectively\n  LP value = switch to apply Lorentz-polarization factor\n    0/1 = off/on\n  manual = flag to use manual spacing of reciprocal lattice points\n             based on the values of the c parameters\n  echo = flag to provide extra output for debugging purposes\n  \n  \n  ",
    "examples": "compute 1 all xrd 1.541838 Al O 2Theta 0.087 0.87 c 1 1 1 LP 1 echo\n  compute 2 all xrd 1.541838 Al O 2Theta 10 100 c 0.05 0.05 0.05 LP 1 manual\n  \n  fix 1 all ave/histo/weight 1 1 1 0.087 0.87 250 c_1[1] c_1[2] mode vector file Rad2Theta.xrd\n  fix 2 all ave/histo/weight 1 1 1 10 100 250 c_2[1] c_2[2] mode vector file Deg2Theta.xrd\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-DIFFRACTION package.  It is only\n  enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\n  The compute_xrd command does not work for triclinic cells.\n  "
},
{
    "command": "angle_coeff",
    "description": "Specify the angle force field coefficients for one or more angle types.\n  The number and meaning of the coefficients depends on the angle style.\n  Angle coefficients can also be set in the data file read by the\n  read_data command or in a restart file.\n  N can be specified in one of two ways.  An explicit numeric value can\n  be used, as in the 1st example above.  Or a wild-card asterisk can be\n  used to set the coefficients for multiple angle types.  This takes the\n  form “*” or “*n” or “n*” or “m*n”.  If N = the number of angle types,\n  then an asterisk with no numeric values means all types from 1 to N.  A\n  leading asterisk means all types from 1 to n (inclusive).  A trailing\n  asterisk means all types from n to N (inclusive).  A middle asterisk\n  means all types from m to n (inclusive).\n  Note that using an angle_coeff command can override a previous setting\n  for the same angle type.  For example, these commands set the coeffs\n  for all angle types, then overwrite the coeffs for just angle type 2:\n  angle_coeff * 200.0 107.0 1.2\n  angle_coeff 2 50.0 107.0\n  \n  \n  A line in a data file that specifies angle coefficients uses the exact\n  same format as the arguments of the angle_coeff command in an input\n  script, except that wild-card asterisks should not be used since\n  coefficients for all N types must be listed in the file.  For example,\n  under the “Angle Coeffs” section of a data file, the line that\n  corresponds to the 1st example above would be listed as\n  1 300.0 107.0\n  \n  \n  The angle_style class2 is an exception to this\n  rule, in that an additional argument is used in the input script to\n  allow specification of the cross-term coefficients.   See its\n  doc page for details.\n  \n  The list of all angle styles defined in LAMMPS is given on the\n  angle_style doc page.  They are also listed in more\n  compact form on the Commands angle doc\n  page.\n  On either of those pages, click on the style to display the formula it\n  computes and its coefficients as specified by the associated\n  angle_coeff command.\n  ",
    "syntax": "angle_coeff N args\n  \n  \n  \n  N = angle type (see asterisk form below)\n  args = coefficients for one or more angle types\n  \n  ",
    "examples": "angle_coeff 1 300.0 107.0\n  angle_coeff * 5.0\n  angle_coeff 2*10 5.0\n  \n  \n  ",
    "restrictions": "This command must come after the simulation box is defined by a\n  read_data, read_restart, or\n  create_box command.\n  An angle style must be defined before any angle coefficients are\n  set, either in the input script or in a data file.\n  "
},
{
    "command": "angle_style",
    "description": "Set the formula(s) LAMMPS uses to compute angle interactions between\n  triplets of atoms, which remain in force for the duration of the\n  simulation.  The list of angle triplets is read in by a\n  read_data or read_restart command\n  from a data or restart file.\n  Hybrid models where angles are computed using different angle\n  potentials can be setup using the hybrid angle style.\n  The coefficients associated with a angle style can be specified in a\n  data or restart file or via the angle_coeff command.\n  All angle potentials store their coefficient data in binary restart\n  files which means angle_style and angle_coeff\n  commands do not need to be re-specified in an input script that\n  restarts a simulation.  See the read_restart\n  command for details on how to do this.  The one exception is that\n  angle_style hybrid only stores the list of sub-styles in the restart\n  file; angle coefficients need to be re-specified.\n  \n  Note\n  When both an angle and pair style is defined, the\n  special_bonds command often needs to be used to\n  turn off (or weight) the pairwise interaction that would otherwise\n  exist between 3 bonded atoms.\n  \n  In the formulas listed for each angle style, theta is the angle\n  between the 3 atoms in the angle.\n  \n  Here is an alphabetic list of angle styles defined in LAMMPS.  Click on\n  the style to display the formula it computes and coefficients\n  specified by the associated angle_coeff command.\n  Click on the style to display the formula it computes, any additional\n  arguments specified in the angle_style command, and coefficients\n  specified by the associated angle_coeff command.\n  There are also additional accelerated pair styles included in the\n  LAMMPS distribution for faster performance on CPUs, GPUs, and KNLs.\n  The individual style names on the Commands angle doc page are followed by one or more\n  of (g,i,k,o,t) to indicate which accelerated styles exist.\n  \n  none - turn off angle interactions\n  zero - topology but no interactions\n  hybrid - define multiple styles of angle interactions\n  charmm - CHARMM angle\n  class2 - COMPASS (class 2) angle\n  class2/p6 - COMPASS (class 2) angle expanded to 6th order\n  cosine - angle with cosine term\n  cosine/buck6d - same as cosine with Buckingham term between 1-3 atoms\n  cosine/delta - angle with difference of cosines\n  cosine/periodic - DREIDING angle\n  cosine/shift - angle cosine with a shift\n  cosine/shift/exp - cosine with shift and exponential term in spring constant\n  cosine/squared - angle with cosine squared term\n  cross - cross term coupling angle and bond lengths\n  dipole - angle that controls orientation of a point dipole\n  fourier - angle with multiple cosine terms\n  fourier/simple - angle with a single cosine term\n  harmonic - harmonic angle\n  mm3 - anharmonic angle\n  quartic - angle with cubic and quartic terms\n  sdk - harmonic angle with repulsive SDK pair style between 1-3 atoms\n  table - tabulated by angle\n  \n  ",
    "syntax": "angle_style style\n  \n  \n  \n  style = none or hybrid or charmm or class2 or cosine or         cosine/squared or harmonic\n  \n  ",
    "examples": "angle_style harmonic\n  angle_style charmm\n  angle_style hybrid harmonic cosine\n  \n  \n  ",
    "restrictions": "Angle styles can only be set for atom_styles that allow angles to be\n  defined.\n  Most angle styles are part of the MOLECULE package.  They are only\n  enabled if LAMMPS was built with that package.  See the Build package doc page for more info.  The doc pages for\n  individual bond potentials tell if it is part of a package.\n  "
},
{
    "command": "atom_modify",
    "description": "Modify certain attributes of atoms defined and stored within LAMMPS,\n  in addition to what is specified by the atom_style\n  command.  The id and map keywords must be specified before a\n  simulation box is defined; other keywords can be specified any time.\n  The id keyword determines whether non-zero atom IDs can be assigned\n  to each atom.  If the value is yes, which is the default, IDs are\n  assigned, whether you use the create atoms or\n  read_data or read_restart\n  commands to initialize atoms.  If the value is no the IDs for all\n  atoms are assumed to be 0.\n  If atom IDs are used, they must all be positive integers.  They should\n  also be unique, though LAMMPS does not check for this.  Typically they\n  should also be consecutively numbered (from 1 to Natoms), though this\n  is not required.  Molecular atom styles are those\n  that store bond topology information (styles bond, angle, molecular,\n  full).  These styles require atom IDs since the IDs are used to encode\n  the topology.  Some other LAMMPS commands also require the use of atom\n  IDs.  E.g. some many-body pair styles use them to avoid double\n  computation of the I-J interaction between two atoms.\n  The only reason not to use atom IDs is if you are running an atomic\n  simulation so large that IDs cannot be uniquely assigned.  For a\n  default LAMMPS build this limit is 2^31 or about 2 billion atoms.\n  However, even in this case, you can use 64-bit atom IDs, allowing 2^63\n  or about 9e18 atoms, if you build LAMMPS with the - DLAMMPS_BIGBIG\n  switch.  This is described on the Build_settings\n  doc page.  If atom IDs are not used, they must be specified as 0 for\n  all atoms, e.g. in a data or restart file.\n  The map keyword determines how atoms with specific IDs are found\n  when required.  An example are the bond (angle, etc) methods which\n  need to find the local index of an atom with a specific global ID\n  which is a bond (angle, etc) partner.  LAMMPS performs this operation\n  efficiently by creating a “map”, which is either an array or hash\n  table, as described below.\n  When the map keyword is not specified in your input script, LAMMPS\n  only creates a map for atom_styles for molecular\n  systems which have permanent bonds (angles, etc).  No map is created\n  for atomic systems, since it is normally not needed.  However some\n  LAMMPS commands require a map, even for atomic systems, and will\n  generate an error if one does not exist.  The map keyword thus\n  allows you to force the creation of a map.  The yes value will\n  create either an array or hash style map, as explained in the next\n  paragraph.  The array and hash values create an atom-style or\n  hash-style map respectively.\n  For an array-style map, each processor stores a lookup table of\n  length N, where N is the largest atom ID in the system.  This is a\n  fast, simple method for many simulations, but requires too much memory\n  for large simulations.  For a hash-style map, a hash table is\n  created on each processor, which finds an atom ID in constant time\n  (independent of the global number of atom IDs).  It can be slightly\n  slower than the array map, but its memory cost is proportional to\n  the number of atoms owned by a processor, i.e. N/P when N is the total\n  number of atoms in the system and P is the number of processors.\n  The first keyword allows a group to be specified whose\n  atoms will be maintained as the first atoms in each processor’s list\n  of owned atoms.  This in only useful when the specified group is a\n  small fraction of all the atoms, and there are other operations LAMMPS\n  is performing that will be sped-up significantly by being able to loop\n  over the smaller set of atoms.  Otherwise the reordering required by\n  this option will be a net slow-down.  The neigh_modify include and comm_modify group\n  commands are two examples of commands that require this setting to\n  work efficiently.  Several fixes, most notably time\n  integration fixes like fix nve, also take advantage of\n  this setting if the group they operate on is the group specified by\n  this command.  Note that specifying “all” as the group-ID effectively\n  turns off the first option.\n  It is OK to use the first keyword with a group that has not yet been\n  defined, e.g. to use the atom_modify first command at the beginning of\n  your input script.  LAMMPS does not use the group until a simulation\n  is run.\n  The sort keyword turns on a spatial sorting or reordering of atoms\n  within each processor’s sub-domain every Nfreq timesteps.  If\n  Nfreq is set to 0, then sorting is turned off.  Sorting can improve\n  cache performance and thus speed-up a LAMMPS simulation, as discussed\n  in a paper by (Meloni).  Its efficacy depends on the problem\n  size (atoms/processor), how quickly the system becomes disordered, and\n  various other factors.  As a general rule, sorting is typically more\n  effective at speeding up simulations of liquids as opposed to solids.\n  In tests we have done, the speed-up can range from zero to 3-4x.\n  Reordering is performed every Nfreq timesteps during a dynamics run\n  or iterations during a minimization.  More precisely, reordering\n  occurs at the first reneighboring that occurs after the target\n  timestep.  The reordering is performed locally by each processor,\n  using bins of the specified binsize.  If binsize is set to 0.0,\n  then a binsize equal to half the neighbor cutoff\n  distance (force cutoff plus skin distance) is used, which is a\n  reasonable value.  After the atoms have been binned, they are\n  reordered so that atoms in the same bin are adjacent to each other in\n  the processor’s 1d list of atoms.\n  The goal of this procedure is for atoms to put atoms close to each\n  other in the processor’s one-dimensional list of atoms that are also\n  near to each other spatially.  This can improve cache performance when\n  pairwise interactions and neighbor lists are computed.  Note that if\n  bins are too small, there will be few atoms/bin.  Likewise if bins are\n  too large, there will be many atoms/bin.  In both cases, the goal of\n  cache locality will be undermined.\n  \n  Note\n  Running a simulation with sorting on versus off should not\n  change the simulation results in a statistical sense.  However, a\n  different ordering will induce round-off differences, which will lead\n  to diverging trajectories over time when comparing two simulations.\n  Various commands, particularly those which use random numbers\n  (e.g. velocity create, and fix langevin), may generate (statistically identical)\n  results which depend on the order in which atoms are processed.  The\n  order of atoms in a dump file will also typically change\n  if sorting is enabled.\n  \n  ",
    "syntax": "atom_modify keyword values ...\n  \n  \n  \n  one or more keyword/value pairs may be appended\n  keyword = id or map or first or sort\n  id value = yes or no\n  map value = yes or array or hash\n  first value = group-ID = group whose atoms will appear first in internal atom lists\n  sort values = Nfreq binsize\n    Nfreq = sort atoms spatially every this many time steps\n    binsize = bin size for spatial sorting (distance units)\n  \n  \n  ",
    "examples": "atom_modify map yes\n  atom_modify map hash sort 10000 2.0\n  atom_modify first colloid\n  \n  \n  ",
    "restrictions": "The first and sort options cannot be used together.  Since sorting\n  is on by default, it will be turned off if the first keyword is\n  used with a group-ID that is not “all”.\n  Related commands: none\n  "
},
{
    "command": "atom_style",
    "description": "Define what style of atoms to use in a simulation.  This determines\n  what attributes are associated with the atoms.  This command must be\n  used before a simulation is setup via a read_data,\n  read_restart, or create_box\n  command.\n  \n  Note\n  Many of the atom styles discussed here are only enabled if\n  LAMMPS was built with a specific package, as listed below in the\n  Restrictions section.\n  \n  Once a style is assigned, it cannot be changed, so use a style general\n  enough to encompass all attributes.  E.g. with style bond, angular\n  terms cannot be used or added later to the model.  It is OK to use a\n  style more general than needed, though it may be slightly inefficient.\n  The choice of style affects what quantities are stored by each atom,\n  what quantities are communicated between processors to enable forces\n  to be computed, and what quantities are listed in the data file read\n  by the read_data command.\n  These are the additional attributes of each style and the typical\n  kinds of physical systems they are used to model.  All styles store\n  coordinates, velocities, atom IDs and types.  See the\n  read_data, create_atoms, and\n  set commands for info on how to set these various\n  quantities.\n  \n  \n  \n  \n  \n  \n  \n  angle\n  bonds and angles\n  bead-spring polymers with stiffness\n  \n  atomic\n  only the default values\n  coarse-grain liquids, solids, metals\n  \n  body\n  mass, inertia moments, quaternion, angular momentum\n  arbitrary bodies\n  \n  bond\n  bonds\n  bead-spring polymers\n  \n  charge\n  charge\n  atomic system with charges\n  \n  dipole\n  charge and dipole moment\n  system with dipolar particles\n  \n  dpd\n  internal temperature and internal energies\n  DPD particles\n  \n  edpd\n  temperature and heat capacity\n  eDPD particles\n  \n  mdpd\n  density\n  mDPD particles\n  \n  tdpd\n  chemical concentration\n  tDPD particles\n  \n  electron\n  charge and spin and eradius\n  electronic force field\n  \n  ellipsoid\n  shape, quaternion, angular momentum\n  aspherical particles\n  \n  full\n  molecular + charge\n  bio-molecules\n  \n  line\n  end points, angular velocity\n  rigid bodies\n  \n  meso\n  rho, e, cv\n  SPH particles\n  \n  molecular\n  bonds, angles, dihedrals, impropers\n  uncharged molecules\n  \n  peri\n  mass, volume\n  mesoscopic Peridynamic models\n  \n  smd\n  volume, kernel diameter, contact radius, mass\n  solid and fluid SPH particles\n  \n  sphere\n  diameter, mass, angular velocity\n  granular models\n  \n  spin\n  magnetic moment\n  system with magnetic particles\n  \n  template\n  template index, template atom\n  small molecules with fixed topology\n  \n  tri\n  corner points, angular momentum\n  rigid bodies\n  \n  wavepacket\n  charge, spin, eradius, etag, cs_re, cs_im\n  AWPMD\n  \n  \n  \n  \n  Note\n  It is possible to add some attributes, such as a molecule ID, to\n  atom styles that do not have them via the fix property/atom command.  This command also\n  allows new custom attributes consisting of extra integer or\n  floating-point values to be added to atoms.  See the fix property/atom doc page for examples of cases\n  where this is useful and details on how to initialize, access, and\n  output the custom values.\n  \n  All of the above styles define point particles, except the sphere,\n  ellipsoid, electron, peri, wavepacket, line, tri, and\n  body styles, which define finite-size particles.  See the Howto spherical doc page for an overview of using\n  finite-size particle models with LAMMPS.\n  All of the point-particle styles assign mass to particles on a\n  per-type basis, using the mass command, The finite-size\n  particle styles assign mass to individual particles on a per-particle\n  basis.\n  For the sphere style, the particles are spheres and each stores a\n  per-particle diameter and mass.  If the diameter > 0.0, the particle\n  is a finite-size sphere.  If the diameter = 0.0, it is a point\n  particle.  Note that by use of the disc keyword with the fix nve/sphere, fix nvt/sphere,\n  fix nph/sphere, fix npt/sphere commands, spheres can be effectively\n  treated as 2d discs for a 2d simulation if desired.  See also the set density/disc command.\n  For the ellipsoid style, the particles are ellipsoids and each\n  stores a flag which indicates whether it is a finite-size ellipsoid or\n  a point particle.  If it is an ellipsoid, it also stores a shape\n  vector with the 3 diameters of the ellipsoid and a quaternion 4-vector\n  with its orientation.\n  For the dipole style, a point dipole is defined for each point\n  particle.  Note that if you wish the particles to be finite-size\n  spheres as in a Stockmayer potential for a dipolar fluid, so that the\n  particles can rotate due to dipole-dipole interactions, then you need\n  to use atom_style hybrid sphere dipole, which will assign both a\n  diameter and dipole moment to each particle.\n  For the electron style, the particles representing electrons are 3d\n  Gaussians with a specified position and bandwidth or uncertainty in\n  position, which is represented by the eradius = electron size.\n  For the peri style, the particles are spherical and each stores a\n  per-particle mass and volume.\n  The dpd style is for dissipative particle dynamics (DPD) particles.\n  Note that it is part of the USER-DPD package, and is not for use with\n  the pair_style dpd or dpd/stat commands, which can\n  simply use atom_style atomic.  Atom_style dpd extends DPD particle\n  properties with internal temperature (dpdTheta), internal conductive\n  energy (uCond), internal mechanical energy (uMech), and internal\n  chemical energy (uChem).\n  The edpd style is for energy-conserving dissipative particle\n  dynamics (eDPD) particles which store a temperature (edpd_temp), and\n  heat capacity(edpd_cv).\n  The mdpd style is for many-body dissipative particle dynamics (mDPD)\n  particles which store a density (rho) for considering\n  density-dependent many-body interactions.\n  The tdpd style is for transport dissipative particle dynamics (tDPD)\n  particles which store a set of chemical concentration. An integer\n  “cc_species” is required to specify the number of chemical species\n  involved in a tDPD system.\n  The meso style is for smoothed particle hydrodynamics (SPH)\n  particles which store a density (rho), energy (e), and heat capacity\n  (cv).\n  The smd style is for a general formulation of Smooth Particle\n  Hydrodynamics.  Both fluids and solids can be modeled.  Particles\n  store the mass and volume of an integration point, a kernel diameter\n  used for calculating the field variables (e.g. stress and deformation)\n  and a contact radius for calculating repulsive forces which prevent\n  individual physical bodies from penetrating each other.\n  For the spin style, a magnetic spin is associated to each atom.\n  Those spins have a norm (their magnetic moment) and a direction.\n  The wavepacket style is similar to electron, but the electrons may\n  consist of several Gaussian wave packets, summed up with coefficients\n  cs= (cs_re,cs_im).  Each of the wave packets is treated as a separate\n  particle in LAMMPS, wave packets belonging to the same electron must\n  have identical etag values.\n  For the line style, the particles are idealized line segments and\n  each stores a per-particle mass and length and orientation (i.e. the\n  end points of the line segment).\n  For the tri style, the particles are planar triangles and each\n  stores a per-particle mass and size and orientation (i.e. the corner\n  points of the triangle).\n  The template style allows molecular topology (bonds,angles,etc) to be\n  defined via a molecule template using the molecule\n  command.  The template stores one or more molecules with a single copy\n  of the topology info (bonds,angles,etc) of each.  Individual atoms\n  only store a template index and template atom to identify which\n  molecule and which atom-within-the-molecule they represent.  Using the\n  template style instead of the bond, angle, molecular styles\n  can save memory for systems comprised of a large number of small\n  molecules, all of a single type (or small number of types).  See the\n  paper by Grime and Voth, in (Grime), for examples of how this\n  can be advantageous for large-scale coarse-grained systems.\n  \n  Note\n  When using the template style with a molecule template that contains multiple molecules, you should\n  insure the atom types, bond types, angle_types, etc in all the\n  molecules are consistent.  E.g. if one molecule represents H2O and\n  another CO2, then you probably do not want each molecule file to\n  define 2 atom types and a single bond type, because they will conflict\n  with each other when a mixture system of H2O and CO2 molecules is\n  defined, e.g. by the read_data command.  Rather the\n  H2O molecule should define atom types 1 and 2, and bond type 1.  And\n  the CO2 molecule should define atom types 3 and 4 (or atom types 3 and\n  2 if a single oxygen type is desired), and bond type 2.\n  \n  For the body style, the particles are arbitrary bodies with internal\n  attributes defined by the “style” of the bodies, which is specified by\n  the bstyle argument.  Body particles can represent complex entities,\n  such as surface meshes of discrete points, collections of\n  sub-particles, deformable objects, etc.\n  The Howto body doc page describes the body styles\n  LAMMPS currently supports, and provides more details as to the kind of\n  body particles they represent.  For all styles, each body particle\n  stores moments of inertia and a quaternion 4-vector, so that its\n  orientation and position can be time integrated due to forces and\n  torques.\n  Note that there may be additional arguments required along with the\n  bstyle specification, in the atom_style body command.  These\n  arguments are described on the Howto body doc page.\n  \n  Typically, simulations require only a single (non-hybrid) atom style.\n  If some atoms in the simulation do not have all the properties defined\n  by a particular style, use the simplest style that defines all the\n  needed properties by any atom.  For example, if some atoms in a\n  simulation are charged, but others are not, use the charge style.\n  If some atoms have bonds, but others do not, use the bond style.\n  The only scenario where the hybrid style is needed is if there is no\n  single style which defines all needed properties of all atoms.  For\n  example, as mentioned above, if you want dipolar particles which will\n  rotate due to torque, you need to use “atom_style hybrid sphere\n  dipole”.  When a hybrid style is used, atoms store and communicate the\n  union of all quantities implied by the individual styles.\n  When using the hybrid style, you cannot combine the template style\n  with another molecular style that stores bond,angle,etc info on a\n  per-atom basis.\n  LAMMPS can be extended with new atom styles as well as new body\n  styles; see the Modify doc page.\n  \n  Styles with a kk suffix are functionally the same as the\n  corresponding style without the suffix.  They have been optimized to\n  run faster, depending on your available hardware, as discussed in on\n  the Speed packages doc page.  The accelerated\n  styles take the same arguments and should produce the same results,\n  except for round-off and precision issues.\n  Note that other acceleration packages in LAMMPS, specifically the GPU,\n  USER-INTEL, USER-OMP, and OPT packages do not use accelerated atom\n  styles.\n  The accelerated styles are part of the KOKKOS package.  They are only\n  enabled if LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "atom_style style args\n  \n  \n  \n  style = angle or atomic or body or bond or charge or dipole or         dpd or edpd or mdpd or tdpd or electron or ellipsoid or         full or line or meso or molecular or peri or smd or         sphere or spin or tri or template or hybrid\n  args = none for any style except the following\n    body args = bstyle bstyle-args\n      bstyle = style of body particles\n      bstyle-args = additional arguments specific to the bstyle\n                    see the Howto body doc page for details\n    tdpd arg = Nspecies\n      Nspecies = # of chemical species\n    template arg = template-ID\n      template-ID = ID of molecule template specified in a separate molecule command\n    hybrid args = list of one or more sub-styles, each with their args\n  \n  accelerated styles (with same args) = angle/kk or atomic/kk or bond/kk or charge/kk or full/kk or molecular/kk\n  \n  ",
    "examples": "atom_style atomic\n  atom_style bond\n  atom_style full\n  atom_style body nparticle 2 10\n  atom_style hybrid charge bond\n  atom_style hybrid charge body nparticle 2 5\n  atom_style spin\n  atom_style template myMols\n  atom_style tdpd 2\n  \n  \n  ",
    "restrictions": "This command cannot be used after the simulation box is defined by a\n  read_data or create_box command.\n  Many of the styles listed above are only enabled if LAMMPS was built\n  with a specific package, as listed below.  See the Build package doc page for more info.\n  The angle, bond, full, molecular, and template styles are\n  part of the MOLECULE package.\n  The line and tri styles are part of the ASPHERE package.\n  The body style is part of the BODY package.\n  The dipole style is part of the DIPOLE package.\n  The peri style is part of the PERI package for Peridynamics.\n  The electron style is part of the USER-EFF package for electronic force fields.\n  The dpd style is part of the USER-DPD package for dissipative\n  particle dynamics (DPD).\n  The edpd, mdpd, and tdpd styles are part of the USER-MESODPD package\n  for energy-conserving dissipative particle dynamics (eDPD), many-body\n  dissipative particle dynamics (mDPD), and transport dissipative particle\n  dynamics (tDPD), respectively.\n  The meso style is part of the USER-SPH package for smoothed particle\n  hydrodynamics (SPH).  See this PDF guide to using SPH in LAMMPS.\n  The spin style is part of the SPIN package.\n  The wavepacket style is part of the USER-AWPMD package for the\n  antisymmetrized wave packet MD method.\n  "
},
{
    "command": "balance",
    "description": "This command adjusts the size and shape of processor sub-domains\n  within the simulation box, to attempt to balance the number of atoms\n  or particles and thus indirectly the computational cost (load) more\n  evenly across processors.  The load balancing is “static” in the sense\n  that this command performs the balancing once, before or between\n  simulations.  The processor sub-domains will then remain static during\n  the subsequent run.  To perform “dynamic” balancing, see the fix balance command, which can adjust processor\n  sub-domain sizes and shapes on-the-fly during a run.\n  Load-balancing is typically most useful if the particles in the\n  simulation box have a spatially-varying density distribution or when\n  the computational cost varies significantly between different\n  particles.  E.g. a model of a vapor/liquid interface, or a solid with\n  an irregular-shaped geometry containing void regions, or hybrid pair style simulations which combine pair styles with\n  different computational cost.  In these cases, the LAMMPS default of\n  dividing the simulation box volume into a regular-spaced grid of 3d\n  bricks, with one equal-volume sub-domain per processor, may assign\n  numbers of particles per processor in a way that the computational\n  effort varies significantly.  This can lead to poor performance when\n  the simulation is run in parallel.\n  The balancing can be performed with or without per-particle weighting.\n  With no weighting, the balancing attempts to assign an equal number of\n  particles to each processor.  With weighting, the balancing attempts\n  to assign an equal aggregate computational weight to each processor,\n  which typically induces a different number of atoms assigned to each\n  processor.  Details on the various weighting options and examples for\n  how they can be used are given below.\n  Note that the processors command allows some control\n  over how the box volume is split across processors.  Specifically, for\n  a Px by Py by Pz grid of processors, it allows choice of Px, Py, and\n  Pz, subject to the constraint that Px * Py * Pz = P, the total number\n  of processors.  This is sufficient to achieve good load-balance for\n  some problems on some processor counts.  However, all the processor\n  sub-domains will still have the same shape and same volume.\n  The requested load-balancing operation is only performed if the\n  current “imbalance factor” in particles owned by each processor\n  exceeds the specified thresh parameter.  The imbalance factor is\n  defined as the maximum number of particles (or weight) owned by any\n  processor, divided by the average number of particles (or weight) per\n  processor.  Thus an imbalance factor of 1.0 is perfect balance.\n  As an example, for 10000 particles running on 10 processors, if the\n  most heavily loaded processor has 1200 particles, then the factor is\n  1.2, meaning there is a 20% imbalance.  Note that a re-balance can be\n  forced even if the current balance is perfect (1.0) be specifying a\n  thresh < 1.0.\n  \n  Note\n  Balancing is performed even if the imbalance factor does not\n  exceed the thresh parameter if a “grid” style is specified when the\n  current partitioning is “tiled”.  The meaning of “grid” vs “tiled” is\n  explained below.  This is to allow forcing of the partitioning to\n  “grid” so that the comm_style brick command can then\n  be used to replace a current comm_style tiled\n  setting.\n  \n  When the balance command completes, it prints statistics about the\n  result, including the change in the imbalance factor and the change in\n  the maximum number of particles on any processor.  For “grid” methods\n  (defined below) that create a logical 3d grid of processors, the\n  positions of all cutting planes in each of the 3 dimensions (as\n  fractions of the box length) are also printed.\n  \n  Note\n  This command attempts to minimize the imbalance factor, as\n  defined above.  But depending on the method a perfect balance (1.0)\n  may not be achieved.  For example, “grid” methods (defined below) that\n  create a logical 3d grid cannot achieve perfect balance for many\n  irregular distributions of particles.  Likewise, if a portion of the\n  system is a perfect lattice, e.g. the initial system is generated by\n  the create_atoms command, then “grid” methods may\n  be unable to achieve exact balance.  This is because entire lattice\n  planes will be owned or not owned by a single processor.\n  \n  \n  Note\n  The imbalance factor is also an estimate of the maximum speed-up\n  you can hope to achieve by running a perfectly balanced simulation\n  versus an imbalanced one.  In the example above, the 10000 particle\n  simulation could run up to 20% faster if it were perfectly balanced,\n  versus when imbalanced.  However, computational cost is not strictly\n  proportional to particle count, and changing the relative size and\n  shape of processor sub-domains may lead to additional computational\n  and communication overheads, e.g. in the PPPM solver used via the\n  kspace_style command.  Thus you should benchmark\n  the run times of a simulation before and after balancing.\n  \n  \n  The method used to perform a load balance is specified by one of the\n  listed styles (or more in the case of x,y,z), which are\n  described in detail below.  There are 2 kinds of styles.\n  The x, y, z, and shift styles are “grid” methods which produce\n  a logical 3d grid of processors.  They operate by changing the cutting\n  planes (or lines) between processors in 3d (or 2d), to adjust the\n  volume (area in 2d) assigned to each processor, as in the following 2d\n  diagram where processor sub-domains are shown and particles are\n  colored by the processor that owns them.  The leftmost diagram is the\n  default partitioning of the simulation box across processors (one\n  sub-box for each of 16 processors); the middle diagram is after a\n  “grid” method has been applied.\n  \n  \n  \n  The rcb style is a “tiling” method which does not produce a logical\n  3d grid of processors.  Rather it tiles the simulation domain with\n  rectangular sub-boxes of varying size and shape in an irregular\n  fashion so as to have equal numbers of particles (or weight) in each\n  sub-box, as in the rightmost diagram above.\n  The “grid” methods can be used with either of the\n  comm_style command options, brick or tiled.  The\n  “tiling” methods can only be used with comm_style tiled.  Note that it can be useful to use a “grid”\n  method with comm_style tiled to return the domain\n  partitioning to a logical 3d grid of processors so that “comm_style\n  brick” can afterwords be specified for subsequent run\n  commands.\n  When a “grid” method is specified, the current domain partitioning can\n  be either a logical 3d grid or a tiled partitioning.  In the former\n  case, the current logical 3d grid is used as a starting point and\n  changes are made to improve the imbalance factor.  In the latter case,\n  the tiled partitioning is discarded and a logical 3d grid is created\n  with uniform spacing in all dimensions.  This becomes the starting\n  point for the balancing operation.\n  When a “tiling” method is specified, the current domain partitioning\n  (“grid” or “tiled”) is ignored, and a new partitioning is computed\n  from scratch.\n  \n  The x, y, and z styles invoke a “grid” method for balancing, as\n  described above.  Note that any or all of these 3 styles can be\n  specified together, one after the other, but they cannot be used with\n  any other style.  This style adjusts the position of cutting planes\n  between processor sub-domains in specific dimensions.  Only the\n  specified dimensions are altered.\n  The uniform argument spaces the planes evenly, as in the left\n  diagrams above.  The numeric argument requires listing Ps-1 numbers\n  that specify the position of the cutting planes.  This requires\n  knowing Ps = Px or Py or Pz = the number of processors assigned by\n  LAMMPS to the relevant dimension.  This assignment is made (and the\n  Px, Py, Pz values printed out) when the simulation box is created by\n  the “create_box” or “read_data” or “read_restart” command and is\n  influenced by the settings of the processors\n  command.\n  Each of the numeric values must be between 0 and 1, and they must be\n  listed in ascending order.  They represent the fractional position of\n  the cutting place.  The left (or lower) edge of the box is 0.0, and\n  the right (or upper) edge is 1.0.  Neither of these values is\n  specified.  Only the interior Ps-1 positions are specified.  Thus is\n  there are 2 processors in the x dimension, you specify a single value\n  such as 0.75, which would make the left processor’s sub-domain 3x\n  larger than the right processor’s sub-domain.\n  \n  The shift style invokes a “grid” method for balancing, as\n  described above.  It changes the positions of cutting planes between\n  processors in an iterative fashion, seeking to reduce the imbalance\n  factor, similar to how the fix balance shift\n  command operates.\n  The dimstr argument is a string of characters, each of which must be\n  an “x” or “y” or “z”.  Eacn character can appear zero or one time,\n  since there is no advantage to balancing on a dimension more than\n  once.  You should normally only list dimensions where you expect there\n  to be a density variation in the particles.\n  Balancing proceeds by adjusting the cutting planes in each of the\n  dimensions listed in dimstr, one dimension at a time.  For a single\n  dimension, the balancing operation (described below) is iterated on up\n  to Niter times.  After each dimension finishes, the imbalance factor\n  is re-computed, and the balancing operation halts if the stopthresh\n  criterion is met.\n  A re-balance operation in a single dimension is performed using a\n  recursive multisectioning algorithm, where the position of each\n  cutting plane (line in 2d) in the dimension is adjusted independently.\n  This is similar to a recursive bisectioning for a single value, except\n  that the bounds used for each bisectioning take advantage of\n  information from neighboring cuts if possible.  At each iteration, the\n  count of particles on either side of each plane is tallied.  If the\n  counts do not match the target value for the plane, the position of\n  the cut is adjusted to be halfway between a low and high bound.  The\n  low and high bounds are adjusted on each iteration, using new count\n  information, so that they become closer together over time.  Thus as\n  the recursion progresses, the count of particles on either side of the\n  plane gets closer to the target value.\n  Once the re-balancing is complete and final processor sub-domains\n  assigned, particles are migrated to their new owning processor, and\n  the balance procedure ends.\n  \n  Note\n  At each re-balance operation, the bisectioning for each cutting\n  plane (line in 2d) typically starts with low and high bounds separated\n  by the extent of a processor’s sub-domain in one dimension.  The size\n  of this bracketing region shrinks by 1/2 every iteration.  Thus if\n  Niter is specified as 10, the cutting plane will typically be\n  positioned to 1 part in 1000 accuracy (relative to the perfect target\n  position).  For Niter = 20, it will be accurate to 1 part in a\n  million.  Thus there is no need ot set Niter to a large value.\n  LAMMPS will check if the threshold accuracy is reached (in a\n  dimension) is less iterations than Niter and exit early.  However,\n  Niter should also not be set too small, since it will take roughly\n  the same number of iterations to converge even if the cutting plane is\n  initially close to the target value.\n  \n  \n  The rcb style invokes a “tiled” method for balancing, as described\n  above.  It performs a recursive coordinate bisectioning (RCB) of the\n  simulation domain. The basic idea is as follows.\n  The simulation domain is cut into 2 boxes by an axis-aligned cut in\n  one of the dimensions, leaving one new sub-box on either side of the\n  cut.  Which dimension is chosen for the cut depends on the particle\n  (weight) distribution within the parent box.  Normally the longest\n  dimension of the box is cut, but if all (or most) of the particles are\n  at one end of the box, a cut may be performed in another dimension to\n  induce sub-boxes that are more cube-ish (3d) or square-ish (2d) in\n  shape.\n  After the cut is made, all the processors are also partitioned into 2\n  groups, half assigned to the box on the lower side of the cut, and\n  half to the box on the upper side.  (If the processor count is odd,\n  one side gets an extra processor.)  The cut is positioned so that the\n  number of (weighted) particles in the lower box is exactly the number\n  that the processors assigned to that box should own for load balance\n  to be perfect.  This also makes load balance for the upper box\n  perfect.  The positioning of the cut is done iteratively, by a\n  bisectioning method (median search).  Note that counting particles on\n  either side of the cut requires communication between all processors\n  at each iteration.\n  That is the procedure for the first cut.  Subsequent cuts are made\n  recursively, in exactly the same manner.  The subset of processors\n  assigned to each box make a new cut in one dimension of that box,\n  splitting the box, the subset of processors, and the particles in the\n  box in two.  The recursion continues until every processor is assigned\n  a sub-box of the entire simulation domain, and owns the (weighted)\n  particles in that sub-box.\n  \n  This sub-section describes how to perform weighted load balancing\n  using the weight keyword.\n  By default, all particles have a weight of 1.0, which means each\n  particle is assumed to require the same amount of computation during a\n  timestep.  There are, however, scenarios where this is not a good\n  assumption.  Measuring the computational cost for each particle\n  accurately would be impractical and slow down the computation.\n  Instead the weight keyword implements several ways to influence the\n  per-particle weights empirically by properties readily available or\n  using the user’s knowledge of the system.  Note that the absolute\n  value of the weights are not important; only their relative ratios\n  affect which particle is assigned to which processor.  A particle with\n  a weight of 2.5 is assumed to require 5x more computational than a\n  particle with a weight of 0.5.  For all the options below the weight\n  assigned to a particle must be a positive value; an error will be be\n  generated if a weight is <= 0.0.\n  Below is a list of possible weight options with a short description of\n  their usage and some example scenarios where they might be applicable.\n  It is possible to apply multiple weight flags and the weightings they\n  induce will be combined through multiplication.  Most of the time,\n  however, it is sufficient to use just one method.\n  The group weight style assigns weight factors to specified\n  groups of particles.  The group style keyword is\n  followed by the number of groups, then pairs of group IDs and the\n  corresponding weight factor.  If a particle belongs to none of the\n  specified groups, its weight is not changed.  If it belongs to\n  multiple groups, its weight is the product of the weight factors.\n  This weight style is useful in combination with pair style\n  hybrid, e.g. when combining a more costly many-body\n  potential with a fast pair-wise potential.  It is also useful when\n  using run_style respa where some portions of the\n  system have many bonded interactions and others none.  It assumes that\n  the computational cost for each group remains constant over time.\n  This is a purely empirical weighting, so a series test runs to tune\n  the assigned weight factors for optimal performance is recommended.\n  The neigh weight style assigns the same weight to each particle\n  owned by a processor based on the total count of neighbors in the\n  neighbor list owned by that processor.  The motivation is that more\n  neighbors means a higher computational cost.  The style does not use\n  neighbors per atom to assign a unique weight to each atom, because\n  that value can vary depending on how the neighbor list is built.\n  The factor setting is applied as an overall scale factor to the\n  neigh weights which allows adjustment of their impact on the\n  balancing operation.  The specified factor value must be positive.\n  A value > 1.0 will increase the weights so that the ratio of max\n  weight to min weight increases by factor.  A value < 1.0 will\n  decrease the weights so that the ratio of max weight to min weight\n  decreases by factor.  In both cases the intermediate weight values\n  increase/decrease proportionally as well.  A value = 1.0 has no effect\n  on the neigh weights.  As a rule of thumb, we have found a factor\n  of about 0.8 often results in the best performance, since the number\n  of neighbors is likely to overestimate the ideal weight.\n  This weight style is useful for systems where there are different\n  cutoffs used for different pairs of interactions, or the density\n  fluctuates, or a large number of particles are in the vicinity of a\n  wall, or a combination of these effects.  If a simulation uses\n  multiple neighbor lists, this weight style will use the first suitable\n  neighbor list it finds.  It will not request or compute a new list.  A\n  warning will be issued if there is no suitable neighbor list available\n  or if it is not current, e.g. if the balance command is used before a\n  run or minimize command is used, in which\n  case the neighbor list may not yet have been built.  In this case no\n  weights are computed.  Inserting a run 0 post no command\n  before issuing the balance command, may be a workaround for this\n  case, as it will induce the neighbor list to be built.\n  The time weight style uses timer data to estimate\n  weights.  It assigns the same weight to each particle owned by a\n  processor based on the total computational time spent by that\n  processor.  See details below on what time window is used.  It uses\n  the same timing information as is used for the MPI task timing breakdown, namely, for sections Pair, Bond,\n  Kspace, and Neigh.  The time spent in those portions of the\n  timestep are measured for each MPI rank, summed, then divided by the\n  number of particles owned by that processor.  I.e. the weight is an\n  effective CPU time/particle averaged over the particles on that\n  processor.\n  The factor setting is applied as an overall scale factor to the\n  time weights which allows adjustment of their impact on the\n  balancing operation.  The specified factor value must be positive.\n  A value > 1.0 will increase the weights so that the ratio of max\n  weight to min weight increases by factor.  A value < 1.0 will\n  decrease the weights so that the ratio of max weight to min weight\n  decreases by factor.  In both cases the intermediate weight values\n  increase/decrease proportionally as well.  A value = 1.0 has no effect\n  on the time weights.  As a rule of thumb, effective values to use\n  are typically between 0.5 and 1.2.  Note that the timer quantities\n  mentioned above can be affected by communication which occurs in the\n  middle of the operations, e.g. pair styles with intermediate exchange\n  of data witin the force computation, and likewise for KSpace solves.\n  When using the time weight style with the balance command, the\n  timing data is taken from the preceding run command, i.e. the timings\n  are for the entire previous run.  For the fix balance command the\n  timing data is for only the timesteps since the last balancing\n  operation was performed.  If timing information for the required\n  sections is not available, e.g. at the beginning of a run, or when the\n  timer command is set to either loop or off, a warning\n  is issued.  In this case no weights are computed.\n  \n  Note\n  The time weight style is the most generic option, and should\n  be tried first, unless the group style is easily applicable.\n  However, since the computed cost function is averaged over all\n  particles on a processor, the weights may not be highly accurate.\n  This style can also be effective as a secondary weight in combination\n  with either group or neigh to offset some of inaccuracies in\n  either of those heuristics.\n  \n  The var weight style assigns per-particle weights by evaluating an\n  atom-style variable specified by name.  This is\n  provided as a more flexible alternative to the group weight style,\n  allowing definition of a more complex heuristics based on information\n  (global and per atom) available inside of LAMMPS.  For example,\n  atom-style variables can reference the position of a particle, its\n  velocity, the volume of its Voronoi cell, etc.\n  The store weight style does not compute a weight factor.  Instead it\n  stores the current accumulated weights in a custom per-atom property\n  specified by name.  This must be a property defined as d_name via\n  the fix property/atom command.  Note that\n  these custom per-atom properties can be output in a dump\n  file, so this is a way to examine, debug, or visualize the\n  per-particle weights computed during the load-balancing operation.\n  \n  The out keyword writes a text file to the specified filename with\n  the results of the balancing operation.  The file contains the bounds\n  of the sub-domain for each processor after the balancing operation\n  completes.  The format of the file is compatible with the\n  Pizza.py mdump tool which has support for manipulating and\n  visualizing mesh files.  An example is shown here for a balancing by 4\n  processors for a 2d problem:\n  ITEM: TIMESTEP\n  0\n  ITEM: NUMBER OF NODES\n  16\n  ITEM: BOX BOUNDS\n  0 10\n  0 10\n  0 10\n  ITEM: NODES\n  1 1 0 0 0\n  2 1 5 0 0\n  3 1 5 5 0\n  4 1 0 5 0\n  5 1 5 0 0\n  6 1 10 0 0\n  7 1 10 5 0\n  8 1 5 5 0\n  9 1 0 5 0\n  10 1 5 5 0\n  11 1 5 10 0\n  12 1 10 5 0\n  13 1 5 5 0\n  14 1 10 5 0\n  15 1 10 10 0\n  16 1 5 10 0\n  ITEM: TIMESTEP\n  0\n  ITEM: NUMBER OF SQUARES\n  4\n  ITEM: SQUARES\n  1 1 1 2 3 4\n  2 1 5 6 7 8\n  3 1 9 10 11 12\n  4 1 13 14 15 16\n  \n  \n  The coordinates of all the vertices are listed in the NODES section, 5\n  per processor.  Note that the 4 sub-domains share vertices, so there\n  will be duplicate nodes in the list.\n  The “SQUARES” section lists the node IDs of the 4 vertices in a\n  rectangle for each processor (1 to 4).\n  For a 3d problem, the syntax is similar with 8 vertices listed for\n  each processor, instead of 4, and “SQUARES” replaced by “CUBES”.\n  ",
    "syntax": "balance thresh style args ... keyword args ...\n  \n  \n  \n  thresh = imbalance threshold that must be exceeded to perform a re-balance\n  one style/arg pair can be used (or multiple for x,y,z)\n  style = x or y or z or shift or rcb\n  x args = uniform or Px-1 numbers between 0 and 1\n    uniform = evenly spaced cuts between processors in x dimension\n    numbers = Px-1 ascending values between 0 and 1, Px - # of processors in x dimension\n    x can be specified together with y or z\n  y args = uniform or Py-1 numbers between 0 and 1\n    uniform = evenly spaced cuts between processors in y dimension\n    numbers = Py-1 ascending values between 0 and 1, Py - # of processors in y dimension\n    y can be specified together with x or z\n  z args = uniform or Pz-1 numbers between 0 and 1\n    uniform = evenly spaced cuts between processors in z dimension\n    numbers = Pz-1 ascending values between 0 and 1, Pz - # of processors in z dimension\n    z can be specified together with x or y\n  shift args = dimstr Niter stopthresh\n    dimstr = sequence of letters containing \"x\" or \"y\" or \"z\", each not more than once\n    Niter = # of times to iterate within each dimension of dimstr sequence\n    stopthresh = stop balancing when this imbalance threshold is reached\n  rcb args = none\n  \n  zero or more keyword/arg pairs may be appended\n  keyword = weight or out\n  weight style args = use weighted particle counts for the balancing\n    style = group or neigh or time or var or store\n      group args = Ngroup group1 weight1 group2 weight2 ...\n        Ngroup = number of groups with assigned weights\n        group1, group2, ... = group IDs\n        weight1, weight2, ...   = corresponding weight factors\n      neigh factor = compute weight based on number of neighbors\n        factor = scaling factor (> 0)\n      time factor = compute weight based on time spend computing\n        factor = scaling factor (> 0)\n      var name = take weight from atom-style variable\n        name = name of the atom-style variable\n      store name = store weight in custom atom property defined by fix property/atom command\n        name = atom property name (without d_ prefix)\n  out arg = filename\n    filename = write each processor's sub-domain to a file\n  \n  \n  ",
    "examples": "balance 0.9 x uniform y 0.4 0.5 0.6\n  balance 1.2 shift xz 5 1.1\n  balance 1.0 shift xz 5 1.1\n  balance 1.1 rcb\n  balance 1.0 shift x 10 1.1 weight group 2 fast 0.5 slow 2.0\n  balance 1.0 shift x 10 1.1 weight time 0.8 weight neigh 0.5 weight store balance\n  balance 1.0 shift x 20 1.0 out tmp.balance\n  \n  \n  ",
    "restrictions": "For 2d simulations, the z style cannot be used.  Nor can a “z”\n  appear in dimstr for the shift style.\n  Balancing through recursive bisectioning (rcb style) requires\n  comm_style tiled\n  "
},
{
    "command": "bond_coeff",
    "description": "Specify the bond force field coefficients for one or more bond types.\n  The number and meaning of the coefficients depends on the bond style.\n  Bond coefficients can also be set in the data file read by the\n  read_data command or in a restart file.\n  N can be specified in one of two ways.  An explicit numeric value can\n  be used, as in the 1st example above.  Or a wild-card asterisk can be\n  used to set the coefficients for multiple bond types.  This takes the\n  form “*” or “*n” or “n*” or “m*n”.  If N = the number of bond types,\n  then an asterisk with no numeric values means all types from 1 to N.  A\n  leading asterisk means all types from 1 to n (inclusive).  A trailing\n  asterisk means all types from n to N (inclusive).  A middle asterisk\n  means all types from m to n (inclusive).\n  Note that using a bond_coeff command can override a previous setting\n  for the same bond type.  For example, these commands set the coeffs\n  for all bond types, then overwrite the coeffs for just bond type 2:\n  bond_coeff * 100.0 1.2\n  bond_coeff 2 200.0 1.2\n  \n  \n  A line in a data file that specifies bond coefficients uses the exact\n  same format as the arguments of the bond_coeff command in an input\n  script, except that wild-card asterisks should not be used since\n  coefficients for all N types must be listed in the file.  For example,\n  under the “Bond Coeffs” section of a data file, the line that\n  corresponds to the 1st example above would be listed as\n  5 80.0 1.2\n  \n  \n  \n  The list of all bond styles defined in LAMMPS is given on the\n  bond_style doc page.  They are also listed in more\n  compact form on the Commands bond doc page.\n  On either of those pages, click on the style to display the formula it\n  computes and its coefficients as specified by the associated\n  bond_coeff command.\n  ",
    "syntax": "bond_coeff N args\n  \n  \n  \n  N = bond type (see asterisk form below)\n  args = coefficients for one or more bond types\n  \n  ",
    "examples": "bond_coeff 5 80.0 1.2\n  bond_coeff * 30.0 1.5 1.0 1.0\n  bond_coeff 1*4 30.0 1.5 1.0 1.0\n  bond_coeff 1 harmonic 200.0 1.0\n  \n  \n  ",
    "restrictions": "This command must come after the simulation box is defined by a\n  read_data, read_restart, or\n  create_box command.\n  A bond style must be defined before any bond coefficients are set,\n  either in the input script or in a data file.\n  "
},
{
    "command": "bond_style",
    "description": "Set the formula(s) LAMMPS uses to compute bond interactions between\n  pairs of atoms.  In LAMMPS, a bond differs from a pairwise\n  interaction, which are set via the pair_style\n  command.  Bonds are defined between specified pairs of atoms and\n  remain in force for the duration of the simulation (unless the bond\n  breaks which is possible in some bond potentials).  The list of bonded\n  atoms is read in by a read_data or\n  read_restart command from a data or restart file.\n  By contrast, pair potentials are typically defined between all pairs\n  of atoms within a cutoff distance and the set of active interactions\n  changes over time.\n  Hybrid models where bonds are computed using different bond potentials\n  can be setup using the hybrid bond style.\n  The coefficients associated with a bond style can be specified in a\n  data or restart file or via the bond_coeff command.\n  All bond potentials store their coefficient data in binary restart\n  files which means bond_style and bond_coeff commands\n  do not need to be re-specified in an input script that restarts a\n  simulation.  See the read_restart command for\n  details on how to do this.  The one exception is that bond_style\n  hybrid only stores the list of sub-styles in the restart file; bond\n  coefficients need to be re-specified.\n  \n  Note\n  When both a bond and pair style is defined, the\n  special_bonds command often needs to be used to\n  turn off (or weight) the pairwise interaction that would otherwise\n  exist between 2 bonded atoms.\n  \n  In the formulas listed for each bond style, r is the distance\n  between the 2 atoms in the bond.\n  \n  Here is an alphabetic list of bond styles defined in LAMMPS.  Click on\n  the style to display the formula it computes and coefficients\n  specified by the associated bond_coeff command.\n  Click on the style to display the formula it computes, any additional\n  arguments specified in the bond_style command, and coefficients\n  specified by the associated bond_coeff command.\n  There are also additional accelerated pair styles included in the\n  LAMMPS distribution for faster performance on CPUs, GPUs, and KNLs.\n  The individual style names on the Commands bond\n  doc page are followed by one or more of (g,i,k,o,t) to indicate which\n  accelerated styles exist.\n  \n  none - turn off bonded interactions\n  zero - topology but no interactions\n  hybrid - define multiple styles of bond interactions\n  class2 - COMPASS (class 2) bond\n  fene - FENE (finite-extensible non-linear elastic) bond\n  fene/expand - FENE bonds with variable size particles\n  gromos - GROMOS force field bond\n  harmonic - harmonic bond\n  harmonic/shift - shifted harmonic bond\n  harmonic/shift/cut - shifted harmonic bond with a cutoff\n  mm3 - MM3 anharmonic bond\n  morse - Morse bond\n  nonlinear - nonlinear bond\n  oxdna/fene - modified FENE bond suitable for DNA modeling\n  oxdna2/fene - same as oxdna but used with different pair styles\n  oxrna2/fene - modified FENE bond suitable for RNA modeling\n  quartic - breakable quartic bond\n  table - tabulated by bond length\n  \n  ",
    "syntax": "bond_style style args\n  \n  \n  \n  style = none or hybrid or class2 or fene or fene/expand or         harmonic or morse or nonlinear or quartic\n  args = none for any style except hybrid\n  \n  hybrid args = list of one or more styles\n  \n  \n  \n  ",
    "examples": "bond_style harmonic\n  bond_style fene\n  bond_style hybrid harmonic fene\n  \n  \n  ",
    "restrictions": "Bond styles can only be set for atom styles that allow bonds to be\n  defined.\n  Most bond styles are part of the MOLECULE package.  They are only\n  enabled if LAMMPS was built with that package.  See the Build package doc page for more info.  The doc pages for\n  individual bond potentials tell if it is part of a package.\n  "
},
{
    "command": "bond_write",
    "description": "Write energy and force values to a file as a function of distance for\n  the currently defined bond potential.  This is useful for plotting the\n  potential function or otherwise debugging its values.  If the file\n  already exists, the table of values is appended to the end of the file\n  to allow multiple tables of energy and force to be included in one\n  file.\n  The energy and force values are computed at distances from inner to\n  outer for 2 interacting atoms forming a bond of type btype, using the\n  appropriate bond_coeff coefficients. N evenly spaced\n  distances are used.\n  For example, for N = 7, inner = 1.0, and outer = 4.0,\n  values are computed at r = 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0.\n  The file is written in the format used as input for the\n  bond_style table option with keyword as the\n  section name.  Each line written to the file lists an index number\n  (1-N), a distance (in distance units), an energy (in energy units),\n  and a force (in force units).\n  ",
    "syntax": "bond_write btype N inner outer file keyword itype jtype\n  \n  \n  \n  btype = bond types\n  N = # of values\n  inner,outer = inner and outer bond length (distance units)\n  file = name of file to write values to\n  keyword = section name in file for this set of tabulated values\n  itype,jtype = 2 atom types (optional)\n  \n  ",
    "examples": "bond_write 1 500 0.5 3.5 table.txt Harmonic_1\n  bond_write 3 1000 0.1 6.0 table.txt Morse\n  \n  \n  ",
    "restrictions": "All force field coefficients for bond and other kinds of interactions\n  must be set before this command can be invoked.\n  Due to how the bond force is computed, an inner value > 0.0 must\n  be specified even if the potential has a finite value at r = 0.0.\n  "
},
{
    "command": "boundary",
    "description": "Set the style of boundaries for the global simulation box in each\n  dimension.  A single letter assigns the same style to both the lower\n  and upper face of the box.  Two letters assigns the first style to the\n  lower face and the second style to the upper face.  The initial size\n  of the simulation box is set by the read_data,\n  read_restart, or create_box\n  commands.\n  The style p means the box is periodic, so that particles interact\n  across the boundary, and they can exit one end of the box and re-enter\n  the other end.  A periodic dimension can change in size due to\n  constant pressure boundary conditions or box deformation (see the fix npt and fix deform commands).  The p\n  style must be applied to both faces of a dimension.\n  The styles f, s, and m mean the box is non-periodic, so that\n  particles do not interact across the boundary and do not move from one\n  side of the box to the other.\n  For style f, the position of the face is fixed.  If an atom moves\n  outside the face it will be deleted on the next timestep that\n  reneighboring occurs.  This will typically generate an error unless\n  you have set the thermo_modify lost option to\n  allow for lost atoms.\n  For style s, the position of the face is set so as to encompass the\n  atoms in that dimension (shrink-wrapping), no matter how far they\n  move. Note that when the difference between the current box dimensions\n  and the shrink-wrap box dimensions is large, this can lead to lost\n  atoms at the beginning of a run when running in parallel. This is due\n  to the large change in the (global) box dimensions also causing\n  significant changes in the individual sub-domain sizes. If these\n  changes are farther than the communication cutoff, atoms will be lost.\n  This is best addressed by setting initial box dimensions to match the\n  shrink-wrapped dimensions more closely, by using m style boundaries\n  (see below).\n  For style m, shrink-wrapping occurs, but is bounded by the value\n  specified in the data or restart file or set by the\n  create_box command.  For example, if the upper z\n  face has a value of 50.0 in the data file, the face will always be\n  positioned at 50.0 or above, even if the maximum z-extent of all the\n  atoms becomes less than 50.0.  This can be useful if you start a\n  simulation with an empty box or if you wish to leave room on one side\n  of the box, e.g. for atoms to evaporate from a surface.\n  For triclinic (non-orthogonal) simulation boxes, if the 2nd dimension\n  of a tilt factor (e.g. y for xy) is periodic, then the periodicity is\n  enforced with the tilt factor offset.  If the 1st dimension is\n  shrink-wrapped, then the shrink wrapping is applied to the tilted box\n  face, to encompass the atoms.  E.g. for a positive xy tilt, the xlo\n  and xhi faces of the box are planes tilting in the +y direction as y\n  increases.  These tilted planes are shrink-wrapped around the atoms to\n  determine the x extent of the box.\n  See the Howto triclinic doc page for a\n  geometric description of triclinic boxes, as defined by LAMMPS, and\n  how to transform these parameters to and from other commonly used\n  triclinic representations.\n  ",
    "syntax": "boundary x y z\n  \n  \n  \n  x,y,z = p or s or f or m, one or two letters\n  p is periodic\n  f is non-periodic and fixed\n  s is non-periodic and shrink-wrapped\n  m is non-periodic and shrink-wrapped with a minimum value\n  \n  \n  ",
    "examples": "boundary p p f\n  boundary p fs p\n  boundary s f fm\n  \n  \n  ",
    "restrictions": "This command cannot be used after the simulation box is defined by a\n  read_data or create_box command or\n  read_restart command.  See the\n  change_box command for how to change the simulation\n  box boundaries after it has been defined.\n  For 2d simulations, the z dimension must be periodic.\n  "
},
{
    "command": "box",
    "description": "Set attributes of the simulation box.\n  For triclinic (non-orthogonal) simulation boxes, the tilt keyword\n  allows simulation domains to be created with arbitrary tilt factors,\n  e.g. via the create_box or\n  read_data commands.  Tilt factors determine how\n  skewed the triclinic box is; see the Howto triclinic doc page for a discussion of triclinic\n  boxes in LAMMPS.\n  LAMMPS normally requires that no tilt factor can skew the box more\n  than half the distance of the parallel box length, which is the 1st\n  dimension in the tilt factor (x for xz).  If tilt is set to\n  small, which is the default, then an error will be\n  generated if a box is created which exceeds this limit.  If tilt\n  is set to large, then no limit is enforced.  You can create\n  a box with any tilt factors you wish.\n  Note that if a simulation box has a large tilt factor, LAMMPS will run\n  less efficiently, due to the large volume of communication needed to\n  acquire ghost atoms around a processor’s irregular-shaped sub-domain.\n  For extreme values of tilt, LAMMPS may also lose atoms and generate an\n  error.\n  ",
    "syntax": "box keyword value ...\n  \n  \n  \n  one or more keyword/value pairs may be appended\n  keyword = tilt\n  tilt value = small or large\n  \n  \n  ",
    "examples": "box tilt large\n  box tilt small\n  \n  \n  ",
    "restrictions": "This command cannot be used after the simulation box is defined by a\n  read_data or create_box command or\n  read_restart command.\n  Related commands: none\n  "
},
{
    "command": "change_box",
    "description": "Change the volume and/or shape and/or boundary conditions for the\n  simulation box.  Orthogonal simulation boxes have 3 adjustable size\n  parameters (x,y,z).  Triclinic (non-orthogonal) simulation boxes have\n  6 adjustable size/shape parameters (x,y,z,xy,xz,yz).  Any or all of\n  them can be adjusted independently by this command.  Thus it can be\n  used to expand or contract a box, or to apply a shear strain to a\n  non-orthogonal box.  It can also be used to change the boundary\n  conditions for the simulation box, similar to the\n  boundary command.\n  The size and shape of the initial simulation box are specified by the\n  create_box or read_data or\n  read_restart command used to setup the simulation.\n  The size and shape may be altered by subsequent runs, e.g. by use of\n  the fix npt or fix deform commands.\n  The create_box, read data, and\n  read_restart commands also determine whether the\n  simulation box is orthogonal or triclinic and their doc pages explain\n  the meaning of the xy,xz,yz tilt factors.\n  See the Howto triclinic doc page for a\n  geometric description of triclinic boxes, as defined by LAMMPS, and\n  how to transform these parameters to and from other commonly used\n  triclinic representations.\n  The keywords used in this command are applied sequentially to the\n  simulation box and the atoms in it, in the order specified.\n  Before the sequence of keywords are invoked, the current box\n  size/shape is stored, in case a remap keyword is used to map the\n  atom coordinates from a previously stored box size/shape to the\n  current one.\n  After all the keywords have been processed, any shrink-wrap boundary\n  conditions are invoked (see the boundary command)\n  which may change simulation box boundaries, and atoms are migrated to\n  new owning processors.\n  \n  Note\n  This means that you cannot use the change_box command to enlarge\n  a shrink-wrapped box, e.g. to make room to insert more atoms via the\n  create_atoms command, because the simulation box\n  will be re-shrink-wrapped before the change_box command completes.\n  Instead you could do something like this, assuming the simulation box\n  is non-periodic and atoms extend from 0 to 20 in all dimensions:\n  \n  change_box all x final -10 20\n  create_atoms 1 single -5 5 5       # this will fail to insert an atom\n  \n  change_box all x final -10 20 boundary f s s\n  create_atoms 1 single -5 5 5\n  change_box all boundary s s s      # this will work\n  \n  \n  \n  Note\n  Unlike the earlier “displace_box” version of this command, atom\n  remapping is NOT performed by default.  This command allows remapping\n  to be done in a more general way, exactly when you specify it (zero or\n  more times) in the sequence of transformations.  Thus if you do not\n  use the remap keyword, atom coordinates will not be changed even if\n  the box size/shape changes.  If a uniformly strained state is desired,\n  the remap keyword should be specified.\n  \n  \n  Note\n  It is possible to lose atoms with this command.  E.g. by\n  changing the box without remapping the atoms, and having atoms end up\n  outside of non-periodic boundaries.  It is also possible to alter\n  bonds between atoms straddling a boundary in bad ways.  E.g. by\n  converting a boundary from periodic to non-periodic.  It is also\n  possible when remapping atoms to put them (nearly) on top of each\n  other.  E.g. by converting a boundary from non-periodic to periodic.\n  All of these will typically lead to bad dynamics and/or generate error\n  messages.\n  \n  \n  Note\n  The simulation box size/shape can be changed by arbitrarily\n  large amounts by this command.  This is not a problem, except that the\n  mapping of processors to the simulation box is not changed from its\n  initial 3d configuration; see the processors\n  command.  Thus, if the box size/shape changes dramatically, the\n  mapping of processors to the simulation box may not end up as optimal\n  as the initial mapping attempted to be.\n  \n  \n  Note\n  Because the keywords used in this command are applied one at a\n  time to the simulation box and the atoms in it, care must be taken\n  with triclinic cells to avoid exceeding the limits on skew after each\n  transformation in the sequence.  If skew is exceeded before the final\n  transformation this can be avoided by changing the order of the\n  sequence, or breaking the transformation into two or more smaller\n  transformations.  For more information on the allowed limits for box\n  skew see the discussion on triclinic boxes on Howto triclinic doc page.\n  \n  \n  For the x, y, and z parameters, this is the meaning of their\n  styles and values.\n  For style final, the final lo and hi box boundaries of a dimension\n  are specified.  The values can be in lattice or box distance units.\n  See the discussion of the units keyword below.\n  For style delta, plus or minus changes in the lo/hi box boundaries\n  of a dimension are specified.  The values can be in lattice or box\n  distance units.  See the discussion of the units keyword below.\n  For style scale, a multiplicative factor to apply to the box length\n  of a dimension is specified.  For example, if the initial box length\n  is 10, and the factor is 1.1, then the final box length will be 11.  A\n  factor less than 1.0 means compression.\n  The volume style changes the specified dimension in such a way that\n  the overall box volume remains constant with respect to the operation\n  performed by the preceding keyword.  The volume style can only be\n  used following a keyword that changed the volume, which is any of the\n  x, y, z keywords.  If the preceding keyword “key” had a volume\n  style, then both it and the current keyword apply to the keyword\n  preceding “key”.  I.e. this sequence of keywords is allowed:\n  change_box all x scale 1.1 y volume z volume\n  \n  \n  The volume style changes the associated dimension so that the\n  overall box volume is unchanged relative to its value before the\n  preceding keyword was invoked.\n  If the following command is used, then the z box length will shrink by\n  the same 1.1 factor the x box length was increased by:\n  change_box all x scale 1.1 z volume\n  \n  \n  If the following command is used, then the y,z box lengths will each\n  shrink by sqrt(1.1) to keep the volume constant.  In this case, the\n  y,z box lengths shrink so as to keep their relative aspect ratio\n  constant:\n  change_box all x scale 1.1 y volume z volume\n  \n  \n  If the following command is used, then the final box will be a factor\n  of 10% larger in x and y, and a factor of 21% smaller in z, so as to\n  keep the volume constant:\n  change_box all x scale 1.1 z volume y scale 1.1 z volume\n  \n  \n  \n  Note\n  For solids or liquids, when one dimension of the box is\n  expanded, it may be physically undesirable to hold the other 2 box\n  lengths constant since that implies a density change.  For solids,\n  adjusting the other dimensions via the volume style may make\n  physical sense (just as for a liquid), but may not be correct for\n  materials and potentials whose Poisson ratio is not 0.5.\n  \n  For the scale and volume styles, the box length is expanded or\n  compressed around its mid point.\n  \n  For the xy, xz, and yz parameters, this is the meaning of their\n  styles and values.  Note that changing the tilt factors of a triclinic\n  box does not change its volume.\n  For style final, the final tilt factor is specified.  The value\n  can be in lattice or box distance units.  See the discussion of the\n  units keyword below.\n  For style delta, a plus or minus change in the tilt factor is\n  specified.  The value can be in lattice or box distance units.  See\n  the discussion of the units keyword below.\n  All of these styles change the xy, xz, yz tilt factors.  In LAMMPS,\n  tilt factors (xy,xz,yz) for triclinic boxes are required to be no more\n  than half the distance of the parallel box length.  For example, if\n  xlo = 2 and xhi = 12, then the x box length is 10 and the xy tilt\n  factor must be between -5 and 5.  Similarly, both xz and yz must be\n  between -(xhi-xlo)/2 and +(yhi-ylo)/2.  Note that this is not a\n  limitation, since if the maximum tilt factor is 5 (as in this\n  example), then configurations with tilt = …, -15, -5, 5, 15, 25,\n  … are all equivalent.  Any tilt factor specified by this command\n  must be within these limits.\n  \n  The boundary keyword takes arguments that have exactly the same\n  meaning as they do for the boundary command.  In each\n  dimension, a single letter assigns the same style to both the lower\n  and upper face of the box.  Two letters assigns the first style to the\n  lower face and the second style to the upper face.\n  The style p means the box is periodic; the other styles mean\n  non-periodic. For style f, the position of the face is fixed.  For\n  style s, the position of the face is set so as to encompass the\n  atoms in that dimension (shrink-wrapping), no matter how far they\n  move.  For style m, shrink-wrapping occurs, but is bounded by the\n  current box edge in that dimension, so that the box will become no\n  smaller.  See the boundary command for more\n  explanation of these style options.\n  Note that the “boundary” command itself can only be used before the\n  simulation box is defined via a read_data or\n  create_box or read_restart\n  command.  This command allows the boundary conditions to be changed\n  later in your input script.  Also note that the\n  read_restart will change boundary conditions to\n  match what is stored in the restart file.  So if you wish to change\n  them, you should use the change_box command after the read_restart\n  command.\n  \n  The ortho and triclinic keywords convert the simulation box to be\n  orthogonal or triclinic (non-orthogonal).\n  The simulation box is defined as either orthogonal or triclinic when\n  it is created via the create_box,\n  read_data, or read_restart\n  commands.\n  These keywords allow you to toggle the existing simulation box from\n  orthogonal to triclinic and vice versa.  For example, an initial\n  equilibration simulation can be run in an orthogonal box, the box can\n  be toggled to triclinic, and then a non-equilibrium MD (NEMD) simulation can be run with deformation via the fix deform command.\n  If the simulation box is currently triclinic and has non-zero tilt in\n  xy, yz, or xz, then it cannot be converted to an orthogonal box.\n  \n  The set keyword saves the current box size/shape.  This can be\n  useful if you wish to use the remap keyword more than once or if you\n  wish it to be applied to an intermediate box size/shape in a sequence\n  of keyword operations.  Note that the box size/shape is saved before\n  any of the keywords are processed, i.e. the box size/shape at the time\n  the create_box command is encountered in the input script.\n  The remap keyword remaps atom coordinates from the last saved box\n  size/shape to the current box state.  For example, if you stretch the\n  box in the x dimension or tilt it in the xy plane via the x and xy\n  keywords, then the remap command will dilate or tilt the atoms to\n  conform to the new box size/shape, as if the atoms moved with the box\n  as it deformed.\n  Note that this operation is performed without regard to periodic\n  boundaries.  Also, any shrink-wrapping of non-periodic boundaries (see\n  the boundary command) occurs after all keywords,\n  including this one, have been processed.\n  Only atoms in the specified group are remapped.\n  \n  The units keyword determines the meaning of the distance units used\n  to define various arguments.  A box value selects standard distance\n  units as defined by the units command, e.g. Angstroms for\n  units = real or metal.  A lattice value means the distance units are\n  in lattice spacings.  The lattice command must have\n  been previously used to define the lattice spacing.\n  ",
    "syntax": "change_box group-ID parameter args ... keyword args ...\n  \n  \n  \n  group-ID = ID of group of atoms to (optionally) displace\n  one or more parameter/arg pairs may be appended\n  parameter = x or y or z or xy or xz or yz or boundary or ortho or triclinic or set or remap\n    x, y, z args = style value(s)\n      style = final or delta or scale or volume\n        final values = lo hi\n          lo hi = box boundaries after displacement (distance units)\n        delta values = dlo dhi\n          dlo dhi = change in box boundaries after displacement (distance units)\n        scale values = factor\n          factor = multiplicative factor for change in box length after displacement\n        volume value = none = adjust this dim to preserve volume of system\n    xy, xz, yz args = style value\n      style = final or delta\n        final value = tilt\n          tilt = tilt factor after displacement (distance units)\n        delta value = dtilt\n          dtilt = change in tilt factor after displacement (distance units)\n    boundary args = x y z\n      x,y,z = p or s or f or m, one or two letters\n      p is periodic\n      f is non-periodic and fixed\n      s is non-periodic and shrink-wrapped\n      m is non-periodic and shrink-wrapped with a minimum value\n    ortho args = none = change box to orthogonal\n    triclinic args = none = change box to triclinic\n    set args = none = store state of current box\n    remap args = none = remap atom coords from last saved state to current box\n  \n  zero or more keyword/value pairs may be appended\n  keyword = units\n  units value = lattice or box\n    lattice = distances are defined in lattice units\n    box = distances are defined in simulation box units\n  \n  \n  ",
    "examples": "change_box all xy final -2.0 z final 0.0 5.0 boundary p p f remap units box\n  change_box all x scale 1.1 y volume z volume remap\n  \n  \n  ",
    "restrictions": "If you use the ortho or triclinic keywords, then at the point in\n  the input script when this command is issued, no dumps can\n  be active, nor can a fix deform be active.  This is\n  because these commands test whether the simulation box is orthogonal\n  when they are first issued.  Note that these commands can be used in\n  your script before a change_box command is issued, so long as an\n  undump or unfix command is also used to\n  turn them off.\n  "
},
{
    "command": "clear",
    "description": "This command deletes all atoms, restores all settings to their default\n  values, and frees all memory allocated by LAMMPS.  Once a clear\n  command has been executed, it is almost as if LAMMPS were starting\n  over, with only the exceptions noted below.  This command enables\n  multiple jobs to be run sequentially from one input script.\n  These settings are not affected by a clear command: the working\n  directory (shell command), log file status\n  (log command), echo status (echo command), and\n  input script variables (variable command).\n  ",
    "syntax": "clear\n  \n  \n  ",
    "examples": "(commands for 1st simulation)\n  clear\n  (commands for 2nd simulation)\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  Related commands: none\n  Default: none\n  "
},
{
    "command": "comm_modify",
    "description": "This command sets parameters that affect the inter-processor\n  communication of atom information that occurs each timestep as\n  coordinates and other properties are exchanged between neighboring\n  processors and stored as properties of ghost atoms.\n  \n  Note\n  These options apply to the currently defined comm style.  When\n  you specify a comm_style or\n  read_restart command, all communication settings\n  are restored to their default or stored values, including those\n  previously reset by a comm_modify command.  Thus if your input script\n  specifies a comm_style or read_restart command, you should use the\n  comm_modify command after it.\n  \n  The mode keyword determines whether a single or multiple cutoff\n  distances are used to determine which atoms to communicate.\n  The default mode is single which means each processor acquires\n  information for ghost atoms that are within a single distance from its\n  sub-domain.  The distance is by default the maximum of the neighbor\n  cutoff across all atom type pairs.\n  For many systems this is an efficient algorithm, but for systems with\n  widely varying cutoffs for different type pairs, the multi mode can\n  be faster.  In this case, each atom type is assigned its own distance\n  cutoff for communication purposes, and fewer atoms will be\n  communicated.  See the neighbor multi command for a\n  neighbor list construction option that may also be beneficial for\n  simulations of this kind.\n  The cutoff keyword allows you to extend the ghost cutoff distance\n  for communication mode single, which is the distance from the borders\n  of a processor’s sub-domain at which ghost atoms are acquired from other\n  processors.  By default the ghost cutoff = neighbor cutoff = pairwise\n  force cutoff + neighbor skin.  See the neighbor command\n  for more information about the skin distance.  If the specified Rcut is\n  greater than the neighbor cutoff, then extra ghost atoms will be acquired.\n  If the provided cutoff is smaller, the provided value will be ignored,\n  the ghost cutoff is set to the neighbor cutoff and a warning will be\n  printed. Specifying a cutoff value of 0.0 will reset any previous value\n  to the default. If bonded interactions exist and equilibrium bond length\n  information is available, then also a heuristic based on that bond length\n  is computed. It is used as communication cutoff, if there is no pair\n  style present and no comm_modify cutoff command used. Otherwise a\n  warning is printed, if this bond based estimate is larger than the\n  communication cutoff used. A\n  The cutoff/multi option is equivalent to cutoff, but applies to\n  communication mode multi instead. Since in this case the communication\n  cutoffs are determined per atom type, a type specifier is needed and\n  cutoff for one or multiple types can be extended. Also ranges of types\n  using the usual asterisk notation can be given.\n  These are simulation scenarios in which it may be useful or even\n  necessary to set a ghost cutoff > neighbor cutoff:\n  \n  a single polymer chain with bond interactions, but no pairwise interactions\n  bonded interactions (e.g. dihedrals) extend further than the pairwise cutoff\n  ghost atoms beyond the pairwise cutoff are needed for some computation\n  \n  In the first scenario, a pairwise potential is not defined.  Thus the\n  pairwise neighbor cutoff will be 0.0.  But ghost atoms are still\n  needed for computing bond, angle, etc interactions between atoms on\n  different processors, or when the interaction straddles a periodic\n  boundary.\n  The appropriate ghost cutoff depends on the newton bond\n  setting.  For newton bond off, the distance needs to be the furthest\n  distance between any two atoms in the bond, angle, etc.  E.g. the\n  distance between 1-4 atoms in a dihedral.  For newton bond on, the\n  distance between the central atom in the bond, angle, etc and any\n  other atom is sufficient.  E.g. the distance between 2-4 atoms in a\n  dihedral.\n  In the second scenario, a pairwise potential is defined, but its\n  neighbor cutoff is not sufficiently long enough to enable bond, angle,\n  etc terms to be computed.  As in the previous scenario, an appropriate\n  ghost cutoff should be set.\n  In the last scenario, a fix or compute or\n  pairwise potential needs to calculate with ghost\n  atoms beyond the normal pairwise cutoff for some computation it\n  performs (e.g. locate neighbors of ghost atoms in a multibody pair\n  potential).  Setting the ghost cutoff appropriately can insure it will\n  find the needed atoms.\n  \n  Note\n  In these scenarios, if you do not set the ghost cutoff long\n  enough, and if there is only one processor in a periodic dimension\n  (e.g. you are running in serial), then LAMMPS may “find” the atom it\n  is looking for (e.g. the partner atom in a bond), that is on the far\n  side of the simulation box, across a periodic boundary.  This will\n  typically lead to bad dynamics (i.e. the bond length is now the\n  simulation box length).  To detect if this is happening, see the\n  neigh_modify cluster command.\n  \n  The group keyword will limit communication to atoms in the specified\n  group.  This can be useful for models where no ghost atoms are needed\n  for some kinds of particles.  All atoms (not just those in the\n  specified group) will still migrate to new processors as they move.\n  The group specified with this option must also be specified via the\n  atom_modify first command.\n  The vel keyword enables velocity information to be communicated with\n  ghost particles.  Depending on the atom_style,\n  velocity info includes the translational velocity, angular velocity,\n  and angular momentum of a particle.  If the vel option is set to\n  yes, then ghost atoms store these quantities; if no then they do\n  not.  The yes setting is needed by some pair styles which require\n  the velocity state of both the I and J particles to compute a pairwise\n  I,J interaction, as well as by some compute and fix commands.\n  Note that if the fix deform command is being used\n  with its “remap v” option enabled, then the velocities for ghost atoms\n  (in the fix deform group) mirrored across a periodic boundary will\n  also include components due to any velocity shift that occurs across\n  that boundary (e.g. due to dilation or shear).\n  ",
    "syntax": "comm_modify keyword value ...\n  \n  \n  \n  zero or more keyword/value pairs may be appended\n  keyword = mode or cutoff or cutoff/multi or group or vel\n  mode value = single or multi = communicate atoms within a single or multiple distances\n  cutoff value = Rcut (distance units) = communicate atoms from this far away\n  cutoff/multi type value\n     type = atom type or type range (supports asterisk notation)\n     value = Rcut (distance units) = communicate atoms for selected types from this far away\n  group value = group-ID = only communicate atoms in the group\n  vel value = yes or no = do or do not communicate velocity info with ghost atoms\n  \n  \n  ",
    "examples": "comm_modify mode multi\n  comm_modify mode multi group solvent\n  comm_modift mode multi cutoff/multi 1 10.0 cutoff/multi 2*4 15.0\n  comm_modify vel yes\n  comm_modify mode single cutoff 5.0 vel yes\n  comm_modify cutoff/multi * 0.0\n  \n  \n  ",
    "restrictions": "Communication mode multi is currently only available for\n  comm_style brick.\n  "
},
{
    "command": "comm_style",
    "description": "This command sets the style of inter-processor communication of atom\n  information that occurs each timestep as coordinates and other\n  properties are exchanged between neighboring processors and stored as\n  properties of ghost atoms.\n  For the default brick style, the domain decomposition used by LAMMPS\n  to partition the simulation box must be a regular 3d grid of bricks,\n  one per processor.  Each processor communicates with its 6 Cartesian\n  neighbors in the grid to acquire information for nearby atoms.\n  For the tiled style, a more general domain decomposition can be\n  used, as triggered by the balance or fix balance commands.  The simulation box can be\n  partitioned into non-overlapping rectangular-shaped “tiles” or varying\n  sizes and shapes.  Again there is one tile per processor.  To acquire\n  information for nearby atoms, communication must now be done with a\n  more complex pattern of neighboring processors.\n  Note that this command does not actually define a partitioning of the\n  simulation box (a domain decomposition), rather it determines what\n  kinds of decompositions are allowed and the pattern of communication\n  used to enable the decomposition.  A decomposition is created when the\n  simulation box is first created, via the create_box\n  or read_data or read_restart\n  commands.  For both the brick and tiled styles, the initial\n  decomposition will be the same, as described by\n  create_box and processors\n  commands.  The decomposition can be changed via the\n  balance or fix balance commands.\n  ",
    "syntax": "comm_style style\n  \n  \n  \n  style = brick or tiled\n  \n  ",
    "examples": "comm_style brick\n  comm_style tiled\n  \n  \n  ",
    "restrictions": "Communication style tiled cannot be used with triclinic simulation\n  cells.\n  "
},
{
    "command": "compute",
    "description": "Define a computation that will be performed on a group of atoms.\n  Quantities calculated by a compute are instantaneous values, meaning\n  they are calculated from information about atoms on the current\n  timestep or iteration, though a compute may internally store some\n  information about a previous state of the system.  Defining a compute\n  does not perform a computation.  Instead computes are invoked by other\n  LAMMPS commands as needed, e.g. to calculate a temperature needed for\n  a thermostat fix or to generate thermodynamic or dump file output.\n  See the Howto output doc page for a summary of\n  various LAMMPS output options, many of which involve computes.\n  The ID of a compute can only contain alphanumeric characters and\n  underscores.\n  \n  Computes calculate one of three styles of quantities: global,\n  per-atom, or local.  A global quantity is one or more system-wide\n  values, e.g. the temperature of the system.  A per-atom quantity is\n  one or more values per atom, e.g. the kinetic energy of each atom.\n  Per-atom values are set to 0.0 for atoms not in the specified compute\n  group.  Local quantities are calculated by each processor based on the\n  atoms it owns, but there may be zero or more per atom, e.g. a list of\n  bond distances.  Computes that produce per-atom quantities have the\n  word “atom” in their style, e.g. ke/atom.  Computes that produce\n  local quantities have the word “local” in their style,\n  e.g. bond/local.  Styles with neither “atom” or “local” in their\n  style produce global quantities.\n  Note that a single compute can produce either global or per-atom or\n  local quantities, but not both global and per-atom.  It can produce\n  local quantities in tandem with global or per-atom quantities.  The\n  compute doc page will explain.\n  Global, per-atom, and local quantities each come in three kinds: a\n  single scalar value, a vector of values, or a 2d array of values.  The\n  doc page for each compute describes the style and kind of values it\n  produces, e.g. a per-atom vector.  Some computes produce more than one\n  kind of a single style, e.g. a global scalar and a global vector.\n  When a compute quantity is accessed, as in many of the output commands\n  discussed below, it can be referenced via the following bracket\n  notation, where ID is the ID of the compute:\n  \n  \n  \n  \n  \n  \n  c_ID\n  entire scalar, vector, or array\n  \n  c_ID[I]\n  one element of vector, one column of array\n  \n  c_ID[I][J]\n  one element of array\n  \n  \n  \n  In other words, using one bracket reduces the dimension of the\n  quantity once (vector -> scalar, array -> vector).  Using two brackets\n  reduces the dimension twice (array -> scalar).  Thus a command that\n  uses scalar compute values as input can also process elements of a\n  vector or array.\n  Note that commands and variables which use compute\n  quantities typically do not allow for all kinds, e.g. a command may\n  require a vector of values, not a scalar.  This means there is no\n  ambiguity about referring to a compute quantity as c_ID even if it\n  produces, for example, both a scalar and vector.  The doc pages for\n  various commands explain the details.\n  \n  In LAMMPS, the values generated by a compute can be used in several\n  ways:\n  \n  The results of computes that calculate a global temperature or\n  pressure can be used by fixes that do thermostatting or barostatting\n  or when atom velocities are created.\n  Global values can be output via the thermo_style custom or fix ave/time command.\n  Or the values can be referenced in a variable equal or\n  variable atom command.\n  Per-atom values can be output via the dump custom command.\n  Or they can be time-averaged via the fix ave/atom\n  command or reduced by the compute reduce\n  command.  Or the per-atom values can be referenced in an atom-style variable.\n  Local values can be reduced by the compute reduce command, or histogrammed by the fix ave/histo command, or output by the dump local command.\n  \n  The results of computes that calculate global quantities can be either\n  “intensive” or “extensive” values.  Intensive means the value is\n  independent of the number of atoms in the simulation,\n  e.g. temperature.  Extensive means the value scales with the number of\n  atoms in the simulation, e.g. total rotational kinetic energy.\n  Thermodynamic output will normalize extensive\n  values by the number of atoms in the system, depending on the\n  “thermo_modify norm” setting.  It will not normalize intensive values.\n  If a compute value is accessed in another way, e.g. by a\n  variable, you may want to know whether it is an\n  intensive or extensive value.  See the doc page for individual\n  computes for further info.\n  \n  LAMMPS creates its own computes internally for thermodynamic output.\n  Three computes are always created, named “thermo_temp”,\n  “thermo_press”, and “thermo_pe”, as if these commands had been invoked\n  in the input script:\n  compute thermo_temp all temp\n  compute thermo_press all pressure thermo_temp\n  compute thermo_pe all pe\n  \n  \n  Additional computes for other quantities are created if the thermo\n  style requires it.  See the documentation for the\n  thermo_style command.\n  Fixes that calculate temperature or pressure, i.e. for thermostatting\n  or barostatting, may also create computes.  These are discussed in the\n  documentation for specific fix commands.\n  In all these cases, the default computes LAMMPS creates can be\n  replaced by computes defined by the user in the input script, as\n  described by the thermo_modify and fix modify commands.\n  Properties of either a default or user-defined compute can be modified\n  via the compute_modify command.\n  Computes can be deleted with the uncompute command.\n  Code for new computes can be added to LAMMPS; see the\n  Modify doc page for details.  The results of their\n  calculations accessed in the various ways described above.\n  \n  Each compute style has its own doc page which describes its arguments\n  and what it does.  Here is an alphabetic list of compute styles\n  available in LAMMPS.  They are also listed in more compact form on the\n  Commands compute doc page.\n  There are also additional accelerated compute styles included in the\n  LAMMPS distribution for faster performance on CPUs, GPUs, and KNLs.\n  The individual style names on the Commands compute doc page are followed by one or more of\n  (g,i,k,o,t) to indicate which accelerated styles exist.\n  \n  ackland/atom - determines the local lattice structure based on the Ackland formulation\n  adf - angular distribution function of triples of atoms\n  aggregate/atom - aggregate ID for each atom\n  angle - energy of each angle sub-style\n  angle/local - theta and energy of each angle\n  angmom/chunk - angular momentum for each chunk\n  basal/atom - calculates the hexagonal close-packed “c” lattice vector of each atom\n  body/local - attributes of body sub-particles\n  bond - energy of each bond sub-style\n  bond/local - distance and energy of each bond\n  centro/atom - centro-symmetry parameter for each atom\n  centroid/stress/atom - centroid based stress tensor for each atom\n  chunk/atom - assign chunk IDs to each atom\n  chunk/spread/atom - spreads chunk values to each atom in chunk\n  cluster/atom - cluster ID for each atom\n  cna/atom - common neighbor analysis (CNA) for each atom\n  cnp/atom - common neighborhood parameter (CNP) for each atom\n  com - center-of-mass of group of atoms\n  com/chunk - center-of-mass for each chunk\n  contact/atom - contact count for each spherical particle\n  coord/atom - coordination number for each atom\n  damage/atom - Peridynamic damage for each atom\n  dihedral - energy of each dihedral sub-style\n  dihedral/local - angle of each dihedral\n  dilatation/atom - Peridynamic dilatation for each atom\n  dipole/chunk - dipole vector and total dipole for each chunk\n  displace/atom - displacement of each atom\n  dpd -\n  dpd/atom -\n  edpd/temp/atom - per-atom temperature for each eDPD particle in a group\n  entropy/atom - pair entropy fingerprint of each atom\n  erotate/asphere - rotational energy of aspherical particles\n  erotate/rigid - rotational energy of rigid bodies\n  erotate/sphere - rotational energy of spherical particles\n  erotate/sphere/atom - rotational energy for each spherical particle\n  event/displace - detect event on atom displacement\n  fep -\n  force/tally -\n  fragment/atom - fragment ID for each atom\n  global/atom -\n  group/group - energy/force between two groups of atoms\n  gyration - radius of gyration of group of atoms\n  gyration/chunk - radius of gyration for each chunk\n  gyration/shape - shape parameters from gyration tensor\n  gyration/shape/chunk - shape parameters from gyration tensor for each chunk\n  heat/flux - heat flux through a group of atoms\n  heat/flux/tally -\n  hexorder/atom - bond orientational order parameter q6\n  hma - harmonically mapped averaging for atomic crystals\n  improper - energy of each improper sub-style\n  improper/local - angle of each improper\n  inertia/chunk - inertia tensor for each chunk\n  ke - translational kinetic energy\n  ke/atom - kinetic energy for each atom\n  ke/atom/eff - per-atom translational and radial kinetic energy in the electron force field model\n  ke/eff - kinetic energy of a group of nuclei and electrons in the electron force field model\n  ke/rigid - translational kinetic energy of rigid bodies\n  meso/e/atom - per-atom internal energy of Smooth-Particle Hydrodynamics atoms\n  meso/rho/atom - per-atom mesoscopic density of Smooth-Particle Hydrodynamics atoms\n  meso/t/atom - per-atom internal temperature of Smooth-Particle Hydrodynamics atoms\n  momentum - translational momentum\n  msd - mean-squared displacement of group of atoms\n  msd/chunk - mean-squared displacement for each chunk\n  msd/nongauss - MSD and non-Gaussian parameter of group of atoms\n  omega/chunk - angular velocity for each chunk\n  orientorder/atom - Steinhardt bond orientational order parameters Ql\n  pair - values computed by a pair style\n  pair/local - distance/energy/force of each pairwise interaction\n  pe - potential energy\n  pe/atom - potential energy for each atom\n  pe/mol/tally -\n  pe/tally -\n  plasticity/atom - Peridynamic plasticity for each atom\n  pressure - total pressure and pressure tensor\n  pressure/cylinder - pressure tensor in cylindrical coordinates\n  pressure/uef - pressure tensor in the reference frame of an applied flow field\n  property/atom - convert atom attributes to per-atom vectors/arrays\n  property/chunk - extract various per-chunk attributes\n  property/local - convert local attributes to localvectors/arrays\n  ptm/atom - determines the local lattice structure based on the Polyhedral Template Matching method\n  rdf - radial distribution function g(r) histogram of group of atoms\n  reduce - combine per-atom quantities into a single global value\n  reduce/chunk - reduce per-atom quantities within each chunk\n  reduce/region - same as compute reduce, within a region\n  rigid/local - extract rigid body attributes\n  saed - electron diffraction intensity on a mesh of reciprocal lattice nodes\n  slice - extract values from global vector or array\n  smd/contact/radius -\n  smd/damage - damage status of SPH particles in Smooth Mach Dynamics\n  smd/hourglass/error -\n  smd/internal/energy - per-particle enthalpy in Smooth Mach Dynamics\n  smd/plastic/strain - equivalent plastic strain per particle in Smooth Mach Dynamics\n  smd/plastic/strain/rate - time rate of the equivalent plastic strain in Smooth Mach Dynamics\n  smd/rho - per-particle mass density in Smooth Mach Dynamics\n  smd/tlsph/defgrad - deformation gradient in Smooth Mach Dynamics\n  smd/tlsph/dt - CFL-stable time increment per particle in Smooth Mach Dynamics\n  smd/tlsph/num/neighs -\n  smd/tlsph/shape -\n  smd/tlsph/strain -\n  smd/tlsph/strain/rate -\n  smd/tlsph/stress - per-particle Cauchy stress tensor for SPH particles\n  smd/triangle/vertices -\n  smd/ulsph/num/neighs -\n  smd/ulsph/strain -\n  smd/ulsph/strain/rate -\n  smd/ulsph/stress - per-particle Cauchy stress tensor and von Mises equivalent stress in Smooth Mach Dynamics\n  smd/vol - per-particle volumes and their sum in Smooth Mach Dynamics\n  snap - bispectrum components and related quantities for a group of atoms\n  sna/atom - bispectrum components for each atom\n  snad/atom - derivative of bispectrum components for each atom\n  snav/atom - virial contribution from bispectrum components for each atom\n  spin - magnetic quantities for a system of atoms having spins\n  stress/atom - stress tensor for each atom\n  stress/mop - normal components of the local stress tensor using the method of planes\n  stress/mop/profile - profile of the normal components of the local stress tensor using the method of planes\n  stress/tally -\n  tdpd/cc/atom - per-atom chemical concentration of a specified species for each tDPD particle\n  temp - temperature of group of atoms\n  temp/asphere - temperature of aspherical particles\n  temp/body - temperature of body particles\n  temp/chunk - temperature of each chunk\n  temp/com - temperature after subtracting center-of-mass velocity\n  temp/cs - temperature based on the center-of-mass velocity of atom pairs that are bonded to each other\n  temp/deform - temperature excluding box deformation velocity\n  temp/deform/eff - temperature excluding box deformation velocity in the electron force field model\n  temp/drude - temperature of Core-Drude pairs\n  temp/eff - temperature of a group of nuclei and electrons in the electron force field model\n  temp/partial - temperature excluding one or more dimensions of velocity\n  temp/profile - temperature excluding a binned velocity profile\n  temp/ramp - temperature excluding ramped velocity component\n  temp/region - temperature of a region of atoms\n  temp/region/eff - temperature of a region of nuclei and electrons in the electron force field model\n  temp/rotate - temperature of a group of atoms after subtracting out their center-of-mass and angular velocities\n  temp/sphere - temperature of spherical particles\n  temp/uef - kinetic energy tensor in the reference frame of an applied flow field\n  ti - thermodynamic integration free energy values\n  torque/chunk - torque applied on each chunk\n  vacf - velocity auto-correlation function of group of atoms\n  vcm/chunk - velocity of center-of-mass for each chunk\n  voronoi/atom - Voronoi volume and neighbors for each atom\n  xrd - x-ray diffraction intensity on a mesh of reciprocal lattice nodes\n  \n  ",
    "syntax": "compute ID group-ID style args\n  \n  \n  \n  ID = user-assigned name for the computation\n  group-ID = ID of the group of atoms to perform the computation on\n  style = one of a list of possible style names (see below)\n  args = arguments used by a particular style\n  \n  ",
    "examples": "compute 1 all temp\n  compute newtemp flow temp/partial 1 1 0\n  compute 3 all ke/atom\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "create_atoms",
    "description": "This command creates atoms (or molecules) on a lattice, or a single\n  atom (or molecule), or a random collection of atoms (or molecules), as\n  an alternative to reading in their coordinates explicitly via a\n  read_data or read_restart\n  command.  A simulation box must already exist, which is typically\n  created via the create_box command.  Before using\n  this command, a lattice must also be defined using the\n  lattice command, unless you specify the single style\n  with units = box or the random style.  For the remainder of this doc\n  page, a created atom or molecule is referred to as a “particle”.\n  If created particles are individual atoms, they are assigned the\n  specified atom type, though this can be altered via the basis\n  keyword as discussed below.  If molecules are being created, the type\n  of each atom in the created molecule is specified in the file read by\n  the molecule command, and those values are added to\n  the specified atom type.  E.g. if type = 2, and the file specifies\n  atom types 1,2,3, then each created molecule will have atom types\n  3,4,5.\n  For the box style, the create_atoms command fills the entire\n  simulation box with particles on the lattice.  If your simulation box\n  is periodic, you should insure its size is a multiple of the lattice\n  spacings, to avoid unwanted atom overlaps at the box boundaries.  If\n  your box is periodic and a multiple of the lattice spacing in a\n  particular dimension, LAMMPS is careful to put exactly one particle at\n  the boundary (on either side of the box), not zero or two.\n  For the region style, a geometric volume is filled with particles on\n  the lattice.  This volume what is inside the simulation box and is\n  also consistent with the region volume.  See the region\n  command for details.  Note that a region can be specified so that its\n  “volume” is either inside or outside a geometric boundary.  Also note\n  that if your region is the same size as a periodic simulation box (in\n  some dimension), LAMMPS does not implement the same logic described\n  above as for the box style, to insure exactly one particle at\n  periodic boundaries.  if this is what you desire, you should either\n  use the box style, or tweak the region size to get precisely the\n  particles you want.\n  For the single style, a single particle is added to the system at\n  the specified coordinates.  This can be useful for debugging purposes\n  or to create a tiny system with a handful of particles at specified\n  positions.\n  For the random style, N particles are added to the system at\n  randomly generated coordinates, which can be useful for generating an\n  amorphous system.  The particles are created one by one using the\n  specified random number seed, resulting in the same set of particles\n  coordinates, independent of how many processors are being used in the\n  simulation.  If the region-ID argument is specified as NULL, then\n  the created particles will be anywhere in the simulation box.  If a\n  region-ID is specified, a geometric volume is filled which is both\n  inside the simulation box and is also consistent with the region\n  volume.  See the region command for details.  Note that\n  a region can be specified so that its “volume” is either inside or\n  outside a geometric boundary.\n  \n  Note\n  Particles generated by the random style will typically be\n  highly overlapped which will cause many interatomic potentials to\n  compute large energies and forces.  Thus you should either perform an\n  energy minimization or run dynamics with fix nve/limit to equilibrate such a system, before\n  running normal dynamics.\n  \n  Note that this command adds particles to those that already exist.\n  This means it can be used to add particles to a system previously read\n  in from a data or restart file.  Or the create_atoms command can be\n  used multiple times, to add multiple sets of particles to the\n  simulation.  For example, grain boundaries can be created, by\n  interleaving create_atoms with lattice commands\n  specifying different orientations.  By using the create_atoms command\n  in conjunction with the delete_atoms command,\n  reasonably complex geometries can be created, or a protein can be\n  solvated with a surrounding box of water molecules.\n  In all these cases, care should be taken to insure that new atoms do\n  not overlap existing atoms inappropriately, especially if molecules\n  are being added.  The delete_atoms command can be\n  used to remove overlapping atoms or molecules.\n  \n  Note\n  You cannot use any of the styles explained above to create atoms\n  that are outside the simulation box; they will just be ignored by\n  LAMMPS.  This is true even if you are using shrink-wrapped box\n  boundaries, as specified by the boundary command.\n  However, you can first use the change_box command to\n  temporarily expand the box, then add atoms via create_atoms, then\n  finally use change_box command again if needed to re-shrink-wrap the\n  new atoms.  See the change_box doc page for an\n  example of how to do this, using the create_atoms single style to\n  insert a new atom outside the current simulation box.\n  \n  \n  Individual atoms are inserted by this command, unless the mol\n  keyword is used.  It specifies a template-ID previously defined\n  using the molecule command, which reads a file that\n  defines the molecule.  The coordinates, atom types, charges, etc, as\n  well as any bond/angle/etc and special neighbor information for the\n  molecule can be specified in the molecule file.  See the\n  molecule command for details.  The only settings\n  required to be in this file are the coordinates and types of atoms in\n  the molecule.\n  Using a lattice to add molecules, e.g. via the box or region or\n  single styles, is exactly the same as adding atoms on lattice\n  points, except that entire molecules are added at each point, i.e. on\n  the point defined by each basis atom in the unit cell as it tiles the\n  simulation box or region.  This is done by placing the geometric\n  center of the molecule at the lattice point, and giving the molecule a\n  random orientation about the point.  The random seed specified with\n  the mol keyword is used for this operation, and the random numbers\n  generated by each processor are different.  This means the coordinates\n  of individual atoms (in the molecules) will be different when running\n  on different numbers of processors, unlike when atoms are being\n  created in parallel.\n  Also note that because of the random rotations, it may be important to\n  use a lattice with a large enough spacing that adjacent molecules will\n  not overlap, regardless of their relative orientations.\n  \n  Note\n  If the create_box command is used to create\n  the simulation box, followed by the create_atoms command with its\n  mol option for adding molecules, then you typically need to use the\n  optional keywords allowed by the create_box command\n  for extra bonds (angles,etc) or extra special neighbors.  This is\n  because by default, the create_box command sets up a\n  non-molecular system which does not allow molecules to be added.\n  \n  \n  This is the meaning of the other allowed keywords.\n  The basis keyword is only used when atoms (not molecules) are being\n  created.  It specifies an atom type that will be assigned to specific\n  basis atoms as they are created.  See the lattice\n  command for specifics on how basis atoms are defined for the unit cell\n  of the lattice.  By default, all created atoms are assigned the\n  argument type as their atom type.\n  The ratio and subset keywords can be used in conjunction with the\n  box or region styles to limit the total number of particles\n  inserted.  The lattice defines a set of Nlatt eligible sites for\n  inserting particles, which may be limited by the region style or the\n  var and set keywords.  For the ratio keyword only the specified\n  fraction of them (0 <= frac <= 1) will be assigned particles.  For\n  the subset keyword only the specified Nsubset of them will be\n  assigned particles.  In both cases the assigned lattice sites are\n  chosen randomly.  An iterative algorithm is used which insures the\n  correct number of particles are inserted, in a perfectly random\n  fashion.  Which lattice sites are selected will change with the number\n  of processors used.\n  The remap keyword only applies to the single style.  If it is set\n  to yes, then if the specified position is outside the simulation\n  box, it will mapped back into the box, assuming the relevant\n  dimensions are periodic.  If it is set to no, no remapping is done\n  and no particle is created if its position is outside the box.\n  The var and set keywords can be used together to provide a\n  criterion for accepting or rejecting the addition of an individual\n  atom, based on its coordinates.  The name specified for the var\n  keyword is the name of an equal-style variable which\n  should evaluate to a zero or non-zero value based on one or two or\n  three variables which will store the x, y, or z coordinates of an atom\n  (one variable per coordinate).  If used, these other variables must be\n  internal-style variables defined in the input script;\n  their initial numeric value can be anything.  They must be\n  internal-style variables, because this command resets their values\n  directly.  The set keyword is used to identify the names of these\n  other variables, one variable for the x-coordinate of a created atom,\n  one for y, and one for z.\n  When an atom is created, its x,y,z coordinates become the values for\n  any set variable that is defined.  The var variable is then\n  evaluated.  If the returned value is 0.0, the atom is not created.  If\n  it is non-zero, the atom is created.\n  As an example, these commands can be used in a 2d simulation, to\n  create a sinusoidal surface.  Note that the surface is “rough” due to\n  individual lattice points being “above” or “below” the mathematical\n  expression for the sinusoidal curve.  If a finer lattice were used,\n  the sinusoid would appear to be “smoother”.  Also note the use of the\n  “xlat” and “ylat” thermo_style keywords which\n  converts lattice spacings to distance.  Click on the image for a\n  larger version.\n  dimension       2\n  variable        x equal 100\n  variable        y equal 25\n  lattice         hex 0.8442\n  region          box block 0 $x 0 $y -0.5 0.5\n  create_box      1 box\n  \n  variable        xx internal 0.0\n  variable        yy internal 0.0\n  variable        v equal \"(0.2*v_y*ylat * cos(v_xx/xlat * 2.0*PI*4.0/v_x) + 0.5*v_y*ylat - v_yy) > 0.0\"\n  create_atoms    1 box var v set x xx set y yy\n  write_dump      all atom sinusoid.lammpstrj\n  \n  \n  \n  The rotate keyword allows specification of the orientation\n  at which molecules are inserted.  The axis of rotation is\n  determined by the rotation vector (Rx,Ry,Rz) that goes through the\n  insertion point.  The specified theta determines the angle of\n  rotation around that axis.  Note that the direction of rotation for\n  the atoms around the rotation axis is consistent with the right-hand\n  rule: if your right-hand’s thumb points along R, then your fingers\n  wrap around the axis in the direction of rotation.\n  The units keyword determines the meaning of the distance units used\n  to specify the coordinates of the one particle created by the single\n  style.  A box value selects standard distance units as defined by\n  the units command, e.g. Angstroms for units = real or\n  metal.  A lattice value means the distance units are in lattice\n  spacings.\n  \n  Atom IDs are assigned to created atoms in the following way.  The\n  collection of created atoms are assigned consecutive IDs that start\n  immediately following the largest atom ID existing before the\n  create_atoms command was invoked.  This is done by the processor’s\n  communicating the number of atoms they each own, the first processor\n  numbering its atoms from 1 to N1, the second processor from N1+1 to\n  N2, etc.  Where N1 = number of atoms owned by the first processor, N2\n  = number owned by the second processor, etc.  Thus when the same\n  simulation is performed on different numbers of processors, there is\n  no guarantee a particular created atom will be assigned the same ID in\n  both simulations.  If molecules are being created, molecule IDs are\n  assigned to created molecules in a similar fashion.\n  Aside from their ID, atom type, and xyz position, other properties of\n  created atoms are set to default values, depending on which quantities\n  are defined by the chosen atom style.  See the atom style command for more details.  See the\n  set and velocity commands for info on how\n  to change these values.\n  \n  charge = 0.0\n  dipole moment magnitude = 0.0\n  diameter = 1.0\n  shape = 0.0 0.0 0.0\n  density = 1.0\n  volume = 1.0\n  velocity = 0.0 0.0 0.0\n  angular velocity = 0.0 0.0 0.0\n  angular momentum = 0.0 0.0 0.0\n  quaternion = (1,0,0,0)\n  bonds, angles, dihedrals, impropers = none\n  \n  If molecules are being created, these defaults can be overridden by\n  values specified in the file read by the molecule\n  command.  E.g. the file typically defines bonds (angles,etc) between\n  atoms in the molecule, and can optionally define charges on each atom.\n  Note that the sphere atom style sets the default particle diameter\n  to 1.0 as well as the density.  This means the mass for the particle\n  is not 1.0, but is PI/6 * diameter^3 = 0.5236.\n  Note that the ellipsoid atom style sets the default particle shape\n  to (0.0 0.0 0.0) and the density to 1.0 which means it is a point\n  particle, not an ellipsoid, and has a mass of 1.0.\n  Note that the peri style sets the default volume and density to 1.0\n  and thus also set the mass for the particle to 1.0.\n  The set command can be used to override many of these\n  default settings.\n  ",
    "syntax": "create_atoms type style args keyword values ...\n  \n  \n  \n  type = atom type (1-Ntypes) of atoms to create (offset for molecule creation)\n  style = box or region or single or random\n  box args = none\n  region args = region-ID\n    region-ID = particles will only be created if contained in the region\n  single args = x y z\n    x,y,z = coordinates of a single particle (distance units)\n  random args = N seed region-ID\n    N = number of particles to create\n    seed = random # seed (positive integer)\n    region-ID = create atoms within this region, use NULL for entire simulation box\n  \n  zero or more keyword/value pairs may be appended\n  keyword = mol or basis or ratio or subset or remap or var or set or rotate or units\n  *mol* value = template-ID seed\n    template-ID = ID of molecule template specified in a separate :doc:`molecule <molecule>` command\n    seed = random # seed (positive integer)\n  *basis* values = M itype\n    M = which basis atom\n    itype = atom type (1-N) to assign to this basis atom\n  *ratio* values = frac seed\n    frac = fraction of lattice sites (0 to 1) to populate randomly\n    seed = random # seed (positive integer)\n  *subset* values = Nsubset seed\n    Nsubset = # of lattice sites to populate randomly\n    seed = random # seed (positive integer)\n  *remap* value = *yes* or *no*\n  *var* value = name = variable name to evaluate for test of atom creation\n  *set* values = dim name\n    dim = *x* or *y* or *z*\n    name = name of variable to set with x, y, or z atom position\n  *rotate* values = theta Rx Ry Rz\n    theta = rotation angle for single molecule (degrees)\n    Rx,Ry,Rz = rotation vector for single molecule\n  *units* value = *lattice* or *box*\n    *lattice* = the geometry is defined in lattice units\n    *box* = the geometry is defined in simulation box units\n  \n  \n  \n  \n  ",
    "examples": "create_atoms 1 box\n  create_atoms 3 region regsphere basis 2 3\n  create_atoms 3 region regsphere basis 2 3 ratio 0.5 74637\n  create_atoms 3 single 0 0 5\n  create_atoms 1 box var v set x xpos set y ypos\n  \n  \n  ",
    "restrictions": "An atom_style must be previously defined to use this\n  command.\n  A rotation vector specified for a single molecule must be in\n  the z-direction for a 2d model.\n  "
},
{
    "command": "create_bonds",
    "description": "Create bonds between pairs of atoms that meet a specified distance\n  criteria.  Or create a single bond, angle, dihedral or improper between 2, 3,\n  or 4 specified atoms.\n  The new bond (angle, dihedral, improper) interactions will then be computed\n  during a simulation by the bond (angle, dihedral, improper) potential defined by\n  the bond_style, bond_coeff,\n  angle_style, angle_coeff,\n  dihedral_style,\n  dihedral_coeff, improper_style,\n  improper_coeff commands.\n  The many style is useful for adding bonds to a system, e.g. between\n  nearest neighbors in a lattice of atoms, without having to enumerate\n  all the bonds in the data file read by the read_data\n  command.\n  The single styles are useful for adding bonds, angles, dihedrals, impropers\n  to a system incrementally, then continuing a simulation.\n  Note that this command does not auto-create any angle, dihedral or improper\n  interactions when a bond is added.  Nor does it auto-create any bonds\n  when an angle, dihedral or improper is added.  Or auto-create any angles when a\n  dihedral or improper is added.  Thus the flexibility of this command is limited.\n  It can be used several times to create different types of bond at\n  different distances.  But it cannot typically auto-create all the\n  bonds or angles or dihedrals or impropers that would normally be defined in a\n  data file for a complex system of molecules.\n  \n  Note\n  If the system has no bonds (angles, dihedrals, impropers) to begin with,\n  or if more bonds per atom are being added than currently exist, then you\n  must insure that the number of bond types and the maximum number of\n  bonds per atom are set to large enough values.  And similarly for\n  angles, dihedrals and impropers.  Otherwise an error may occur when too many\n  bonds (angles, dihedrals, impropers) are added to an atom.  If the\n  read_data command is used to define the system, these\n  parameters can be set via the “bond types” and “extra bond per atom”\n  fields in the header section of the data file.  If the\n  create_box command is used to define the system,\n  these 2 parameters can be set via its optional “bond/types” and\n  “extra/bond/per/atom” arguments.  And similarly for angles, dihedrals and\n  impropers.  See the doc pages for these 2 commands for details.\n  \n  \n  The many style will create bonds between pairs of atoms I,J where I\n  is in one of the two specified groups, and J is in the other.  The two\n  groups can be the same, e.g. group “all”.  The created bonds will be\n  of bond type btype, where btype must be a value between 1 and the\n  number of bond types defined.\n  For a bond to be created, an I,J pair of atoms must be a distance D\n  apart such that rmin <= D <= rmax.\n  The following settings must have been made in an input script before\n  this style is used:\n  \n  special_bonds weight for 1-2 interactions must be 0.0\n  a pair_style must be defined\n  no kspace_style defined\n  minimum pair_style cutoff + neighbor skin >= rmax\n  \n  These settings are required so that a neighbor list can be created to\n  search for nearby atoms.  Pairs of atoms that are already bonded\n  cannot appear in the neighbor list, to avoid creation of duplicate\n  bonds.  The neighbor list for all atom type pairs must also extend to\n  a distance that encompasses the rmax for new bonds to create.\n  An additional requirement for this style is that your system must be\n  ready to perform a simulation.  This means, for example, that all\n  pair_style coefficients be set via the\n  pair_coeff command.  A bond_style\n  command and all bond coefficients must also be set, even if no bonds\n  exist before this command is invoked.  This is because the building of\n  neighbor list requires initialization and setup of a simulation,\n  similar to what a run command would require.\n  Note that you can change any of these settings after this command\n  executes, e.g. if you wish to use long-range Coulombic interactions\n  via the kspace_style command for your subsequent\n  simulation.\n  \n  The single/bond style creates a single bond of type btype between\n  two atoms with IDs batom1 and batom2.  Btype must be a value\n  between 1 and the number of bond types defined.\n  The single/angle style creates a single angle of type atype\n  between three atoms with IDs aatom1, aatom2, and aatom3.  The\n  ordering of the atoms is the same as in the Angles section of a data\n  file read by the read_data command.  I.e. the 3 atoms are\n  ordered linearly within the angle; the central atom is aatom2.\n  Atype must be a value between 1 and the number of angle types\n  defined.\n  The single/dihedral style creates a single dihedral of type dtype\n  between four atoms with IDs datom1, datom2, datom3, and datom4.  The\n  ordering of the atoms is the same as in the Dihedrals section of a data file\n  read by the read_data command.  I.e. the 4 atoms are ordered\n  linearly within the dihedral.  dtype must be a value between 1 and\n  the number of dihedral types defined.\n  The single/improper style creates a single improper of type itype\n  between four atoms with IDs iatom1, iatom2, iatom3, and iatom4.  The\n  ordering of the atoms is the same as in the Impropers section of a data file\n  read by the read_data command.  I.e. the 4 atoms are ordered\n  linearly within the improper.  itype must be a value between 1 and\n  the number of improper types defined.\n  \n  The keyword special controls whether an internal list of special\n  bonds is created after one or more bonds, or a single angle, dihedral or\n  improper is added to the system.\n  The default value is yes.  A value of no cannot be used\n  with the many style.\n  This is an expensive operation since the bond topology for the system\n  must be walked to find all 1-2, 1-3, 1-4 interactions to store in an\n  internal list, which is used when pairwise interactions are weighted;\n  see the special_bonds command for details.\n  Thus if you are adding a few bonds or a large list of angles all at\n  the same time, by using this command repeatedly, it is more efficient\n  to only trigger the internal list to be created once, after the last\n  bond (or angle, or dihedral, or improper) is added:\n  create_bonds single/bond 5 52 98 special no\n  create_bonds single/bond 5 73 74 special no\n  ...\n  create_bonds single/bond 5 17 386 special no\n  create_bonds single/bond 4 112 183 special yes\n  \n  \n  Note that you MUST insure the internal list is re-built after the last\n  bond (angle, dihedral, improper) is added, before performing a simulation.\n  Otherwise pairwise interactions will not be properly excluded or\n  weighted.  LAMMPS does NOT check that you have done this correctly.\n  ",
    "syntax": "create_bonds style args ... keyword value ...\n  \n  \n  \n  style = many or single/bond or single/angle or single/dihedral\n  \n  many args = group-ID group2-ID btype rmin rmax\n    group-ID = ID of first group\n    group2-ID = ID of second group, bonds will be between atoms in the 2 groups\n    btype = bond type of created bonds\n    rmin = minimum distance between pair of atoms to bond together\n    rmax = maximum distance between pair of atoms to bond together\n  single/bond args = btype batom1 batom2\n    btype = bond type of new bond\n    batom1,batom2 = atom IDs for two atoms in bond\n  single/angle args = atype aatom1 aatom2 aatom3\n    atype = angle type of new angle\n    aatom1,aatom2,aatom3 = atom IDs for three atoms in angle\n  single/dihedral args = dtype datom1 datom2 datom3 datom4\n    dtype = dihedral type of new dihedral\n    datom1,datom2,datom3,datom4 = atom IDs for four atoms in dihedral\n  single/improper args = itype iatom1 iatom2 iatom3 iatom4\n    itype = improper type of new improper\n    iatom1,iatom2,iatom3,iatom4 = atom IDs for four atoms in improper\n  \n  zero or more keyword/value pairs may be appended\n  keyword = special\n  \n  special value = yes or no\n  ",
    "examples": "create_bonds many all all 1 1.0 1.2\n  create_bonds many surf solvent 3 2.0 2.4\n  create_bonds single/bond 1 1 2\n  create_bonds single/angle 5 52 98 107 special no\n  create_bonds single/dihedral 2 4 19 27 101\n  create_bonds single/improper 3 23 26 31 57\n  \n  \n  ",
    "restrictions": "This command cannot be used with molecular systems defined using\n  molecule template files via the molecule and\n  atom_style template commands.\n  "
},
{
    "command": "create_box",
    "description": "This command creates a simulation box based on the specified region.\n  Thus a region command must first be used to define a\n  geometric domain.  It also partitions the simulation box into a\n  regular 3d grid of rectangular bricks, one per processor, based on the\n  number of processors being used and the settings of the\n  processors command.  The partitioning can later be\n  changed by the balance or fix balance commands.\n  The argument N is the number of atom types that will be used in the\n  simulation.\n  If the region is not of style prism, then LAMMPS encloses the region\n  (block, sphere, etc) with an axis-aligned orthogonal bounding box\n  which becomes the simulation domain.\n  If the region is of style prism, LAMMPS creates a non-orthogonal\n  simulation domain shaped as a parallelepiped with triclinic symmetry.\n  As defined by the region prism command, the\n  parallelepiped has its “origin” at (xlo,ylo,zlo) and is defined by 3\n  edge vectors starting from the origin given by A = (xhi-xlo,0,0); B =\n  (xy,yhi-ylo,0); C = (xz,yz,zhi-zlo).  Xy,xz,yz can be 0.0 or\n  positive or negative values and are called “tilt factors” because they\n  are the amount of displacement applied to faces of an originally\n  orthogonal box to transform it into the parallelepiped.\n  By default, a prism region used with the create_box command must\n  have tilt factors (xy,xz,yz) that do not skew the box more than half\n  the distance of the parallel box length.  For example, if xlo = 2 and\n  xhi = 12, then the x box length is 10 and the xy tilt factor must be\n  between -5 and 5.  Similarly, both xz and yz must be between\n  -(xhi-xlo)/2 and +(yhi-ylo)/2.  Note that this is not a limitation,\n  since if the maximum tilt factor is 5 (as in this example), then\n  configurations with tilt = …, -15, -5, 5, 15, 25, … are all\n  geometrically equivalent.  If you wish to define a box with tilt\n  factors that exceed these limits, you can use the box tilt\n  command, with a setting of large; a setting of small is the\n  default.\n  See the Howto triclinic doc page for a\n  geometric description of triclinic boxes, as defined by LAMMPS, and\n  how to transform these parameters to and from other commonly used\n  triclinic representations.\n  When a prism region is used, the simulation domain should normally be\n  periodic in the dimension that the tilt is applied to, which is given\n  by the second dimension of the tilt factor (e.g. y for xy tilt).  This\n  is so that pairs of atoms interacting across that boundary will have\n  one of them shifted by the tilt factor.  Periodicity is set by the\n  boundary command.  For example, if the xy tilt factor\n  is non-zero, then the y dimension should be periodic.  Similarly, the\n  z dimension should be periodic if xz or yz is non-zero.  LAMMPS does\n  not require this periodicity, but you may lose atoms if this is not\n  the case.\n  Also note that if your simulation will tilt the box, e.g. via the fix deform command, the simulation box must be setup to\n  be triclinic, even if the tilt factors are initially 0.0.  You can\n  also change an orthogonal box to a triclinic box or vice versa by\n  using the change box command with its ortho and\n  triclinic options.\n  \n  Note\n  If the system is non-periodic (in a dimension), then you should\n  not make the lo/hi box dimensions (as defined in your\n  region command) radically smaller/larger than the extent\n  of the atoms you eventually plan to create, e.g. via the\n  create_atoms command.  For example, if your atoms\n  extend from 0 to 50, you should not specify the box bounds as -10000\n  and 10000. This is because as described above, LAMMPS uses the\n  specified box size to layout the 3d grid of processors.  A huge\n  (mostly empty) box will be sub-optimal for performance when using\n  “fixed” boundary conditions (see the boundary\n  command).  When using “shrink-wrap” boundary conditions (see the\n  boundary command), a huge (mostly empty) box may cause\n  a parallel simulation to lose atoms the first time that LAMMPS\n  shrink-wraps the box around the atoms.\n  \n  \n  The optional keywords can be used to create a system that allows for\n  bond (angle, dihedral, improper) interactions, or for molecules with\n  special 1-2,1-3,1-4 neighbors to be added later.  These optional\n  keywords serve the same purpose as the analogous keywords that can be\n  used in a data file which are recognized by the\n  read_data command when it sets up a system.\n  Note that if these keywords are not used, then the create_box command\n  creates an atomic (non-molecular) simulation that does not allow bonds\n  between pairs of atoms to be defined, or a bond potential to be specified, or for molecules with\n  special neighbors to be added to the system by commands such as\n  create_atoms mol, fix deposit\n  or fix pour.\n  As an example, see the examples/deposit/in.deposit.molecule script,\n  which deposits molecules onto a substrate.  Initially there are no\n  molecules in the system, but they are added later by the fix deposit command.  The create_box command in the\n  script uses the bond/types and extra/bond/per/atom keywords to allow\n  this.  If the added molecule contained more than 1 special bond\n  (allowed by default), an extra/special/per/atom keyword would also\n  need to be specified.\n  ",
    "syntax": "create_box N region-ID keyword value ...\n  \n  \n  \n  N = # of atom types to use in this simulation\n  region-ID = ID of region to use as simulation domain\n  zero or more keyword/value pairs may be appended\n  keyword = bond/types or angle/types or dihedral/types or improper/types or extra/bond/per/atom or extra/angle/per/atom or extra/dihedral/per/atom or extra/improper/per/atom\n  bond/types value = # of bond types\n  angle/types value = # of angle types\n  dihedral/types value = # of dihedral types\n  improper/types value = # of improper types\n  extra/bond/per/atom value = # of bonds per atom\n  extra/angle/per/atom value = # of angles per atom\n  extra/dihedral/per/atom value = # of dihedrals per atom\n  extra/improper/per/atom value = # of impropers per atom\n  extra/special/per/atom value = # of special neighbors per atom\n  \n  \n  ",
    "examples": "create_box 2 mybox\n  create_box 2 mybox bond/types 2 extra/bond/per/atom 1\n  \n  \n  ",
    "restrictions": "An atom_style and region must have\n  been previously defined to use this command.\n  "
},
{
    "command": "delete_atoms",
    "description": "Delete the specified atoms.  This command can be used to carve out\n  voids from a block of material or to delete created atoms that are too\n  close to each other (e.g. at a grain boundary).\n  For style group, all atoms belonging to the group are deleted.\n  For style region, all atoms in the region volume are deleted.\n  Additional atoms can be deleted if they are in a molecule for which\n  one or more atoms were deleted within the region; see the mol\n  keyword discussion below.\n  For style overlap pairs of atoms whose distance of separation is\n  within the specified cutoff distance are searched for, and one of the\n  2 atoms is deleted.  Only pairs where one of the two atoms is in the\n  first group specified and the other atom is in the second group are\n  considered.  The atom that is in the first group is the one that is\n  deleted.\n  Note that it is OK for the two group IDs to be the same (e.g. group\n  all), or for some atoms to be members of both groups.  In these\n  cases, either atom in the pair may be deleted.  Also note that if\n  there are atoms which are members of both groups, the only guarantee\n  is that at the end of the deletion operation, enough deletions will\n  have occurred that no atom pairs within the cutoff will remain\n  (subject to the group restriction).  There is no guarantee that the\n  minimum number of atoms will be deleted, or that the same atoms will\n  be deleted when running on different numbers of processors.\n  For style porosity a specified fraction of atoms are deleted\n  within the specified region.  For example, if fraction is 0.1, then\n  10% of the atoms will be deleted.  The atoms to delete are chosen\n  randomly.  There is no guarantee that the exact fraction of atoms will\n  be deleted, or that the same atoms will be deleted when running on\n  different numbers of processors.\n  If the compress keyword is set to yes, then after atoms are\n  deleted, then atom IDs are re-assigned so that they run from 1 to the\n  number of atoms in the system.  Note that this is not done for\n  molecular systems (see the atom_style command),\n  regardless of the compress setting, since it would foul up the bond\n  connectivity that has already been assigned.  However, the\n  reset_ids command can be used after this command to\n  accomplish the same thing.\n  Note that the re-assignment of IDs is not really a compression, where\n  gaps in atom IDs are removed by decrementing atom IDs that are larger.\n  Instead the IDs for all atoms are erased, and new IDs are assigned so\n  that the atoms owned by individual processors have consecutive IDs, as\n  the create_atoms command explains.\n  A molecular system with fixed bonds, angles, dihedrals, or improper\n  interactions, is one where the topology of the interactions is\n  typically defined in the data file read by the\n  read_data command, and where the interactions\n  themselves are defined with the bond_style,\n  angle_style, etc commands.  If you delete atoms\n  from such a system, you must be careful not to end up with bonded\n  interactions that are stored by remaining atoms but which include\n  deleted atoms.  This will cause LAMMPS to generate a “missing atoms”\n  error when the bonded interaction is computed.  The bond and mol\n  keywords offer two ways to do that.\n  It the bond keyword is set to yes then any bond or angle or\n  dihedral or improper interaction that includes a deleted atom is also\n  removed from the lists of such interactions stored by non-deleted\n  atoms.  Note that simply deleting interactions due to dangling bonds\n  (e.g. at a surface) may result in a inaccurate or invalid model for\n  the remaining atoms.\n  It the mol keyword is set to yes, then for every atom that is\n  deleted, all other atoms in the same molecule (with the same molecule\n  ID) will also be deleted.  This is not done for atoms with molecule ID\n  = 0, since such an ID is assumed to flag isolated atoms that are not\n  part of molecules.\n  \n  Note\n  The molecule deletion operation in invoked after all individual\n  atoms have been deleted using the rules described above for each\n  style.  This means additional atoms may be deleted that are not in the\n  group or region, that are not required by the overlap cutoff\n  criterion, or that will create a higher fraction of porosity than was\n  requested.\n  \n  ",
    "syntax": "delete_atoms style args keyword value ...\n  \n  \n  \n  style = group or region or overlap or porosity\n  group args = group-ID\n  region args = region-ID\n  overlap args = cutoff group1-ID group2-ID\n    cutoff = delete one atom from pairs of atoms within the cutoff (distance units)\n    group1-ID = one atom in pair must be in this group\n    group2-ID = other atom in pair must be in this group\n  porosity args = region-ID fraction seed\n    region-ID = region within which to perform deletions\n    fraction = delete this fraction of atoms\n    seed = random number seed (positive integer)\n  \n  zero or more keyword/value pairs may be appended\n  keyword = compress or bond or mol\n  compress value = no or yes\n  bond value = no or yes\n  mol value = no or yes\n  \n  \n  ",
    "examples": "delete_atoms group edge\n  delete_atoms region sphere compress no\n  delete_atoms overlap 0.3 all all\n  delete_atoms overlap 0.5 solvent colloid\n  delete_atoms porosity cube 0.1 482793 bond yes\n  \n  \n  ",
    "restrictions": "The overlap styles requires inter-processor communication to acquire\n  ghost atoms and build a neighbor list.  This means that your system\n  must be ready to perform a simulation before using this command (force\n  fields setup, atom masses set, etc).  Since a neighbor list is used to\n  find overlapping atom pairs, it also means that you must define a\n  pair style with the minimum force cutoff distance\n  between any pair of atoms types (plus the neighbor\n  skin) >= the specified overlap cutoff.\n  If the special_bonds command is used with a\n  setting of 0, then a pair of bonded atoms (1-2, 1-3, or 1-4) will not\n  appear in the neighbor list, and thus will not be considered for\n  deletion by the overlap styles.  You probably don’t want to be\n  deleting one atom in a bonded pair anyway.\n  The bond yes option cannot be used with molecular systems defined\n  using molecule template files via the molecule and\n  atom_style template commands.\n  "
},
{
    "command": "delete_bonds",
    "description": "Turn off (or on) molecular topology interactions, i.e. bonds, angles,\n  dihedrals, impropers.  This command is useful for deleting\n  interactions that have been previously turned off by bond-breaking\n  potentials.  It is also useful for turning off topology interactions\n  between frozen or rigid atoms.  Pairwise interactions can be turned\n  off via the neigh_modify exclude command.  The\n  fix shake command also effectively turns off certain\n  bond and angle interactions.\n  For all styles, by default, an interaction is only turned off (or on)\n  if all the atoms involved are in the specified group.  See the any\n  keyword to change the behavior.\n  Several of the styles (atom, bond, angle, dihedral,\n  improper) take a type as an argument.  The specified type should\n  be an integer from 0 to N, where N is the number of relevant types\n  (atom types, bond types, etc).  A value of 0 is only relevant for\n  style bond; see details below.  In all cases, a wildcard asterisk\n  can be used in place of or in conjunction with the type argument to\n  specify a range of types.  This takes the form “*” or “*n” or “n*” or\n  “m*n”.  If N = the number of types, then an asterisk with no numeric\n  values means all types from 0 to N.  A leading asterisk means all\n  types from 0 to n (inclusive).  A trailing asterisk means all types\n  from n to N (inclusive).  A middle asterisk means all types from m to\n  n (inclusive).  Note that it is fine to include a type of 0 for\n  non-bond styles; it will simply be ignored.\n  For style multi all bond, angle, dihedral, and improper interactions\n  of any type, involving atoms in the group, are turned off.\n  Style atom is the same as style multi except that in addition, one\n  or more of the atoms involved in the bond, angle, dihedral, or\n  improper interaction must also be of the specified atom type.\n  For style bond, only bonds are candidates for turn-off, and the bond\n  must also be of the specified type.  Styles angle, dihedral, and\n  improper are treated similarly.\n  For style bond, you can set the type to 0 to delete bonds that have\n  been previously broken by a bond-breaking potential (which sets the\n  bond type to 0 when a bond is broken); e.g. see the bond_style quartic command.\n  For style stats no interactions are turned off (or on); the status\n  of all interactions in the specified group is simply reported.  This\n  is useful for diagnostic purposes if bonds have been turned off by a\n  bond-breaking potential during a previous run.\n  The default behavior of the delete_bonds command is to turn off\n  interactions by toggling their type to a negative value, but not to\n  permanently remove the interaction.  E.g. a bond_type of 2 is set to\n  -2.  The neighbor list creation routines will not include such an\n  interaction in their interaction lists.  The default is also to not\n  alter the list of 1-2, 1-3, 1-4 neighbors computed by the\n  special_bonds command and used to weight pairwise\n  force and energy calculations.  This means that pairwise computations\n  will proceed as if the bond (or angle, etc) were still turned on.\n  Several keywords can be appended to the argument list to alter the\n  default behaviors.\n  The any keyword changes the requirement that all atoms in the bond\n  (angle, etc) must be in the specified group in order to turn-off the\n  interaction.  Instead, if any of the atoms in the interaction are in\n  the specified group, it will be turned off (or on if the undo\n  keyword is used).\n  The undo keyword inverts the delete_bonds command so that the\n  specified bonds, angles, etc are turned on if they are currently\n  turned off.  This means a negative value is toggled to positive.  For\n  example, for style angle, if type is specified as 2, then all\n  angles with current type = -2, are reset to type = 2.  Note that the\n  fix shake command also sets bond and angle types\n  negative, so this option should not be used on those interactions.\n  The remove keyword is invoked at the end of the delete_bonds\n  operation.  It causes turned-off bonds (angles, etc) to be removed\n  from each atom’s data structure and then adjusts the global bond\n  (angle, etc) counts accordingly.  Removal is a permanent change;\n  removed bonds cannot be turned back on via the undo keyword.\n  Removal does not alter the pairwise 1-2, 1-3, 1-4 weighting list.\n  The special keyword is invoked at the end of the delete_bonds\n  operation, after (optional) removal.  It re-computes the pairwise 1-2,\n  1-3, 1-4 weighting list.  The weighting list computation treats\n  turned-off bonds the same as turned-on.  Thus, turned-off bonds must\n  be removed if you wish to change the weighting list.\n  Note that the choice of remove and special options affects how\n  1-2, 1-3, 1-4 pairwise interactions will be computed across bonds that\n  have been modified by the delete_bonds command.\n  ",
    "syntax": "delete_bonds group-ID style arg keyword ...\n  \n  \n  \n  group-ID = group ID\n  style = multi or atom or bond or angle or dihedral or improper or stats\n  multi arg = none\n  atom arg = an atom type or range of types (see below)\n  bond arg = a bond type or range of types (see below)\n  angle arg = an angle type or range of types (see below)\n  dihedral arg = a dihedral type or range of types (see below)\n  improper arg = an improper type or range of types (see below)\n  stats arg = none\n  \n  zero or more keywords may be appended\n  keyword = any or undo or remove or special\n  \n  ",
    "examples": "delete_bonds frozen multi remove\n  delete_bonds all atom 4 special\n  delete_bonds all bond 0*3 special\n  delete_bonds all stats\n  \n  \n  ",
    "restrictions": "This command requires inter-processor communication to acquire ghost\n  atoms, to coordinate the deleting of bonds, angles, etc between atoms\n  shared by multiple processors.  This means that your system must be\n  ready to perform a simulation before using this command (force fields\n  setup, atom masses set, etc).  Just as would be needed to run\n  dynamics, the force field you define should define a cutoff\n  (e.g. through a pair_style command) which is long\n  enough for a processor to acquire the ghost atoms its needs to compute\n  bond, angle, etc interactions.\n  If deleted bonds (angles, etc) are removed but the 1-2, 1-3, 1-4\n  weighting list is not re-computed, this can cause a later fix shake command to fail due to an atom’s bonds being\n  inconsistent with the weighting list.  This should only happen if the\n  group used in the fix command includes both atoms in the bond, in\n  which case you probably should be recomputing the weighting list.\n  "
},
{
    "command": "dielectric",
    "description": "Set the dielectric constant for Coulombic interactions (pairwise and\n  long-range) to this value.  The constant is unitless, since it is used\n  to reduce the strength of the interactions.  The value is used in the\n  denominator of the formulas for Coulombic interactions - e.g. a value\n  of 4.0 reduces the Coulombic interactions to 25% of their default\n  strength.  See the pair_style command for more\n  details.\n  ",
    "syntax": "dielectric value\n  \n  \n  \n  value = dielectric constant\n  \n  ",
    "examples": "dielectric 2.0\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "dihedral_coeff",
    "description": "Specify the dihedral force field coefficients for one or more dihedral types.\n  The number and meaning of the coefficients depends on the dihedral style.\n  Dihedral coefficients can also be set in the data file read by the\n  read_data command or in a restart file.\n  N can be specified in one of two ways.  An explicit numeric value can\n  be used, as in the 1st example above.  Or a wild-card asterisk can be\n  used to set the coefficients for multiple dihedral types.  This takes the\n  form “*” or “*n” or “n*” or “m*n”.  If N = the number of dihedral types,\n  then an asterisk with no numeric values means all types from 1 to N.  A\n  leading asterisk means all types from 1 to n (inclusive).  A trailing\n  asterisk means all types from n to N (inclusive).  A middle asterisk\n  means all types from m to n (inclusive).\n  Note that using a dihedral_coeff command can override a previous setting\n  for the same dihedral type.  For example, these commands set the coeffs\n  for all dihedral types, then overwrite the coeffs for just dihedral type 2:\n  dihedral_coeff * 80.0 1 3\n  dihedral_coeff 2 200.0 1 3\n  \n  \n  A line in a data file that specifies dihedral coefficients uses the exact\n  same format as the arguments of the dihedral_coeff command in an input\n  script, except that wild-card asterisks should not be used since\n  coefficients for all N types must be listed in the file.  For example,\n  under the “Dihedral Coeffs” section of a data file, the line that\n  corresponds to the 1st example above would be listed as\n  1 80.0 1 3\n  \n  \n  The dihedral_style class2 is an exception to\n  this rule, in that an additional argument is used in the input script\n  to allow specification of the cross-term coefficients.  See its doc\n  page for details.\n  \n  Note\n  When comparing the formulas and coefficients for various LAMMPS\n  dihedral styles with dihedral equations defined by other force fields,\n  note that some force field implementations divide/multiply the energy\n  prefactor K by the multiple number of torsions that contain the J-K\n  bond in an I-J-K-L torsion.  LAMMPS does not do this, i.e. the listed\n  dihedral equation applies to each individual dihedral.  Thus you need\n  to define K appropriately to account for this difference if\n  necessary.\n  \n  \n  The list of all dihedral styles defined in LAMMPS is given on the\n  dihedral_style doc page.  They are also listed\n  in more compact form on the Commands dihedral doc page.\n  On either of those pages, click on the style to display the formula it\n  computes and its coefficients as specified by the associated\n  dihedral_coeff command.\n  ",
    "syntax": "dihedral_coeff N args\n  \n  \n  \n  N = dihedral type (see asterisk form below)\n  args = coefficients for one or more dihedral types\n  \n  ",
    "examples": "dihedral_coeff 1 80.0 1 3\n  dihedral_coeff * 80.0 1 3 0.5\n  dihedral_coeff 2* 80.0 1 3 0.5\n  \n  \n  ",
    "restrictions": "This command must come after the simulation box is defined by a\n  read_data, read_restart, or\n  create_box command.\n  A dihedral style must be defined before any dihedral coefficients are\n  set, either in the input script or in a data file.\n  "
},
{
    "command": "dihedral_style",
    "description": "Set the formula(s) LAMMPS uses to compute dihedral interactions\n  between quadruplets of atoms, which remain in force for the duration\n  of the simulation.  The list of dihedral quadruplets is read in by a\n  read_data or read_restart command\n  from a data or restart file.\n  Hybrid models where dihedrals are computed using different dihedral\n  potentials can be setup using the hybrid dihedral style.\n  The coefficients associated with a dihedral style can be specified in\n  a data or restart file or via the dihedral_coeff\n  command.\n  All dihedral potentials store their coefficient data in binary restart\n  files which means dihedral_style and\n  dihedral_coeff commands do not need to be\n  re-specified in an input script that restarts a simulation.  See the\n  read_restart command for details on how to do\n  this.  The one exception is that dihedral_style hybrid only stores\n  the list of sub-styles in the restart file; dihedral coefficients need\n  to be re-specified.\n  \n  Note\n  When both a dihedral and pair style is defined, the\n  special_bonds command often needs to be used to\n  turn off (or weight) the pairwise interaction that would otherwise\n  exist between 4 bonded atoms.\n  \n  In the formulas listed for each dihedral style, phi is the torsional\n  angle defined by the quadruplet of atoms.  This angle has a sign\n  convention as shown in this diagram:\n  \n  where the I,J,K,L ordering of the 4 atoms that define the dihedral\n  is from left to right.\n  This sign convention effects several of the dihedral styles listed\n  below (e.g. charmm, helix) in the sense that the energy formula\n  depends on the sign of phi, which may be reflected in the value of the\n  coefficients you specify.\n  \n  Note\n  When comparing the formulas and coefficients for various LAMMPS\n  dihedral styles with dihedral equations defined by other force fields,\n  note that some force field implementations divide/multiply the energy\n  prefactor K by the multiple number of torsions that contain the J-K\n  bond in an I-J-K-L torsion.  LAMMPS does not do this, i.e. the listed\n  dihedral equation applies to each individual dihedral.  Thus you need\n  to define K appropriately via the\n  dihedral_coeff command to account for this\n  difference if necessary.\n  \n  \n  Here is an alphabetic list of dihedral styles defined in LAMMPS.  Click on\n  the style to display the formula it computes and coefficients\n  specified by the associated dihedral_coeff command.\n  Click on the style to display the formula it computes, any additional\n  arguments specified in the dihedral_style command, and coefficients\n  specified by the associated dihedral_coeff\n  command.\n  There are also additional accelerated pair styles included in the\n  LAMMPS distribution for faster performance on CPUs, GPUs, and KNLs.\n  The individual style names on the Commands dihedral doc page are followed by one or\n  more of (g,i,k,o,t) to indicate which accelerated styles exist.\n  \n  none - turn off dihedral interactions\n  zero - topology but no interactions\n  hybrid - define multiple styles of dihedral interactions\n  charmm - CHARMM dihedral\n  charmmfsw - CHARMM dihedral with force switching\n  class2 - COMPASS (class 2) dihedral\n  cosine/shift/exp - dihedral with exponential in spring constant\n  fourier - dihedral with multiple cosine terms\n  harmonic - harmonic dihedral\n  helix - helix dihedral\n  multi/harmonic - dihedral with 5 harmonic terms\n  nharmonic - same as multi-harmonic with N terms\n  opls - OPLS dihedral\n  quadratic - dihedral with quadratic term in angle\n  spherical - dihedral which includes angle terms to avoid singularities\n  table - tabulated dihedral\n  table/cut - tabulated dihedral with analytic cutoff\n  \n  ",
    "syntax": "dihedral_style style\n  \n  \n  \n  style = none or hybrid or charmm or class2 or harmonic or helix or         multi/harmonic or opls\n  \n  ",
    "examples": "dihedral_style harmonic\n  dihedral_style multi/harmonic\n  dihedral_style hybrid harmonic charmm\n  \n  \n  ",
    "restrictions": "Dihedral styles can only be set for atom styles that allow dihedrals\n  to be defined.\n  Most dihedral styles are part of the MOLECULE package.  They are only\n  enabled if LAMMPS was built with that package.  See the Build package doc page for more info.  The doc pages for\n  individual dihedral potentials tell if it is part of a package.\n  "
},
{
    "command": "dimension",
    "description": "Set the dimensionality of the simulation.  By default LAMMPS runs 3d\n  simulations.  To run a 2d simulation, this command should be used\n  prior to setting up a simulation box via the\n  create_box or read_data commands.\n  Restart files also store this setting.\n  See the discussion on the Howto 2d doc page for\n  additional instructions on how to run 2d simulations.\n  \n  Note\n  Some models in LAMMPS treat particles as finite-size spheres or\n  ellipsoids, as opposed to point particles.  In 2d, the particles will\n  still be spheres or ellipsoids, not circular disks or ellipses,\n  meaning their moment of inertia will be the same as in 3d.\n  \n  ",
    "syntax": "dimension N\n  \n  \n  \n  N = 2 or 3\n  \n  ",
    "examples": "dimension 2\n  \n  \n  ",
    "restrictions": "This command must be used before the simulation box is defined by a\n  read_data or create_box command.\n  "
},
{
    "command": "displace_atoms",
    "description": "Displace a group of atoms.  This can be used to move atoms a large\n  distance before beginning a simulation or to randomize atoms initially\n  on a lattice.  For example, in a shear simulation, an initial strain\n  can be imposed on the system.  Or two groups of atoms can be brought\n  into closer proximity.\n  The move style displaces the group of atoms by the specified 3d\n  displacement vector.  Any of the 3 quantities defining the vector\n  components can be specified as an equal-style or atom-style\n  variable.  If the value is a variable, it should be\n  specified as v_name, where name is the variable name.  In this case,\n  the variable will be evaluated, and its value(s) used for the\n  displacement(s).  The scale factor implied by the units keyword will\n  also be applied to the variable result.\n  Equal-style variables can specify formulas with various mathematical\n  functions, and include thermo_style command\n  keywords for the simulation box parameters and timestep and elapsed\n  time.  Atom-style variables can specify the same formulas as\n  equal-style variables but can also include per-atom values, such as\n  atom coordinates or per-atom values read from a file.  Note that if\n  the variable references other compute or fix\n  commands, those values must be up-to-date for the current timestep.\n  See the “Variable Accuracy” section of the variable\n  doc page for more details.\n  The ramp style displaces atoms a variable amount in one dimension\n  depending on the atom’s coordinate in a (possibly) different\n  dimension.  For example, the second example command displaces atoms in\n  the x-direction an amount between 0.0 and 5.0 distance units.  Each\n  atom’s displacement depends on the fractional distance its y\n  coordinate is between 2.0 and 20.5.  Atoms with y-coordinates outside\n  those bounds will be moved the minimum (0.0) or maximum (5.0) amount.\n  The random style independently moves each atom in the group by a\n  random displacement, uniformly sampled from a value between -dx and\n  +dx in the x dimension, and similarly for y and z.  Random numbers are\n  used in such a way that the displacement of a particular atom is the\n  same, regardless of how many processors are being used.\n  The rotate style rotates each atom in the group by the angle theta\n  around a rotation axis R = (Rx,Ry,Rz) that goes through a point P =\n  (Px,Py,Pz).  The direction of rotation for the atoms around the\n  rotation axis is consistent with the right-hand rule: if your\n  right-hand thumb points along R, then your fingers wrap around the\n  axis in the direction of positive theta.\n  If the defined atom_style assigns an orientation to\n  each atom (atom styles ellipsoid, line, tri, body),\n  then that property is also updated appropriately to correspond to the\n  atom’s rotation.\n  Distance units for displacements and the origin point of the rotate\n  style are determined by the setting of box or lattice for the\n  units keyword.  Box means distance units as defined by the\n  units command - e.g. Angstroms for real units.\n  Lattice means distance units are in lattice spacings.  The\n  lattice command must have been previously used to\n  define the lattice spacing.\n  \n  \n  Note\n  Care should be taken not to move atoms on top of other atoms.\n  After the move, atoms are remapped into the periodic simulation box if\n  needed, and any shrink-wrap boundary conditions (see the\n  boundary command) are enforced which may change the\n  box size.  Other than this effect, this command does not change the\n  size or shape of the simulation box.  See the\n  change_box command if that effect is desired.\n  \n  \n  Note\n  Atoms can be moved arbitrarily long distances by this command.\n  If the simulation box is non-periodic and shrink-wrapped (see the\n  boundary command), this can change its size or shape.\n  This is not a problem, except that the mapping of processors to the\n  simulation box is not changed by this command from its initial 3d\n  configuration; see the processors command.  Thus, if\n  the box size/shape changes dramatically, the mapping of processors to\n  the simulation box may not end up as optimal as the initial mapping\n  attempted to be.\n  \n  ",
    "syntax": "displace_atoms group-ID style args keyword value ...\n  \n  \n  \n  group-ID = ID of group of atoms to displace\n  style = move or ramp or random or rotate\n  move args = delx dely delz\n    delx,dely,delz = distance to displace in each dimension (distance units)\n    any of delx,dely,delz can be a variable (see below)\n  ramp args = ddim dlo dhi dim clo chi\n    ddim = x or y or z\n    dlo,dhi = displacement distance between dlo and dhi (distance units)\n    dim = x or y or z\n    clo,chi = lower and upper bound of domain to displace (distance units)\n  random args = dx dy dz seed\n    dx,dy,dz = random displacement magnitude in each dimension (distance units)\n    seed = random # seed (positive integer)\n  rotate args = Px Py Pz Rx Ry Rz theta\n    Px,Py,Pz = origin point of axis of rotation (distance units)\n    Rx,Ry,Rz = axis of rotation vector\n    theta = angle of rotation (degrees)\n  \n  zero or more keyword/value pairs may be appended\n  keyword = units\n    value = box or lattice\n  \n  \n  ",
    "examples": "displace_atoms top move 0 -5 0 units box\n  displace_atoms flow ramp x 0.0 5.0 y 2.0 20.5\n  \n  \n  ",
    "restrictions": "For a 2d simulation, only rotations around the a vector parallel to\n  the z-axis are allowed.\n  "
},
{
    "command": "dump",
    "description": "Dump a snapshot of atom quantities to one or more files every N\n  timesteps in one of several styles.  The image and movie styles are\n  the exception: the image style renders a JPG, PNG, or PPM image file\n  of the atom configuration every N timesteps while the movie style\n  combines and compresses them into a movie file; both are discussed in\n  detail on the dump image doc page.  The timesteps on\n  which dump output is written can also be controlled by a variable.\n  See the dump_modify every command.\n  Only information for atoms in the specified group is dumped.  The\n  dump_modify thresh and region and refresh commands\n  can also alter what atoms are included.  Not all styles support\n  these options; see details on the dump_modify doc\n  page.\n  As described below, the filename determines the kind of output (text\n  or binary or gzipped, one big file or one per timestep, one big file\n  or multiple smaller files).\n  \n  Note\n  Because periodic boundary conditions are enforced only on\n  timesteps when neighbor lists are rebuilt, the coordinates of an atom\n  written to a dump file may be slightly outside the simulation box.\n  Re-neighbor timesteps will not typically coincide with the timesteps\n  dump snapshots are written.  See the dump_modify pbc command if you with to force coordinates to be\n  strictly inside the simulation box.\n  \n  \n  Note\n  Unless the dump_modify sort option is\n  invoked, the lines of atom information written to dump files\n  (typically one line per atom) will be in an indeterminate order for\n  each snapshot.  This is even true when running on a single processor,\n  if the atom_modify sort option is on, which it is\n  by default.  In this case atoms are re-ordered periodically during a\n  simulation, due to spatial sorting.  It is also true when running in\n  parallel, because data for a single snapshot is collected from\n  multiple processors, each of which owns a subset of the atoms.\n  \n  For the atom, custom, cfg, and local styles, sorting is off by\n  default.  For the dcd, xtc, xyz, and molfile styles, sorting by\n  atom ID is on by default. See the dump_modify doc\n  page for details.\n  The atom/gz, cfg/gz, custom/gz, and xyz/gz styles are identical\n  in command syntax to the corresponding styles without “gz”, however,\n  they generate compressed files using the zlib library. Thus the filename\n  suffix “.gz” is mandatory. This is an alternative approach to writing\n  compressed files via a pipe, as done by the regular dump styles, which\n  may be required on clusters where the interface to the high-speed network\n  disallows using the fork() library call (which is needed for a pipe).\n  For the remainder of this doc page, you should thus consider the atom\n  and atom/gz styles (etc) to be inter-changeable, with the exception\n  of the required filename suffix.\n  As explained below, the atom/mpiio, cfg/mpiio, custom/mpiio, and\n  xyz/mpiio styles are identical in command syntax and in the format\n  of the dump files they create, to the corresponding styles without\n  “mpiio”, except the single dump file they produce is written in\n  parallel via the MPI-IO library.  For the remainder of this doc page,\n  you should thus consider the atom and atom/mpiio styles (etc) to\n  be inter-changeable.  The one exception is how the filename is\n  specified for the MPI-IO styles, as explained below.\n  The precision of values output to text-based dump files can be\n  controlled by the dump_modify format command and\n  its options.\n  \n  The style keyword determines what atom quantities are written to the\n  file and in what format.  Settings made via the\n  dump_modify command can also alter the format of\n  individual values and the file itself.\n  The atom, local, and custom styles create files in a simple text\n  format that is self-explanatory when viewing a dump file.  Some of the\n  LAMMPS post-processing tools described on the Tools doc\n  page, including Pizza.py,\n  work with this format, as does the rerun command.\n  For post-processing purposes the atom, local, and custom text\n  files are self-describing in the following sense.\n  The dimensions of the simulation box are included in each snapshot.\n  For an orthogonal simulation box this information is formatted as:\n  ITEM: BOX BOUNDS xx yy zz\n  xlo xhi\n  ylo yhi\n  zlo zhi\n  \n  \n  where xlo,xhi are the maximum extents of the simulation box in the\n  x-dimension, and similarly for y and z.  The “xx yy zz” represent 6\n  characters that encode the style of boundary for each of the 6\n  simulation box boundaries (xlo,xhi and ylo,yhi and zlo,zhi).  Each of\n  the 6 characters is either p = periodic, f = fixed, s = shrink wrap,\n  or m = shrink wrapped with a minimum value.  See the\n  boundary command for details.\n  For triclinic simulation boxes (non-orthogonal), an orthogonal\n  bounding box which encloses the triclinic simulation box is output,\n  along with the 3 tilt factors (xy, xz, yz) of the triclinic box,\n  formatted as follows:\n  ITEM: BOX BOUNDS xy xz yz xx yy zz\n  xlo_bound xhi_bound xy\n  ylo_bound yhi_bound xz\n  zlo_bound zhi_bound yz\n  \n  \n  The presence of the text “xy xz yz” in the ITEM line indicates that\n  the 3 tilt factors will be included on each of the 3 following lines.\n  This bounding box is convenient for many visualization programs.  The\n  meaning of the 6 character flags for “xx yy zz” is the same as above.\n  Note that the first two numbers on each line are now xlo_bound instead\n  of xlo, etc, since they represent a bounding box.  See the Howto triclinic doc page for a geometric description\n  of triclinic boxes, as defined by LAMMPS, simple formulas for how the\n  6 bounding box extents (xlo_bound,xhi_bound,etc) are calculated from\n  the triclinic parameters, and how to transform those parameters to and\n  from other commonly used triclinic representations.\n  The “ITEM: ATOMS” line in each snapshot lists column descriptors for\n  the per-atom lines that follow.  For example, the descriptors would be\n  “id type xs ys zs” for the default atom style, and would be the atom\n  attributes you specify in the dump command for the custom style.\n  For style atom, atom coordinates are written to the file, along with\n  the atom ID and atom type.  By default, atom coords are written in a\n  scaled format (from 0 to 1).  I.e. an x value of 0.25 means the atom\n  is at a location 1/4 of the distance from xlo to xhi of the box\n  boundaries.  The format can be changed to unscaled coords via the\n  dump_modify settings.  Image flags can also be\n  added for each atom via dump_modify.\n  Style custom allows you to specify a list of atom attributes to be\n  written to the dump file for each atom.  Possible attributes are\n  listed above and will appear in the order specified.  You cannot\n  specify a quantity that is not defined for a particular simulation -\n  such as q for atom style bond, since that atom style does not\n  assign charges.  Dumps occur at the very end of a timestep, so atom\n  attributes will include effects due to fixes that are applied during\n  the timestep.  An explanation of the possible dump custom attributes\n  is given below.\n  For style local, local output generated by computes\n  and fixes is used to generate lines of output that is\n  written to the dump file.  This local data is typically calculated by\n  each processor based on the atoms it owns, but there may be zero or\n  more entities per atom, e.g. a list of bond distances.  An explanation\n  of the possible dump local attributes is given below.  Note that by\n  using input from the compute property/local command with dump local,\n  it is possible to generate information on bonds, angles, etc that can\n  be cut and pasted directly into a data file read by the\n  read_data command.\n  Style cfg has the same command syntax as style custom and writes\n  extended CFG format files, as used by the\n  AtomEye visualization\n  package.  Since the extended CFG format uses a single snapshot of the\n  system per file, a wildcard “*” must be included in the filename, as\n  discussed below.  The list of atom attributes for style cfg must\n  begin with either “mass type xs ys zs” or “mass type xsu ysu zsu”\n  since these quantities are needed to write the CFG files in the\n  appropriate format (though the “mass” and “type” fields do not appear\n  explicitly in the file).  Any remaining attributes will be stored as\n  “auxiliary properties” in the CFG files.  Note that you will typically\n  want to use the dump_modify element command with\n  CFG-formatted files, to associate element names with atom types, so\n  that AtomEye can render atoms appropriately. When unwrapped\n  coordinates xsu, ysu, and zsu are requested, the nominal AtomEye\n  periodic cell dimensions are expanded by a large factor UNWRAPEXPAND =\n  10.0, which ensures atoms that are displayed correctly for up to\n  UNWRAPEXPAND/2 periodic boundary crossings in any direction.  Beyond\n  this, AtomEye will rewrap the unwrapped coordinates.  The expansion\n  causes the atoms to be drawn farther away from the viewer, but it is\n  easy to zoom the atoms closer, and the interatomic distances are\n  unaffected.\n  The dcd style writes DCD files, a standard atomic trajectory format\n  used by the CHARMM, NAMD, and XPlor molecular dynamics packages.  DCD\n  files are binary and thus may not be portable to different machines.\n  The number of atoms per snapshot cannot change with the dcd style.\n  The unwrap option of the dump_modify command\n  allows DCD coordinates to be written “unwrapped” by the image flags\n  for each atom.  Unwrapped means that if the atom has passed through\n  a periodic boundary one or more times, the value is printed for what\n  the coordinate would be if it had not been wrapped back into the\n  periodic box.  Note that these coordinates may thus be far outside\n  the box size stored with the snapshot.\n  The xtc style writes XTC files, a compressed trajectory format used\n  by the GROMACS molecular dynamics package, and described\n  here.\n  The precision used in XTC files can be adjusted via the\n  dump_modify command.  The default value of 1000\n  means that coordinates are stored to 1/1000 nanometer accuracy.  XTC\n  files are portable binary files written in the NFS XDR data format,\n  so that any machine which supports XDR should be able to read them.\n  The number of atoms per snapshot cannot change with the xtc style.\n  The unwrap option of the dump_modify command allows\n  XTC coordinates to be written “unwrapped” by the image flags for each\n  atom.  Unwrapped means that if the atom has passed through a periodic\n  boundary one or more times, the value is printed for what the\n  coordinate would be if it had not been wrapped back into the periodic\n  box.  Note that these coordinates may thus be far outside the box size\n  stored with the snapshot.\n  The xyz style writes XYZ files, which is a simple text-based\n  coordinate format that many codes can read. Specifically it has\n  a line with the number of atoms, then a comment line that is\n  usually ignored followed by one line per atom with the atom type\n  and the x-, y-, and z-coordinate of that atom. You can use the\n  dump_modify element option to change the output\n  from using the (numerical) atom type to an element name (or some\n  other label). This will help many visualization programs to guess\n  bonds and colors.\n  Note that atom, custom, dcd, xtc, and xyz style dump files\n  can be read directly by VMD, a\n  popular molecular viewing program.\n  \n  Dumps are performed on timesteps that are a multiple of N (including\n  timestep 0) and on the last timestep of a minimization if the\n  minimization converges.  Note that this means a dump will not be\n  performed on the initial timestep after the dump command is invoked,\n  if the current timestep is not a multiple of N.  This behavior can be\n  changed via the dump_modify first command, which\n  can also be useful if the dump command is invoked after a minimization\n  ended on an arbitrary timestep.  N can be changed between runs by\n  using the dump_modify every command (not allowed\n  for dcd style).  The dump_modify every command\n  also allows a variable to be used to determine the sequence of\n  timesteps on which dump files are written.  In this mode a dump on the\n  first timestep of a run will also not be written unless the\n  dump_modify first command is used.\n  The specified filename determines how the dump file(s) is written.\n  The default is to write one large text file, which is opened when the\n  dump command is invoked and closed when an undump\n  command is used or when LAMMPS exits.  For the dcd and xtc styles,\n  this is a single large binary file.\n  Dump filenames can contain two wildcard characters.  If a “*”\n  character appears in the filename, then one file per snapshot is\n  written and the “*” character is replaced with the timestep value.\n  For example, tmp.dump.* becomes tmp.dump.0, tmp.dump.10000,\n  tmp.dump.20000, etc.  This option is not available for the dcd and\n  xtc styles.  Note that the dump_modify pad\n  command can be used to insure all timestep numbers are the same length\n  (e.g. 00010), which can make it easier to read a series of dump files\n  in order with some post-processing tools.\n  If a “%” character appears in the filename, then each of P processors\n  writes a portion of the dump file, and the “%” character is replaced\n  with the processor ID from 0 to P-1.  For example, tmp.dump.% becomes\n  tmp.dump.0, tmp.dump.1, … tmp.dump.P-1, etc.  This creates smaller\n  files and can be a fast mode of output on parallel machines that\n  support parallel I/O for output. This option is not available for the\n  dcd, xtc, and xyz styles.\n  By default, P = the number of processors meaning one file per\n  processor, but P can be set to a smaller value via the nfile or\n  fileper keywords of the dump_modify command.\n  These options can be the most efficient way of writing out dump files\n  when running on large numbers of processors.\n  Note that using the “*” and “%” characters together can produce a\n  large number of small dump files!\n  For the atom/mpiio, cfg/mpiio, custom/mpiio, and xyz/mpiio\n  styles, a single dump file is written in parallel via the MPI-IO\n  library, which is part of the MPI standard for versions 2.0 and above.\n  Using MPI-IO requires two steps.  First, build LAMMPS with its MPIIO\n  package installed, e.g.\n  make yes-mpiio    # installs the MPIIO package\n  make mpi          # build LAMMPS for your platform\n  \n  \n  Second, use a dump filename which contains “.mpiio”.  Note that it\n  does not have to end in “.mpiio”, just contain those characters.\n  Unlike MPI-IO restart files, which must be both written and read using\n  MPI-IO, the dump files produced by these MPI-IO styles are identical\n  in format to the files produced by their non-MPI-IO style\n  counterparts.  This means you can write a dump file using MPI-IO and\n  use the read_dump command or perform other\n  post-processing, just as if the dump file was not written using\n  MPI-IO.\n  Note that MPI-IO dump files are one large file which all processors\n  write to.  You thus cannot use the “%” wildcard character described\n  above in the filename since that specifies generation of multiple\n  files.  You can use the “.bin” suffix described below in an MPI-IO\n  dump file; again this file will be written in parallel and have the\n  same binary format as if it were written without MPI-IO.\n  If the filename ends with “.bin”, the dump file (or files, if “*” or\n  “%” is also used) is written in binary format.  A binary dump file\n  will be about the same size as a text version, but will typically\n  write out much faster.  Of course, when post-processing, you will need\n  to convert it back to text format (see the binary2txt tool) or write your own code to read the binary\n  file.  The format of the binary file can be understood by looking at\n  the tools/binary2txt.cpp file.  This option is only available for the\n  atom and custom styles.\n  If the filename ends with “.gz”, the dump file (or files, if “*” or “%”\n  is also used) is written in gzipped format.  A gzipped dump file will\n  be about 3x smaller than the text version, but will also take longer\n  to write.  This option is not available for the dcd and xtc\n  styles.\n  \n  Note that in the discussion which follows, for styles which can\n  reference values from a compute or fix, like the custom, cfg, or\n  local styles, the bracketed index I can be specified using a\n  wildcard asterisk with the index to effectively specify multiple\n  values.  This takes the form “*” or “*n” or “n*” or “m*n”.  If N = the\n  size of the vector (for mode = scalar) or the number of columns in\n  the array (for mode = vector), then an asterisk with no numeric\n  values means all indices from 1 to N.  A leading asterisk means all\n  indices from 1 to n (inclusive).  A trailing asterisk means all\n  indices from n to N (inclusive).  A middle asterisk means all indices\n  from m to n (inclusive).\n  Using a wildcard is the same as if the individual columns of the array\n  had been listed one by one.  E.g. these 2 dump commands are\n  equivalent, since the compute stress/atom\n  command creates a per-atom array with 6 columns:\n  compute myPress all stress/atom NULL\n  dump 2 all custom 100 tmp.dump id myPress[*]\n  dump 2 all custom 100 tmp.dump id myPress[1] myPress[2] myPress[3] &\n                                    myPress[4] myPress[5] myPress[6]\n  \n  \n  \n  This section explains the local attributes that can be specified as\n  part of the local style.\n  The index attribute can be used to generate an index number from 1\n  to N for each line written into the dump file, where N is the total\n  number of local datums from all processors, or lines of output that\n  will appear in the snapshot.  Note that because data from different\n  processors depend on what atoms they currently own, and atoms migrate\n  between processor, there is no guarantee that the same index will be\n  used for the same info (e.g. a particular bond) in successive\n  snapshots.\n  The c_ID and c_ID[I] attributes allow local vectors or arrays\n  calculated by a compute to be output.  The ID in the\n  attribute should be replaced by the actual ID of the compute that has\n  been defined previously in the input script.  See the\n  compute command for details.  There are computes for\n  calculating local information such as indices, types, and energies for\n  bonds and angles.\n  Note that computes which calculate global or per-atom quantities, as\n  opposed to local quantities, cannot be output in a dump local command.\n  Instead, global quantities can be output by the thermo_style custom command, and per-atom quantities can be\n  output by the dump custom command.\n  If c_ID is used as a attribute, then the local vector calculated by\n  the compute is printed.  If c_ID[I] is used, then I must be in the\n  range from 1-M, which will print the Ith column of the local array\n  with M columns calculated by the compute.  See the discussion above\n  for how I can be specified with a wildcard asterisk to effectively\n  specify multiple values.\n  The f_ID and f_ID[I] attributes allow local vectors or arrays\n  calculated by a fix to be output.  The ID in the attribute\n  should be replaced by the actual ID of the fix that has been defined\n  previously in the input script.\n  If f_ID is used as a attribute, then the local vector calculated by\n  the fix is printed.  If f_ID[I] is used, then I must be in the\n  range from 1-M, which will print the Ith column of the local with M\n  columns calculated by the fix.  See the discussion above for how I can\n  be specified with a wildcard asterisk to effectively specify multiple\n  values.\n  Here is an example of how to dump bond info for a system, including\n  the distance and energy of each bond:\n  compute 1 all property/local batom1 batom2 btype\n  compute 2 all bond/local dist eng\n  dump 1 all local 1000 tmp.dump index c_1[1] c_1[2] c_1[3] c_2[1] c_2[2]\n  \n  \n  \n  This section explains the atom attributes that can be specified as\n  part of the custom and cfg styles.\n  The id, mol, proc, procp1, type, element, mass, vx,\n  vy, vz, fx, fy, fz, q attributes are self-explanatory.\n  Id is the atom ID.  Mol is the molecule ID, included in the data\n  file for molecular systems.  Proc is the ID of the processor (0 to\n  Nprocs-1) that currently owns the atom.  Procp1 is the proc ID+1,\n  which can be convenient in place of a type attribute (1 to Ntypes)\n  for coloring atoms in a visualization program.  Type is the atom\n  type (1 to Ntypes).  Element is typically the chemical name of an\n  element, which you must assign to each type via the dump_modify element command.  More generally, it can be any\n  string you wish to associated with an atom type.  Mass is the atom\n  mass.  Vx, vy, vz, fx, fy, fz, and q are components of\n  atom velocity and force and atomic charge.\n  There are several options for outputting atom coordinates.  The x,\n  y, z attributes write atom coordinates “unscaled”, in the\n  appropriate distance units (Angstroms, sigma, etc).  Use\n  xs, ys, zs if you want the coordinates “scaled” to the box size,\n  so that each value is 0.0 to 1.0.  If the simulation box is triclinic\n  (tilted), then all atom coords will still be between 0.0 and 1.0.\n  I.e. actual unscaled (x,y,z) = xs*A + ys*B + zs*C, where (A,B,C) are\n  the non-orthogonal vectors of the simulation box edges, as discussed\n  on the Howto triclinic doc page.\n  Use xu, yu, zu if you want the coordinates “unwrapped” by the\n  image flags for each atom.  Unwrapped means that if the atom has\n  passed through a periodic boundary one or more times, the value is\n  printed for what the coordinate would be if it had not been wrapped\n  back into the periodic box.  Note that using xu, yu, zu means\n  that the coordinate values may be far outside the box bounds printed\n  with the snapshot.  Using xsu, ysu, zsu is similar to using\n  xu, yu, zu, except that the unwrapped coordinates are scaled by\n  the box size. Atoms that have passed through a periodic boundary will\n  have the corresponding coordinate increased or decreased by 1.0.\n  The image flags can be printed directly using the ix, iy, iz\n  attributes.  For periodic dimensions, they specify which image of the\n  simulation box the atom is considered to be in.  An image of 0 means\n  it is inside the box as defined.  A value of 2 means add 2 box lengths\n  to get the true value.  A value of -1 means subtract 1 box length to\n  get the true value.  LAMMPS updates these flags as atoms cross\n  periodic boundaries during the simulation.\n  The mux, muy, muz attributes are specific to dipolar systems\n  defined with an atom style of dipole.  They give the orientation of\n  the atom’s point dipole moment.  The mu attribute gives the\n  magnitude of the atom’s dipole moment.\n  The radius and diameter attributes are specific to spherical\n  particles that have a finite size, such as those defined with an atom\n  style of sphere.\n  The omegax, omegay, and omegaz attributes are specific to\n  finite-size spherical particles that have an angular velocity.  Only\n  certain atom styles, such as sphere define this quantity.\n  The angmomx, angmomy, and angmomz attributes are specific to\n  finite-size aspherical particles that have an angular momentum.  Only\n  the ellipsoid atom style defines this quantity.\n  The tqx, tqy, tqz attributes are for finite-size particles that\n  can sustain a rotational torque due to interactions with other\n  particles.\n  The c_ID and c_ID[I] attributes allow per-atom vectors or arrays\n  calculated by a compute to be output.  The ID in the\n  attribute should be replaced by the actual ID of the compute that has\n  been defined previously in the input script.  See the\n  compute command for details.  There are computes for\n  calculating the per-atom energy, stress, centro-symmetry parameter,\n  and coordination number of individual atoms.\n  Note that computes which calculate global or local quantities, as\n  opposed to per-atom quantities, cannot be output in a dump custom\n  command.  Instead, global quantities can be output by the\n  thermo_style custom command, and local quantities\n  can be output by the dump local command.\n  If c_ID is used as a attribute, then the per-atom vector calculated\n  by the compute is printed.  If c_ID[I] is used, then I must be in\n  the range from 1-M, which will print the Ith column of the per-atom\n  array with M columns calculated by the compute.  See the discussion\n  above for how I can be specified with a wildcard asterisk to\n  effectively specify multiple values.\n  The f_ID and f_ID[I] attributes allow vector or array per-atom\n  quantities calculated by a fix to be output.  The ID in the\n  attribute should be replaced by the actual ID of the fix that has been\n  defined previously in the input script.  The fix ave/atom command is one that calculates per-atom\n  quantities.  Since it can time-average per-atom quantities produced by\n  any compute, fix, or atom-style\n  variable, this allows those time-averaged results to\n  be written to a dump file.\n  If f_ID is used as a attribute, then the per-atom vector calculated\n  by the fix is printed.  If f_ID[I] is used, then I must be in the\n  range from 1-M, which will print the Ith column of the per-atom array\n  with M columns calculated by the fix.  See the discussion above for\n  how I can be specified with a wildcard asterisk to effectively specify\n  multiple values.\n  The v_name attribute allows per-atom vectors calculated by a\n  variable to be output.  The name in the attribute\n  should be replaced by the actual name of the variable that has been\n  defined previously in the input script.  Only an atom-style variable\n  can be referenced, since it is the only style that generates per-atom\n  values.  Variables of style atom can reference individual atom\n  attributes, per-atom attributes, thermodynamic keywords, or\n  invoke other computes, fixes, or variables when they are evaluated, so\n  this is a very general means of creating quantities to output to a\n  dump file.\n  The d_name and i_name attributes allow to output custom per atom\n  floating point or integer properties that are managed by\n  fix property/atom.\n  See the Modify doc page for information on how to add\n  new compute and fix styles to LAMMPS to calculate per-atom quantities\n  which could then be output into dump files.\n  ",
    "syntax": "dump ID group-ID style N file args\n  \n  \n  \n  ID = user-assigned name for the dump\n  group-ID = ID of the group of atoms to be dumped\n  style = atom or atom/gz or atom/mpiio or cfg or cfg/gz or\n  cfg/mpiio or custom or custom/gz or custom/mpiio or dcd or h5md or image or local or local/gz or molfile or movie or netcdf or netcdf/mpiio or vtk or xtc or xyz or xyz/gz or xyz/mpiio\n  N = dump every this many timesteps\n  file = name of file to write dump info to\n  args = list of arguments for a particular style\n  atom args = none\n  atom/gz args = none\n  atom/mpiio args = none\n  atom/adios args = none,  discussed on dump atom/adios doc page\n  cfg args = same as custom args, see below\n  cfg/gz args = same as custom args, see below\n  cfg/mpiio args = same as custom args, see below\n  custom, custom/gz, custom/mpiio args = see below\n  custom/adios args = same as custom args, discussed on dump custom/adios doc page\n  dcd args = none\n  h5md args = discussed on dump h5md doc page\n  image args = discussed on dump image doc page\n  local args = see below\n  molfile args = discussed on dump molfile doc page\n  movie args = discussed on dump image doc page\n  netcdf args = discussed on dump netcdf doc page\n  netcdf/mpiio args = discussed on dump netcdf doc page\n  vtk args = same as custom args, see below, also dump vtk doc page\n  xtc args = none\n  xyz args = none\n  xyz/gz args = none\n  xyz/mpiio args = none\n  \n  custom or custom/gz or custom/mpiio or netcdf or netcdf/mpiio args = list of atom attributes\n  possible attributes = id, mol, proc, procp1, type, element, mass,\n                        x, y, z, xs, ys, zs, xu, yu, zu,\n                        xsu, ysu, zsu, ix, iy, iz,\n                        vx, vy, vz, fx, fy, fz,\n                        q, mux, muy, muz, mu,\n                        radius, diameter, omegax, omegay, omegaz,\n                        angmomx, angmomy, angmomz, tqx, tqy, tqz,\n                        c_ID, c_ID[N], f_ID, f_ID[N], v_name\n  \n  \n  id = atom ID\n  mol = molecule ID\n  proc = ID of processor that owns atom\n  procp1 = ID+1 of processor that owns atom\n  type = atom type\n  element = name of atom element, as defined by dump_modify command\n  mass = atom mass\n  x,y,z = unscaled atom coordinates\n  xs,ys,zs = scaled atom coordinates\n  xu,yu,zu = unwrapped atom coordinates\n  xsu,ysu,zsu = scaled unwrapped atom coordinates\n  ix,iy,iz = box image that the atom is in\n  vx,vy,vz = atom velocities\n  fx,fy,fz = forces on atoms\n  q = atom charge\n  mux,muy,muz = orientation of dipole moment of atom\n  mu = magnitude of dipole moment of atom\n  radius,diameter = radius,diameter of spherical particle\n  omegax,omegay,omegaz = angular velocity of spherical particle\n  angmomx,angmomy,angmomz = angular momentum of aspherical particle\n  tqx,tqy,tqz = torque on finite-size particles\n  c_ID = per-atom vector calculated by a compute with ID\n  c_ID[I] = Ith column of per-atom array calculated by a compute with ID, I can include wildcard (see below)\n  f_ID = per-atom vector calculated by a fix with ID\n  f_ID[I] = Ith column of per-atom array calculated by a fix with ID, I can include wildcard (see below)\n  v_name = per-atom vector calculated by an atom-style variable with name\n  d_name = per-atom floating point vector with name, managed by fix property/atom\n  i_name = per-atom integer vector with name, managed by fix property/atom\n  \n  local args = list of local attributes\n  possible attributes = index, c_ID, c_ID[I], f_ID, f_ID[I]\n    index = enumeration of local values\n    c_ID = local vector calculated by a compute with ID\n    c_ID[I] = Ith column of local array calculated by a compute with ID, I can include wildcard (see below)\n    f_ID = local vector calculated by a fix with ID\n    f_ID[I] = Ith column of local array calculated by a fix with ID, I can include wildcard (see below)\n  \n  \n  \n  \n  ",
    "examples": "dump myDump all atom 100 dump.atom\n  dump myDump all atom/mpiio 100 dump.atom.mpiio\n  dump myDump all atom/gz 100 dump.atom.gz\n  dump 2 subgroup atom 50 dump.run.bin\n  dump 2 subgroup atom 50 dump.run.mpiio.bin\n  dump 4a all custom 100 dump.myforce.* id type x y vx fx\n  dump 4b flow custom 100 dump.%.myforce id type c_myF[3] v_ke\n  dump 4b flow custom 100 dump.%.myforce id type c_myF[\\*] v_ke\n  dump 2 inner cfg 10 dump.snap.*.cfg mass type xs ys zs vx vy vz\n  dump snap all cfg 100 dump.config.*.cfg mass type xs ys zs id type c_Stress[2]\n  dump 1 all xtc 1000 file.xtc\n  \n  \n  ",
    "restrictions": "To write gzipped dump files, you must either compile LAMMPS with the\n  -DLAMMPS_GZIP option or use the styles from the COMPRESS package.\n  See the Build settings doc page for details.\n  The atom/gz, cfg/gz, custom/gz, and xyz/gz styles are part of\n  the COMPRESS package.  They are only enabled if LAMMPS was built with\n  that package.  See the Build package doc page for\n  more info.\n  The atom/mpiio, cfg/mpiio, custom/mpiio, and xyz/mpiio styles\n  are part of the MPIIO package.  They are only enabled if LAMMPS was\n  built with that package.  See the Build package\n  doc page for more info.\n  The xtc style is part of the MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "dump atom/adios",
    "description": "Dump a snapshot of atom coordinates every N timesteps in the\n  ADIOS based “BP” file format, or using different I/O solutions in ADIOS,\n  to a stream that can be read on-line by another program.\n  ADIOS-BP files are binary, portable and self-describing.\n  Use from write_dump:\n  It is possible to use these dump styles with the\n  write_dump command.  In this case, the sub-intervals\n  must not be set at all.  The write_dump command can be used to\n  create a new file at each individual dump.\n  dump 4     all atom/adios 100 dump.bp\n  write_dump all atom/adios singledump.bp\n  \n  \n  ",
    "syntax": "dump ID group-ID atom/adios N file.bp\n  \n  dump ID group-ID custom/adios N file.bp args\n  \n  \n  \n  ID = user-assigned name for the dump\n  group-ID = ID of the group of atoms to be imaged\n  adios = style of dump command (other styles atom or cfg or dcd or xtc or xyz or local or custom are discussed on the dump doc page)\n  N = dump every this many timesteps\n  file.bp = name of file/stream to write to\n  args = same options as in *dump custom* command\n  \n  ",
    "examples": "dump adios1 all atom/adios   100 atoms.bp\n  dump 4a     all custom/adios 100 dump_adios.bp id v_p x y z\n  dump 2 subgroup custom/adios 100 dump_adios.bp mass type xs ys zs vx vy vz\n  \n  \n  ",
    "restrictions": "The number of atoms per snapshot CAN change with the adios style.\n  When using the ADIOS tool ‘bpls’ to list the content of a .bp file,\n  bpls will print __ for the size of the output table indicating that\n  its size is changing every step.\n  The atom/adios and custom/adios dump styles are part of the USER-ADIOS\n  package.  They are only enabled if LAMMPS was built with that package.\n  See the Build package doc page for more info.\n  "
},
{
    "command": "dump cfg/uef",
    "description": "This command is used to dump atomic coordinates in the\n  reference frame of the applied flow field when\n  fix nvt/uef or\n  fix npt/uef or is used. Only the atomic\n  coordinates and frame-invariant scalar quantities\n  will be in the flow frame. If velocities are selected\n  as output, for example, they will not be in the same\n  reference frame as the atomic positions.\n  ",
    "syntax": "dump ID group-ID cfg/uef N file mass type xs ys zs args\n  \n  \n  \n  ID = user-assigned name for the dump\n  group-ID = ID of the group of atoms to be dumped\n  N = dump every this many timesteps\n  file = name of file to write dump info to\n  args = same as args for dump custom\n  \n  \n  ",
    "examples": "dump 1 all cfg/uef 10 dump.\\*.cfg mass type xs ys zs\n  dump 2 all cfg/uef 100 dump.\\*.cfg mass type xs ys zs id c_stress\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-UEF package. It is only enabled if LAMMPS\n  was built with that package. See the Build package doc page for more info.\n  This command can only be used when fix nvt/uef\n  or fix npt/uef is active.\n  "
},
{
    "command": "dump h5md",
    "description": "Dump a snapshot of atom coordinates every N timesteps in the\n  HDF5 based H5MD file format (de Buyl).\n  HDF5 files are binary, portable and self-describing.  This dump style\n  will write only one file, on the root node.\n  Several dumps may write to the same file, by using file_from and\n  referring to a previously defined dump.  Several groups may also be\n  stored within the same file by defining several dumps.  A dump that\n  refers (via file_from) to an already open dump ID and that concerns\n  another particle group must specify create_group yes.\n  Each data element is written every N*N_element steps. For image, no\n  sub-interval is needed as it must be present at the same interval as\n  position.  image must be given after position in any case.  The\n  box information (edges in each dimension) is stored at the same\n  interval than the position element, if present. Else it is stored\n  every N steps.\n  \n  Note\n  Because periodic boundary conditions are enforced only on\n  timesteps when neighbor lists are rebuilt, the coordinates of an atom\n  written to a dump file may be slightly outside the simulation box.\n  \n  Use from write_dump:\n  It is possible to use this dump style with the\n  write_dump command.  In this case, the sub-intervals\n  must not be set at all.  The write_dump command can be used either to\n  create a new file or to add current data to an existing dump file by\n  using the file_from keyword.\n  Typically, the species data is fixed. The following two commands\n  store the position data every 100 timesteps, with the image data, and\n  store once the species data in the same file.\n  dump h5md1 all h5md 100 dump.h5 position image\n  write_dump all h5md dump.h5 file_from h5md1 species\n  \n  \n  ",
    "syntax": "dump ID group-ID h5md N file.h5 args\n  \n  \n  \n  ID = user-assigned name for the dump\n  group-ID = ID of the group of atoms to be imaged\n  h5md = style of dump command (other styles atom or cfg or dcd or xtc or xyz or local or custom are discussed on the dump doc page)\n  N = dump every this many timesteps\n  file.h5 = name of file to write to\n  \n  args = list of data elements to dump, with their dump \"sub-intervals\"\n    position options\n    image\n    velocity options\n    force options\n    species options\n    file_from ID: do not open a new file, re-use the already opened file from dump ID\n    box value = yes or no\n    create_group value = yes or no\n    author value = quoted string\n  Note that at least one element must be specified and image may only be\n  present if position is specified first.\n  For the elements position, velocity, force and species, a\n  sub-interval may be specified to write the data only every N_element\n  iterations of the dump (i.e. every N*N_element time steps). This is\n  specified by this option directly following the element declaration:\n  every N_element\n  \n  \n  ",
    "examples": "dump h5md1 all h5md 100 dump_h5md.h5 position image\n  dump h5md1 all h5md 100 dump_h5md.h5 position velocity every 10\n  dump h5md1 all h5md 100 dump_h5md.h5 velocity author \"John Doe\"\n  \n  \n  ",
    "restrictions": "The number of atoms per snapshot cannot change with the h5md style.\n  The position data is stored wrapped (box boundaries not enforced, see\n  note above).  Only orthogonal domains are currently supported. This is\n  a limitation of the present dump h5md command and not of H5MD itself.\n  The h5md dump style is part of the USER-H5MD package. It is only\n  enabled if LAMMPS was built with that package. See the Build package doc page for more info. It also requires\n  (i) building the ch5md library provided with LAMMPS (See the Build package doc page for more info.) and (ii) having\n  the HDF5 library installed (C bindings are sufficient) on\n  your system.  The library ch5md is compiled with the h5cc wrapper\n  provided by the HDF5 library.\n  "
},
{
    "command": "dump_modify",
    "description": "Modify the parameters of a previously defined dump command.  Not all\n  parameters are relevant to all dump styles.\n  As explained on the dump doc page, the atom/mpiio,\n  custom/mpiio, and xyz/mpiio dump styles are identical in command\n  syntax and in the format of the dump files they create, to the\n  corresponding styles without “mpiio”, except the single dump file they\n  produce is written in parallel via the MPI-IO library.  Thus if a\n  dump_modify option below is valid for the atom style, it is also\n  valid for the atom/mpiio style, and similarly for the other styles\n  which allow for use of MPI-IO.\n  \n  These keywords apply to various dump styles, including the dump image and dump movie styles.  The\n  description gives details.\n  \n  The append keyword applies to all dump styles except cfg and xtc\n  and dcd.  It also applies only to text output files, not to binary\n  or gzipped or image/movie files.  If specified as yes, then dump\n  snapshots are appended to the end of an existing dump file.  If\n  specified as no, then a new dump file will be created which will\n  overwrite an existing file with the same name.\n  \n  The at keyword only applies to the netcdf dump style.  It can only\n  be used if the append yes keyword is also used.  The N argument is\n  the index of which frame to append to.  A negative value can be\n  specified for N, which means a frame counted from the end of the\n  file.  The at keyword can only be used if the dump_modify command is\n  before the first command that causes dump snapshots to be output,\n  e.g. a run or minimize command.  Once the\n  dump file has been opened, this keyword has no further effect.\n  \n  The buffer keyword applies only to dump styles atom, cfg,\n  custom, local, and xyz.  It also applies only to text output\n  files, not to binary or gzipped files.  If specified as yes, which\n  is the default, then each processor writes its output into an internal\n  text buffer, which is then sent to the processor(s) which perform file\n  writes, and written by those processors(s) as one large chunk of text.\n  If specified as no, each processor sends its per-atom data in binary\n  format to the processor(s) which perform file wirtes, and those\n  processor(s) format and write it line by line into the output file.\n  The buffering mode is typically faster since each processor does the\n  relatively expensive task of formatting the output for its own atoms.\n  However it requires about twice the memory (per processor) for the\n  extra buffering.\n  \n  The delay keyword applies to all dump styles.  No snapshots will be\n  output until the specified Dstep timestep or later.  Specifying\n  Dstep < 0 is the same as turning off the delay setting.  This is a\n  way to turn off unwanted output early in a simulation, for example,\n  during an equilibration phase.\n  \n  The element keyword applies only to the dump cfg, xyz, and\n  image styles.  It associates element names (e.g. H, C, Fe) with\n  LAMMPS atom types.  See the list of element names at the bottom of\n  this page.\n  In the case of dump cfg, this allows the AtomEye\n  visualization package to read the dump file and render atoms with the\n  appropriate size and color.\n  In the case of dump image, the output images will follow the same\n  AtomEye convention.  An element name is specified for each\n  atom type (1 to Ntype) in the simulation.  The same element name can\n  be given to multiple atom types.\n  In the case of xyz format dumps, there are no restrictions to what\n  label can be used as an element name.  Any white-space separated text\n  will be accepted.\n  \n  The every keyword changes the dump frequency originally specified by\n  the dump command to a new value.  The every keyword can be\n  specified in one of two ways.  It can be a numeric value in which case\n  it must be > 0.  Or it can be an equal-style variable,\n  which should be specified as v_name, where name is the variable name.\n  In this case, the variable is evaluated at the beginning of a run to\n  determine the next timestep at which a dump snapshot will be written\n  out.  On that timestep the variable will be evaluated again to\n  determine the next timestep, etc.  Thus the variable should return\n  timestep values.  See the stagger() and logfreq() and stride() math\n  functions for equal-style variables, as examples of\n  useful functions to use in this context.  Other similar math functions\n  could easily be added as options for equal-style variables.  Also see the next() function, which allows\n  use of a file-style variable which reads successive values from a\n  file, each time the variable is evaluated.  Used with the every\n  keyword, if the file contains a list of ascending timesteps, you can\n  output snapshots whenever you wish.\n  Note that when using the variable option with the every keyword, you\n  need to use the first option if you want an initial snapshot written\n  to the dump file.  The every keyword cannot be used with the dump\n  dcd style.\n  For example, the following commands will\n  write snapshots at timesteps 0,10,20,30,100,200,300,1000,2000,etc:\n  variable        s equal logfreq(10,3,10)\n  dump            1 all atom 100 tmp.dump\n  dump_modify     1 every v_s first yes\n  \n  \n  The following commands would write snapshots at the timesteps listed\n  in file tmp.times:\n  variable        f file tmp.times\n  variable        s equal next(f)\n  dump            1 all atom 100 tmp.dump\n  dump_modify     1 every v_s\n  \n  \n  \n  Note\n  When using a file-style variable with the every keyword, the\n  file of timesteps must list a first timestep that is beyond the\n  current timestep (e.g. it cannot be 0).  And it must list one or more\n  timesteps beyond the length of the run you perform.  This is because\n  the dump command will generate an error if the next timestep it reads\n  from the file is not a value greater than the current timestep.  Thus\n  if you wanted output on steps 0,15,100 of a 100-timestep run, the file\n  should contain the values 15,100,101 and you should also use the\n  dump_modify first command.  Any final value > 100 could be used in\n  place of 101.\n  \n  \n  The first keyword determines whether a dump snapshot is written on\n  the very first timestep after the dump command is invoked.  This will\n  always occur if the current timestep is a multiple of N, the frequency\n  specified in the dump command, including timestep 0.  But\n  if this is not the case, a dump snapshot will only be written if the\n  setting of this keyword is yes.  If it is no, which is the\n  default, then it will not be written.\n  \n  The flush keyword determines whether a flush operation is invoked\n  after a dump snapshot is written to the dump file.  A flush insures\n  the output in that file is current (no buffering by the OS), even if\n  LAMMPS halts before the simulation completes.  Flushes cannot be\n  performed with dump style xtc.\n  \n  The format keyword can be used to change the default numeric format\n  output by the text-based dump styles: atom, custom, cfg, and\n  xyz styles, and their MPIIO variants.  Only the line or none\n  options can be used with the atom and xyz styles.\n  All the specified format strings are C-style formats, e.g. as used by\n  the C/C++ printf() command.  The line keyword takes a single\n  argument which is the format string for an entire line of output for\n  each atom (do not include a trailing “n”), with N fields, which you\n  must enclose in quotes if it is more than one field.  The int and\n  float keywords take a single format argument and are applied to all\n  integer or floating-point quantities output.  The setting for M\n  string also takes a single format argument which is used for the Mth\n  value output in each line, e.g. the 5th column is output in high\n  precision for “format 5 %20.15g”.\n  \n  Note\n  When using the line keyword for the cfg style, the first two\n  fields (atom ID and type) are not actually written into the CFG file,\n  however you must include formats for them in the format string.\n  \n  The format keyword can be used multiple times.  The precedence is\n  that for each value in a line of output, the M format (if specified)\n  is used, else the int or float setting (if specified) is used,\n  else the line setting (if specified) for that value is used, else\n  the default setting is used.  A setting of none clears all previous\n  settings, reverting all values to their default format.\n  \n  Note\n  Atom and molecule IDs are stored internally as 4-byte or 8-byte\n  signed integers, depending on how LAMMPS was compiled.  When\n  specifying the format int option you can use a “%d”-style format\n  identifier in the format string and LAMMPS will convert this to the\n  corresponding 8-byte form if it is needed when outputting those\n  values.  However, when specifying the line option or format M\n  string option for those values, you should specify a format string\n  appropriate for an 8-byte signed integer, e.g. one with “%ld”, if\n  LAMMPS was compiled with the -DLAMMPS_BIGBIG option for 8-byte IDs.\n  \n  \n  Note\n  Any value written to a text-based dump file that is a per-atom\n  quantity calculated by a compute or fix is\n  stored internally as a floating-point value.  If the value is actually\n  an integer and you wish it to appear in the text dump file as a\n  (large) integer, then you need to use an appropriate format.  For\n  example, these commands:\n  \n  compute     1 all property/local batom1 batom2\n  dump        1 all local 100 tmp.bonds index c_1[1] c_1[2]\n  dump_modify 1 format \"%d %0.0f %0.0f\"\n  \n  \n  will output the two atom IDs for atoms in each bond as integers.  If\n  the dump_modify command were omitted, they would appear as\n  floating-point values, assuming they were large integers (more than 6\n  digits).  The “index” keyword should use the “%d” format since it is\n  not generated by a compute or fix, and is stored internally as an\n  integer.\n  \n  The fileper keyword is documented below with the nfile keyword.\n  \n  The image keyword applies only to the dump atom style.  If the\n  image value is yes, 3 flags are appended to each atom’s coords which\n  are the absolute box image of the atom in each dimension.  For\n  example, an x image flag of -2 with a normalized coord of 0.5 means\n  the atom is in the center of the box, but has passed through the box\n  boundary 2 times and is really 2 box lengths to the left of its\n  current coordinate.  Note that for dump style custom these various\n  values can be printed in the dump file by using the appropriate atom\n  attributes in the dump command itself.\n  \n  The label keyword applies only to the dump local style.  When\n  it writes local information, such as bond or angle topology\n  to a dump file, it will use the specified label to format\n  the header.  By default this includes 2 lines:\n  ITEM: NUMBER OF ENTRIES\n  ITEM: ENTRIES ...\n  \n  \n  The word “ENTRIES” will be replaced with the string specified,\n  e.g. BONDS or ANGLES.\n  \n  The maxfiles keyword can only be used when a ‘*’ wildcard is\n  included in the dump file name, i.e. when writing a new file(s) for\n  each snapshot.  The specified Fmax is how many snapshots will be\n  kept.  Once this number is reached, the file(s) containing the oldest\n  snapshot is deleted before a new dump file is written.  If the\n  specified Fmax <= 0, then all files are retained.\n  This can be useful for debugging, especially if you don’t know on what\n  timestep something bad will happen, e.g. when LAMMPS will exit with an\n  error.  You can dump every timestep, and limit the number of dump\n  files produced, even if you run for 1000s of steps.\n  \n  The nfile or fileper keywords can be used in conjunction with the\n  “%” wildcard character in the specified dump file name, for all dump\n  styles except the dcd, image, movie, xtc, and xyz styles\n  (for which “%” is not allowed).  As explained on the dump\n  command doc page, the “%” character causes the dump file to be written\n  in pieces, one piece for each of P processors.  By default P = the\n  number of processors the simulation is running on.  The nfile or\n  fileper keyword can be used to set P to a smaller value, which can\n  be more efficient when running on a large number of processors.\n  The nfile keyword sets P to the specified Nf value.  For example, if\n  Nf = 4, and the simulation is running on 100 processors, 4 files will\n  be written, by processors 0,25,50,75.  Each will collect information\n  from itself and the next 24 processors and write it to a dump file.\n  For the fileper keyword, the specified value of Np means write one\n  file for every Np processors.  For example, if Np = 4, every 4th\n  processor (0,4,8,12,etc) will collect information from itself and the\n  next 3 processors and write it to a dump file.\n  \n  The pad keyword only applies when the dump filename is specified\n  with a wildcard “*” character which becomes the timestep.  If pad is\n  0, which is the default, the timestep is converted into a string of\n  unpadded length, e.g. 100 or 12000 or 2000000.  When pad is\n  specified with Nchar > 0, the string is padded with leading zeroes\n  so they are all the same length = Nchar.  For example, pad 7 would\n  yield 0000100, 0012000, 2000000.  This can be useful so that\n  post-processing programs can easily read the files in ascending\n  timestep order.\n  \n  The pbc keyword applies to all the dump styles.  As explained on the\n  dump doc page, atom coordinates in a dump file may be\n  slightly outside the simulation box.  This is because periodic\n  boundary conditions are enforced only on timesteps when neighbor lists\n  are rebuilt, which will not typically coincide with the timesteps dump\n  snapshots are written.  If the setting of this keyword is set to\n  yes, then all atoms will be remapped to the periodic box before the\n  snapshot is written, then restored to their original position.  If it\n  is set to no they will not be.  The no setting is the default\n  because it requires no extra computation.\n  \n  The precision keyword only applies to the dump xtc style.  A\n  specified value of N means that coordinates are stored to 1/N\n  nanometer accuracy, e.g. for N = 1000, the coordinates are written to\n  1/1000 nanometer accuracy.\n  \n  The refresh keyword only applies to the dump custom, cfg,\n  image, and movie styles.  It allows an “incremental” dump file to\n  be written, by refreshing a compute that is used as a threshold for\n  determining which atoms are included in a dump snapshot.  The\n  specified c_ID gives the ID of the compute.  It is prefixed by “c_”\n  to indicate a compute, which is the only current option.  At some\n  point, other options may be added, e.g. fixes or variables.\n  \n  Note\n  This keyword can only be specified once for a dump.  Refreshes\n  of multiple computes cannot yet be performed.\n  \n  The definition and motivation of an incremental dump file is as\n  follows.  Instead of outputting all atoms at each snapshot (with some\n  associated values), you may only wish to output the subset of atoms\n  with a value that has changed in some way compared to the value the\n  last time that atom was output.  In some scenarios this can result in\n  a dramatically smaller dump file.  If desired, by post-processing the\n  sequence of snapshots, the values for all atoms at all timesteps can\n  be inferred.\n  A concrete example is a simulation of atom diffusion in a solid,\n  represented as atoms on a lattice.  Diffusive hops are rare.  Imagine\n  that when a hop occurs an atom moves more than a distance Dhop.  For\n  any snapshot we only want to output atoms that have hopped since the\n  last snapshot.  This can be accomplished with something the following\n  commands:\n  variable        Dhop equal 0.6\n  variable        check atom \"c_dsp[4] > v_Dhop\"\n  compute         dsp all displace/atom refresh check\n  dump            1 all custom 20 tmp.dump id type x y z\n  dump_modify     1 append yes thresh c_dsp[4] > ${Dhop} refresh c_dsp\n  \n  \n  The compute displace/atom command\n  calculates the displacement of each atom from its reference position.\n  The “4” index is the scalar displacement; 1,2,3 are the xyz components\n  of the displacement.  The dump_modify thresh\n  command will cause only atoms that have displaced more than 0.6\n  Angstroms to be output on a given snapshot (assuming metal units).\n  However, note that when an atom is output, we also need to update the\n  reference position for that atom to its new coordinates.  So that it\n  will not be output in every snapshot thereafter.  That reference\n  position is stored by compute displace/atom.  So the dump_modify\n  refresh option triggers a call to compute displace/atom at the end\n  of every dump to perform that update.  The refresh check option\n  shown as part of the compute displace/atom command enables the compute\n  to respond to the call from the dump command, and update the\n  appropriate reference positions.  This is done be defining an\n  atom-style variable, check in this example, which\n  calculates a Boolean value (0 or 1) for each atom, based on the same\n  criterion used by dump_modify thresh.\n  See the compute displace/atom command for\n  more details, including an example of how to produce output that\n  includes an initial snapshot with the reference position of all atoms.\n  Note that only computes with a refresh option will work with\n  dump_modify refresh.  See individual compute doc pages for details.\n  Currently, only compute displace/atom supports this option.  Others\n  may be added at some point.  If you use a compute that does not support\n  refresh operations, LAMMPS will not complain; dump_modify refresh will\n  simply do nothing.\n  \n  The region keyword only applies to the dump custom, cfg,\n  image, and movie styles.  If specified, only atoms in the region\n  will be written to the dump file or included in the image/movie.  Only\n  one region can be applied as a filter (the last one specified).  See\n  the region command for more details.  Note that a region\n  can be defined as the “inside” or “outside” of a geometric shape, and\n  it can be the “union” or “intersection” of a series of simpler\n  regions.\n  \n  The scale keyword applies only to the dump atom style.  A scale\n  value of yes means atom coords are written in normalized units from\n  0.0 to 1.0 in each box dimension.  If the simulation box is triclinic\n  (tilted), then all atom coords will still be between 0.0 and 1.0.  A\n  value of no means they are written in absolute distance units\n  (e.g. Angstroms or sigma).\n  \n  The sfactor and tfactor keywords only apply to the dump xtc\n  style.  They allow customization of the unit conversion factors used\n  when writing to XTC files.  By default they are initialized for\n  whatever units style is being used, to write out\n  coordinates in nanometers and time in picoseconds.  I.e. for real\n  units, LAMMPS defines sfactor = 0.1 and tfactor = 0.001, since the\n  Angstroms and fmsec used by real units are 0.1 nm and 0.001 psec\n  respectively.  If you are using a units system with distance and time\n  units far from nm and psec, you may wish to write XTC files with\n  different units, since the compression algorithm used in XTC files is\n  most effective when the typical magnitude of position data is between\n  10.0 and 0.1.\n  \n  The sort keyword determines whether lines of per-atom output in a\n  snapshot are sorted or not.  A sort value of off means they will\n  typically be written in indeterminate order, either in serial or\n  parallel.  This is the case even in serial if the atom_modify sort option is turned on, which it is by default, to\n  improve performance.  A sort value of id means sort the output by\n  atom ID.  A sort value of N or -N means sort the output by the value\n  in the Nth column of per-atom info in either ascending or descending\n  order.\n  The dump local style cannot be sorted by atom ID, since there are\n  typically multiple lines of output per atom.  Some dump styles, such\n  as dcd and xtc, require sorting by atom ID to format the output\n  file correctly.  If multiple processors are writing the dump file, via\n  the “%” wildcard in the dump filename, then sorting cannot be\n  performed.\n  \n  Note\n  Unless it is required by the dump style, sorting dump file\n  output requires extra overhead in terms of CPU and communication cost,\n  as well as memory, versus unsorted output.\n  \n  \n  The thermo keyword only applies the dump netcdf style.  It\n  triggers writing of thermo information to the dump file\n  alongside per-atom data.  The values included in the dump file are\n  identical to the values specified by thermo_style.\n  \n  The thresh keyword only applies to the dump custom, cfg,\n  image, and movie styles.  Multiple thresholds can be specified.\n  Specifying none turns off all threshold criteria.  If thresholds are\n  specified, only atoms whose attributes meet all the threshold criteria\n  are written to the dump file or included in the image.  The possible\n  attributes that can be tested for are the same as those that can be\n  specified in the dump custom command, with the exception\n  of the element attribute, since it is not a numeric value.  Note\n  that a different attributes can be used than those output by the dump custom command.  E.g. you can output the coordinates and\n  stress of atoms whose energy is above some threshold.\n  If an atom-style variable is used as the attribute, then it can\n  produce continuous numeric values or effective Boolean 0/1 values\n  which may be useful for the comparison operator.  Boolean values can\n  be generated by variable formulas that use comparison or Boolean math\n  operators or special functions like gmask() and rmask() and grmask().\n  See the variable command doc page for details.\n  The specified value must be a simple numeric value or the word LAST.\n  If LAST is used, it refers to the value of the attribute the last time\n  the dump command was invoked to produce a snapshot.  This is a way to\n  only dump atoms whose attribute has changed (or not changed).\n  Three examples follow.\n  dump_modify ... thresh ix != LAST\n  \n  \n  This will dump atoms which have crossed the periodic x boundary of the\n  simulation box since the last dump.  (Note that atoms that crossed\n  once and then crossed back between the two dump timesteps would not be\n  included.)\n  region foo sphere 10 20 10 15\n  variable inregion atom rmask(foo)\n  dump_modify ... thresh v_inregion |^ LAST\n  \n  \n  This will dump atoms which crossed the boundary of the spherical\n  region since the last dump.\n  variable charge atom \"(q > 0.5) || (q < -0.5)\"\n  dump_modify ... thresh v_charge |^ LAST\n  \n  \n  This will dump atoms whose charge has changed from an absolute value\n  less than 1/2 to greater than 1/2 (or vice versa) since the last dump.\n  E.g. due to reactions and subsequent charge equilibration in a\n  reactive force field.\n  The choice of operators listed above are the usual comparison\n  operators.  The XOR operation (exclusive or) is also included as “|^”.\n  In this context, XOR means that if either the attribute or value is\n  0.0 and the other is non-zero, then the result is “true” and the\n  threshold criterion is met.  Otherwise it is not met.\n  \n  The time keyword only applies to the dump atom, custom, and\n  local styles (and their COMPRESS package versions atom/gz,\n  custom/gz and local/gz). If set to yes, each frame will will\n  contain two extra lines before the “ITEM: TIMESTEP” entry:\n  ITEM: TIME\n  <elapsed time>\n  This will output the current elapsed simulation time in current\n  time units equivalent to the thermo keyword time.\n  This is to simplify post-processing of trajectories using a variable time\n  step, e.g. when using fix dt/reset.\n  The default setting is no.\n  \n  The units keyword only applies to the dump atom, custom, and\n  local styles (and their COMPRESS package versions atom/gz,\n  custom/gz and local/gz). If set to yes, each individual dump\n  file will contain two extra lines at the very beginning with:\n  ITEM: UNITS\n  <units style>\n  This will output the current selected units style\n  to the dump file and thus allows visualization and post-processing\n  tools to determine the choice of units of the data in the dump file.\n  The default setting is no.\n  \n  The unwrap keyword only applies to the dump dcd and xtc styles.\n  If set to yes, coordinates will be written “unwrapped” by the image\n  flags for each atom.  Unwrapped means that if the atom has passed through\n  a periodic boundary one or more times, the value is printed for what\n  the coordinate would be if it had not been wrapped back into the\n  periodic box.  Note that these coordinates may thus be far outside the\n  box size stored with the snapshot.\n  \n  These keywords apply only to the dump image and\n  dump movie styles.  Any keyword that affects an\n  image, also affects a movie, since the movie is simply a collection of\n  images.  Some of the keywords only affect the dump movie style.  The descriptions give details.\n  \n  The acolor keyword can be used with the dump image\n  command, when its atom color setting is type, to set the color that\n  atoms of each type will be drawn in the image.\n  The specified type should be an integer from 1 to Ntypes = the\n  number of atom types.  A wildcard asterisk can be used in place of or\n  in conjunction with the type argument to specify a range of atom\n  types.  This takes the form “*” or “*n” or “n*” or “m*n”.  If N = the\n  number of atom types, then an asterisk with no numeric values means\n  all types from 1 to N.  A leading asterisk means all types from 1 to n\n  (inclusive).  A trailing asterisk means all types from n to N\n  (inclusive).  A middle asterisk means all types from m to n\n  (inclusive).\n  The specified color can be a single color which is any of the 140\n  pre-defined colors (see below) or a color name defined by the\n  dump_modify color option.  Or it can be two or more colors separated\n  by a “/” character, e.g. red/green/blue.  In the former case, that\n  color is assigned to all the specified atom types.  In the latter\n  case, the list of colors are assigned in a round-robin fashion to each\n  of the specified atom types.\n  \n  The adiam keyword can be used with the dump image\n  command, when its atom diameter setting is type, to set the size\n  that atoms of each type will be drawn in the image.  The specified\n  type should be an integer from 1 to Ntypes.  As with the acolor\n  keyword, a wildcard asterisk can be used as part of the type\n  argument to specify a range of atom types.  The specified diam is\n  the size in whatever distance units the input script is\n  using, e.g. Angstroms.\n  \n  The amap keyword can be used with the dump image\n  command, with its atom keyword, when its atom setting is an\n  atom-attribute, to setup a color map.  The color map is used to assign\n  a specific RGB (red/green/blue) color value to an individual atom when\n  it is drawn, based on the atom’s attribute, which is a numeric value,\n  e.g. its x-component of velocity if the atom-attribute “vx” was\n  specified.\n  The basic idea of a color map is that the atom-attribute will be\n  within a range of values, and that range is associated with a series\n  of colors (e.g. red, blue, green).  An atom’s specific value (vx =\n  -3.2) can then mapped to the series of colors (e.g. halfway between\n  red and blue), and a specific color is determined via an interpolation\n  procedure.\n  There are many possible options for the color map, enabled by the\n  amap keyword.  Here are the details.\n  The lo and hi settings determine the range of values allowed for\n  the atom attribute.  If numeric values are used for lo and/or hi,\n  then values that are lower/higher than that value are set to the\n  value.  I.e. the range is static.  If lo is specified as min or\n  hi as max then the range is dynamic, and the lower and/or\n  upper bound will be calculated each time an image is drawn, based\n  on the set of atoms being visualized.\n  The style setting is two letters, such as “ca”.  The first letter is\n  either “c” for continuous, “d” for discrete, or “s” for sequential.\n  The second letter is either “a” for absolute, or “f” for fractional.\n  A continuous color map is one in which the color changes continuously\n  from value to value within the range.  A discrete color map is one in\n  which discrete colors are assigned to sub-ranges of values within the\n  range.  A sequential color map is one in which discrete colors are\n  assigned to a sequence of sub-ranges of values covering the entire\n  range.\n  An absolute color map is one in which the values to which colors are\n  assigned are specified explicitly as values within the range.  A\n  fractional color map is one in which the values to which colors are\n  assigned are specified as a fractional portion of the range.  For\n  example if the range is from -10.0 to 10.0, and the color red is to be\n  assigned to atoms with a value of 5.0, then for an absolute color map\n  the number 5.0 would be used.  But for a fractional map, the number\n  0.75 would be used since 5.0 is 3/4 of the way from -10.0 to 10.0.\n  The delta setting must be specified for all styles, but is only used\n  for the sequential style; otherwise the value is ignored.  It\n  specifies the bin size to use within the range for assigning\n  consecutive colors to.  For example, if the range is from -10.0 to\n  10.0 and a delta of 1.0 is used, then 20 colors will be assigned to\n  the range.  The first will be from -10.0 <= color1 < -9.0, then 2nd\n  from -9.0 <= color2 < -8.0, etc.\n  The N setting is how many entries follow.  The format of the entries\n  depends on whether the color map style is continuous, discrete or\n  sequential.  In all cases the color setting can be any of the 140\n  pre-defined colors (see below) or a color name defined by the\n  dump_modify color option.\n  For continuous color maps, each entry has a value and a color.\n  The value is either a number within the range of values or min or\n  max.  The value of the first entry must be min and the value\n  of the last entry must be max.  Any entries in between must have\n  increasing values.  Note that numeric values can be specified either\n  as absolute numbers or as fractions (0.0 to 1.0) of the range,\n  depending on the “a” or “f” in the style setting for the color map.\n  Here is how the entries are used to determine the color of an\n  individual atom, given the value X of its atom attribute.  X will fall\n  between 2 of the entry values.  The color of the atom is linearly\n  interpolated (in each of the RGB values) between the 2 colors\n  associated with those entries.  For example, if X = -5.0 and the 2\n  surrounding entries are “red” at -10.0 and “blue” at 0.0, then the\n  atom’s color will be halfway between “red” and “blue”, which happens\n  to be “purple”.\n  For discrete color maps, each entry has a lo and hi value and a\n  color.  The lo and hi settings are either numbers within the\n  range of values or lo can be min or hi can be max.  The lo\n  and hi settings of the last entry must be min and max.  Other\n  entries can have any lo and hi values and the sub-ranges of\n  different values can overlap.  Note that numeric lo and hi values\n  can be specified either as absolute numbers or as fractions (0.0 to\n  1.0) of the range, depending on the “a” or “f” in the style setting\n  for the color map.\n  Here is how the entries are used to determine the color of an\n  individual atom, given the value X of its atom attribute.  The entries\n  are scanned from first to last.  The first time that lo <= X <=\n  hi, X is assigned the color associated with that entry.  You can\n  think of the last entry as assigning a default color (since it will\n  always be matched by X), and the earlier entries as colors that\n  override the default.  Also note that no interpolation of a color RGB\n  is done.  All atoms will be drawn with one of the colors in the list\n  of entries.\n  For sequential color maps, each entry has only a color.  Here is how\n  the entries are used to determine the color of an individual atom,\n  given the value X of its atom attribute.  The range is partitioned\n  into N bins of width binsize.  Thus X will fall in a specific bin\n  from 1 to N, say the Mth bin.  If it falls on a boundary between 2\n  bins, it is considered to be in the higher of the 2 bins.  Each bin is\n  assigned a color from the E entries.  If E < N, then the colors are\n  repeated.  For example if 2 entries with colors red and green are\n  specified, then the odd numbered bins will be red and the even bins\n  green.  The color of the atom is the color of its bin.  Note that the\n  sequential color map is really a shorthand way of defining a discrete\n  color map without having to specify where all the bin boundaries are.\n  Here is an example of using a sequential color map to color all the\n  atoms in individual molecules with a different color.  See the\n  examples/pour/in.pour.2d.molecule input script for an example of how\n  this is used.\n  variable        colors string &\n                  \"red green blue yellow white &\n                  purple pink orange lime gray\"\n  variable        mol atom mol%10\n  dump            1 all image 250 image.*.jpg v_mol type &\n                  zoom 1.6 adiam 1.5\n  dump_modify     1 pad 5 amap 0 10 sa 1 10 ${colors}\n  \n  \n  In this case, 10 colors are defined, and molecule IDs are\n  mapped to one of the colors, even if there are 1000s of molecules.\n  \n  The backcolor sets the background color of the images.  The color\n  name can be any of the 140 pre-defined colors (see below) or a color\n  name defined by the dump_modify color option.\n  \n  The bcolor keyword can be used with the dump image\n  command, with its bond keyword, when its color setting is type, to\n  set the color that bonds of each type will be drawn in the image.\n  The specified type should be an integer from 1 to Nbondtypes = the\n  number of bond types.  A wildcard asterisk can be used in place of or\n  in conjunction with the type argument to specify a range of bond\n  types.  This takes the form “*” or “*n” or “n*” or “m*n”.  If N = the\n  number of bond types, then an asterisk with no numeric values means\n  all types from 1 to N.  A leading asterisk means all types from 1 to n\n  (inclusive).  A trailing asterisk means all types from n to N\n  (inclusive).  A middle asterisk means all types from m to n\n  (inclusive).\n  The specified color can be a single color which is any of the 140\n  pre-defined colors (see below) or a color name defined by the\n  dump_modify color option.  Or it can be two or more colors separated\n  by a “/” character, e.g. red/green/blue.  In the former case, that\n  color is assigned to all the specified bond types.  In the latter\n  case, the list of colors are assigned in a round-robin fashion to each\n  of the specified bond types.\n  \n  The bdiam keyword can be used with the dump image\n  command, with its bond keyword, when its diam setting is type, to\n  set the diameter that bonds of each type will be drawn in the image.\n  The specified type should be an integer from 1 to Nbondtypes.  As\n  with the bcolor keyword, a wildcard asterisk can be used as part of\n  the type argument to specify a range of bond types.  The specified\n  diam is the size in whatever distance units you are\n  using, e.g. Angstroms.\n  \n  The bitrate keyword can be used with the dump movie command to define the size of the resulting\n  movie file and its quality via setting how many kbits per second are\n  to be used for the movie file. Higher bitrates require less\n  compression and will result in higher quality movies.  The quality is\n  also determined by the compression format and encoder.  The default\n  setting is 2000 kbit/s, which will result in average quality with\n  older compression formats.\n  \n  Note\n  Not all movie file formats supported by dump movie allow the\n  bitrate to be set.  If not, the setting is silently ignored.\n  \n  \n  The boxcolor keyword sets the color of the simulation box drawn\n  around the atoms in each image as well as the color of processor\n  sub-domain boundaries.  See the “dump image box” command for how to\n  specify that a box be drawn via the box keyword, and the sub-domain\n  boundaries via the subbox keyword.  The color name can be any of the\n  140 pre-defined colors (see below) or a color name defined by the\n  dump_modify color option.\n  \n  The color keyword allows definition of a new color name, in addition\n  to the 140-predefined colors (see below), and associates 3\n  red/green/blue RGB values with that color name.  The color name can\n  then be used with any other dump_modify keyword that takes a color\n  name as a value.  The RGB values should each be floating point values\n  between 0.0 and 1.0 inclusive.\n  When a color name is converted to RGB values, the user-defined color\n  names are searched first, then the 140 pre-defined color names.  This\n  means you can also use the color keyword to overwrite one of the\n  pre-defined color names with new RBG values.\n  \n  The framerate keyword can be used with the dump movie command to define the duration of the resulting\n  movie file.  Movie files written by the dump movie command have a\n  default frame rate of 24 frames per second and the images generated\n  will be converted at that rate.  Thus a sequence of 1000 dump images\n  will result in a movie of about 42 seconds.  To make a movie run\n  longer you can either generate images more frequently or lower the\n  frame rate.  To speed a movie up, you can do the inverse.  Using a\n  frame rate higher than 24 is not recommended, as it will result in\n  simply dropping the rendered images. It is more efficient to dump\n  images less frequently.\n  ",
    "syntax": "dump_modify dump-ID keyword values ...\n  \n  \n  \n  dump-ID = ID of dump to modify\n  one or more keyword/value pairs may be appended\n  these keywords apply to various dump styles\n  keyword = append or at or buffer or delay or element or every or fileper or first or flush or format or image or label or maxfiles or nfile or pad or pbc or precision or region or refresh or scale or sfactor or sort or tfactor or thermo or thresh or time or units or unwrap\n  append arg = yes or no\n  at arg = N\n    N = index of frame written upon first dump\n  buffer arg = yes or no\n  delay arg = Dstep\n    Dstep = delay output until this timestep\n  element args = E1 E2 ... EN, where N = # of atom types\n    E1,...,EN = element name, e.g. C or Fe or Ga\n  every arg = N\n    N = dump every this many timesteps\n    N can be a variable (see below)\n  fileper arg = Np\n    Np = write one file for every this many processors\n  first arg = yes or no\n  flush arg = yes or no\n  format args = line string, int string, float string, M string, or none\n    string = C-style format string\n    M = integer from 1 to N, where N = # of per-atom quantities being output\n  image arg = yes or no\n  label arg = string\n    string = character string (e.g. BONDS) to use in header of dump local file\n  maxfiles arg = Fmax\n    Fmax = keep only the most recent Fmax snapshots (one snapshot per file)\n  nfile arg = Nf\n    Nf = write this many files, one from each of Nf processors\n  pad arg = Nchar = # of characters to convert timestep to\n  pbc arg = yes or no = remap atoms via periodic boundary conditions\n  precision arg = power-of-10 value from 10 to 1000000\n  region arg = region-ID or \"none\"\n  refresh arg = c_ID = compute ID that supports a refresh operation\n  scale arg = yes or no\n  sfactor arg = coordinate scaling factor (> 0.0)\n  sort arg = off or id or N or -N\n     off = no sorting of per-atom lines within a snapshot\n     id = sort per-atom lines by atom ID\n     N = sort per-atom lines in ascending order by the Nth column\n     -N = sort per-atom lines in descending order by the Nth column\n  tfactor arg = time scaling factor (> 0.0)\n  thermo arg = yes or no\n  time arg = yes or no\n  thresh args = attribute operator value\n    attribute = same attributes (x,fy,etotal,sxx,etc) used by dump custom style\n    operator = \"<\" or \"<=\" or \">\" or \">=\" or \"==\" or \"!=\" or \"|^\"\n    value = numeric value to compare to, or LAST\n    these 3 args can be replaced by the word \"none\" to turn off thresholding\n  units arg = yes or no\n  unwrap arg = yes or no\n  \n  these keywords apply only to the image and movie styles\n  keyword = acolor or adiam or amap or backcolor or bcolor or bdiam or boxcolor or color or bitrate or framerate\n  acolor args = type color\n    type = atom type or range of types (see below)\n    color = name of color or color1/color2/...\n  adiam args = type diam\n    type = atom type or range of types (see below)\n    diam = diameter of atoms of that type (distance units)\n  amap args = lo hi style delta N entry1 entry2 ... entryN\n    lo = number or min = lower bound of range of color map\n    hi = number or max = upper bound of range of color map\n    style = 2 letters = \"c\" or \"d\" or \"s\" plus \"a\" or \"f\"\n      \"c\" for continuous\n      \"d\" for discrete\n      \"s\" for sequential\n      \"a\" for absolute\n      \"f\" for fractional\n    delta = binsize (only used for style \"s\", otherwise ignored)\n      binsize = range is divided into bins of this width\n    N = # of subsequent entries\n    entry = value color (for continuous style)\n      value = number or min or max = single value within range\n      color = name of color used for that value\n    entry = lo hi color (for discrete style)\n      lo/hi = number or min or max = lower/upper bound of subset of range\n      color = name of color used for that subset of values\n    entry = color (for sequential style)\n      color = name of color used for a bin of values\n  backcolor arg = color\n    color = name of color for background\n  bcolor args = type color\n    type = bond type or range of types (see below)\n    color = name of color or color1/color2/...\n  bdiam args = type diam\n    type = bond type or range of types (see below)\n    diam = diameter of bonds of that type (distance units)\n  boxcolor arg = color\n    color = name of color for simulation box lines and processor sub-domain lines\n  color args = name R G B\n    name = name of color\n    R,G,B = red/green/blue numeric values from 0.0 to 1.0\n  bitrate arg = rate\n    rate = target bitrate for movie in kbps\n  framerate arg = fps\n    fps = frames per second for movie\n  \n  \n  ",
    "examples": "dump_modify 1 format line \"%d %d %20.15g %g %g\" scale yes\n  dump_modify 1 format float %20.15g scale yes\n  dump_modify myDump image yes scale no flush yes\n  dump_modify 1 region mySphere thresh x < 0.0 thresh epair >= 3.2\n  dump_modify xtcdump precision 10000 sfactor 0.1\n  dump_modify 1 every 1000 nfile 20\n  dump_modify 1 every v_myVar\n  dump_modify 1 amap min max cf 0.0 3 min green 0.5 yellow max blue boxcolor red\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "dump molfile",
    "description": "Dump a snapshot of atom coordinates and selected additional quantities\n  to one or more files every N timesteps in one of several formats.\n  Only information for atoms in the specified group is dumped.  This\n  specific dump style uses molfile plugins that are bundled with the\n  VMD molecular visualization and\n  analysis program.\n  Unless the filename contains a * character, the output will be written\n  to one single file with the specified format. Otherwise there will be\n  one file per snapshot and the * will be replaced by the time step number\n  when the snapshot is written.\n  \n  Note\n  Because periodic boundary conditions are enforced only on\n  timesteps when neighbor lists are rebuilt, the coordinates of an atom\n  written to a dump file may be slightly outside the simulation box.\n  \n  The molfile plugin API has a few restrictions that have to be honored\n  by this dump style: the number of atoms must not change, the atoms\n  must be sorted, outside of the coordinates no change in atom properties\n  (like type, mass, charge) will be recorded.\n  \n  The format keyword determines what format is used to write out the\n  dump. For this to work, LAMMPS must be able to find and load a\n  compatible molfile plugin that supports this format.  Settings made via\n  the dump_modify command can alter per atom properties\n  like element names.\n  The path keyword determines which in directories. This is a “path”\n  like other search paths, i.e. it can contain multiple directories\n  separated by a colon (or semi-colon on windows). This keyword is\n  optional and default to “.”, the current directory.\n  The unwrap option of the dump_modify command allows\n  coordinates to be written “unwrapped” by the image flags for each atom.\n  Unwrapped means that if the atom has passed through a periodic boundary\n  one or more times, the value is printed for what the coordinate would be\n  if it had not been wrapped back into the periodic box.  Note that these\n  coordinates may thus be far outside the box size stored with the\n  snapshot.\n  \n  Dumps are performed on timesteps that are a multiple of N (including\n  timestep 0) and on the last timestep of a minimization if the\n  minimization converges.  Note that this means a dump will not be\n  performed on the initial timestep after the dump command is invoked,\n  if the current timestep is not a multiple of N.  This behavior can be\n  changed via the dump_modify first command, which can\n  be useful if the dump command is invoked after a minimization ended on\n  an arbitrary timestep.  N can be changed between runs by using the\n  dump_modify every command. The dump_modify every command also allows a variable to be used to\n  determine the sequence of timesteps on which dump files are written.\n  ",
    "syntax": "dump ID group-ID molfile N file format path\n  \n  \n  \n  ID = user-assigned name for the dump\n  group-ID = ID of the group of atoms to be imaged\n  molfile = style of dump command (other styles atom or cfg or dcd or xtc or xyz or local or custom are discussed on the dump doc page)\n  N = dump every this many timesteps\n  file = name of file to write to\n  format = file format to be used\n  path = file path with plugins (optional)\n  \n  ",
    "examples": "dump mf1 all molfile 10 melt1.xml hoomd\n  dump mf2 all molfile 10 melt2-*.pdb pdb .\n  dump mf3 all molfile 50 melt3.xyz xyz .:/home/akohlmey/vmd/plugins/LINUX/molfile\n  \n  \n  ",
    "restrictions": "The molfile dump style is part of the USER-MOLFILE package.  It is\n  only enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\n  Molfile plugins provide a consistent programming interface to read and\n  write file formats commonly used in molecular simulations. The\n  USER-MOLFILE package only provides the interface code, not the plugins.\n  These can be obtained from a VMD installation which has to match the\n  platform that you are using to compile LAMMPS for. By adding plugins\n  to VMD, support for new file formats can be added to LAMMPS (or VMD\n  or other programs that use them) without having to re-compile the\n  application itself.  The plugins are installed in the directory:\n  <VMDHOME>/plugins/<VMDARCH>/molfile\n  \n  Note\n  while the programming interface (API) to the plugins is backward\n  compatible, the binary interface (ABI) has been changing over time, so\n  it is necessary to compile this package with the plugin header files\n  from VMD that match the binary plugins.  These header files in the\n  directory: <VMDHOME>/plugins/include For convenience, the package ships\n  with a set of header files that are compatible with VMD 1.9 and 1.9.1\n  (June 2012)\n  \n  "
},
{
    "command": "dump netcdf",
    "description": "Dump a snapshot of atom coordinates every N timesteps in Amber-style\n  NetCDF file format.  NetCDF files are binary, portable and\n  self-describing.  This dump style will write only one file on the root\n  node.  The dump style netcdf uses the standard NetCDF library.  All data is collected on one processor and then\n  written to the dump file.  Dump style netcdf/mpiio uses the\n  parallel NetCDF library and MPI-IO to write to the dump\n  file in parallel; it has better performance on a larger number of\n  processors.  Note that style netcdf outputs all atoms sorted by atom\n  tag while style netcdf/mpiio outputs atoms in order of their MPI\n  rank.\n  NetCDF files can be directly visualized via the following tools:\n  Ovito (http://www.ovito.org/). Ovito supports the AMBER convention and\n  all extensions of this dump style.\n  \n  VMD (http://www.ks.uiuc.edu/Research/vmd/).\n  AtomEye (http://www.libatoms.org/). The libAtoms version of AtomEye\n  contains a NetCDF reader that is not present in the standard\n  distribution of AtomEye.\n  \n  In addition to per-atom data, thermo data can be included in the\n  dump file. The data included in the dump file is identical to the data specified\n  by thermo_style.\n  ",
    "syntax": "dump ID group-ID netcdf N file args\n  dump ID group-ID netcdf/mpiio N file args\n  \n  \n  \n  ID = user-assigned name for the dump\n  group-ID = ID of the group of atoms to be imaged\n  netcdf or netcdf/mpiio  = style of dump command (other styles atom or cfg or dcd or xtc or xyz or local or custom are discussed on the dump doc page)\n  N = dump every this many timesteps\n  file = name of file to write dump info to\n  args = list of atom attributes, same as for dump_style custom\n  \n  ",
    "examples": "dump 1 all netcdf 100 traj.nc type x y z vx vy vz\n  dump_modify 1 append yes at -1 thermo yes\n  dump 1 all netcdf/mpiio 1000 traj.nc id type x y z\n  dump 1 all netcdf 1000 traj.*.nc id type x y z\n  \n  \n  ",
    "restrictions": "The netcdf and netcdf/mpiio dump styles are part of the\n  USER-NETCDF package.  They are only enabled if LAMMPS was built with\n  that package. See the Build package doc page for\n  more info.\n  "
},
{
    "command": "dump vtk",
    "description": "Dump a snapshot of atom quantities to one or more files every N\n  timesteps in a format readable by the VTK visualization toolkit or other visualization tools that use it,\n  e.g. ParaView.  The timesteps on which dump\n  output is written can also be controlled by a variable; see the\n  dump_modify every command for details.\n  This dump style is similar to dump_style custom but uses\n  the VTK library to write data to VTK simple legacy or XML format\n  depending on the filename extension specified for the dump file.  This\n  can be either *.vtk for the legacy format or *.vtp and *.vtu,\n  respectively, for XML format; see the VTK homepage for a detailed\n  description of these formats.  Since this naming convention conflicts\n  with the way binary output is usually specified (see below), the\n  dump_modify binary command allows setting of a\n  binary option for this dump style explicitly.\n  Only information for atoms in the specified group is dumped.  The\n  dump_modify thresh and region commands can also\n  alter what atoms are included; see details below.\n  As described below, special characters (“*”, “%”) in the filename\n  determine the kind of output.\n  \n  Warning\n  Because periodic boundary conditions are enforced only\n  on timesteps when neighbor lists are rebuilt, the coordinates of an\n  atom written to a dump file may be slightly outside the simulation\n  box.\n  \n  \n  Warning\n  Unless the dump_modify sort option\n  is invoked, the lines of atom information written to dump files will\n  be in an indeterminate order for each snapshot.  This is even true\n  when running on a single processor, if the atom_modify sort option is on, which it is by default.  In this\n  case atoms are re-ordered periodically during a simulation, due to\n  spatial sorting.  It is also true when running in parallel, because\n  data for a single snapshot is collected from multiple processors, each\n  of which owns a subset of the atoms.\n  \n  For the vtk style, sorting is off by default. See the\n  dump_modify doc page for details.\n  \n  The dimensions of the simulation box are written to a separate file\n  for each snapshot (either in legacy VTK or XML format depending on the\n  format of the main dump file) with the suffix _boundingBox appended\n  to the given dump filename.\n  For an orthogonal simulation box this information is saved as a\n  rectilinear grid (legacy .vtk or .vtr XML format).\n  Triclinic simulation boxes (non-orthogonal) are saved as\n  hexahedrons in either legacy .vtk or .vtu XML format.\n  Style vtk allows you to specify a list of atom attributes to be\n  written to the dump file for each atom.  The list of possible attributes\n  is the same as for the dump_style custom command; see\n  its doc page for a listing and an explanation of each attribute.\n  \n  Note\n  Since position data is required to write VTK files the atom\n  attributes “x y z” do not have to be specified explicitly; they will\n  be included in the dump file regardless.  Also, in contrast to the\n  custom style, the specified vtk attributes are rearranged to\n  ensure correct ordering of vector components (except for computes and\n  fixes - these have to be given in the right order) and duplicate\n  entries are removed.\n  \n  The VTK format uses a single snapshot of the system per file, thus\n  a wildcard “*” must be included in the filename, as discussed below.\n  Otherwise the dump files will get overwritten with the new snapshot\n  each time.\n  \n  Dumps are performed on timesteps that are a multiple of N (including\n  timestep 0) and on the last timestep of a minimization if the\n  minimization converges.  Note that this means a dump will not be\n  performed on the initial timestep after the dump command is invoked,\n  if the current timestep is not a multiple of N.  This behavior can be\n  changed via the dump_modify first command, which\n  can also be useful if the dump command is invoked after a minimization\n  ended on an arbitrary timestep.  N can be changed between runs by\n  using the dump_modify every command.\n  The dump_modify every command\n  also allows a variable to be used to determine the sequence of\n  timesteps on which dump files are written.  In this mode a dump on the\n  first timestep of a run will also not be written unless the\n  dump_modify first command is used.\n  Dump filenames can contain two wildcard characters.  If a “*”\n  character appears in the filename, then one file per snapshot is\n  written and the “*” character is replaced with the timestep value.\n  For example, tmp.dump*.vtk becomes tmp.dump0.vtk, tmp.dump10000.vtk,\n  tmp.dump20000.vtk, etc.  Note that the dump_modify pad\n  command can be used to insure all timestep numbers are the same length\n  (e.g. 00010), which can make it easier to read a series of dump files\n  in order with some post-processing tools.\n  If a “%” character appears in the filename, then each of P processors\n  writes a portion of the dump file, and the “%” character is replaced\n  with the processor ID from 0 to P-1 preceded by an underscore character.\n  For example, tmp.dump%.vtp becomes tmp.dump_0.vtp, tmp.dump_1.vtp, …\n  tmp.dump_P-1.vtp, etc.  This creates smaller files and can be a fast\n  mode of output on parallel machines that support parallel I/O for output.\n  By default, P = the number of processors meaning one file per\n  processor, but P can be set to a smaller value via the nfile or\n  fileper keywords of the dump_modify command.\n  These options can be the most efficient way of writing out dump files\n  when running on large numbers of processors.\n  For the legacy VTK format “%” is ignored and P = 1, i.e., only\n  processor 0 does write files.\n  Note that using the “*” and “%” characters together can produce a\n  large number of small dump files!\n  If dump_modify binary is used, the dump file (or files, if “*” or\n  “%” is also used) is written in binary format.  A binary dump file\n  will be about the same size as a text version, but will typically\n  write out much faster.\n  ",
    "syntax": "dump ID group-ID vtk N file args\n  \n  \n  \n  ID = user-assigned name for the dump\n  group-ID = ID of the group of atoms to be dumped\n  vtk = style of dump command (other styles atom or cfg or dcd or xtc or xyz or local or custom are discussed on the dump doc page)\n  N = dump every this many timesteps\n  file = name of file to write dump info to\n  args = same as arguments for dump_style custom\n  \n  ",
    "examples": "dump dmpvtk all vtk 100 dump*.myforce.vtk id type vx fx\n  dump dmpvtp flow vtk 100 dump*.%.displace.vtp id type c_myD[1] c_myD[2] c_myD[3] v_ke\n  \n  \n  ",
    "restrictions": "The vtk style does not support writing of gzipped dump files.\n  The vtk dump style is part of the USER-VTK package. It is only\n  enabled if LAMMPS was built with that package. See the Build package doc page for more info.\n  To use this dump style, you also must link to the VTK library.  See\n  the info in lib/vtk/README and insure the Makefile.lammps file in that\n  directory is appropriate for your machine.\n  The vtk dump style supports neither buffering or custom format\n  strings.\n  "
},
{
    "command": "dynamical_matrix",
    "description": "Calculate the dynamical matrix by finite difference of the selected group,\n  \n  \\[D = \\frac{\\Phi_{ij}^{\\alpha\\beta}}{\\sqrt{M_i M_j}}\\]\n  where D is the dynamical matrix and \\(\\Phi\\) is the force constant\n  matrix defined by\n  \n  \\[\\Phi_{ij}^{\\alpha\\beta} = \\frac{\\partial^2 U}{\\partial x_{i,\\alpha} \\partial x_{j,\\beta}}\\]\n  The output for the dynamical matrix is printed three elements at a time.\n  The three elements are the three \\(\\beta\\) elements for a respective\n  i/\\(\\alpha\\)/j combination.  Each line is printed in order of j\n  increasing first, \\(\\alpha\\) second, and i last.\n  If the style eskm is selected, the dynamical matrix will be in units of\n  inverse squared femtoseconds. These units will then conveniently leave\n  frequencies in THz.\n  ",
    "syntax": "dynamical_matrix group-ID style gamma args keyword value ...\n  \n  \n  \n  group-ID = ID of group of atoms to displace\n  style = regular or eskm\n  gamma = finite different displacement length (distance units)\n  one or more keyword/arg pairs may be appended\n  keyword = file or binary\n    file name = name of output file for the dynamical matrix\n    binary arg = yes or no or gzip\n  \n  \n  ",
    "examples": "dynamical_matrix 1 regular 0.000001\n  dynamical_matrix 1 eskm 0.000001\n  dynamical_matrix 3 regular 0.00004 file dynmat.dat\n  dynamical_matrix 5 eskm 0.00000001 file dynamical.dat binary yes\n  \n  \n  ",
    "restrictions": "The command collects an array of nine times the number of atoms in a group\n  on every single MPI rank, so the memory requirements can be very significant\n  for large systems.\n  This command is part of the USER-PHONON package.  It is only enabled if\n  LAMMPS was built with that package.\n  See the Build package doc page for more info.\n  "
},
{
    "command": "echo",
    "description": "This command determines whether LAMMPS echoes each input script\n  command to the screen and/or log file as it is read and processed.  If\n  an input script has errors, it can be useful to look at echoed output\n  to see the last command processed.\n  The command-line switch -echo can be used in place\n  of this command.\n  ",
    "syntax": "echo style\n  \n  \n  \n  style = none or screen or log or both\n  \n  ",
    "examples": "echo both\n  echo log\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  Related commands: none\n  "
},
{
    "command": "fix",
    "description": "Set a fix that will be applied to a group of atoms.  In LAMMPS, a\n  “fix” is any operation that is applied to the system during\n  timestepping or minimization.  Examples include updating of atom\n  positions and velocities due to time integration, controlling\n  temperature, applying constraint forces to atoms, enforcing boundary\n  conditions, computing diagnostics, etc.  There are hundreds of fixes\n  defined in LAMMPS and new ones can be added; see the\n  Modify doc page for details.\n  Fixes perform their operations at different stages of the timestep.\n  If 2 or more fixes operate at the same stage of the timestep, they are\n  invoked in the order they were specified in the input script.\n  The ID of a fix can only contain alphanumeric characters and\n  underscores.\n  Fixes can be deleted with the unfix command.\n  \n  Note\n  The unfix command is the only way to turn off a\n  fix; simply specifying a new fix with a similar style will not turn\n  off the first one.  This is especially important to realize for\n  integration fixes.  For example, using a fix nve\n  command for a second run after using a fix nvt command\n  for the first run, will not cancel out the NVT time integration\n  invoked by the “fix nvt” command.  Thus two time integrators would be\n  in place!\n  \n  If you specify a new fix with the same ID and style as an existing\n  fix, the old fix is deleted and the new one is created (presumably\n  with new settings).  This is the same as if an “unfix” command were\n  first performed on the old fix, except that the new fix is kept in the\n  same order relative to the existing fixes as the old one originally\n  was.  Note that this operation also wipes out any additional changes\n  made to the old fix via the fix_modify command.\n  The fix modify command allows settings for some\n  fixes to be reset.  See the doc page for individual fixes for details.\n  Some fixes store an internal “state” which is written to binary\n  restart files via the restart or\n  write_restart commands.  This allows the fix to\n  continue on with its calculations in a restarted simulation.  See the\n  read_restart command for info on how to re-specify\n  a fix in an input script that reads a restart file.  See the doc pages\n  for individual fixes for info on which ones can be restarted.\n  \n  Some fixes calculate one of three styles of quantities: global,\n  per-atom, or local, which can be used by other commands or output as\n  described below.  A global quantity is one or more system-wide values,\n  e.g. the energy of a wall interacting with particles.  A per-atom\n  quantity is one or more values per atom, e.g. the displacement vector\n  for each atom since time 0.  Per-atom values are set to 0.0 for atoms\n  not in the specified fix group.  Local quantities are calculated by\n  each processor based on the atoms it owns, but there may be zero or\n  more per atoms.\n  Note that a single fix can produce either global or per-atom or local\n  quantities (or none at all), but not both global and per-atom.  It can\n  produce local quantities in tandem with global or per-atom quantities.\n  The fix doc page will explain.\n  Global, per-atom, and local quantities each come in three kinds: a\n  single scalar value, a vector of values, or a 2d array of values.  The\n  doc page for each fix describes the style and kind of values it\n  produces, e.g. a per-atom vector.  Some fixes produce more than one\n  kind of a single style, e.g. a global scalar and a global vector.\n  When a fix quantity is accessed, as in many of the output commands\n  discussed below, it can be referenced via the following bracket\n  notation, where ID is the ID of the fix:\n  \n  \n  \n  \n  \n  \n  f_ID       | entire scalar, vector, or array\n  \n  f_ID[I]    | one element of vector, one column of array\n  \n  f_ID[I][J] | one element of array\n  \n  \n  \n  In other words, using one bracket reduces the dimension of the\n  quantity once (vector -> scalar, array -> vector).  Using two brackets\n  reduces the dimension twice (array -> scalar).  Thus a command that\n  uses scalar fix values as input can also process elements of a vector\n  or array.\n  Note that commands and variables which use fix\n  quantities typically do not allow for all kinds, e.g. a command may\n  require a vector of values, not a scalar.  This means there is no\n  ambiguity about referring to a fix quantity as f_ID even if it\n  produces, for example, both a scalar and vector.  The doc pages for\n  various commands explain the details.\n  \n  In LAMMPS, the values generated by a fix can be used in several ways:\n  \n  Global values can be output via the thermo_style custom or fix ave/time command.\n  Or the values can be referenced in a variable equal or\n  variable atom command.\n  Per-atom values can be output via the dump custom command.\n  Or they can be time-averaged via the fix ave/atom\n  command or reduced by the compute reduce\n  command.  Or the per-atom values can be referenced in an atom-style variable.\n  Local values can be reduced by the compute reduce command, or histogrammed by the fix ave/histo command.\n  \n  See the Howto output doc page for a summary of\n  various LAMMPS output options, many of which involve fixes.\n  The results of fixes that calculate global quantities can be either\n  “intensive” or “extensive” values.  Intensive means the value is\n  independent of the number of atoms in the simulation,\n  e.g. temperature.  Extensive means the value scales with the number of\n  atoms in the simulation, e.g. total rotational kinetic energy.\n  Thermodynamic output will normalize extensive\n  values by the number of atoms in the system, depending on the\n  “thermo_modify norm” setting.  It will not normalize intensive values.\n  If a fix value is accessed in another way, e.g. by a\n  variable, you may want to know whether it is an\n  intensive or extensive value.  See the doc page for individual fixes\n  for further info.\n  \n  Each fix style has its own doc page which describes its arguments and\n  what it does, as listed below.  Here is an alphabetic list of fix\n  styles available in LAMMPS.  They are also listed in more compact form\n  on the Commands fix doc page.\n  There are also additional accelerated fix styles included in the\n  LAMMPS distribution for faster performance on CPUs, GPUs, and KNLs.\n  The individual style names on the Commands fix doc\n  page are followed by one or more of (g,i,k,o,t) to indicate which\n  accelerated styles exist.\n  \n  adapt - change a simulation parameter over time\n  adapt/fep - enhanced version of fix adapt\n  addforce - add a force to each atom\n  addtorque - add a torque to a group of atoms\n  append/atoms - append atoms to a running simulation\n  atc - initiates a coupled MD/FE simulation\n  atom/swap - Monte Carlo atom type swapping\n  ave/atom - compute per-atom time-averaged quantities\n  ave/chunk - compute per-chunk time-averaged quantities\n  ave/correlate - compute/output time correlations\n  ave/correlate/long -\n  ave/histo - compute/output time-averaged histograms\n  ave/histo/weight - weighted version of fix ave/histo\n  ave/time - compute/output global time-averaged quantities\n  aveforce - add an averaged force to each atom\n  balance - perform dynamic load-balancing\n  bocs - NPT style time integration with pressure correction\n  bond/break - break bonds on the fly\n  bond/create - create bonds on the fly\n  bond/react - apply topology changes to model reactions\n  bond/swap - Monte Carlo bond swapping\n  box/relax - relax box size during energy minimization\n  client/md - MD client for client/server simulations\n  cmap - enables CMAP cross-terms of the CHARMM force field\n  colvars - interface to the collective variables “Colvars” library\n  controller - apply control loop feedback mechanism\n  deform - change the simulation box size/shape\n  deposit - add new atoms above a surface\n  dpd/energy - constant energy dissipative particle dynamics\n  drag - drag atoms towards a defined coordinate\n  drude - part of Drude oscillator polarization model\n  drude/transform/direct -  part of Drude oscillator polarization model\n  drude/transform/inverse -  part of Drude oscillator polarization model\n  dt/reset - reset the timestep based on velocity, forces\n  edpd/source - add heat source to eDPD simulations\n  efield - impose electric field on system\n  ehex - enhanced heat exchange algorithm\n  electron/stopping - electronic stopping power as a friction force\n  enforce2d - zero out z-dimension velocity and force\n  eos/cv -\n  eos/table -\n  eos/table/rx -\n  evaporate - remove atoms from simulation periodically\n  external - callback to an external driver program\n  ffl - apply a Fast-Forward Langevin equation thermostat\n  filter/corotate - implement corotation filter to allow larger timesteps with r-RESPA\n  flow/gauss - Gaussian dynamics for constant mass flux\n  freeze - freeze atoms in a granular simulation\n  gcmc - grand canonical insertions/deletions\n  gld - generalized Langevin dynamics integrator\n  gle - generalized Langevin equation thermostat\n  gravity - add gravity to atoms in a granular simulation\n  grem - implements the generalized replica exchange method\n  halt - terminate a dynamics run or minimization\n  heat - add/subtract momentum-conserving heat\n  hyper/global - global hyperdynamics\n  hyper/local - local hyperdynamics\n  imd - implements the “Interactive MD” (IMD) protocol\n  indent - impose force due to an indenter\n  ipi - enable LAMMPS to run as a client for i-PI path-integral simulations\n  langevin - Langevin temperature control\n  langevin/drude - Langevin temperature control of Drude oscillators\n  langevin/eff - Langevin temperature control for the electron force field model\n  langevin/spin - Langevin temperature control for a spin or spin-lattice system\n  latte - wrapper on LATTE density-functional tight-binding code\n  lb/fluid -\n  lb/momentum -\n  lb/pc -\n  lb/rigid/pc/sphere -\n  lb/viscous -\n  lineforce - constrain atoms to move in a line\n  manifoldforce - restrain atoms to a manifold during minimization\n  meso - time integration for SPH/DPDE particles\n  meso/move - move mesoscopic SPH/SDPD particles in a prescribed fashion\n  meso/stationary -\n  momentum - zero the linear and/or angular momentum of a group of atoms\n  move - move atoms in a prescribed fashion\n  mscg - apply MSCG method for force-matching to generate coarse grain models\n  msst - multi-scale shock technique (MSST) integration\n  mvv/dpd - DPD using the modified velocity-Verlet integration algorithm\n  mvv/edpd - constant energy DPD using the modified velocity-Verlet algorithm\n  mvv/tdpd - constant temperature DPD using the modified velocity-Verlet algorithm\n  neb - nudged elastic band (NEB) spring forces\n  neb/spin - nudged elastic band (NEB) spring forces for spins\n  nph - constant NPH time integration via Nose/Hoover\n  nph/asphere - NPH for aspherical particles\n  nph/body - NPH for body particles\n  nph/eff - NPH for  nuclei and electrons in the electron force field model\n  nph/sphere - NPH for spherical particles\n  nphug - constant-stress Hugoniostat integration\n  npt - constant NPT time integration via Nose/Hoover\n  npt/asphere - NPT for aspherical particles\n  npt/body - NPT for body particles\n  npt/cauchy - NPT with Cauchy stress\n  npt/eff - NPT for  nuclei and electrons in the electron force field model\n  npt/sphere - NPT for spherical particles\n  npt/uef - NPT style time integration with diagonal flow\n  numdiff - compute derivatives of per-atom data from finite differences\n  nve - constant NVE time integration\n  nve/asphere - NVE for aspherical particles\n  nve/asphere/noforce - NVE for aspherical particles without forces\n  nve/awpmd - NVE for the Antisymmetrized Wave Packet Molecular Dynamics model\n  nve/body - NVE for body particles\n  nve/dot - rigid body constant energy time integrator for coarse grain models\n  nve/dotc/langevin - Langevin style rigid body time integrator for coarse grain models\n  nve/eff - NVE for  nuclei and electrons in the electron force field model\n  nve/limit - NVE with limited step length\n  nve/line - NVE for line segments\n  nve/manifold/rattle -\n  nve/noforce - NVE without forces (v only)\n  nve/sphere - NVE for spherical particles\n  nve/spin - NVE for a spin or spin-lattice system\n  nve/tri - NVE for triangles\n  nvk - constant kinetic energy time integration\n  nvt - NVT time integration via Nose/Hoover\n  nvt/asphere - NVT for aspherical particles\n  nvt/body - NVT for body particles\n  nvt/eff - NVE for  nuclei and electrons in the electron force field model\n  nvt/manifold/rattle -\n  nvt/sllod - NVT for NEMD with SLLOD equations\n  nvt/sllod/eff - NVT for NEMD with SLLOD equations for the electron force field model\n  nvt/sphere - NVT for spherical particles\n  nvt/uef - NVT style time integration with diagonal flow\n  oneway - constrain particles on move in one direction\n  orient/bcc - add grain boundary migration force for BCC\n  orient/fcc - add grain boundary migration force for FCC\n  phonon - calculate dynamical matrix from MD simulations\n  pimd - Feynman path integral molecular dynamics\n  planeforce - constrain atoms to move in a plane\n  plumed - wrapper on PLUMED free energy library\n  poems - constrain clusters of atoms to move as coupled rigid bodies\n  pour - pour new atoms/molecules into a granular simulation domain\n  precession/spin -\n  press/berendsen - pressure control by Berendsen barostat\n  print - print text and variables during a simulation\n  propel/self - model self-propelled particles\n  property/atom - add customized per-atom values\n  python/invoke - call a Python function during a simulation\n  python/move -  call a Python function during a simulation run\n  qbmsst - quantum bath multi-scale shock technique time integrator\n  qeq/comb - charge equilibration for COMB potential\n  qeq/dynamic - charge equilibration via dynamic method\n  qeq/fire - charge equilibration via FIRE minimizer\n  qeq/point - charge equilibration via point method\n  qeq/reax - charge equilibration for ReaxFF potential\n  qeq/shielded - charge equilibration via shielded method\n  qeq/slater - charge equilibration via Slater method\n  qmmm - functionality to enable a quantum mechanics/molecular mechanics coupling\n  qtb - implement quantum thermal bath scheme\n  rattle - RATTLE constraints on bonds and/or angles\n  reax/c/bonds - write out ReaxFF bond information\n  reax/c/species - write out ReaxFF molecule information\n  recenter - constrain the center-of-mass position of a group of atoms\n  restrain - constrain a bond, angle, dihedral\n  rhok - add bias potential for long-range ordered systems\n  rigid - constrain one or more clusters of atoms to move as a rigid body with NVE integration\n  rigid/meso - constrain clusters of mesoscopic SPH/SDPD particles to move as a rigid body\n  rigid/nph - constrain one or more clusters of atoms to move as a rigid body with NPH integration\n  rigid/nph/small - constrain many small clusters of atoms to move as a rigid body with NPH integration\n  rigid/npt - constrain one or more clusters of atoms to move as a rigid body with NPT integration\n  rigid/npt/small - constrain many small clusters of atoms to move as a rigid body with NPT integration\n  rigid/nve - constrain one or more clusters of atoms to move as a rigid body with alternate NVE integration\n  rigid/nve/small - constrain many small clusters of atoms to move as a rigid body with alternate NVE integration\n  rigid/nvt - constrain one or more clusters of atoms to move as a rigid body with NVT integration\n  rigid/nvt/small - constrain many small clusters of atoms to move as a rigid body with NVT integration\n  rigid/small - constrain many small clusters of atoms to move as a rigid body with NVE integration\n  rx -\n  saed/vtk -\n  setforce - set the force on each atom\n  setforce/spin - set magnetic precession vectors on each atom\n  shake - SHAKE constraints on bonds and/or angles\n  shardlow - integration of DPD equations of motion using the Shardlow splitting\n  smd - applied a steered MD force to a group\n  smd/adjust_dt -\n  smd/integrate_tlsph -\n  smd/integrate_ulsph -\n  smd/move_tri_surf -\n  smd/setvel -\n  smd/wall_surface -\n  spring - apply harmonic spring force to group of atoms\n  spring/chunk - apply harmonic spring force to each chunk of atoms\n  spring/rg - spring on radius of gyration of group of atoms\n  spring/self - spring from each atom to its origin\n  srd - stochastic rotation dynamics (SRD)\n  store/force - store force on each atom\n  store/state - store attributes for each atom\n  tdpd/source -\n  temp/berendsen - temperature control by Berendsen thermostat\n  temp/csld - canonical sampling thermostat with Langevin dynamics\n  temp/csvr - canonical sampling thermostat with Hamiltonian dynamics\n  temp/rescale - temperature control by velocity rescaling\n  temp/rescale/eff - temperature control by velocity rescaling in the electron force field model\n  tfmc - perform force-bias Monte Carlo with time-stamped method\n  thermal/conductivity - Muller-Plathe kinetic energy exchange for thermal conductivity calculation\n  ti/spring -\n  tmd - guide a group of atoms to a new configuration\n  ttm - two-temperature model for electronic/atomic coupling\n  ttm/mod - enhanced two-temperature model with additional options\n  tune/kspace - auto-tune KSpace parameters\n  vector - accumulate a global vector every N timesteps\n  viscosity - Muller-Plathe momentum exchange for viscosity calculation\n  viscous - viscous damping for granular simulations\n  wall/body/polygon -\n  wall/body/polyhedron -\n  wall/colloid - Lennard-Jones wall interacting with finite-size particles\n  wall/ees - wall for ellipsoidal particles\n  wall/gran - frictional wall(s) for granular simulations\n  wall/gran/region -\n  wall/harmonic - harmonic spring wall\n  wall/lj1043 - Lennard-Jones 10-4-3 wall\n  wall/lj126 - Lennard-Jones 12-6 wall\n  wall/lj93 - Lennard-Jones 9-3 wall\n  wall/morse - Morse potential wall\n  wall/piston - moving reflective piston wall\n  wall/reflect - reflecting wall(s)\n  wall/reflect/stochastic - reflecting wall(s) with finite temperature\n  wall/region - use region surface as wall\n  wall/region/ees - use region surface as wall for ellipsoidal particles\n  wall/srd - slip/no-slip wall for SRD particles\n  \n  ",
    "syntax": "fix ID group-ID style args\n  \n  \n  \n  ID = user-assigned name for the fix\n  group-ID = ID of the group of atoms to apply the fix to\n  style = one of a long list of possible style names (see below)\n  args = arguments used by a particular style\n  \n  ",
    "examples": "fix 1 all nve\n  fix 3 all nvt temp 300.0 300.0 0.01\n  fix mine top setforce 0.0 NULL 0.0\n  \n  \n  ",
    "restrictions": "Some fix styles are part of specific packages.  They are only enabled\n  if LAMMPS was built with that package.  See the Build package doc page for more info.  The doc pages for\n  individual fixes tell if it is part of a package.\n  "
},
{
    "command": "fix_modify",
    "description": "Modify one or more parameters of a previously defined fix.  Only\n  specific fix styles support specific parameters.  See the doc pages\n  for individual fix commands for info on which ones support which\n  fix_modify parameters.\n  The temp keyword is used to determine how a fix computes\n  temperature.  The specified compute ID must have been previously\n  defined by the user via the compute command and it must\n  be a style of compute that calculates a temperature.  All fixes that\n  compute temperatures define their own compute by default, as described\n  in their documentation.  Thus this option allows the user to override\n  the default method for computing T.\n  The press keyword is used to determine how a fix computes pressure.\n  The specified compute ID must have been previously defined by the user\n  via the compute command and it must be a style of\n  compute that calculates a pressure.  All fixes that compute pressures\n  define their own compute by default, as described in their\n  documentation.  Thus this option allows the user to override the\n  default method for computing P.\n  The energy keyword can be used with fixes that support it.\n  energy yes adds a contribution to the potential energy of the\n  system. The fix’s global and per-atom\n  energy is included in the calculation performed by the compute pe or compute pe/atom\n  commands.  See the thermo_style command for info\n  on how potential energy is output.  For fixes that tally a global\n  energy, it can be printed by using the keyword f_ID in the\n  thermo_style custom command, where ID is the fix-ID of the appropriate\n  fix.\n  \n  Note\n  You must also specify the energy yes setting for a fix if you\n  are using it when performing an energy minimization\n  and if you want the energy and forces it produces to be part of the\n  optimization criteria.\n  \n  The virial keyword can be used with fixes that support it.\n  virial yes adds a contribution to the virial of the\n  system. The fix’s global and per-atom\n  virial is included in the calculation performed by the compute pressure or\n  compute stress/atom\n  commands.  See the thermo_style command for info\n  on how pressure is output.\n  \n  Note\n  You must specify the virial yes setting for a fix if you\n  are doing box relaxation and\n  if you want virial contribution of the fix to be part of the\n  relaxation criteria, although this seems unlikely.\n  \n  \n  Note\n  This option is only supported by fixes that explicitly say\n  so. For some of these (e.g. the fix shake command)\n  the default setting is virial yes, for others it is virial no.\n  \n  For fixes that set or modify forces, it may be possible to select at\n  which r-RESPA level the fix operates via the respa\n  keyword. The RESPA level at which the fix is active can be selected.\n  This is a number ranging from 1 to the number of levels. If the RESPA\n  level is larger than the current maximum, the outermost level will be\n  used, which is also the default setting. This default can be restored\n  using a value of 0 for the RESPA level. The affected fix has to be\n  enabled to support this feature; if not, fix_modify will report an\n  error. Active fixes with a custom RESPA level setting are reported\n  with their specified level at the beginning of a r-RESPA run.\n  The dynamic/dof keyword determines whether the number of atoms N in\n  the fix group and their associated degrees of freedom are re-computed\n  each time a temperature is computed.  Only fix styles that calculate\n  their own internal temperature use this option.  Currently this is\n  only the fix rigid/nvt/small and fix rigid/npt/small commands for the purpose of\n  thermostatting rigid body translation and rotation.  By default, N and\n  their DOF are assumed to be constant.  If you are adding atoms or\n  molecules to the system (see the fix pour, fix deposit, and fix gcmc commands) or\n  expect atoms or molecules to be lost (e.g. due to exiting the\n  simulation box or via fix evaporate), then\n  this option should be used to insure the temperature is correctly\n  normalized.\n  \n  Note\n  Other thermostatting fixes, such as fix nvt, do\n  not use the dynamic/dof keyword because they use a temperature\n  compute to calculate temperature.  See the compute_modify dynamic/dof command for a similar way to insure\n  correct temperature normalization for those thermostats.\n  \n  The bodyforces keyword determines whether the forces and torques\n  acting on rigid bodies are computed early at the post-force stage of\n  each timestep (right after per-atom forces have been computed and\n  communicated among processors), or late at the final-integrate stage\n  of each timestep (after any other fixes have finished their post-force\n  tasks).  Only the rigid-body integration fixes use this option, which\n  includes fix rigid and fix rigid/small, and their variants, and also fix poems.\n  The default is late.  If there are other fixes that add forces to\n  individual atoms, then the rigid-body constraints will include these\n  forces when time-integrating the rigid bodies.  If early is\n  specified, then new fixes can be written that use or modify the\n  per-body force and torque, before time-integration of the rigid bodies\n  occurs.  Note however this has the side effect, that fixes such as\n  fix addforce, fix setforce,\n  fix spring, which add forces to individual atoms\n  will have no effect on the motion of the rigid bodies if they are\n  specified in the input script after the fix rigid command.  LAMMPS\n  will give a warning if that is the case.\n  ",
    "syntax": "fix_modify fix-ID keyword value ...\n  \n  \n  \n  fix-ID = ID of the fix to modify\n  one or more keyword/value pairs may be appended\n  keyword = temp or press or energy or virial or respa or dynamic/dof or bodyforces\n  temp value = compute ID that calculates a temperature\n  press value = compute ID that calculates a pressure\n  energy value = yes or no\n  virial value = yes or no\n  respa value = 1 to max respa level or 0 (for outermost level)\n  dynamic/dof value = yes or no\n    yes/no = do or do not re-compute the number of degrees of freedom (DOF) contributing to the temperature\n  bodyforces value = early or late\n    early/late = compute rigid-body forces/torques early or late in the timestep\n  \n  \n  ",
    "examples": "fix_modify 3 temp myTemp press myPress\n  fix_modify 1 energy yes\n  fix_modify tether respa 2\n  \n  \n  ",
    "restrictions": "none\n  "
},
{
    "command": "group",
    "description": "Identify a collection of atoms as belonging to a group.  The group ID\n  can then be used in other commands such as fix,\n  compute, dump, or velocity\n  to act on those atoms together.\n  If the group ID already exists, the group command adds the specified\n  atoms to the group.\n  \n  Note\n  By default groups are static, meaning the atoms are permanently\n  assigned to the group.  For example, if the region style is used to\n  assign atoms to a group, the atoms will remain in the group even if\n  they later move out of the region.  As explained below, the dynamic\n  style can be used to make a group dynamic so that a periodic\n  determination is made as to which atoms are in the group.  Since many\n  LAMMPS commands operate on groups of atoms, you should think carefully\n  about whether making a group dynamic makes sense for your model.\n  \n  A group with the ID all is predefined.  All atoms belong to this\n  group.  This group cannot be deleted, or made dynamic.\n  The delete style removes the named group and un-assigns all atoms\n  that were assigned to that group.  Since there is a restriction (see\n  below) that no more than 32 groups can be defined at any time, the\n  delete style allows you to remove groups that are no longer needed,\n  so that more can be specified.  You cannot delete a group if it has\n  been used to define a current fix or compute\n  or dump.\n  The clear style un-assigns all atoms that were assigned to that\n  group.  This may be dangerous to do during a simulation run,\n  e.g. using the run every command if a fix or compute or\n  other operation expects the atoms in the group to remain constant, but\n  LAMMPS does not check for this.\n  The empty style creates an empty group, which is useful for commands\n  like fix gcmc or with complex scripts that add atoms\n  to a group.\n  The region style puts all atoms in the region volume into the group.\n  Note that this is a static one-time assignment.  The atoms remain\n  assigned (or not assigned) to the group even in they later move out of\n  the region volume.\n  The type, id, and molecule styles put all atoms with the\n  specified atom types, atom IDs, or molecule IDs into the group.  These\n  3 styles can use arguments specified in one of two formats.\n  The first format is a list of values (types or IDs).  For example, the\n  2nd command in the examples above puts all atoms of type 3 or 4 into\n  the group named water.  Each entry in the list can be a\n  colon-separated sequence A:B or A:B:C, as in two of the examples\n  above.  A “sequence” generates a sequence of values (types or IDs),\n  with an optional increment.  The first example with 500:1000 has the\n  default increment of 1 and would add all atom IDs from 500 to 1000\n  (inclusive) to the group sub, along with 10,25,50 since they also\n  appear in the list of values.  The second example with 100:10000:10\n  uses an increment of 10 and would thus would add atoms IDs\n  100,110,120, … 9990,10000 to the group sub.\n  The second format is a logical followed by one or two values (type\n  or ID).  The 7 valid logicals are listed above.  All the logicals\n  except <> take a single argument.  The 3rd example above adds all\n  atoms with IDs from 1 to 150 to the group named sub.  The logical <>\n  means “between” and takes 2 arguments.  The 4th example above adds all\n  atoms belonging to molecules with IDs from 50 to 250 (inclusive) to\n  the group named polyA.\n  The variable style evaluates a variable to determine which atoms to\n  add to the group.  It must be an atom-style variable\n  previously defined in the input script.  If the variable evaluates\n  to a non-zero value for a particular atom, then that atom is added\n  to the specified group.\n  Atom-style variables can specify formulas that include thermodynamic\n  quantities, per-atom values such as atom coordinates, or per-atom\n  quantities calculated by computes, fixes, or other variables.  They\n  can also include Boolean logic where 2 numeric values are compared to\n  yield a 1 or 0 (effectively a true or false).  Thus using the\n  variable style, is a general way to flag specific atoms to include\n  or exclude from a group.\n  For example, these lines define a variable “eatom” that calculates the\n  potential energy of each atom and includes it in the group if its\n  potential energy is above the threshold value -3.0.\n  compute         1 all pe/atom\n  compute         2 all reduce sum c_1\n  thermo_style    custom step temp pe c_2\n  run             0\n  \n  variable        eatom atom \"c_1 > -3.0\"\n  group           hienergy variable eatom\n  \n  \n  Note that these lines\n  compute         2 all reduce sum c_1\n  thermo_style    custom step temp pe c_2\n  run             0\n  \n  \n  are necessary to insure that the “eatom” variable is current when the\n  group command invokes it.  Because the eatom variable computes the\n  per-atom energy via the pe/atom compute, it will only be current if a\n  run has been performed which evaluated pairwise energies, and the\n  pe/atom compute was actually invoked during the run.  Printing the\n  thermodynamic info for compute 2 insures that this is the case, since\n  it sums the pe/atom compute values (in the reduce compute) to output\n  them to the screen.  See the “Variable Accuracy” section of the\n  variable doc page for more details on insuring that\n  variables are current when they are evaluated between runs.\n  The include style with its arg molecule adds atoms to a group that\n  have the same molecule ID as atoms already in the group.  The molecule\n  ID = 0 is ignored in this operation, since it is assumed to flag\n  isolated atoms that are not part of molecules.  An example of where\n  this operation is useful is if the region style has been used\n  previously to add atoms to a group that are within a geometric region.\n  If molecules straddle the region boundary, then atoms outside the\n  region that are part of molecules with atoms inside the region will\n  not be in the group.  Using the group command a 2nd time with include\n  molecule will add those atoms that are outside the region to the\n  group.\n  \n  Note\n  The include molecule operation is relatively expensive in a\n  parallel sense.  This is because it requires communication of relevant\n  molecule IDs between all the processors and each processor to loop\n  over its atoms once per processor, to compare its atoms to the list of\n  molecule IDs from every other processor.  Hence it scales as N, rather\n  than N/P as most of the group operations do, where N is the number of\n  atoms, and P is the number of processors.\n  \n  The subtract style takes a list of two or more existing group names\n  as arguments.  All atoms that belong to the 1st group, but not to any\n  of the other groups are added to the specified group.\n  The union style takes a list of one or more existing group names as\n  arguments.  All atoms that belong to any of the listed groups are\n  added to the specified group.\n  The intersect style takes a list of two or more existing group names\n  as arguments.  Atoms that belong to every one of the listed groups are\n  added to the specified group.\n  \n  The dynamic style flags an existing or new group as dynamic.  This\n  means atoms will be (re)assigned to the group periodically as a\n  simulation runs.  This is in contrast to static groups where atoms are\n  permanently assigned to the group.  The way the assignment occurs is\n  as follows.  Only atoms in the group specified as the parent group via\n  the parent-ID are assigned to the dynamic group before the following\n  conditions are applied.  If the region keyword is used, atoms not in\n  the specified region are removed from the dynamic group.  If the var\n  keyword is used, the variable name must be an atom-style or\n  atomfile-style variable.  The variable is evaluated and atoms whose\n  per-atom values are 0.0, are removed from the dynamic group. If the property\n  keyword is used, the per-atom property name must be a previously defined\n  per-atom property.  The per-atom property is evaluated and atoms whose\n  values are 0.0 are removed from the dynamic group.\n  The assignment of atoms to a dynamic group is done at the beginning of\n  each run and on every timestep that is a multiple of N, which is the\n  argument for the every keyword (N = 1 is the default).  For an\n  energy minimization, via the minimize command, an\n  assignment is made at the beginning of the minimization, but not\n  during the iterations of the minimizer.\n  The point in the timestep at which atoms are assigned to a dynamic\n  group is after the initial stage of velocity Verlet time integration\n  has been performed, and before neighbor lists or forces are computed.\n  This is the point in the timestep where atom positions have just\n  changed due to the time integration, so the region criterion should be\n  accurate, if applied.\n  \n  Note\n  If the region keyword is used to determine what atoms are in\n  the dynamic group, atoms can move outside of the simulation box\n  between reneighboring events.  Thus if you want to include all atoms\n  on the left side of the simulation box, you probably want to set the\n  left boundary of the region to be outside the simulation box by some\n  reasonable amount (e.g. up to the cutoff of the potential), else they\n  may be excluded from the dynamic region.\n  \n  Here is an example of using a dynamic group to shrink the set of atoms\n  being integrated by using a spherical region with a variable radius\n  (shrinking from 18 to 5 over the course of the run).  This could be\n  used to model a quench of the system, freezing atoms outside the\n  shrinking sphere, then converting the remaining atoms to a static\n  group and running further.\n  variable        nsteps equal 5000\n  variable        rad equal 18-(step/v_nsteps)\\*(18-5)\n  region          ss sphere 20 20 0 v_rad\n  group           mobile dynamic all region ss\n  fix             1 mobile nve\n  run             ${nsteps}\n  group           mobile static\n  run             ${nsteps}\n  \n  \n  \n  Note\n  All fixes and computes take a group ID as an argument, but they\n  do not all allow for use of a dynamic group.  If you get an error\n  message that this is not allowed, but feel that it should be for the\n  fix or compute in question, then please post your reasoning to the\n  LAMMPS mail list and we can change it.\n  \n  The static style removes the setting for a dynamic group, converting\n  it to a static group (the default).  The atoms in the static group are\n  those currently in the dynamic group.\n  ",
    "syntax": "group ID style args\n  \n  \n  \n  ID = user-defined name of the group\n  style = delete or clear or empty or region or         type or id or molecule or variable or         include or subtract or union or intersect or         dynamic or static\n  delete = no args\n  clear = no args\n  empty = no args\n  region args = region-ID\n  type or id or molecule\n    args = list of one or more atom types, atom IDs, or molecule IDs\n      any entry in list can be a sequence formatted as A:B or A:B:C where\n      A = starting index, B = ending index,\n      C = increment between indices, 1 if not specified\n    args = logical value\n      logical = \"<\" or \"<=\" or \">\" or \">=\" or \"==\" or \"!=\"\n      value = an atom type or atom ID or molecule ID (depending on style)\n    args = logical value1 value2\n      logical = \"<>\"\n      value1,value2 = atom types or atom IDs or molecule IDs (depending on style)\n  variable args = variable-name\n  include args = molecule\n    molecule = add atoms to group with same molecule ID as atoms already in group\n  subtract args = two or more group IDs\n  union args = one or more group IDs\n  intersect args = two or more group IDs\n  dynamic args = parent-ID keyword value ...\n    one or more keyword/value pairs may be appended\n    keyword = region or var or every\n      region value = region-ID\n      var value = name of variable\n      property value = name of per-atom property\n      every value = N = update group every this many timesteps\n  static = no args\n  \n  \n  ",
    "examples": "group edge region regstrip\n  group water type 3 4\n  group sub id 10 25 50\n  group sub id 10 25 50 500:1000\n  group sub id 100:10000:10\n  group sub id <= 150\n  group polyA molecule <> 50 250\n  group hienergy variable eng\n  group hienergy include molecule\n  group boundary subtract all a2 a3\n  group boundary union lower upper\n  group boundary intersect upper flow\n  group boundary delete\n  group mine dynamic all region myRegion every 100\n  \n  \n  ",
    "restrictions": "There can be no more than 32 groups defined at one time, including\n  “all”.\n  The parent group of a dynamic group cannot itself be a dynamic group.\n  "
},
{
    "command": "group2ndx",
    "description": "Write or read a Gromacs style index file in text format that associates\n  atom IDs with the corresponding group definitions. This index file can be\n  used with in combination with Gromacs analysis tools or to import group\n  definitions into the fix colvars input file. It can\n  also be used to save and restore group definitions for static groups.\n  The group2ndx command will write group definitions to an index file.\n  Without specifying any group IDs, all groups will be written to the index\n  file. When specifying group IDs, only those groups will be written to the\n  index file. In order to follow the Gromacs conventions, the group all\n  will be renamed to System in the index file.\n  The ndx2group command will create of update group definitions from those\n  stored in an index file. Without specifying any group IDs, all groups except\n  System will be read from the index file and the corresponding groups\n  recreated. If a group of the same name already exists, it will be completely\n  reset. When specifying group IDs, those groups, if present, will be read\n  from the index file and restored.\n  ",
    "syntax": "group2ndx file group-ID ...\n  ndx2group file group-ID ...\n  \n  \n  \n  file = name of index file to write out or read in\n  zero or more group IDs may be appended\n  \n  ",
    "examples": "group2ndx allindex.ndx\n  group2ndx someindex.ndx upper lower mobile\n  ndx2group someindex.ndx\n  ndx2group someindex.ndx mobile\n  \n  \n  ",
    "restrictions": "This command requires that atoms have atom IDs, since this is the\n  information that is written to the index file.\n  These commands are part of the USER-COLVARS package.  They are only\n  enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "hyper",
    "description": "Run a bond-boost hyperdynamics (HD) simulation where time is\n  accelerated by application of a bias potential to one or more pairs of\n  nearby atoms in the system.  This command can be used to run both\n  global and local hyperdynamics.  In global HD a single bond within the\n  system is biased on each timestep.  In local HD multiple bonds\n  (separated by a sufficient distance) can be biased simultaneously at\n  each timestep.  In the bond-boost hyperdynamics context, a “bond” is\n  not a covalent bond between a pair of atoms in a molecule.  Rather it\n  is simply a pair of nearby atoms as discussed below.\n  Both global and local HD are described in (Voter2013) by\n  Art Voter and collaborators.  Similar to parallel replica dynamics\n  (PRD), global and local HD are methods for performing accelerated\n  dynamics that are suitable for infrequent-event systems that obey\n  first-order kinetics.  A good overview of accelerated dynamics methods\n  for such systems in given in (Voter2002) from the same\n  group.  To quote from the review paper: “The dynamical evolution is\n  characterized by vibrational excursions within a potential basin,\n  punctuated by occasional transitions between basins.”  The transition\n  probability is characterized by p(t) = k*exp(-kt) where k is the rate\n  constant.  Running multiple replicas gives an effective enhancement in\n  the timescale spanned by the multiple simulations, while waiting for\n  an event to occur.\n  Both HD and PRD produce a time-accurate trajectory that effectively\n  extends the timescale over which a system can be simulated, but they\n  do it differently.  HD uses a single replica of the system and\n  accelerates time by biasing the interaction potential in a manner such\n  that each timestep is effectively longer.  PRD creates Nr replicas of\n  the system and runs dynamics on each independently with a normal\n  unbiased potential until an event occurs in one of the replicas.  The\n  time between events is reduced by a factor of Nr replicas.  For both\n  methods, per CPU second, more physical time elapses and more events\n  occur.  See the prd doc page for more info about PRD.\n  An HD run has several stages, which are repeated each time an event\n  occurs, as explained below.  The logic for an HD run is as follows:\n  quench\n  create initial list of bonds\n  \n  while (time remains):\n    run dynamics for Nevent steps\n    quench\n    check for an event\n    if event occurred: reset list of bonds\n    restore pre-quench state\n  \n  \n  The list of bonds is the list of atom pairs of atoms that are within a\n  short cutoff distance of each other after the system energy is\n  minimized (quenched).  This list is created and reset by a fix hyper/global or fix hyper/local command specified as fix-ID.  At\n  every dynamics timestep, the same fix selects one of more bonds to\n  apply a bias potential to.\n  \n  Note\n  The style of fix associated with the specified fix-ID\n  determines whether you are running the global versus local\n  hyperdynamics algorithm.\n  \n  Dynamics (with the bias potential) is run continuously, stopping every\n  Nevent steps to check if a transition event has occurred.  The\n  specified N for total steps must be a multiple of Nevent.  check\n  is performed by quenching the system and comparing the resulting atom\n  coordinates to the coordinates from the previous basin.\n  A quench is an energy minimization and is performed by whichever\n  algorithm has been defined by the min_style command.\n  Minimization parameters may be set via the\n  min_modify command and by the min keyword of the\n  hyper command.  The latter are the settings that would be used with\n  the minimize command.  Note that typically, you do not\n  need to perform a highly-converged minimization to detect a transition\n  event, though you may need to in order to prevent a set of atoms in\n  the system from relaxing to a saddle point.\n  The event check is performed by a compute with the specified\n  compute-ID.  Currently there is only one compute that works with the\n  hyper command, which is the compute event/displace command.  Other\n  event-checking computes may be added.  Compute event/displace checks whether any atom in\n  the compute group has moved further than a specified threshold\n  distance.  If so, an event has occurred.\n  If this happens, the list of bonds is reset, since some bond pairs\n  are likely now too far apart, and new pairs are likely close enough\n  to be considered a bond.  The pre-quenched state of the\n  system (coordinates and velocities) is restored, and dynamics continue.\n  At the end of the hyper run, a variety of statistics are output to the\n  screen and logfile.  These include info relevant to both global and\n  local hyperdynamics, such as the number of events and the elapsed\n  hyper time (accelerated time), And it includes info specific to one or\n  the other, depending on which style of fix was specified by fix-ID.\n  \n  The optional keywords operate as follows.\n  As explained above, the min keyword can be used to specify\n  parameters for the quench.  Their meaning is the same\n  as for the minimize command\n  The dump keyword can be used to trigger a specific dump command with\n  the specified dump-ID to output a snapshot each time an event is\n  detected.  It can be specified multiple times with different dump-ID\n  values, as in the example above.  These snapshots will be for the\n  quenched state of the system on a timestep that is a multiple of\n  Nevent, i.e. a timestep after the event has occurred.  Note that any\n  dump command in the input script will also output snapshots at\n  whatever timestep interval it defines via its N argument; see the\n  dump command for details.  This means if you only want a\n  particular dump to output snapshots when events are detected, you\n  should specify its N as a value larger than the length of the\n  hyperdynamics run.\n  As in the code logic above, the bond list is normally only reset when\n  an event occurs.  The rebond keyword will force a reset of the bond\n  list every Nrebond steps, even if an event has not occurred.\n  Nrebond must be a multiple of Nevent.  This can be useful to check\n  if more frequent resets alter event statistics, perhaps because the\n  parameters chosen for defining what is a bond and what is an event are\n  producing bad dynamics in the presence of the bias potential.\n  ",
    "syntax": "hyper N Nevent fix-ID compute-ID keyword values ...\n  \n  \n  \n  N = # of timesteps to run\n  Nevent = check for events every this many steps\n  fix-ID = ID of a fix that applies a global or local bias potential, can be NULL\n  compute-ID = ID of a compute that identifies when an event has occurred\n  zero or more keyword/value pairs may be appended\n  keyword = min or dump or rebond\n  min values = etol ftol maxiter maxeval\n    etol = stopping tolerance for energy, used in quenching\n    ftol = stopping tolerance for force, used in quenching\n    maxiter = max iterations of minimize, used in quenching\n    maxeval = max number of force/energy evaluations, used in quenching\n  dump value = dump-ID\n    dump-ID = ID of dump to trigger whenever an event takes place\n  rebond value = Nrebond\n    Nrebond = frequency at which to reset bonds, even if no event has occurred\n  \n  \n  ",
    "examples": "compute event all event/displace 1.0\n  fix HG mobile hyper/global 3.0 0.3 0.4 800.0\n  hyper 5000 100 HG event min 1.0e-6 1.0e-6 100 100 dump 1 dump 5\n  \n  \n  ",
    "restrictions": "This command can only be used if LAMMPS was built with the REPLICA\n  package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "if",
    "description": "This command provides an if-then-else capability within an input\n  script.  A Boolean expression is evaluated and the result is TRUE or\n  FALSE.  Note that as in the examples above, the expression can contain\n  variables, as defined by the variable command, which\n  will be evaluated as part of the expression.  Thus a user-defined\n  formula that reflects the current state of the simulation can be used\n  to issue one or more new commands.\n  If the result of the Boolean expression is TRUE, then one or more\n  commands (t1, t2, …, tN) are executed.  If it is FALSE, then Boolean\n  expressions associated with successive elif keywords are evaluated\n  until one is found to be true, in which case its commands (f1, f2,\n  …, fN) are executed.  If no Boolean expression is TRUE, then the\n  commands associated with the else keyword, namely (e1, e2, …, eN),\n  are executed.  The elif and else keywords and their associated\n  commands are optional.  If they are not specified and the initial\n  Boolean expression is FALSE, then no commands are executed.\n  The syntax for Boolean expressions is described below.\n  Each command (t1, f1, e1, etc) can be any valid LAMMPS input script\n  command.  If the command is more than one word, it must enclosed in\n  quotes, so it will be treated as a single argument, as in the examples\n  above.\n  \n  Note\n  If a command itself requires a quoted argument (e.g. a\n  print command), then double and single quotes can be used\n  and nested in the usual manner, as in the examples above and below.\n  The Commands parse doc page has more details on\n  using quotes in arguments.  Only one of level of nesting is allowed,\n  but that should be sufficient for most use cases.\n  \n  Note that by using the line continuation character “&”, the if command\n  can be spread across many lines, though it is still a single command:\n  if \"$a < $b\" then &\n    \"print 'Minimum value = $a'\" &\n    \"run 1000\" &\n  else &\n    'print \"Minimum value = $b\"' &\n    \"minimize 0.001 0.001 1000 10000\"\n  \n  \n  Note that if one of the commands to execute is quit, as in\n  the first example above, then executing the command will cause LAMMPS\n  to halt.\n  Note that by jumping to a label in the same input script, the if\n  command can be used to break out of a loop.  See the variable delete command for info on how to delete the associated\n  loop variable, so that it can be re-used later in the input script.\n  Here is an example of a loop which checks every 1000 steps if the\n  system temperature has reached a certain value, and if so, breaks out\n  of the loop to finish the run.  Note that any variable could be\n  checked, so long as it is current on the timestep when the run\n  completes.  As explained on the variable doc page,\n  this can be insured by including the variable in thermodynamic output.\n  variable myTemp equal temp\n  label loop\n  variable a loop 1000\n  run 1000\n  if \"${myTemp} < 300.0\" then \"jump SELF break\"\n  next a\n  jump SELF loop\n  label break\n  print \"ALL DONE\"\n  \n  \n  Here is an example of a double loop which uses the if and\n  jump commands to break out of the inner loop when a\n  condition is met, then continues iterating through the outer loop.\n  label       loopa\n  variable    a loop 5\n    label     loopb\n    variable  b loop 5\n      print     \"A,B = $a,$b\"\n      run       10000\n      if        \"$b > 2\" then \"jump SELF break\"\n    next      b\n    jump      in.script loopb\n    label       break\n    variable    b delete\n  next        a\n  jump        SELF loopa\n  \n  \n  \n  The Boolean expressions for the if and elif keywords have a C-like\n  syntax.  Note that each expression is a single argument within the if\n  command.  Thus if you want to include spaces in the expression for\n  clarity, you must enclose the entire expression in quotes.\n  An expression is built out of numbers (which start with a digit or\n  period or minus sign) or strings (which start with a letter and can\n  contain alphanumeric characters or underscores):\n  0.2, 100, 1.0e20, -15.4, etc\n  InP, myString, a123, ab_23_cd, etc\n  \n  \n  and Boolean operators:\n  A == B, A != B, A < B, A <= B, A > B, A >= B, A && B, A || B, A |^ B, !A\n  Each A and B is a number or string or a variable reference like $a or\n  ${abc}, or A or B can be another Boolean expression.\n  If a variable is used it can produce a number when evaluated, like an\n  equal-style variable.  Or it can produce a string,\n  like an index-style variable.  For an individual\n  Boolean operator, A and B must both be numbers or must both be\n  strings.  You cannot compare a number to a string.\n  Expressions are evaluated left to right and have the usual C-style\n  precedence: the unary logical NOT operator “!” has the highest\n  precedence, the 4 relational operators “<”, “<=”, “>”, and “>=” are\n  next; the two remaining relational operators “==” and “!=” are next;\n  then the logical AND operator “&&”; and finally the logical OR\n  operator “||” and logical XOR (exclusive or) operator “|^” have the\n  lowest precedence.  Parenthesis can be used to group one or more\n  portions of an expression and/or enforce a different order of\n  evaluation than what would occur with the default precedence.\n  When the 6 relational operators (first 6 in list above) compare 2\n  numbers, they return either a 1.0 or 0.0 depending on whether the\n  relationship between A and B is TRUE or FALSE.  When the 6 relational\n  operators compare 2 strings, they also return a 1.0 or 0.0 for TRUE or\n  FALSE, but the comparison is done by the C function strcmp().\n  When the 3 logical operators (last 3 in list above) compare 2 numbers,\n  they also return either a 1.0 or 0.0 depending on whether the\n  relationship between A and B is TRUE or FALSE (or just A).  The\n  logical AND operator will return 1.0 if both its arguments are\n  non-zero, else it returns 0.0.  The logical OR operator will return\n  1.0 if either of its arguments is non-zero, else it returns 0.0.  The\n  logical XOR operator will return 1.0 if one of its arguments is zero\n  and the other non-zero, else it returns 0.0.  The logical NOT operator\n  returns 1.0 if its argument is 0.0, else it returns 0.0.  The 3\n  logical operators can only be used to operate on numbers, not on\n  strings.\n  The overall Boolean expression produces a TRUE result if the result is\n  non-zero.  If the result is zero, the expression result is FALSE.\n  ",
    "syntax": "if boolean then t1 t2 ... elif boolean f1 f2 ... elif boolean f1 f2 ... else e1 e2 ...\n  \n  \n  \n  boolean = a Boolean expression evaluated as TRUE or FALSE (see below)\n  then = required word\n  t1,t2,…,tN = one or more LAMMPS commands to execute if condition is met, each enclosed in quotes\n  elif = optional word, can appear multiple times\n  f1,f2,…,fN = one or more LAMMPS commands to execute if elif condition is met, each enclosed in quotes (optional arguments)\n  else = optional argument\n  e1,e2,…,eN = one or more LAMMPS commands to execute if no condition is met, each enclosed in quotes (optional arguments)\n  \n  ",
    "examples": "if \"${steps} > 1000\" then quit\n  if \"${myString} == a10\" then quit\n  if \"$x <= $y\" then \"print X is smaller = $x\" else \"print Y is smaller = $y\"\n  if \"(${eng} > 0.0) \\|\\| ($n < 1000)\" then &\n    \"timestep 0.005\" &\n  elif $n<10000 &\n    \"timestep 0.01\" &\n  else &\n    \"timestep 0.02\" &\n    \"print 'Max step reached'\"\n  if \"${eng} > ${eng_previous}\" then \"jump file1\" else \"jump file2\"\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "improper_coeff",
    "description": "Specify the improper force field coefficients for one or more improper\n  types.  The number and meaning of the coefficients depends on the\n  improper style.  Improper coefficients can also be set in the data\n  file read by the read_data command or in a restart\n  file.\n  N can be specified in one of two ways.  An explicit numeric value can\n  be used, as in the 1st example above.  Or a wild-card asterisk can be\n  used to set the coefficients for multiple improper types.  This takes\n  the form “*” or “*n” or “n*” or “m*n”.  If N = the number of improper\n  types, then an asterisk with no numeric values means all types from 1\n  to N.  A leading asterisk means all types from 1 to n (inclusive).  A\n  trailing asterisk means all types from n to N (inclusive).  A middle\n  asterisk means all types from m to n (inclusive).\n  Note that using an improper_coeff command can override a previous\n  setting for the same improper type.  For example, these commands set\n  the coeffs for all improper types, then overwrite the coeffs for just\n  improper type 2:\n  improper_coeff * 300.0 0.0\n  improper_coeff 2 50.0 0.0\n  \n  \n  A line in a data file that specifies improper coefficients uses the\n  exact same format as the arguments of the improper_coeff command in an\n  input script, except that wild-card asterisks should not be used since\n  coefficients for all N types must be listed in the file.  For example,\n  under the “Improper Coeffs” section of a data file, the line that\n  corresponds to the 1st example above would be listed as\n  1 300.0 0.0\n  \n  \n  The improper_style class2 is an exception to\n  this rule, in that an additional argument is used in the input script\n  to allow specification of the cross-term coefficients.  See its doc\n  page for details.\n  \n  The list of all improper styles defined in LAMMPS is given on the\n  improper_style doc page.  They are also listed\n  in more compact form on the Commands improper doc page.\n  On either of those pages, click on the style to display the formula it\n  computes and its coefficients as specified by the associated\n  improper_coeff command.\n  ",
    "syntax": "improper_coeff N args\n  \n  \n  \n  N = improper type (see asterisk form below)\n  args = coefficients for one or more improper types\n  \n  ",
    "examples": "improper_coeff 1 300.0 0.0\n  improper_coeff * 80.2 -1 2\n  improper_coeff *4 80.2 -1 2\n  \n  \n  ",
    "restrictions": "This command must come after the simulation box is defined by a\n  read_data, read_restart, or\n  create_box command.\n  An improper style must be defined before any improper coefficients are\n  set, either in the input script or in a data file.\n  "
},
{
    "command": "improper_style",
    "description": "Set the formula(s) LAMMPS uses to compute improper interactions\n  between quadruplets of atoms, which remain in force for the duration\n  of the simulation.  The list of improper quadruplets is read in by a\n  read_data or read_restart command\n  from a data or restart file.  Note that the ordering of the 4 atoms in\n  an improper quadruplet determines the definition of the improper\n  angle used in the formula for each style.  See the doc pages of\n  individual styles for details.\n  Hybrid models where impropers are computed using different improper\n  potentials can be setup using the hybrid improper style.\n  The coefficients associated with an improper style can be specified in\n  a data or restart file or via the improper_coeff\n  command.\n  All improper potentials store their coefficient data in binary restart\n  files which means improper_style and\n  improper_coeff commands do not need to be\n  re-specified in an input script that restarts a simulation.  See the\n  read_restart command for details on how to do\n  this.  The one exception is that improper_style hybrid only stores\n  the list of sub-styles in the restart file; improper coefficients need\n  to be re-specified.\n  \n  Note\n  When both an improper and pair style is defined, the\n  special_bonds command often needs to be used to\n  turn off (or weight) the pairwise interaction that would otherwise\n  exist between a group of 4 bonded atoms.\n  \n  \n  Here is an alphabetic list of improper styles defined in LAMMPS.\n  Click on the style to display the formula it computes and coefficients\n  specified by the associated improper_coeff\n  command.\n  Click on the style to display the formula it computes, any additional\n  arguments specified in the improper_style command, and coefficients\n  specified by the associated improper_coeff\n  command.\n  There are also additional accelerated pair styles included in the\n  LAMMPS distribution for faster performance on CPUs, GPUs, and KNLs.\n  The individual style names on the Commands improper doc page are followed by one or\n  more of (g,i,k,o,t) to indicate which accelerated styles exist.\n  \n  none - turn off improper interactions\n  zero - topology but no interactions\n  hybrid - define multiple styles of improper interactions\n  class2 - COMPASS (class 2) improper\n  cossq - improper with a cosine squared term\n  cvff - CVFF improper\n  distance - improper based on distance between atom planes\n  distharm - improper that is harmonic in the out-of-plane distance\n  fourier - improper with multiple cosine terms\n  harmonic - harmonic improper\n  inversion/harmonic - harmonic improper with Wilson-Decius out-of-plane definition\n  ring - improper which prevents planar conformations\n  umbrella - DREIDING improper\n  \n  sqdistharm - improper that is harmonic in the square of the out-of-plane distance\n  ",
    "syntax": "improper_style style\n  \n  \n  \n  style = none or hybrid or class2 or cvff or harmonic\n  \n  ",
    "examples": "improper_style harmonic\n  improper_style cvff\n  improper_style hybrid cvff harmonic\n  \n  \n  ",
    "restrictions": "Improper styles can only be set for atom_style choices that allow\n  impropers to be defined.\n  Most improper styles are part of the MOLECULE package.  They are only\n  enabled if LAMMPS was built with that package.  See the Build package doc page for more info.  The doc pages for\n  individual improper potentials tell if it is part of a package.\n  "
},
{
    "command": "include",
    "description": "This command opens a new input script file and begins reading LAMMPS\n  commands from that file.  When the new file is finished, the original\n  file is returned to.  Include files can be nested as deeply as\n  desired.  If input script A includes script B, and B includes A, then\n  LAMMPS could run for a long time.\n  If the filename is a variable (see the variable\n  command), different processor partitions can run different input\n  scripts.\n  ",
    "syntax": "include file\n  \n  \n  \n  file = filename of new input script to switch to\n  \n  ",
    "examples": "include newfile\n  include in.run2\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "info",
    "description": "Print out information about the current internal state of the running\n  LAMMPS process. This can be helpful when debugging or validating\n  complex input scripts.  Several output categories are available and\n  one or more output category may be requested.\n  The out flag controls where the output is sent. It can only be sent\n  to one target. By default this is the screen, if it is active. The\n  log argument selects the log file instead. With the append and\n  overwrite option, followed by a filename, the output is written\n  to that file, which is either appended to or overwritten, respectively.\n  The all flag activates printing all categories listed below.\n  The configuration category prints some information about the\n  LAMMPS version as well as architecture and OS it is run on.\n  The memory category prints some information about the current\n  memory allocation of MPI rank 0 (this the amount of dynamically\n  allocated memory reported by LAMMPS classes). Where supported,\n  also some OS specific information about the size of the reserved\n  memory pool size (this is where malloc() and the new operator\n  request memory from) and the maximum resident set size is reported\n  (this is the maximum amount of physical memory occupied so far).\n  The system category prints a general system overview listing.  This\n  includes the unit style, atom style, number of atoms, bonds, angles,\n  dihedrals, and impropers and the number of the respective types, box\n  dimensions and properties, force computing styles and more.\n  The communication category prints a variety of information about\n  communication and parallelization: the MPI library version level,\n  the number of MPI ranks and OpenMP threads, the communication style\n  and layout, the processor grid dimensions, ghost atom communication\n  mode, cutoff, and related settings.\n  The computes category prints a list of all currently defined\n  computes, their IDs and styles and groups they operate on.\n  The dumps category prints a list of all currently active dumps,\n  their IDs, styles, filenames, groups, and dump frequencies.\n  The fixes category prints a list of all currently defined fixes,\n  their IDs and styles and groups they operate on.\n  The groups category prints a list of all currently defined groups.\n  The regions category prints a list of all currently defined regions,\n  their IDs and styles and whether “inside” or “outside” atoms are\n  selected.\n  The variables category prints a list of all currently defined\n  variables, their names, styles, definition and last computed value, if\n  available.\n  The coeffs category prints a list for each defined force style\n  (pair, bond, angle, dihedral, improper) indicating which of the\n  corresponding coefficients have been set. This can be very helpful\n  to debug error messages like “All pair coeffs are not set”.\n  The styles category prints the list of styles available in the\n  current LAMMPS binary. It supports one of the following options\n  to control which category of styles is printed out:\n  \n  all\n  angle\n  atom\n  bond\n  compute\n  command\n  dump\n  dihedral\n  fix\n  improper\n  integrate\n  kspace\n  minimize\n  pair\n  region\n  \n  The time category prints the accumulated CPU and wall time for the\n  process that writes output (usually MPI rank 0).\n  ",
    "syntax": "info args\n  \n  \n  \n  args = one or more of the following keywords: out, all, system, memory, communication, computes, dumps, fixes, groups, regions, variables, coeffs, styles, time, or configuration\n  out values = screen, log, append filename, overwrite filename\n  styles values = all, angle, atom, bond, compute, command, dump, dihedral, fix, improper, integrate, kspace, minimize, pair, region\n  \n  ",
    "examples": "info system\n  info groups computes variables\n  info all out log\n  info all out append info.txt\n  info styles all\n  info styles atom\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "jump",
    "description": "This command closes the current input script file, opens the file with\n  the specified name, and begins reading LAMMPS commands from that file.\n  Unlike the include command, the original file is not\n  returned to, although by using multiple jump commands it is possible\n  to chain from file to file or back to the original file.\n  If the word “SELF” is used for the filename, then the current input\n  script is re-opened and read again.\n  \n  Note\n  The SELF option is not guaranteed to work when the current input\n  script is being read through stdin (standard input), e.g.\n  \n  lmp_g++ < in.script\n  \n  \n  since the SELF option invokes the C-library rewind() call, which may\n  not be supported for stdin on some systems or by some MPI\n  implementations.  This can be worked around by using the -in command-line switch, e.g.\n  lmp_g++ -in in.script\n  \n  \n  or by using the -var command-line switch to pass\n  the script name as a variable to the input script.  In the latter\n  case, a variable called “fname” could be used in place\n  of SELF, e.g.\n  lmp_g++ -var fname in.script < in.script\n  \n  \n  The 2nd argument to the jump command is optional.  If specified, it is\n  treated as a label and the new file is scanned (without executing\n  commands) until the label is found, and commands are executed from\n  that point forward.  This can be used to loop over a portion of the\n  input script, as in this example.  These commands perform 10 runs,\n  each of 10000 steps, and create 10 dump files named file.1, file.2,\n  etc.  The next command is used to exit the loop after 10\n  iterations.  When the “a” variable has been incremented for the tenth\n  time, it will cause the next jump command to be skipped.\n  variable a loop 10\n  label loop\n  dump 1 all atom 100 file.$a\n  run 10000\n  undump 1\n  next a\n  jump in.lj loop\n  \n  \n  If the jump file argument is a variable, the jump command can be\n  used to cause different processor partitions to run different input\n  scripts.  In this example, LAMMPS is run on 40 processors, with 4\n  partitions of 10 procs each.  An in.file containing the example\n  variable and jump command will cause each partition to run a different\n  simulation.\n  mpirun -np 40 lmp_ibm -partition 4x10 -in in.file\n  \n  variable f world script.1 script.2 script.3 script.4\n  jump $f\n  \n  \n  Here is an example of a loop which checks every 1000 steps if the\n  system temperature has reached a certain value, and if so, breaks out\n  of the loop to finish the run.  Note that any variable could be\n  checked, so long as it is current on the timestep when the run\n  completes.  As explained on the variable doc page,\n  this can be insured by including the variable in thermodynamic output.\n  variable myTemp equal temp\n  label loop\n  variable a loop 1000\n  run 1000\n  if \"${myTemp} < 300.0\" then \"jump SELF break\"\n  next a\n  jump SELF loop\n  label break\n  print \"ALL DONE\"\n  \n  \n  Here is an example of a double loop which uses the if and\n  jump commands to break out of the inner loop when a\n  condition is met, then continues iterating through the outer loop.\n  label       loopa\n  variable    a loop 5\n    label     loopb\n    variable  b loop 5\n      print     \"A,B = $a,$b\"\n      run       10000\n      if        \"$b > 2\" then \"jump SELF break\"\n    next      b\n    jump      in.script loopb\n    label       break\n    variable    b delete\n  next        a\n  jump        SELF loopa\n  \n  \n  ",
    "syntax": "jump file label\n  \n  \n  \n  file = filename of new input script to switch to\n  label = optional label within file to jump to\n  \n  ",
    "examples": "jump newfile\n  jump in.run2 runloop\n  jump SELF runloop\n  \n  \n  ",
    "restrictions": "If you jump to a file and it does not contain the specified label,\n  LAMMPS will come to the end of the file and exit.\n  "
},
{
    "command": "kspace_modify",
    "description": "Set parameters used by the kspace solvers defined by the\n  kspace_style command.  Not all parameters are\n  relevant to all kspace styles.\n  \n  The collective keyword applies only to PPPM.  It is set to no by\n  default, except on IBM BlueGene machines.  If this option is set to\n  yes, LAMMPS will use MPI collective operations to remap data for\n  3d-FFT operations instead of the default point-to-point communication.\n  This is faster on IBM BlueGene machines, and may also be faster on\n  other machines if they have an efficient implementation of MPI\n  collective operations and adequate hardware.\n  \n  The compute keyword allows Kspace computations to be turned off,\n  even though a kspace_style is defined.  This is\n  not useful for running a real simulation, but can be useful for\n  debugging purposes or for computing only partial forces that do not\n  include the Kspace contribution.  You can also do this by simply not\n  defining a kspace_style, but a Kspace-compatible\n  pair_style requires a kspace style to be defined.\n  This keyword gives you that option.\n  \n  The cutoff/adjust keyword applies only to MSM. If this option is\n  turned on, the Coulombic cutoff will be automatically adjusted at the\n  beginning of the run to give the desired estimated error. Other\n  cutoffs such as LJ will not be affected. If the grid is not set using\n  the mesh command, this command will also attempt to use the optimal\n  grid that minimizes cost using an estimate given by\n  (Hardy). Note that this cost estimate is not exact, somewhat\n  experimental, and still may not yield the optimal parameters.\n  \n  The diff keyword specifies the differentiation scheme used by the\n  PPPM method to compute forces on particles given electrostatic\n  potentials on the PPPM mesh.  The ik approach is the default for\n  PPPM and is the original formulation used in (Hockney).  It\n  performs differentiation in Kspace, and uses 3 FFTs to transfer each\n  component of the computed fields back to real space for total of 4\n  FFTs per timestep.\n  The analytic differentiation ad approach uses only 1 FFT to transfer\n  information back to real space for a total of 2 FFTs per timestep.  It\n  then performs analytic differentiation on the single quantity to\n  generate the 3 components of the electric field at each grid point.\n  This is sometimes referred to as “smoothed” PPPM.  This approach\n  requires a somewhat larger PPPM mesh to achieve the same accuracy as\n  the ik method. Currently, only the ik method (default) can be\n  used for a triclinic simulation cell with PPPM. The ad method is\n  always used for MSM.\n  \n  Note\n  Currently, not all PPPM styles support the ad option.  Support\n  for those PPPM variants will be added later.\n  \n  \n  The disp/auto option controls whether the pppm/disp is allowed to\n  generate PPPM parameters automatically. If set to no, parameters have\n  to be specified using the gewald/disp, mesh/disp,\n  force/disp/real or force/disp/kspace keywords, or\n  the code will stop with an error message. When this option is set to\n  yes, the error message will not appear and the simulation will start.\n  For a typical application, using the automatic parameter generation\n  will provide simulations that are either inaccurate or slow. Using this\n  option is thus not recommended. For guidelines on how to obtain good\n  parameters, see the How-To discussion.\n  \n  The fftbench keyword applies only to PPPM. It is off by default. If\n  this option is turned on, LAMMPS will perform a short FFT benchmark\n  computation and report its timings, and will thus finish a some seconds\n  later than it would if this option were off.\n  \n  The force/disp/real and force/disp/kspace keywords set the force\n  accuracy for the real and space computations for the dispersion part\n  of pppm/disp. As shown in (Isele-Holder), optimal\n  performance and accuracy in the results is obtained when these values\n  are different.\n  \n  The force keyword overrides the relative accuracy parameter set by\n  the kspace_style command with an absolute\n  accuracy.  The accuracy determines the RMS error in per-atom forces\n  calculated by the long-range solver and is thus specified in force\n  units.  A negative value for the accuracy setting means to use the\n  relative accuracy parameter.  The accuracy setting is used in\n  conjunction with the pairwise cutoff to determine the number of\n  K-space vectors for style ewald, the FFT grid size for style\n  pppm, or the real space grid size for style msm.\n  \n  The gewald keyword sets the value of the Ewald or PPPM G-ewald\n  parameter for charge as rinv in reciprocal distance units.  Without\n  this setting, LAMMPS chooses the parameter automatically as a function\n  of cutoff, precision, grid spacing, etc.  This means it can vary from\n  one simulation to the next which may not be desirable for matching a\n  KSpace solver to a pre-tabulated pairwise potential.  This setting can\n  also be useful if Ewald or PPPM fails to choose a good grid spacing\n  and G-ewald parameter automatically.  If the value is set to 0.0,\n  LAMMPS will choose the G-ewald parameter automatically.  MSM does not\n  use the gewald parameter.\n  \n  The gewald/disp keyword sets the value of the Ewald or PPPM G-ewald\n  parameter for dispersion as rinv in reciprocal distance units.  It\n  has the same meaning as the gewald setting for Coulombics.\n  \n  The kmax/ewald keyword sets the number of kspace vectors in each\n  dimension for kspace style ewald.  The three values must be positive\n  integers, or else (0,0,0), which unsets the option.  When this option\n  is not set, the Ewald sum scheme chooses its own kspace vectors,\n  consistent with the user-specified accuracy and pairwise cutoff. In\n  any case, if kspace style ewald is invoked, the values used are\n  printed to the screen and the log file at the start of the run.\n  \n  The mesh keyword sets the grid size for kspace style pppm or\n  msm.  In the case of PPPM, this is the FFT mesh, and each dimension\n  must be factorizable into powers of 2, 3, and 5.  In the case of MSM,\n  this is the finest scale real-space mesh, and each dimension must be\n  factorizable into powers of 2.  When this option is not set, the PPPM\n  or MSM solver chooses its own grid size, consistent with the\n  user-specified accuracy and pairwise cutoff.  Values for x,y,z of\n  0,0,0 unset the option.\n  \n  The mesh/disp keyword sets the grid size for kspace style\n  pppm/disp.  This is the FFT mesh for long-range dispersion and ach\n  dimension must be factorizable into powers of 2, 3, and 5.  When this\n  option is not set, the PPPM solver chooses its own grid size,\n  consistent with the user-specified accuracy and pairwise cutoff.\n  Values for x,y,z of 0,0,0 unset the option.\n  \n  The minorder keyword allows LAMMPS to reduce the order setting if\n  necessary to keep the communication of ghost grid point limited to\n  exchanges between nearest-neighbor processors.  See the discussion of\n  the overlap keyword for details.  If the overlap keyword is set to\n  yes, which is the default, this is never needed.  If it set to no\n  and overlap occurs, then LAMMPS will reduce the order setting, one\n  step at a time, until the ghost grid overlap only extends to nearest\n  neighbor processors.  The minorder keyword limits how small the\n  order setting can become.  The minimum allowed value for PPPM is 2,\n  which is the default.  If minorder is set to the same value as\n  order then no reduction is allowed, and LAMMPS will generate an\n  error if the grid communication is non-nearest-neighbor and overlap\n  is set to no. The minorder keyword is not currently supported in\n  MSM.\n  \n  The mix/disp keyword selects the mixing rule for the dispersion\n  coefficients.  With pair, the dispersion coefficients of unlike\n  types are computed as indicated with pair_modify.\n  With geom, geometric mixing is enforced on the dispersion\n  coefficients in the kspace coefficients. When using the arithmetic\n  mixing rule, this will speed-up the simulations but introduces some\n  error in the force computations, as shown in (Wennberg).\n  With none, it is assumed that no mixing rule is\n  applicable. Splitting of the dispersion coefficients will be performed\n  as described in (Isele-Holder).\n  This splitting can be influenced with the splittol keywords.  Only\n  the eigenvalues that are larger than tol compared to the largest\n  eigenvalues are included. Using this keywords the original matrix of\n  dispersion coefficients is approximated. This leads to faster\n  computations, but the accuracy in the reciprocal space computations of\n  the dispersion part is decreased.\n  \n  The order keyword determines how many grid spacings an atom’s charge\n  extends when it is mapped to the grid in kspace style pppm or msm.\n  The default for this parameter is 5 for PPPM and 8 for MSM, which\n  means each charge spans 5 or 8 grid cells in each dimension,\n  respectively.  For the LAMMPS implementation of MSM, the order can\n  range from 4 to 10 and must be even. For PPPM, the minimum allowed\n  setting is 2 and the maximum allowed setting is 7.  The larger the\n  value of this parameter, the smaller that LAMMPS will set the grid\n  size, to achieve the requested accuracy.  Conversely, the smaller the\n  order value, the larger the grid size will be.  Note that there is an\n  inherent trade-off involved: a small grid will lower the cost of FFTs\n  or MSM direct sum, but a larger order parameter will increase the cost\n  of interpolating charge/fields to/from the grid.\n  The PPPM order parameter may be reset by LAMMPS when it sets up the\n  FFT grid if the implied grid stencil extends beyond the grid cells\n  owned by neighboring processors.  Typically this will only occur when\n  small problems are run on large numbers of processors.  A warning will\n  be generated indicating the order parameter is being reduced to allow\n  LAMMPS to run the problem. Automatic adjustment of the order parameter\n  is not supported in MSM.\n  \n  The order/disp keyword determines how many grid spacings an atom’s\n  dispersion term extends when it is mapped to the grid in kspace style\n  pppm/disp.  It has the same meaning as the order setting for\n  Coulombics.\n  \n  The overlap keyword can be used in conjunction with the minorder\n  keyword with the PPPM styles to adjust the amount of communication\n  that occurs when values on the FFT grid are exchanged between\n  processors.  This communication is distinct from the communication\n  inherent in the parallel FFTs themselves, and is required because\n  processors interpolate charge and field values using grid point values\n  owned by neighboring processors (i.e. ghost point communication).  If\n  the overlap keyword is set to yes then this communication is\n  allowed to extend beyond nearest-neighbor processors, e.g. when using\n  lots of processors on a small problem.  If it is set to no then the\n  communication will be limited to nearest-neighbor processors and the\n  order setting will be reduced if necessary, as explained by the\n  minorder keyword discussion. The overlap keyword is always set to\n  yes in MSM.\n  \n  The pressure/scalar keyword applies only to MSM. If this option is\n  turned on, only the scalar pressure (i.e. (Pxx + Pyy + Pzz)/3.0) will\n  be computed, which can be used, for example, to run an isotropic barostat.\n  Computing the full pressure tensor with MSM is expensive, and this option\n  provides a faster alternative. The scalar pressure is computed using a\n  relationship between the Coulombic energy and pressure (Hummer)\n  instead of using the virial equation. This option cannot be used to access\n  individual components of the pressure tensor, to compute per-atom virial,\n  or with suffix kspace/pair styles of MSM, like OMP or GPU.\n  \n  The scafacos keyword is used for settings that are passed to the\n  ScaFaCoS library when using kspace_style scafacos.\n  The tolerance option affects how the accuracy specified with the\n  kspace_style command is interpreted by ScaFaCoS.\n  The following values may be used:\n  \n  energy = absolute accuracy in total Coulombic energy\n  energy_rel = relative accuracy in total Coulombic energy\n  potential = absolute accuracy in total Coulombic potential\n  potential_rel = relative accuracy in total Coulombic potential\n  field = absolute accuracy in electric field\n  field_rel = relative accuracy in electric field\n  \n  The values with suffix _rel indicate the tolerance is a relative\n  tolerance; the other values impose an absolute tolerance on the given\n  quantity. Absolute tolerance in this case means, that for a given\n  quantity q and a given absolute tolerance of t_a the result should\n  be between q-t_a and q+t_a. For a relative tolerance t_r the relative\n  error should not be greater than t_r, i.e. abs(1 - (result/q)) < t_r.\n  As a consequence of this, the tolerance type should be checked, when\n  performing computations with a high absolute field / energy. E.g.\n  if the total energy in the system is 1000000.0 an absolute tolerance\n  of 1e-3 would mean that the result has to be between 999999.999 and\n  1000000.001, which would be equivalent to a relative tolerance of\n  1e-9.\n  The energy and energy_rel values, set a tolerance based on the total\n  Coulombic energy of the system.  The potential and potential_rel set a\n  tolerance based on the per-atom Coulombic energy.  The field and\n  field_rel tolerance types set a tolerance based on the electric field\n  values computed by ScaFaCoS.  Since per-atom forces are derived from\n  the per-atom electric field, this effectively sets a tolerance on the\n  forces, similar to other LAMMPS KSpace styles, as explained on the\n  kspace_style doc page.\n  Note that not all ScaFaCoS solvers support all tolerance types.\n  These are the allowed values for each method:\n  \n  fmm = energy and energy_rel\n  p2nfft = field (1d-,2d-,3d-periodic systems) or potential (0d-periodic)\n  p3m = field\n  ewald = field\n  direct = has no tolerance tuning\n  \n  If the tolerance type is not changed, the default values for the\n  tolerance type are the first values in the above list, e.g. energy\n  is the default tolerance type for the fmm solver.\n  The fmm_tuning option is only relevant when using the FMM method.\n  It activates (value=1) or deactivates (value=0) an internal tuning\n  mechanism for the FMM solver.  The tuning operation runs sequentially\n  and can be very time-consuming.  Usually it is not needed for systems\n  with a homogeneous charge distribution. The default for this option is\n  therefore 0. The FMM internal tuning is performed once, when the\n  solver is set up.\n  \n  The slab keyword allows an Ewald or PPPM solver to be used for a\n  systems that are periodic in x,y but non-periodic in z - a\n  boundary setting of “boundary p p f”.  This is done by\n  treating the system as if it were periodic in z, but inserting empty\n  volume between atom slabs and removing dipole inter-slab interactions\n  so that slab-slab interactions are effectively turned off.  The\n  volfactor value sets the ratio of the extended dimension in z divided\n  by the actual dimension in z.  The recommended value is 3.0.  A larger\n  value is inefficient; a smaller value introduces unwanted slab-slab\n  interactions.  The use of fixed boundaries in z means that the user\n  must prevent particle migration beyond the initial z-bounds, typically\n  by providing a wall-style fix.  The methodology behind the slab\n  option is explained in the paper by (Yeh).  The slab option\n  is also extended to non-neutral systems (Ballenegger).\n  An alternative slab option can be invoked with the nozforce keyword\n  in lieu of the volfactor.  This turns off all kspace forces in the z\n  direction.  The nozforce option is not supported by MSM. For MSM,\n  any combination of periodic, non-periodic, or shrink-wrapped\n  boundaries can be set using boundary (the slab\n  approximation in not needed).  The slab keyword is not currently\n  supported by Ewald or PPPM when using a triclinic simulation cell. The\n  slab correction has also been extended to point dipole interactions\n  (Klapp) in kspace_style ewald/disp,\n  ewald/dipole, and pppm/dipole.\n  \n  Note\n  If you wish to apply an electric field in the Z-direction, in\n  conjunction with the slab keyword, you should do it by adding\n  explicit charged particles to the +/- Z surfaces.  If you do it via\n  the fix efield command, it will not give the correct\n  dielectric constant due to the Yeh/Berkowitz (Yeh) correction\n  not being compatible with how fix efield works.\n  \n  \n  The force/disp/real and force/disp/kspace keywords set the force\n  accuracy for the real and space computations for the dispersion part\n  of pppm/disp. As shown in (Isele-Holder), optimal\n  performance and accuracy in the results is obtained when these values\n  are different.\n  The disp/auto option controls whether the pppm/disp is allowed to\n  generate PPPM parameters automatically. If set to no, parameters\n  have to be specified using the gewald/disp, mesh/disp,\n  force/disp/real or force/disp/kspace keywords, or the code will\n  stop with an error message. When this option is set to yes, the\n  error message will not appear and the simulation will start.  For a\n  typical application, using the automatic parameter generation will\n  provide simulations that are either inaccurate or slow. Using this\n  option is thus not recommended.  For guidelines on how to obtain good\n  parameters, see the Howto dispersion doc page.\n  ",
    "syntax": "kspace_modify keyword value ...\n  \n  \n  \n  one or more keyword/value pairs may be listed\n  keyword = collective or compute or cutoff/adjust or diff or disp/auto or fftbench or force/disp/kspace or force/disp/real or force or gewald/disp or gewald or kmax/ewald or mesh or minorder or mix/disp or order/disp or order or overlap or scafacos or slab or splittol\n  collective value = yes or no\n  compute value = yes or no\n  cutoff/adjust value = yes or no\n  diff value = ad or ik = 2 or 4 FFTs for PPPM in smoothed or non-smoothed mode\n  disp/auto value = yes or no\n  fftbench value = yes or no\n  force/disp/real value = accuracy (force units)\n  force/disp/kspace value = accuracy (force units)\n  force value = accuracy (force units)\n  gewald value = rinv (1/distance units)\n    rinv = G-ewald parameter for Coulombics\n  gewald/disp value = rinv (1/distance units)\n    rinv = G-ewald parameter for dispersion\n  kmax/ewald value = kx ky kz\n    kx,ky,kz = number of Ewald sum kspace vectors in each dimension\n  mesh value = x y z\n    x,y,z = grid size in each dimension for long-range Coulombics\n  mesh/disp value = x y z\n    x,y,z = grid size in each dimension for 1/r^6 dispersion\n  minorder value = M\n    M = min allowed extent of Gaussian when auto-adjusting to minimize grid communication\n  mix/disp value = pair or geom or none\n  order value = N\n    N = extent of Gaussian for PPPM or MSM mapping of charge to grid\n  order/disp value = N\n    N = extent of Gaussian for PPPM mapping of dispersion term to grid\n  overlap = yes or no = whether the grid stencil for PPPM is allowed to overlap into more than the nearest-neighbor processor\n  pressure/scalar value = yes or no\n  scafacos values = option value1 value2 ...\n    option = tolerance\n      value = energy or energy_rel or field or field_rel or potential or potential_rel\n    option = fmm_tuning\n      value = 0 or 1\n  slab value = volfactor or nozforce\n    volfactor = ratio of the total extended volume used in the\n      2d approximation compared with the volume of the simulation domain\n    nozforce turns off kspace forces in the z direction\n  splittol value = tol\n    tol = relative size of two eigenvalues (see discussion below)\n  \n  \n  ",
    "examples": "kspace_modify mesh 24 24 30 order 6\n  kspace_modify slab 3.0\n  kspace_modify scafacos tolerance energy\n  \n  \n  ",
    "restrictions": "none\n  "
},
{
    "command": "kspace_style",
    "description": "Define a long-range solver for LAMMPS to use each timestep to compute\n  long-range Coulombic interactions or long-range \\(1/r^6\\) interactions.\n  Most of the long-range solvers perform their computation in K-space,\n  hence the name of this command.\n  When such a solver is used in conjunction with an appropriate pair\n  style, the cutoff for Coulombic or \\(1/r^N\\) interactions is effectively\n  infinite.  If the Coulombic case, this means each charge in the system\n  interacts with charges in an infinite array of periodic images of the\n  simulation domain.\n  Note that using a long-range solver requires use of a matching pair style to perform consistent short-range pairwise\n  calculations.  This means that the name of the pair style contains a\n  matching keyword to the name of the KSpace style, as in this table:\n  \n  \n  \n  \n  \n  \n  Pair style\n  KSpace style\n  \n  coul/long\n  ewald or pppm\n  \n  coul/msm\n  msm\n  \n  lj/long or buck/long\n  disp (for dispersion)\n  \n  tip4p/long\n  tip4p\n  \n  \n  \n  \n  The ewald style performs a standard Ewald summation as described in\n  any solid-state physics text.\n  The ewald/disp style adds a long-range dispersion sum option for\n  \\(1/r^6\\) potentials and is useful for simulation of interfaces\n  (Veld).  It also performs standard Coulombic Ewald summations,\n  but in a more efficient manner than the ewald style.  The \\(1/r^6\\)\n  capability means that Lennard-Jones or Buckingham potentials can be\n  used without a cutoff, i.e. they become full long-range potentials.\n  The ewald/disp style can also be used with point-dipoles, see\n  (Toukmaji).\n  The ewald/dipole style adds long-range standard Ewald summations\n  for dipole-dipole interactions, see (Toukmaji).\n  The ewald/dipole/spin style adds long-range standard Ewald\n  summations for magnetic dipole-dipole interactions between\n  magnetic spins.\n  \n  The pppm style invokes a particle-particle particle-mesh solver\n  (Hockney) which maps atom charge to a 3d mesh, uses 3d FFTs\n  to solve Poisson’s equation on the mesh, then interpolates electric\n  fields on the mesh points back to the atoms.  It is closely related to\n  the particle-mesh Ewald technique (PME) (Darden) used in\n  AMBER and CHARMM.  The cost of traditional Ewald summation scales as\n  \\(N^{\\frac{3}{2}}\\) where \\(N\\) is the number of atoms in the system.  The PPPM solver\n  scales as \\(N \\log{N}\\) due to the FFTs, so it is almost always a faster\n  choice (Pollock).\n  The pppm/cg style is identical to the pppm style except that it\n  has an optimization for systems where most particles are uncharged.\n  Similarly the msm/cg style implements the same optimization for msm.\n  The optional smallq argument defines the cutoff for the absolute\n  charge value which determines whether a particle is considered charged\n  or not.  Its default value is 1.0e-5.\n  The pppm/dipole style invokes a particle-particle particle-mesh solver\n  for dipole-dipole interactions, following the method of (Cerda).\n  The pppm/dipole/spin style invokes a particle-particle particle-mesh solver\n  for magnetic dipole-dipole interactions between magnetic spins.\n  The pppm/tip4p style is identical to the pppm style except that it\n  adds a charge at the massless 4th site in each TIP4P water molecule.\n  It should be used with pair styles with a\n  tip4p/long in their style name.\n  The pppm/stagger style performs calculations using two different\n  meshes, one shifted slightly with respect to the other.  This can\n  reduce force aliasing errors and increase the accuracy of the method\n  for a given mesh size.  Or a coarser mesh can be used for the same\n  target accuracy, which saves CPU time.  However, there is a trade-off\n  since FFTs on two meshes are now performed which increases the\n  computation required.  See (Cerutti), (Neelov),\n  and (Hockney) for details of the method.\n  For high relative accuracy, using staggered PPPM allows the mesh size\n  to be reduced by a factor of 2 in each dimension as compared to\n  regular PPPM (for the same target accuracy).  This can give up to a 4x\n  speedup in the KSpace time (8x less mesh points, 2x more expensive).\n  However, for low relative accuracy, the staggered PPPM mesh size may\n  be essentially the same as for regular PPPM, which means the method\n  will be up to 2x slower in the KSpace time (simply 2x more expensive).\n  For more details and timings, see the Speed tips doc\n  page.\n  \n  Note\n  Using pppm/stagger may not give the same increase in the\n  accuracy of energy and pressure as it does in forces, so some caution\n  must be used if energy and/or pressure are quantities of interest,\n  such as when using a barostat.\n  \n  \n  The pppm/disp and pppm/disp/tip4p styles add a mesh-based long-range\n  dispersion sum option for 1/r^6 potentials (Isele-Holder),\n  similar to the ewald/disp style. The 1/r^6 capability means\n  that Lennard-Jones or Buckingham potentials can be used without a cutoff,\n  i.e. they become full long-range potentials.\n  For these styles, you will possibly want to adjust the default choice\n  of parameters by using the kspace_modify command.\n  This can be done by either choosing the Ewald and grid parameters, or\n  by specifying separate accuracies for the real and kspace\n  calculations. When not making any settings, the simulation will stop\n  with an error message. Further information on the influence of the\n  parameters and how to choose them is described in\n  (Isele-Holder),\n  (Isele-Holder2) and the Howto dispersion doc page.\n  \n  \n  Note\n  All of the PPPM styles can be used with single-precision FFTs by\n  using the compiler switch -DFFT_SINGLE for the FFT_INC setting in your\n  low-level Makefile.  This setting also changes some of the PPPM\n  operations (e.g. mapping charge to mesh and interpolating electric\n  fields to particles) to be performed in single precision.  This option\n  can speed-up long-range calculations, particularly in parallel or on\n  GPUs.  The use of the -DFFT_SINGLE flag is discussed on the Build settings doc page. MSM does not currently support\n  the -DFFT_SINGLE compiler switch.\n  \n  \n  The msm style invokes a multi-level summation method MSM solver,\n  (Hardy) or (Hardy2), which maps atom charge\n  to a 3d mesh, and uses a multi-level hierarchy of coarser and coarser\n  meshes on which direct Coulomb solvers are done.  This method does not\n  use FFTs and scales as \\(N\\). It may therefore be faster than the other\n  K-space solvers for relatively large problems when running on large\n  core counts. MSM can also be used for non-periodic boundary conditions\n  and for mixed periodic and non-periodic boundaries.\n  MSM is most competitive versus Ewald and PPPM when only relatively\n  low accuracy forces, about 1e-4 relative error or less accurate,\n  are needed. Note that use of a larger Coulombic cutoff (i.e. 15\n  angstroms instead of 10 angstroms) provides better MSM accuracy for\n  both the real space and grid computed forces.\n  Currently calculation of the full pressure tensor in MSM is expensive.\n  Using the kspace_modify pressure/scalar yes\n  command provides a less expensive way to compute the scalar pressure\n  (Pxx + Pyy + Pzz)/3.0. The scalar pressure can be used, for example,\n  to run an isotropic barostat. If the full pressure tensor is needed,\n  then calculating the pressure at every timestep or using a fixed\n  pressure simulation with MSM will cause the code to run slower.\n  \n  The scafacos style is a wrapper on the ScaFaCoS Coulomb solver library which provides a variety of solver\n  methods which can be used with LAMMPS.  The paper by (Who)\n  gives an overview of ScaFaCoS.\n  ScaFaCoS was developed by a consortium of German research facilities\n  with a BMBF (German Ministry of Science and Education) funded project\n  in 2009-2012. Participants of the consortium were the Universities of\n  Bonn, Chemnitz, Stuttgart, and Wuppertal as well as the\n  Forschungszentrum Juelich.\n  The library is available for download at “http://scafacos.de” or can\n  be cloned from the git-repository\n  “git://github.com/scafacos/scafacos.git”.\n  In order to use this KSpace style, you must download and build the\n  ScaFaCoS library, then build LAMMPS with the USER-SCAFACOS package\n  installed package which links LAMMPS to the ScaFaCoS library.\n  See details on this page.\n  \n  Note\n  Unlike other KSpace solvers in LAMMPS, ScaFaCoS computes all\n  Coulombic interactions, both short- and long-range.  Thus you should\n  NOT use a Coulombic pair style when using kspace_style scafacos.  This\n  also means the total Coulombic energy (short- and long-range) will be\n  tallied for thermodynamic output command as part\n  of the elong keyword; the ecoul keyword will be zero.\n  \n  \n  Note\n  See the current restriction below about use of ScaFaCoS in\n  LAMMPS with molecular charged systems or the TIP4P water model.\n  \n  The specified method determines which ScaFaCoS algorithm is used.\n  These are the ScaFaCoS methods currently available from LAMMPS:\n  \n  fmm = Fast Multi-Pole method\n  p2nfft = FFT-based Coulomb solver\n  ewald = Ewald summation\n  direct = direct O(N^2) summation\n  p3m = PPPM\n  \n  We plan to support additional ScaFaCoS solvers from LAMMPS in the\n  future.  For an overview of the included solvers, refer to\n  (Sutmann)\n  The specified accuracy is similar to the accuracy setting for other\n  LAMMPS KSpace styles, but is passed to ScaFaCoS, which can interpret\n  it in different ways for different methods it supports.  Within the\n  ScaFaCoS library the accuracy is treated as a tolerance level\n  (either absolute or relative) for the chosen quantity, where the\n  quantity can be either the Columic field values, the per-atom Columic\n  energy or the total Columic energy.  To select from these options, see\n  the kspace_modify scafacos accuracy doc page.\n  The kspace_modify scafacos command also explains\n  other ScaFaCoS options currently exposed to LAMMPS.\n  \n  The specified accuracy determines the relative RMS error in per-atom\n  forces calculated by the long-range solver.  It is set as a\n  dimensionless number, relative to the force that two unit point\n  charges (e.g. 2 monovalent ions) exert on each other at a distance of\n  1 Angstrom.  This reference value was chosen as representative of the\n  magnitude of electrostatic forces in atomic systems.  Thus an accuracy\n  value of 1.0e-4 means that the RMS error will be a factor of 10000\n  smaller than the reference force.\n  The accuracy setting is used in conjunction with the pairwise cutoff\n  to determine the number of K-space vectors for style ewald or the\n  grid size for style pppm or msm.\n  Note that style pppm only computes the grid size at the beginning of\n  a simulation, so if the length or triclinic tilt of the simulation\n  cell increases dramatically during the course of the simulation, the\n  accuracy of the simulation may degrade.  Likewise, if the\n  kspace_modify slab option is used with\n  shrink-wrap boundaries in the z-dimension, and the box size changes\n  dramatically in z.  For example, for a triclinic system with all three\n  tilt factors set to the maximum limit, the PPPM grid should be\n  increased roughly by a factor of 1.5 in the y direction and 2.0 in the\n  z direction as compared to the same system using a cubic orthogonal\n  simulation cell.  One way to handle this issue if you have a long\n  simulation where the box size changes dramatically, is to break it\n  into shorter simulations (multiple run commands).  This\n  works because the grid size is re-computed at the beginning of each\n  run.  Another way to ensure the described accuracy requirement is met\n  is to run a short simulation at the maximum expected tilt or length,\n  note the required grid size, and then use the\n  kspace_modify mesh command to manually set the\n  PPPM grid size to this value for the long run.  The simulation then\n  will be “too accurate” for some portion of the run.\n  RMS force errors in real space for ewald and pppm are estimated\n  using equation 18 of (Kolafa), which is also referenced as\n  equation 9 of (Petersen). RMS force errors in K-space for\n  ewald are estimated using equation 11 of (Petersen),\n  which is similar to equation 32 of (Kolafa). RMS force\n  errors in K-space for pppm are estimated using equation 38 of\n  (Deserno). RMS force errors for msm are estimated\n  using ideas from chapter 3 of (Hardy), with equation 3.197\n  of particular note. When using msm with non-periodic boundary\n  conditions, it is expected that the error estimation will be too\n  pessimistic. RMS force errors for dipoles when using ewald/disp\n  or ewald/dipole are estimated using equations 33 and 46 of\n  (Wang). The RMS force errors for pppm/dipole are estimated\n  using the equations in (Cerda).\n  See the kspace_modify command for additional\n  options of the K-space solvers that can be set, including a force\n  option for setting an absolute RMS error in forces, as opposed to a\n  relative RMS error.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  More specifically, the pppm/gpu style performs charge assignment and\n  force interpolation calculations on the GPU.  These processes are\n  performed either in single or double precision, depending on whether\n  the -DFFT_SINGLE setting was specified in your low-level Makefile, as\n  discussed above.  The FFTs themselves are still calculated on the CPU.\n  If pppm/gpu is used with a GPU-enabled pair style, part of the PPPM\n  calculation can be performed concurrently on the GPU while other\n  calculations for non-bonded and bonded force calculation are performed\n  on the CPU.\n  The pppm/kk style performs charge assignment and force interpolation\n  calculations, along with the FFTs themselves, on the GPU or (optionally) threaded\n  on the CPU when using OpenMP and FFTW3.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP, and OPT packages respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "kspace_style style value\n  \n  \n  \n  style = none or ewald or ewald/dipole or ewald/dipole/spin or ewald/disp or ewald/omp or pppm or pppm/cg or pppm/disp or pppm/tip4p or pppm/stagger or pppm/disp/tip4p or pppm/gpu or pppm/intel or pppm/disp/intel or pppm/kk or pppm/omp or pppm/cg/omp or pppm/disp/tip4p/omp or pppm/tip4p/omp or msm or msm/cg or msm/omp or msm/cg/omp or scafacos\n  none value = none\n  ewald value = accuracy\n    accuracy = desired relative error in forces\n  ewald/dipole value = accuracy\n    accuracy = desired relative error in forces\n  ewald/dipole/spin value = accuracy\n    accuracy = desired relative error in forces\n  ewald/disp value = accuracy\n    accuracy = desired relative error in forces\n  ewald/omp value = accuracy\n    accuracy = desired relative error in forces\n  pppm value = accuracy\n    accuracy = desired relative error in forces\n  pppm/cg values = accuracy (smallq)\n    accuracy = desired relative error in forces\n    smallq = cutoff for charges to be considered (optional) (charge units)\n  pppm/dipole value = accuracy\n    accuracy = desired relative error in forces\n  pppm/dipole/spin value = accuracy\n    accuracy = desired relative error in forces\n  pppm/disp value = accuracy\n    accuracy = desired relative error in forces\n  pppm/tip4p value = accuracy\n    accuracy = desired relative error in forces\n  pppm/disp/tip4p value = accuracy\n    accuracy = desired relative error in forces\n  pppm/gpu value = accuracy\n    accuracy = desired relative error in forces\n  pppm/intel value = accuracy\n    accuracy = desired relative error in forces\n  pppm/disp/intel value = accuracy\n    accuracy = desired relative error in forces\n  pppm/kk value = accuracy\n    accuracy = desired relative error in forces\n  pppm/omp value = accuracy\n    accuracy = desired relative error in forces\n  pppm/cg/omp values = accuracy (smallq)\n    accuracy = desired relative error in forces\n    smallq = cutoff for charges to be considered (optional) (charge units)\n  pppm/disp/omp value = accuracy\n    accuracy = desired relative error in forces\n  pppm/tip4p/omp value = accuracy\n    accuracy = desired relative error in forces\n  pppm/disp/tip4p/omp value = accuracy\n    accuracy = desired relative error in forces\n  pppm/stagger value = accuracy\n    accuracy = desired relative error in forces\n  msm value = accuracy\n    accuracy = desired relative error in forces\n  msm/cg value = accuracy (smallq)\n    accuracy = desired relative error in forces\n    smallq = cutoff for charges to be considered (optional) (charge units)\n  msm/omp value = accuracy\n    accuracy = desired relative error in forces\n  msm/cg/omp value = accuracy (smallq)\n    accuracy = desired relative error in forces\n    smallq = cutoff for charges to be considered (optional) (charge units)\n  scafacos values = method accuracy\n    method = fmm or p2nfft or p3m or ewald or direct\n    accuracy = desired relative error in forces\n  \n  \n  ",
    "examples": "kspace_style pppm 1.0e-4\n  kspace_style pppm/cg 1.0e-5 1.0e-6\n  kspace style msm 1.0e-4\n  kspace style scafacos fmm 1.0e-4\n  kspace_style none\n  \n  \n  ",
    "restrictions": "Note that the long-range electrostatic solvers in LAMMPS assume conducting\n  metal (tinfoil) boundary conditions for both charge and dipole\n  interactions. Vacuum boundary conditions are not currently supported.\n  The ewald/disp, ewald, pppm, and msm styles support\n  non-orthogonal (triclinic symmetry) simulation boxes. However,\n  triclinic simulation cells may not yet be supported by all suffix\n  versions of these styles.\n  All of the kspace styles are part of the KSPACE package.  They are\n  only enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\n  For MSM, a simulation must be 3d and one can use any combination of\n  periodic, non-periodic, or shrink-wrapped boundaries (specified using\n  the boundary command).\n  For Ewald and PPPM, a simulation must be 3d and periodic in all\n  dimensions.  The only exception is if the slab option is set with\n  kspace_modify, in which case the xy dimensions\n  must be periodic and the z dimension must be non-periodic.\n  The scafacos KSpace style will only be enabled if LAMMPS is built with\n  the USER-SCAFACOS package.  See the Build package\n  doc page for more info.\n  The use of ScaFaCos in LAMMPS does not yet support molecular charged\n  systems where the short-range Coulombic interactions between atoms in\n  the same bond/angle/dihedral are weighted by the\n  special_bonds command.  Likewise it does not\n  support the “TIP4P water style” where a fictitious charge site is\n  introduced in each water molecule.\n  Finally, the methods p3m and ewald do not support computing the\n  virial, so this contribution is not included.\n  "
},
{
    "command": "label",
    "description": "Label this line of the input script with the chosen ID.  Unless a jump\n  command was used previously, this does nothing.  But if a\n  jump command was used with a label argument to begin\n  invoking this script file, then all command lines in the script prior\n  to this line will be ignored.  I.e. execution of the script will begin\n  at this line.  This is useful for looping over a section of the input\n  script as discussed in the jump command.\n  ",
    "syntax": "label ID\n  \n  \n  \n  ID = string used as label name\n  \n  ",
    "examples": "label xyz\n  label loop\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  Related commands: none\n  Default: none\n  "
},
{
    "command": "lattice",
    "description": "Define a lattice for use by other commands.  In LAMMPS, a lattice is\n  simply a set of points in space, determined by a unit cell with basis\n  atoms, that is replicated infinitely in all dimensions.  The arguments\n  of the lattice command can be used to define a wide variety of\n  crystallographic lattices.\n  A lattice is used by LAMMPS in two ways.  First, the\n  create_atoms command creates atoms on the lattice\n  points inside the simulation box.  Note that the\n  create_atoms command allows different atom types\n  to be assigned to different basis atoms of the lattice.  Second, the\n  lattice spacing in the x,y,z dimensions implied by the lattice, can be\n  used by other commands as distance units\n  (e.g. create_box, region and\n  velocity), which are often convenient to use when the\n  underlying problem geometry is atoms on a lattice.\n  The lattice style must be consistent with the dimension of the\n  simulation - see the dimension command.  Styles sc\n  or bcc or fcc or hcp or diamond are for 3d problems.  Styles\n  sq or sq2 or hex are for 2d problems.  Style custom can be\n  used for either 2d or 3d problems.\n  A lattice consists of a unit cell, a set of basis atoms within that\n  cell, and a set of transformation parameters (scale, origin, orient)\n  that map the unit cell into the simulation box.  The vectors a1,a2,a3\n  are the edge vectors of the unit cell.  This is the nomenclature for\n  “primitive” vectors in solid-state crystallography, but in LAMMPS the\n  unit cell they determine does not have to be a “primitive cell” of\n  minimum volume.\n  Note that the lattice command can be used multiple times in an input\n  script.  Each time it is invoked, the lattice attributes are\n  re-defined and are used for all subsequent commands (that use lattice\n  attributes).  For example, a sequence of lattice,\n  region, and create_atoms commands\n  can be repeated multiple times to build a poly-crystalline model with\n  different geometric regions populated with atoms in different lattice\n  orientations.\n  \n  A lattice of style none does not define a unit cell and basis set,\n  so it cannot be used with the create_atoms\n  command.  However it does define a lattice spacing via the specified\n  scale parameter.  As explained above the lattice spacings in x,y,z can\n  be used by other commands as distance units.  No additional\n  keyword/value pairs can be specified for the none style.  By\n  default, a “lattice none 1.0” is defined, which means the lattice\n  spacing is the same as one distance unit, as defined by the\n  units command.\n  Lattices of style sc, fcc, bcc, and diamond are 3d lattices\n  that define a cubic unit cell with edge length = 1.0.  This means a1 =\n  1 0 0, a2 = 0 1 0, and a3 = 0 0 1.  Style hcp has a1 = 1 0 0, a2 = 0\n  sqrt(3) 0, and a3 = 0 0 sqrt(8/3).  The placement of the basis atoms\n  within the unit cell are described in any solid-state physics text.  A\n  sc lattice has 1 basis atom at the lower-left-bottom corner of the\n  cube.  A bcc lattice has 2 basis atoms, one at the corner and one at\n  the center of the cube.  A fcc lattice has 4 basis atoms, one at the\n  corner and 3 at the cube face centers.  A hcp lattice has 4 basis\n  atoms, two in the z = 0 plane and 2 in the z = 0.5 plane.  A diamond\n  lattice has 8 basis atoms.\n  Lattices of style sq and sq2 are 2d lattices that define a square\n  unit cell with edge length = 1.0.  This means a1 = 1 0 0 and a2 = 0 1\n  0.  A sq lattice has 1 basis atom at the lower-left corner of the\n  square.  A sq2 lattice has 2 basis atoms, one at the corner and one\n  at the center of the square.  A hex style is also a 2d lattice, but\n  the unit cell is rectangular, with a1 = 1 0 0 and a2 = 0 sqrt(3) 0.\n  It has 2 basis atoms, one at the corner and one at the center of the\n  rectangle.\n  A lattice of style custom allows you to specify a1, a2, a3, and a\n  list of basis atoms to put in the unit cell.  By default, a1 and a2\n  and a3 are 3 orthogonal unit vectors (edges of a unit cube).  But you\n  can specify them to be of any length and non-orthogonal to each other,\n  so that they describe a tilted parallelepiped.  Via the basis\n  keyword you add atoms, one at a time, to the unit cell.  Its arguments\n  are fractional coordinates (0.0 <= x,y,z < 1.0).  The position vector\n  x of a basis atom within the unit cell is thus a linear combination of\n  the unit cell’s 3 edge vectors, i.e. x = bx a1 + by a2 + bz a3,\n  where bx,by,bz are the 3 values specified for the basis keyword.\n  \n  This sub-section discusses the arguments that determine how the\n  idealized unit cell is transformed into a lattice of points within the\n  simulation box.\n  The scale argument determines how the size of the unit cell will be\n  scaled when mapping it into the simulation box.  I.e. it determines a\n  multiplicative factor to apply to the unit cell, to convert it to a\n  lattice of the desired size and distance units in the simulation box.\n  The meaning of the scale argument depends on the units\n  being used in your simulation.\n  For all unit styles except lj, the scale argument is specified in\n  the distance units defined by the unit style.  For example, in real\n  or metal units, if the unit cell is a unit cube with edge length\n  1.0, specifying scale = 3.52 would create a cubic lattice with a\n  spacing of 3.52 Angstroms.  In cgs units, the spacing would be 3.52\n  cm.\n  For unit style lj, the scale argument is the Lennard-Jones reduced\n  density, typically written as rho*.  LAMMPS converts this value into\n  the multiplicative factor via the formula “factor^dim = rho/rho*”,\n  where rho = N/V with V = the volume of the lattice unit cell and N =\n  the number of basis atoms in the unit cell (described below), and dim\n  = 2 or 3 for the dimensionality of the simulation.  Effectively, this\n  means that if LJ particles of size sigma = 1.0 are used in the\n  simulation, the lattice of particles will be at the desired reduced\n  density.\n  The origin option specifies how the unit cell will be shifted or\n  translated when mapping it into the simulation box.  The x,y,z values\n  are fractional values (0.0 <= x,y,z < 1.0) meaning shift the lattice\n  by a fraction of the lattice spacing in each dimension.  The meaning\n  of “lattice spacing” is discussed below.\n  The orient option specifies how the unit cell will be rotated when\n  mapping it into the simulation box.  The dim argument is one of the\n  3 coordinate axes in the simulation box.  The other 3 arguments are\n  the crystallographic direction in the lattice that you want to orient\n  along that axis, specified as integers.  E.g. “orient x 2 1 0” means\n  the x-axis in the simulation box will be the [210] lattice\n  direction, and similarly for y and z.  The 3 lattice directions you\n  specify do not have to be unit vectors, but they must be mutually\n  orthogonal and obey the right-hand rule, i.e. (X cross Y) points in\n  the Z direction.\n  \n  Note\n  The preceding paragraph describing lattice directions is only\n  valid for orthogonal cubic unit cells (or square in 2d).  If you are\n  using a hcp or hex lattice or the more general lattice style\n  custom with non-orthogonal a1,a2,a3 vectors, then you should think\n  of the 3 orient vectors as creating a 3x3 rotation matrix which is\n  applied to a1,a2,a3 to rotate the original unit cell to a new\n  orientation in the simulation box.\n  \n  \n  Several LAMMPS commands have the option to use distance units that are\n  inferred from “lattice spacings” in the x,y,z box directions.\n  E.g. the region command can create a block of size\n  10x20x20, where 10 means 10 lattice spacings in the x direction.\n  \n  Note\n  Though they are called lattice spacings, all the commands that\n  have a “units lattice” option, simply use the 3 values as scale\n  factors on the distance units defined by the units\n  command.  Thus if you do not like the lattice spacings computed by\n  LAMMPS (e.g. for a non-orthogonal or rotated unit cell), you can\n  define the 3 values to be whatever you wish, via the spacing option.\n  \n  If the spacing option is not specified, the lattice spacings are\n  computed by LAMMPS in the following way.  A unit cell of the lattice\n  is mapped into the simulation box (scaled and rotated), so that it now\n  has (perhaps) a modified size and orientation.  The lattice spacing in\n  X is defined as the difference between the min/max extent of the x\n  coordinates of the 8 corner points of the modified unit cell (4 in\n  2d).  Similarly, the Y and Z lattice spacings are defined as the\n  difference in the min/max of the y and z coordinates.\n  Note that if the unit cell is orthogonal with axis-aligned edges (no\n  rotation via the orient keyword), then the lattice spacings in each\n  dimension are simply the scale factor (described above) multiplied by\n  the length of a1,a2,a3.  Thus a hex style lattice with a scale\n  factor of 3.0 Angstroms, would have a lattice spacing of 3.0 in x and\n  3*sqrt(3.0) in y.\n  \n  Note\n  For non-orthogonal unit cells and/or when a rotation is applied\n  via the orient keyword, then the lattice spacings computed by LAMMPS\n  are typically less intuitive.  In particular, in these cases, there is\n  no guarantee that a particular lattice spacing is an integer multiple\n  of the periodicity of the lattice in that direction.  Thus, if you\n  create an orthogonal periodic simulation box whose size in a dimension\n  is a multiple of the lattice spacing, and then fill it with atoms via\n  the create_atoms command, you will NOT necessarily\n  create a periodic system.  I.e. atoms may overlap incorrectly at the\n  faces of the simulation box.\n  \n  The spacing option sets the 3 lattice spacings directly.  All must\n  be non-zero (use 1.0 for dz in a 2d simulation).  The specified values\n  are multiplied by the multiplicative factor described above that is\n  associated with the scale factor.  Thus a spacing of 1.0 means one\n  unit cell edge length independent of the scale factor.  As mentioned\n  above, this option can be useful if the spacings LAMMPS computes are\n  inconvenient to use in subsequent commands, which can be the case for\n  non-orthogonal or rotated lattices.\n  Note that whenever the lattice command is used, the values of the\n  lattice spacings LAMMPS calculates are printed out.  Thus their effect\n  in commands that use the spacings should be decipherable.\n  \n  Example commands for generating a Wurtzite crystal (courtesy\n  of Aidan Thompson), with its 8 atom unit cell.\n  variable a equal  4.340330\n  variable b equal  $a*sqrt(3.0)\n  variable c equal  $a*sqrt(8.0/3.0)\n  \n  variable 1_3 equal 1.0/3.0\n  variable 2_3 equal 2.0/3.0\n  variable 1_6 equal 1.0/6.0\n  variable 5_6 equal 5.0/6.0\n  variable 1_12 equal 1.0/12.0\n  variable 5_12 equal 5.0/12.0\n  \n  lattice custom    1.0     &\n          a1      $a      0.0     0.0     &\n          a2      0.0     $b      0.0     &\n          a3      0.0     0.0     $c      &\n          basis   0.0     0.0     0.0     &\n          basis   0.5     0.5     0.0     &\n          basis   ${1_3}  0.0     0.5     &\n          basis   ${5_6}  0.5     0.5     &\n          basis   0.0     0.0     0.625   &\n          basis   0.5     0.5     0.625   &\n          basis   ${1_3}  0.0     0.125   &\n          basis   ${5_6}  0.5     0.125\n  \n  region myreg block 0 1 0 1 0 1\n  create_box      2 myreg\n  create_atoms    1 box      &\n          basis   5       2       &\n          basis   6       2       &\n          basis   7       2       &\n          basis   8       2\n  \n  \n  ",
    "syntax": "lattice style scale keyword values ...\n  \n  \n  \n  style = none or sc or bcc or fcc or hcp or diamond or         sq or sq2 or hex or custom\n  scale = scale factor between lattice and simulation box\n  scale = reduced density rho* (for LJ units)\n  scale = lattice constant in distance units (for all other units)\n  \n  zero or more keyword/value pairs may be appended\n  keyword = origin or orient or spacing or a1 or a2 or a3 or basis\n  origin values = x y z\n    x,y,z = fractions of a unit cell (0 <= x,y,z < 1)\n  orient values = dim i j k\n    dim = x or y or z\n    i,j,k = integer lattice directions\n  spacing values = dx dy dz\n    dx,dy,dz = lattice spacings in the x,y,z box directions\n  a1,a2,a3 values = x y z\n    x,y,z = primitive vector components that define unit cell\n  basis values = x y z\n    x,y,z = fractional coords of a basis atom (0 <= x,y,z < 1)\n  \n  \n  ",
    "examples": "lattice fcc 3.52\n  lattice hex 0.85\n  lattice sq 0.8 origin 0.0 0.5 0.0 orient x 1 1 0 orient y -1 1 0\n  lattice custom 3.52 a1 1.0 0.0 0.0 a2 0.5 1.0 0.0 a3 0.0 0.0 0.5 &\n                      basis 0.0 0.0 0.0 basis 0.5 0.5 0.5\n  lattice none 2.0\n  \n  \n  ",
    "restrictions": "The a1,a2,a3,basis keywords can only be used with style custom.\n  "
},
{
    "command": "log",
    "description": "This command closes the current LAMMPS log file, opens a new file with\n  the specified name, and begins logging information to it.  If the\n  specified file name is none, then no new log file is opened.  If the\n  optional keyword append is specified, then output will be appended\n  to an existing log file, instead of overwriting it.\n  If multiple processor partitions are being used, the file name should\n  be a variable, so that different processors do not attempt to write to\n  the same log file.\n  The file “log.lammps” is the default log file for a LAMMPS run.  The\n  name of the initial log file can also be set by the -log command-line switch.\n  ",
    "syntax": "log file keyword\n  \n  \n  \n  file = name of new logfile\n  keyword = append if output should be appended to logfile (optional)\n  \n  ",
    "examples": "log log.equil\n  log log.equil append\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  Related commands: none\n  "
},
{
    "command": "mass",
    "description": "Set the mass for all atoms of one or more atom types.  Per-type mass\n  values can also be set in the read_data data file\n  using the “Masses” keyword.  See the units command for\n  what mass units to use.\n  The I index can be specified in one of two ways.  An explicit numeric\n  value can be used, as in the 1st example above.  Or a wild-card\n  asterisk can be used to set the mass for multiple atom types.  This\n  takes the form “*” or “*n” or “n*” or “m*n”.  If N = the number of\n  atom types, then an asterisk with no numeric values means all types\n  from 1 to N.  A leading asterisk means all types from 1 to n\n  (inclusive).  A trailing asterisk means all types from n to N\n  (inclusive).  A middle asterisk means all types from m to n\n  (inclusive).\n  A line in a data file that follows the “Masses”\n  keyword specifies mass using the same format as the arguments of the\n  mass command in an input script, except that no wild-card asterisk can\n  be used.  For example, under the “Masses” section of a data file, the\n  line that corresponds to the 1st example above would be listed as\n  1 1.0\n  \n  \n  Note that the mass command can only be used if the atom style requires per-type atom mass to be set.\n  Currently, all but the sphere and ellipsoid and peri styles do.\n  They require mass to be set for individual particles, not types.\n  Per-atom masses are defined in the data file read by the\n  read_data command, or set to default values by the\n  create_atoms command.  Per-atom masses can also be\n  set to new values by the set mass or set density\n  commands.\n  Also note that pair_style eam and pair_style bop commands define the masses of atom types in their\n  respective potential files, in which case the mass command is normally\n  not used.\n  If you define a hybrid atom style which includes one\n  (or more) sub-styles which require per-type mass and one (or more)\n  sub-styles which require per-atom mass, then you must define both.\n  However, in this case the per-type mass will be ignored; only the\n  per-atom mass will be used by LAMMPS.\n  ",
    "syntax": "mass I value\n  \n  \n  \n  I = atom type (see asterisk form below)\n  value = mass\n  \n  ",
    "examples": "mass 1 1.0\n  mass * 62.5\n  mass 2* 62.5\n  \n  \n  ",
    "restrictions": "This command must come after the simulation box is defined by a\n  read_data, read_restart, or\n  create_box command.\n  All masses must be defined before a simulation is run.  They must also\n  all be defined before a velocity or fix shake command is used.\n  The mass assigned to any type or atom must be > 0.0.\n  Related commands: none\n  Default: none\n  "
},
{
    "command": "message",
    "description": "Establish a messaging protocol between LAMMPS and another code for the\n  purpose of client/server coupling.\n  The Howto client/server doc page gives an\n  overview of client/server coupling of LAMMPS with another code where\n  one code is the “client” and sends request messages to a “server”\n  code.  The server responds to each request with a reply message.  This\n  enables the two codes to work in tandem to perform a simulation.\n  \n  The which argument defines LAMMPS to be the client or the server.\n  As explained below the quit option should be used when LAMMPS is\n  finished as a client.  It sends a message to the server to tell it to\n  shut down.\n  \n  The protocol argument defines the format and content of messages\n  that will be exchanged between the two codes.  The current options\n  are:\n  \n  md = run dynamics with another code\n  mc = perform Monte Carlo moves with another code\n  \n  For protocol md, LAMMPS can be either a client or server.  See the\n  server md doc page for details on the protocol.\n  For protocol mc, LAMMPS can be the server.  See the server mc doc page for details on the protocol.\n  \n  The mode argument specifies how messages are exchanged between the\n  client and server codes.  Both codes must use the same mode and use\n  consistent parameters.\n  For mode file, the 2 codes communicate via binary files.  They must\n  use the same filename, which is actually a file prefix.  Several files\n  with that prefix will be created and deleted as a simulation runs.\n  The filename can include a path.  Both codes must be able to access\n  the path/file in a common filesystem.\n  For mode zmq, the 2 codes communicate via a socket on the server\n  code’s machine.  Support for socket messaging is provided by the\n  open-source ZeroMQ library, which must be\n  installed on your system.  The client specifies an IP address (IPv4\n  format) or the DNS name of the machine the server code is running on,\n  followed by a 4 or 5 digit port ID for the socket, separated by a colon.\n  E.g.\n  localhost:5555        # client and server running on same machine\n  192.168.1.1:5555      # server is 192.168.1.1\n  deptbox.uni.edu:5555  # server is deptbox.uni.edu\n  \n  \n  The server specifies “*:5555” where “*” represents all available\n  interfaces on the server’s machine, and the port ID must match\n  what the client specifies.\n  \n  Note\n  On Linux or Unix machines port IDs below 1024 are reserved to the\n  superuser and thus not available.  Other ports may already be in\n  use and cannot be opened by a second process.  On a Linux machine\n  the commands “netstat -t4an” or “ss -t4an” will list all locally\n  used port IDs for IPv4 addresses.\n  \n  \n  Note\n  On many machines (and sometimes on local networks) also ports IDs\n  may be blocked by default through firewalls.  In that case either\n  access to the required port (or a desired range of ports) has to\n  be selectively enabled to the firewall disabled (the latter is\n  usually not a good idea unless you are on a (small) local network\n  that is already protected from outside access.\n  \n  \n  Note\n  Additional explanation is needed here about how to use the zmq\n  mode on a parallel machine, e.g. a cluster with many nodes.\n  \n  For mode mpi/one, the 2 codes communicate via MPI and are launched\n  by the same mpirun command, e.g. with this syntax for OpenMPI:\n  mpirun -np 2 lmp_mpi -mpicolor 0 -in in.client -log log.client : -np 4 othercode args  # LAMMPS is client\n  mpirun -np 2 othercode args : -np 4 lmp_mpi -mpicolor 1 -in in.server  # LAMMPS is server\n  \n  \n  Note the use of the “-mpicolor color” command-line argument with\n  LAMMPS.  See the command-line args doc page for\n  further explanation.\n  For mode mpi/two, the 2 codes communicate via MPI, but are launched\n  be 2 separate mpirun commands.  The specified filename argument is a\n  file the 2 MPI processes will use to exchange info so that an MPI\n  inter-communicator can be established to enable the 2 codes to send\n  MPI messages to each other.  Both codes must be able to access the\n  path/file in a common filesystem.\n  \n  Normally, the message client or message server command should be used\n  at the top of a LAMMPS input script.  It performs an initial handshake\n  with the other code to setup messaging and to verify that both codes\n  are using the same message protocol and mode.  Assuming both codes are\n  launched at (nearly) the same time, the other code should perform the\n  same kind of initialization.\n  If LAMMPS is the client code, it will begin sending messages when a\n  LAMMPS client command begins its operation.  E.g. for the fix client/md command, it is when a run\n  command is executed.\n  If LAMMPS is the server code, it will begin receiving messages when\n  the server command is invoked.\n  If LAMMPS is being used as a client, the message quit command will\n  terminate its messaging with the server.  If you do not use this\n  command and just allow LAMMPS to exit, then the server will continue\n  to wait for further messages.  This may not be a problem, but if both\n  the client and server programs were launched in the same batch script,\n  then if the server runs indefinitely, it may consume the full allocation\n  of computer time, even if the calculation finishes sooner.\n  Note that if LAMMPS is the client or server, it will continue\n  processing the rest of its input script after client/server\n  communication terminates.\n  If both codes cooperate in this manner, a new round of client/server\n  messaging can be initiated after termination by re-using a 2nd message\n  command in your LAMMPS input script, followed by a new fix client or\n  server command, followed by another message quit command (if LAMMPS is\n  the client).  As an example, this can be performed in a loop to use a\n  quantum code as a server to compute quantum forces for multiple LAMMPS\n  data files or periodic snapshots while running dynamics.\n  ",
    "syntax": "message which protocol mode arg\n  \n  \n  \n  which = client or server or quit\n  protocol = md or mc\n  mode = file or zmq or mpi/one or mpi/two\n  file arg = filename\n    filename = file used for message exchanges\n  zmq arg = socket-ID\n    socket-ID for client = localhost:5555, see description below\n    socket-ID for server = *:5555, see description below\n  mpi/one arg = none\n  mpi/two arg = filename\n    filename = file used to establish communication between 2 MPI jobs\n  \n  \n  ",
    "examples": "message client md file tmp.couple\n  message server md file tmp.couple\n  \n  message client md zmq localhost:5555\n  message server md zmq \\*:5555\n  \n  message client md mpi/one\n  message server md mpi/one\n  \n  message client md mpi/two tmp.couple\n  message server md mpi/two tmp.couple\n  \n  message quit\n  \n  \n  ",
    "restrictions": "This command is part of the MESSAGE package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "min_modify",
    "description": "This command sets parameters that affect the energy minimization\n  algorithms selected by the min_style command.  The\n  various settings may affect the convergence rate and overall number of\n  force evaluations required by a minimization, so users can experiment\n  with these parameters to tune their minimizations.\n  The cg and sd minimization styles have an outer iteration and an\n  inner iteration which is steps along a one-dimensional line search in\n  a particular search direction.  The dmax parameter is how far any\n  atom can move in a single line search in any dimension (x, y, or z).\n  For the quickmin and fire minimization styles, the dmax setting\n  is how far any atom can move in a single iteration (timestep).  Thus a\n  value of 0.1 in real units means no atom will move\n  further than 0.1 Angstroms in a single outer iteration.  This prevents\n  highly overlapped atoms from being moved long distances (e.g. through\n  another atom) due to large forces.\n  The choice of line search algorithm for the cg and sd minimization\n  styles can be selected via the line keyword.  The default\n  quadratic line search algorithm starts out using the robust\n  backtracking method described below. However, once the system gets\n  close to a local minimum and the linesearch steps get small, so that\n  the energy is approximately quadratic in the step length, it uses the\n  estimated location of zero gradient as the linesearch step, provided\n  the energy change is downhill.  This becomes more efficient than\n  backtracking for highly-converged relaxations. The forcezero line\n  search algorithm is similar to quadratic.  It may be more\n  efficient than quadratic on some systems.\n  The backtracking search is robust and should always find a local\n  energy minimum.  However, it will “converge” when it can no longer\n  reduce the energy of the system.  Individual atom forces may still be\n  larger than desired at this point, because the energy change is\n  measured as the difference of two large values (energy before and\n  energy after) and that difference may be smaller than machine epsilon\n  even if atoms could move in the gradient direction to reduce forces\n  further.\n  The choice of a norm can be modified for the min styles cg, sd, quickmin, fire, fire/old, spin, spin/cg and\n  spin/lbfgs using the norm keyword.  The default two norm computes\n  the 2-norm (Euclidean length) of the global force vector:\n  \n  \\[|| \\vec{F} ||_{2} = \\sqrt{\\vec{F}_1+ \\cdots + \\vec{F}_N}\\]\n  The max norm computes the length of the 3-vector force\n  for each atom  (2-norm), and takes the maximum value of those across\n  all atoms\n  \n  \\[|| \\vec{F} ||_{max} = {\\rm max}\\left(||\\vec{F}_1||, \\cdots, ||\\vec{F}_N||\\right)\\]\n  The inf norm takes the maximum component across the forces of\n  all atoms in the system:\n  \n  \\[|| \\vec{F} ||_{inf} = {\\rm max}\\left(|F_1^1|, |F_1^2|, |F_1^3| \\cdots, |F_N^1|, |F_N^2|, |F_N^3|\\right)\\]\n  For the min styles spin, spin/cg and spin/lbfgs, the force\n  norm is replaced by the spin-torque norm.\n  Keywords alpha_damp and discrete_factor only make sense when\n  a min_spin command is declared.\n  Keyword alpha_damp defines an analog of a magnetic Gilbert\n  damping. It defines a relaxation rate toward an equilibrium for\n  a given magnetic system.\n  Keyword discrete_factor defines a discretization factor for the\n  adaptive timestep used in the spin minimization.\n  See min_spin for more information about those\n  quantities.\n  The choice of a line search algorithm for the spin/cg and\n  spin/lbfgs styles can be specified via the line keyword.  The\n  spin_cubic and spin_none keywords only make sense when one of those two\n  minimization styles is declared.  The spin_cubic performs the line\n  search based on a cubic interpolation of the energy along the search\n  direction. The spin_none keyword deactivates the line search\n  procedure.  The spin_none is a default value for line keyword for\n  both spin/lbfgs and spin/cg. Convergence of spin/lbfgs can be\n  more robust if spin_cubic line search is used.\n  The Newton integrator used for fire minimization can be selected\n  to be either the symplectic Euler (eulerimplicit) or velocity\n  Verlet (verlet).  tmax defines the maximum value for the\n  adaptive timestep during a fire minimization. It is a multiplication\n  factor applied to the current timestep (not in time\n  unit). For example, tmax = 4.0 with a timestep of\n  2fs, means that the maximum value the timestep can reach during a fire\n  minimization is 4fs.\n  Note that parameter defaults has been chosen to be reliable in most cases,\n  but one should consider adjusting timestep and tmax to\n  optimize the minimization for large or complex systems.  Other\n  parameters of the fire minimization can be tuned (tmin,\n  delaystep, dtgrow, dtshrink, alpha0, and\n  alphashrink). Please refer to the references describing the\n  min_style fire.\n  An additional stopping criteria vdfmax is used by fire in order to avoid\n  unnecessary looping when it is reasonable to think the system will not\n  be relaxed further.  Note that in this case the system will NOT have\n  reached your minimization criteria. This could happen when the system\n  comes to be stuck in a local basin of the phase space.  vdfmax is\n  the maximum number of consecutive iterations with P(t) < 0.\n  The min_style fire is an optimized implementation of\n  min_style fire/old. It can however behave similarly\n  to the fire/old style by using the following set of parameters:\n  min_modify integrator eulerexplicit tmax 10.0 tmin 0.0 delaystep 5 &\n            dtgrow 1.1 dtshrink 0.5 alpha0 0.1 alphashrink 0.99 &\n            vdfmax 100000 halfstepback no initialdelay no\n  \n  \n  ",
    "syntax": "min_modify keyword values ...\n  \n  \n  \n  one or more keyword/value pairs may be listed\n  keyword = dmax or line or norm or alpha_damp or discrete_factor or integrator or tmax\n    dmax value = max\n      max = maximum distance for line search to move (distance units)\n    line value = backtrack or quadratic or forcezero or spin_cubic or spin_none\n      backtrack,quadratic,forcezero,spin_cubic,spin_none = style of linesearch to use\n    norm value = two or max\n      two = Euclidean two-norm (length of 3N vector)\n      inf = max force component across all 3-vectors\n      max = max force norm across all 3-vectors\n    alpha_damp value = damping\n      damping = fictitious Gilbert damping for spin minimization (adim)\n    discrete_factor value = factor\n      factor = discretization factor for adaptive spin timestep (adim)\n    integrator value = eulerimplicit or verlet\n      time integration scheme for fire minimization\n    tmax value = factor\n      factor = maximum adaptive timestep for fire minimization (adim)\n  \n  \n  ",
    "examples": "min_modify dmax 0.2\n  min_modify integrator verlet tmax 4\n  \n  \n  ",
    "restrictions": "For magnetic GNEB calculations, only spin_none value for line\n  keyword can be used when minimization styles spin/cg and spin/lbfgs are\n  employed.  See neb/spin for more explanation.\n  "
},
{
    "command": "min_style spin",
    "description": "Apply a minimization algorithm to use when a minimize\n  command is performed.\n  Style spin defines a damped spin dynamics with an adaptive\n  timestep, according to:\n  \n  \\[\\frac{d \\vec{s}_{i}}{dt} = \\lambda\\, \\vec{s}_{i} \\times\\left( \\vec{\\omega}_{i} \\times\\vec{s}_{i} \\right)\\]\n  with \\(\\lambda\\) a damping coefficient (similar to a Gilbert\n  damping). \\(\\lambda\\) can be defined by setting the\n  alpha_damp keyword with the min_modify command.\n  The minimization procedure solves this equation using an\n  adaptive timestep. The value of this timestep is defined\n  by the largest precession frequency that has to be solved in the\n  system:\n  \n  \\[{\\Delta t}_{\\rm max} = \\frac{2\\pi}{\\kappa \\left|\\vec{\\omega}_{\\rm max} \\right|}\\]\n  with \\(\\left|\\vec{\\omega}_{\\rm max}\\right|\\) the norm of the largest precession\n  frequency in the system (across all processes, and across all replicas if a\n  spin/neb calculation is performed).\n  \\(\\kappa\\) defines a discretization factor discrete_factor for\n  the definition of this timestep.  discrete_factor can be defined with\n  the min_modify command.\n  Style spin/cg defines an orthogonal spin optimization\n  (OSO) combined to a conjugate gradient (CG) algorithm.\n  The min_modify command can be used to\n  couple the spin/cg to a line search procedure, and to modify the\n  discretization factor discrete_factor.\n  By default, style spin/cg does not employ the line search procedure\n  and uses the adaptive time-step technique in the same way as style spin.\n  Style spin/lbfgs defines an orthogonal spin optimization (OSO)\n  combined to a limited-memory Broyden-Fletcher-Goldfarb-Shanno (L-BFGS)\n  algorithm.  By default, style spin/lbfgs does not employ line search\n  procedure.  If the line search procedure is not used then the discrete\n  factor defines the maximum root mean squared rotation angle of spins by\n  equation pi/(5*Kappa).  The default value for Kappa is 10.  The\n  spin_cubic line search option can improve the convergence of the\n  spin/lbfgs algorithm.\n  The min_modify command can be used to\n  activate the line search procedure, and to modify the\n  discretization factor discrete_factor.\n  For more information about styles spin/cg and spin/lbfgs,\n  see their implementation reported in (Ivanov).\n  \n  Note\n  All the spin styles replace the force tolerance by a torque\n  tolerance. See minimize for more explanation.\n  \n  \n  Note\n  The spin/cg and spin/lbfgs styles can be used\n  for magnetic NEB calculations only if the line search procedure\n  is deactivated. See neb/spin for more explanation.\n  \n  ",
    "syntax": "min_style spin\n  min_style spin/cg\n  min_style spin/lbfgs\n  \n  \n  ",
    "examples": "min_style  spin/lbfgs\n  min_modify line spin_cubic discrete_factor 10.0\n  \n  \n  ",
    "restrictions": "This minimization procedure is only applied to spin degrees of\n  freedom for a frozen lattice configuration.\n  "
},
{
    "command": "min_style",
    "description": "Choose a minimization algorithm to use when a minimize command is performed.\n  Style cg is the Polak-Ribiere version of the conjugate gradient (CG)\n  algorithm.  At each iteration the force gradient is combined with the\n  previous iteration information to compute a new search direction\n  perpendicular (conjugate) to the previous search direction.  The PR\n  variant affects how the direction is chosen and how the CG method is\n  restarted when it ceases to make progress.  The PR variant is thought\n  to be the most effective CG choice for most problems.\n  Style hftn is a Hessian-free truncated Newton algorithm.  At each\n  iteration a quadratic model of the energy potential is solved by a\n  conjugate gradient inner iteration.  The Hessian (second derivatives)\n  of the energy is not formed directly, but approximated in each\n  conjugate search direction by a finite difference directional\n  derivative.  When close to an energy minimum, the algorithm behaves\n  like a Newton method and exhibits a quadratic convergence rate to high\n  accuracy.  In most cases the behavior of hftn is similar to cg,\n  but it offers an alternative if cg seems to perform poorly.  This\n  style is not affected by the min_modify command.\n  Style sd is a steepest descent algorithm.  At each iteration, the\n  search direction is set to the downhill direction corresponding to the\n  force vector (negative gradient of energy).  Typically, steepest\n  descent will not converge as quickly as CG, but may be more robust in\n  some situations.\n  Style quickmin is a damped dynamics method described in\n  (Sheppard), where the damping parameter is related\n  to the projection of the velocity vector along the current force\n  vector for each atom.  The velocity of each atom is initialized to 0.0\n  by this style, at the beginning of a minimization.\n  Style fire is a damped dynamics method described in (Bitzek), which is similar to quickmin but adds a variable timestep\n  and alters the projection operation to maintain components of the\n  velocity non-parallel to the current force vector.  The velocity of\n  each atom is initialized to 0.0 by this style, at the beginning of a\n  minimization. This style correspond to an optimized version described\n  in (Guenole) that include different time integration\n  schemes and defaults parameters. The default parameters can be\n  modified with the command min_modify.\n  Style fire/old is the original implementation of fire in Lammps,\n  conserved for backward compatibility. The main differences regarding\n  the current version fire are: time integration by Explicit Euler\n  only, different sequence in maintaining velocity components non-parallel\n  to the current force vector and hard-coded minimization parameters.\n  A complete description of the differences between fire/old and fire\n  can be found in (Guenole) (where the current fire\n  in LAMMPS is called fire2.0). By using an appropriate set of\n  parameters, fire can behave similar to fire/old, as described\n  in the min_modify command.\n  Style spin is a damped spin dynamics with an adaptive timestep.\n  Style spin/cg uses an orthogonal spin optimization (OSO) combined to\n  a conjugate gradient (CG) approach to minimize spin configurations.\n  Style spin/lbfgs uses an orthogonal spin optimization (OSO) combined\n  to a limited-memory Broyden-Fletcher-Goldfarb-Shanno (LBFGS) approach\n  to minimize spin configurations.\n  See the min/spin doc page for more information about\n  the spin, spin/cg and spin/lbfgs styles.\n  Either the quickmin, fire and fire/old styles are useful in the\n  context of nudged elastic band (NEB) calculations via the neb command.\n  Either the spin, spin/cg and spin/lbfgs styles are useful in\n  the context of magnetic geodesic nudged elastic band (GNEB)\n  calculations via the neb/spin command.\n  \n  Note\n  The damped dynamic minimizers use whatever timestep you have\n  defined via the timestep command.  Often they\n  will converge more quickly if you use a timestep about 10x larger\n  than you would normally use for dynamics simulations.\n  For fire, the default timestep is recommended to be equal to\n  the one you would normally use for dynamics simulations.\n  \n  \n  Note\n  The quickmin, fire, fire/old, hftn, and cg/kk styles do not yet\n  support the use of the fix box/relax command\n  or minimizations involving the electron radius in eFF models.\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages\n  doc page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix\n  command-line switch when you invoke LAMMPS, or you can\n  use the suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "min_style style\n  \n  \n  \n  style = cg or hftn or sd or quickmin or fire or fire/old or spin or spin/cg or spin/lbfgs\n  \n  ",
    "examples": "min_style cg\n  min_style spin\n  min_style fire\n  \n  \n  ",
    "restrictions": "none\n  "
},
{
    "command": "minimize",
    "description": "Perform an energy minimization of the system, by iteratively adjusting\n  atom coordinates.  Iterations are terminated when one of the stopping\n  criteria is satisfied.  At that point the configuration will hopefully\n  be in local potential energy minimum.  More precisely, the\n  configuration should approximate a critical point for the objective\n  function (see below), which may or may not be a local minimum.\n  The minimization algorithm used is set by the\n  min_style command.  Other options are set by the\n  min_modify command.  Minimize commands can be\n  interspersed with run commands to alternate between\n  relaxation and dynamics.  The minimizers bound the distance atoms move\n  in one iteration, so that you can relax systems with highly overlapped\n  atoms (large energies and forces) by pushing the atoms off of each\n  other.\n  Alternate means of relaxing a system are to run dynamics with a small\n  or limited timestep.  Or dynamics can be run\n  using fix viscous to impose a damping force that\n  slowly drains all kinetic energy from the system.  The pair_style soft potential can be used to un-overlap atoms while\n  running dynamics.\n  un-overlap atoms while running dynamics.\n  Note that you can minimize some atoms in the system while holding the\n  coordinates of other atoms fixed by applying fix setforce to the other atoms.  See a fuller discussion of using\n  fixes while minimizing below.\n  The minimization styles cg, sd, and hftn\n  involves an outer iteration loop which sets the search direction along\n  which atom coordinates are changed.  An inner iteration is then\n  performed using a line search algorithm.  The line search typically\n  evaluates forces and energies several times to set new coordinates.\n  Currently, a backtracking algorithm is used which may not be optimal\n  in terms of the number of force evaluations performed, but appears to\n  be more robust than previous line searches we’ve tried.  The\n  backtracking method is described in Nocedal and Wright’s Numerical\n  Optimization (Procedure 3.1 on p 41).\n  The minimization styles quickmin, fire and\n  fire/old perform damped dynamics using an Euler integration step.  Thus\n  they require a timestep be defined.\n  \n  Note\n  The damped dynamic minimizers use whatever timestep you have\n  defined via the timestep command.  Often they\n  will converge more quickly if you use a timestep about 10x larger\n  than you would normally use for dynamics simulations.\n  \n  \n  In all cases, the objective function being minimized is the total\n  potential energy of the system as a function of the N atom\n  coordinates:\n  \n  \\[\\begin{split}E(r_1,r_2, \\ldots ,r_N)  = & \\sum_{i,j} E_{\\it pair}(r_i,r_j) +\n                               \\sum_{ij} E_{\\it bond}(r_i,r_j) +\n                               \\sum_{ijk} E_{\\it angle}(r_i,r_j,r_k) + \\\\\n                             & \\sum_{ijkl} E_{\\it dihedral}(r_i,r_j,r_k,r_l) +\n                               \\sum_{ijkl} E_{\\it improper}(r_i,r_j,r_k,r_l) +\n                               \\sum_i E_{\\it fix}(r_i)\\end{split}\\]\n  where the first term is the sum of all non-bonded pairwise\n  interactions including long-range Coulombic\n  interactions, the 2nd through 5th terms are bond, angle, dihedral, and improper interactions\n  respectively, and the last term is energy due to fixes\n  which can act as constraints or apply force to atoms, such as through\n  interaction with a wall.  See the discussion below about how fix\n  commands affect minimization.\n  The starting point for the minimization is the current configuration\n  of the atoms.\n  \n  The minimization procedure stops if any of several criteria are met:\n  \n  the change in energy between outer iterations is less than etol\n  the 2-norm (length) of the global force vector is less than the ftol\n  the line search fails because the step distance backtracks to 0.0\n  the number of outer iterations or timesteps exceeds maxiter\n  the number of total force evaluations exceeds maxeval\n  \n  \n  Note\n  the minimization style spin,\n  spin/cg, and spin/lbfgs replace\n  the force tolerance ftol by a torque tolerance.\n  The minimization procedure stops if the 2-norm (length) of the torque vector on atom\n  (defined as the cross product between the\n  atomic spin and its precession vectors omega) is less than ftol,\n  or if any of the other criteria are met. Torque have the same units as the energy.\n  \n  \n  Note\n  You can also use the fix halt command to specify\n  a general criterion for exiting a minimization, that is a\n  calculation performed on the state of the current system, as\n  defined by an equal-style variable.\n  \n  For the first criterion, the specified energy tolerance etol is\n  unitless; it is met when the energy change between successive\n  iterations divided by the energy magnitude is less than or equal to\n  the tolerance.  For example, a setting of 1.0e-4 for etol means an\n  energy tolerance of one part in 10^4.  For the damped dynamics\n  minimizers this check is not performed for a few steps after\n  velocities are reset to 0, otherwise the minimizer would prematurely\n  converge.\n  For the second criterion, the specified force tolerance ftol is in\n  force units, since it is the length of the global force vector for all\n  atoms, e.g. a vector of size 3N for N atoms.  Since many of the\n  components will be near zero after minimization, you can think of\n  ftol as an upper bound on the final force on any component of any\n  atom.  For example, a setting of 1.0e-4 for ftol means no x, y, or z\n  component of force on any atom will be larger than 1.0e-4 (in force\n  units) after minimization.\n  Either or both of the etol and ftol values can be set to 0.0, in\n  which case some other criterion will terminate the minimization.\n  During a minimization, the outer iteration count is treated as a\n  timestep.  Output is triggered by this timestep, e.g. thermodynamic\n  output or dump and restart files.\n  Using the thermo_style custom command with the\n  fmax or fnorm keywords can be useful for monitoring the progress\n  of the minimization.  Note that these outputs will be calculated only\n  from forces on the atoms, and will not include any extra degrees of\n  freedom, such as from the fix box/relax command.\n  Following minimization, a statistical summary is printed that lists\n  which convergence criterion caused the minimizer to stop, as well as\n  information about the energy, force, final line search, and iteration\n  counts.  An example is as follows:\n  Minimization stats:\n    Stopping criterion = max iterations\n    Energy initial, next-to-last, final =\n         -0.626828169302     -2.82642039062     -2.82643549739\n    Force two-norm initial, final = 2052.1 91.9642\n    Force max component initial, final = 346.048 9.78056\n    Final line search alpha, max atom move = 2.23899e-06 2.18986e-05\n    Iterations, force evaluations = 2000 12724\n  \n  \n  The 3 energy values are for before and after the minimization and on\n  the next-to-last iteration.  This is what the etol parameter checks.\n  The two-norm force values are the length of the global force vector\n  before and after minimization.  This is what the ftol parameter\n  checks.\n  The max-component force values are the absolute value of the largest\n  component (x,y,z) in the global force vector, i.e. the infinity-norm\n  of the force vector.\n  The alpha parameter for the line-search, when multiplied by the max\n  force component (on the last iteration), gives the max distance any\n  atom moved during the last iteration.  Alpha will be 0.0 if the line\n  search could not reduce the energy.  Even if alpha is non-zero, if the\n  “max atom move” distance is tiny compared to typical atom coordinates,\n  then it is possible the last iteration effectively caused no atom\n  movement and thus the evaluated energy did not change and the\n  minimizer terminated.  Said another way, even with non-zero forces,\n  it’s possible the effect of those forces is to move atoms a distance\n  less than machine precision, so that the energy cannot be further\n  reduced.\n  The iterations and force evaluation values are what is checked by the\n  maxiter and maxeval parameters.\n  \n  \n  Note\n  There are several force fields in LAMMPS which have\n  discontinuities or other approximations which may prevent you from\n  performing an energy minimization to high tolerances.  For example,\n  you should use a pair style that goes to 0.0 at the\n  cutoff distance when performing minimization (even if you later change\n  it when running dynamics).  If you do not do this, the total energy of\n  the system will have discontinuities when the relative distance\n  between any pair of atoms changes from cutoff+epsilon to\n  cutoff-epsilon and the minimizer may behave poorly.  Some of the\n  many-body potentials use splines and other internal cutoffs that\n  inherently have this problem.  The long-range Coulombic styles (PPPM, Ewald) are approximate to within the\n  user-specified tolerance, which means their energy and forces may not\n  agree to a higher precision than the Kspace-specified tolerance.  In\n  all these cases, the minimizer may give up and stop before finding a\n  minimum to the specified energy or force tolerance.\n  \n  Note that a cutoff Lennard-Jones potential (and others) can be shifted\n  so that its energy is 0.0 at the cutoff via the\n  pair_modify command.  See the doc pages for\n  individual pair styles for details.  Note that\n  Coulombic potentials always have a cutoff, unless versions with a\n  long-range component are used (e.g. pair_style lj/cut/coul/long).  The CHARMM potentials go to 0.0 at\n  the cutoff (e.g. pair_style lj/charmm/coul/charmm),\n  as do the GROMACS potentials (e.g. pair_style lj/gromacs).\n  If a soft potential (pair_style soft) is used the\n  Astop value is used for the prefactor (no time dependence).\n  The fix box/relax command can be used to apply an\n  external pressure to the simulation box and allow it to shrink/expand\n  during the minimization.\n  Only a few other fixes (typically those that add forces) are invoked\n  during minimization.  See the doc pages for individual fix\n  commands to see which ones are relevant.  Current examples of fixes\n  that can be used include:\n  \n  fix addforce\n  fix addtorque\n  fix efield\n  fix enforce2d\n  fix indent\n  fix lineforce\n  fix planeforce\n  fix setforce\n  fix spring\n  fix spring/self\n  fix viscous\n  fix wall\n  fix wall/region\n  \n  \n  Note\n  Some fixes which are invoked during minimization have an\n  associated potential energy.  For that energy to be included in the\n  total potential energy of the system (the quantity being minimized),\n  you MUST enable the fix_modify energy option for\n  that fix.  The doc pages for individual fix commands\n  specify if this should be done.\n  \n  \n  Note\n  The minimizers in LAMMPS do not allow for bonds (or angles, etc)\n  to be held fixed while atom coordinates are being relaxed, e.g. via\n  fix shake or fix rigid.  See more\n  info in the Restrictions section below.\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "minimize etol ftol maxiter maxeval\n  \n  \n  \n  etol = stopping tolerance for energy (unitless)\n  ftol = stopping tolerance for force (force units)\n  maxiter = max iterations of minimizer\n  maxeval = max number of force/energy evaluations\n  \n  ",
    "examples": "minimize 1.0e-4 1.0e-6 100 1000\n  minimize 0.0 1.0e-8 1000 100000\n  \n  \n  ",
    "restrictions": "Features that are not yet implemented are listed here, in case someone\n  knows how they could be coded:\n  It is an error to use fix shake with minimization\n  because it turns off bonds that should be included in the potential\n  energy of the system.  The effect of a fix shake can be approximated\n  during a minimization by using stiff spring constants for the bonds\n  and/or angles that would normally be constrained by the SHAKE\n  algorithm.\n  Fix rigid is also not supported by minimization.  It\n  is not an error to have it defined, but the energy minimization will\n  not keep the defined body(s) rigid during the minimization.  Note that\n  if bonds, angles, etc internal to a rigid body have been turned off\n  (e.g. via neigh_modify exclude), they will not\n  contribute to the potential energy which is probably not what is\n  desired.\n  Pair potentials that produce torque on a particle (e.g. granular potentials or the GayBerne potential for ellipsoidal particles) are not\n  relaxed by a minimization.  More specifically, radial relaxations are\n  induced, but no rotations are induced by a minimization, so such a\n  system will not fully relax.\n  "
},
{
    "command": "molecule",
    "description": "Define a molecule template that can be used as part of other LAMMPS\n  commands, typically to define a collection of particles as a bonded\n  molecule or a rigid body.  Commands that currently use molecule\n  templates include:\n  \n  fix deposit\n  fix pour\n  fix rigid/small\n  fix shake\n  fix gcmc\n  fix bond/react\n  create_atoms\n  atom_style template\n  \n  The ID of a molecule template can only contain alphanumeric characters\n  and underscores.\n  A single template can contain multiple molecules, listed one per file.\n  Some of the commands listed above currently use only the first\n  molecule in the template, and will issue a warning if the template\n  contains multiple molecules.  The atom_style template command allows multiple-molecule templates\n  to define a system with more than one templated molecule.\n  Each filename can be followed by optional keywords which are applied\n  only to the molecule in the file as used in this template.  This is to\n  make it easy to use the same molecule file in different molecule\n  templates or in different simulations.  You can specify the same file\n  multiple times with different optional keywords.\n  The offset, toff, aoff, doff, ioff keywords add the\n  specified offset values to the atom types, bond types, angle types,\n  dihedral types, and/or improper types as they are read from the\n  molecule file.  E.g. if toff = 2, and the file uses atom types\n  1,2,3, then each created molecule will have atom types 3,4,5.  For the\n  offset keyword, all five offset values must be specified, but\n  individual values will be ignored if the molecule template does not\n  use that attribute (e.g. no bonds).\n  The scale keyword scales the size of the molecule.  This can be\n  useful for modeling polydisperse granular rigid bodies.  The scale\n  factor is applied to each of these properties in the molecule file, if\n  they are defined: the individual particle coordinates (Coords\n  section), the individual mass of each particle (Masses section), the\n  individual diameters of each particle (Diameters section), the total\n  mass of the molecule (header keyword = mass), the center-of-mass of\n  the molecule (header keyword = com), and the moments of inertia of the\n  molecule (header keyword = inertia).\n  \n  Note\n  The molecule command can be used to define molecules with bonds,\n  angles, dihedrals, impropers, or special bond lists of neighbors\n  within a molecular topology, so that you can later add the molecules\n  to your simulation, via one or more of the commands listed above.\n  Since this topology-related information requires that suitable storage\n  is reserved when LAMMPS creates the simulation box (e.g. when using\n  the create_box command or the\n  read_data command) suitable space has to be reserved\n  so you do not overflow those pre-allocated data structures when adding\n  molecules later.  Both the create_box command and\n  the read_data command have “extra” options which\n  insure space is allocated for storing topology info for molecules that\n  are added later.\n  \n  The format of an individual molecule file is similar but\n  (not identical) to the data file read by the read_data\n  commands, and is as follows.\n  A molecule file has a header and a body.  The header appears first.\n  The first line of the header is always skipped; it typically contains\n  a description of the file.  Then lines are read one at a time.  Lines\n  can have a trailing comment starting with ‘#’ that is ignored.  If the\n  line is blank (only white-space after comment is deleted), it is\n  skipped.  If the line contains a header keyword, the corresponding\n  value(s) is read from the line.  If it does not contain a header\n  keyword, the line begins the body of the file.\n  The body of the file contains zero or more sections.  The first line\n  of a section has only a keyword.  The next line is skipped.  The\n  remaining lines of the section contain values.  The number of lines\n  depends on the section keyword as described below.  Zero or more blank\n  lines can be used between sections.  Sections can appear in any order,\n  with a few exceptions as noted below.\n  These are the recognized header keywords.  Header lines can come in\n  any order.  The numeric value(s) are read from the beginning of the\n  line.  The keyword should appear at the end of the line.  All these\n  settings have default values, as explained below.  A line need only\n  appear if the value(s) are different than the default.\n  \n  N atoms = # of atoms N in molecule, default = 0\n  Nb bonds = # of bonds Nb in molecule, default = 0\n  Na angles = # of angles Na in molecule, default = 0\n  Nd dihedrals = # of dihedrals Nd in molecule, default = 0\n  Ni impropers = # of impropers Ni in molecule, default = 0\n  Nf fragments = # of fragments in molecule, default = 0\n  Mtotal mass = total mass of molecule\n  Xc Yc Zc com = coordinates of center-of-mass of molecule\n  Ixx Iyy Izz Ixy Ixz Iyz inertia = 6 components of inertia tensor of molecule\n  \n  For mass, com, and inertia, the default is for LAMMPS to\n  calculate this quantity itself if needed, assuming the molecules\n  consists of a set of point particles or finite-size particles (with a\n  non-zero diameter) that do not overlap.  If finite-size particles in\n  the molecule do overlap, LAMMPS will not account for the overlap\n  effects when calculating any of these 3 quantities, so you should\n  pre-compute them yourself and list the values in the file.\n  The mass and center-of-mass coordinates (Xc,Yc,Zc) are\n  self-explanatory.  The 6 moments of inertia (ixx,iyy,izz,ixy,ixz,iyz)\n  should be the values consistent with the current orientation of the\n  rigid body around its center of mass.  The values are with respect to\n  the simulation box XYZ axes, not with respect to the principal axes of\n  the rigid body itself.  LAMMPS performs the latter calculation\n  internally.\n  These are the allowed section keywords for the body of the file.\n  \n  Coords, Types, Molecules, Fragments, Charges, Diameters, Masses = atom-property sections\n  Bonds, Angles, Dihedrals, Impropers = molecular topology sections\n  Special Bond Counts, Special Bonds = special neighbor info\n  Shake Flags, Shake Atoms, Shake Bond Types = SHAKE info\n  \n  If a Bonds section is specified then the Special Bond Counts and\n  Special Bonds sections can also be used, if desired, to explicitly\n  list the 1-2, 1-3, 1-4 neighbors within the molecule topology (see\n  details below).  This is optional since if these sections are not\n  included, LAMMPS will auto-generate this information.  Note that\n  LAMMPS uses this info to properly exclude or weight bonded pairwise\n  interactions between bonded atoms.  See the\n  special_bonds command for more details.  One\n  reason to list the special bond info explicitly is for the\n  thermalized Drude oscillator model which treats the\n  bonds between nuclear cores and Drude electrons in a different manner.\n  \n  Note\n  Whether a section is required depends on how the molecule\n  template is used by other LAMMPS commands.  For example, to add a\n  molecule via the fix deposit command, the Coords\n  and Types sections are required.  To add a rigid body via the fix pour command, the Bonds (Angles, etc) sections are not\n  required, since the molecule will be treated as a rigid body.  Some\n  sections are optional.  For example, the fix pour\n  command can be used to add “molecules” which are clusters of\n  finite-size granular particles.  If the Diameters section is not\n  specified, each particle in the molecule will have a default diameter\n  of 1.0.  See the doc pages for LAMMPS commands that use molecule\n  templates for more details.\n  \n  Each section is listed below in alphabetic order.  The format of each\n  section is described including the number of lines it must contain and\n  rules (if any) for whether it can appear in the data file.  In each\n  case the ID is ignored; it is simply included for readability, and\n  should be a number from 1 to Nlines for the section, indicating which\n  atom (or bond, etc) the entry applies to.  The lines are assumed to be\n  listed in order from 1 to Nlines, but LAMMPS does not check for this.\n  \n  Coords section:\n  \n  one line per atom\n  line syntax: ID x y z\n  x,y,z = coordinate of atom\n  \n  \n  Types section:\n  \n  one line per atom\n  line syntax: ID type\n  type = atom type of atom\n  \n  \n  Molecules section:\n  \n  one line per atom\n  line syntax: ID molecule-ID\n  molecule-ID = molecule ID of atom\n  \n  \n  Fragments section:\n  \n  one line per fragment\n  line syntax: ID a b c d …\n  a,b,c,d,… = IDs of atoms in fragment\n  \n  The ID of a fragment can only contain alphanumeric characters and\n  underscores.  The atom IDs should be values from 1 to Natoms, where\n  Natoms = # of atoms in the molecule.\n  \n  Charges section:\n  \n  one line per atom\n  line syntax: ID q\n  q = charge on atom\n  \n  This section is only allowed for atom styles that\n  support charge.  If this section is not included, the default charge\n  on each atom in the molecule is 0.0.\n  \n  Diameters section:\n  \n  one line per atom\n  line syntax: ID diam\n  diam = diameter of atom\n  \n  This section is only allowed for atom styles that\n  support finite-size spherical particles, e.g. atom_style sphere.  If\n  not listed, the default diameter of each atom in the molecule is 1.0.\n  \n  Masses section:\n  \n  one line per atom\n  line syntax: ID mass\n  mass = mass of atom\n  \n  This section is only allowed for atom styles that\n  support per-atom mass, as opposed to per-type mass.  See the\n  mass command for details.  If this section is not\n  included, the default mass for each atom is derived from its volume\n  (see Diameters section) and a default density of 1.0, in\n  units of mass/volume.\n  \n  Bonds section:\n  \n  one line per bond\n  line syntax: ID type atom1 atom2\n  type = bond type (1-Nbondtype)\n  atom1,atom2 = IDs of atoms in bond\n  \n  The IDs for the two atoms in each bond should be values\n  from 1 to Natoms, where Natoms = # of atoms in the molecule.\n  \n  Angles section:\n  \n  one line per angle\n  line syntax: ID type atom1 atom2 atom3\n  type = angle type (1-Nangletype)\n  atom1,atom2,atom3 = IDs of atoms in angle\n  \n  The IDs for the three atoms in each angle should be values from 1 to\n  Natoms, where Natoms = # of atoms in the molecule.  The 3 atoms are\n  ordered linearly within the angle.  Thus the central atom (around\n  which the angle is computed) is the atom2 in the list.\n  \n  Dihedrals section:\n  \n  one line per dihedral\n  line syntax: ID type atom1 atom2 atom3 atom4\n  type = dihedral type (1-Ndihedraltype)\n  atom1,atom2,atom3,atom4 = IDs of atoms in dihedral\n  \n  The IDs for the four atoms in each dihedral should be values from 1 to\n  Natoms, where Natoms = # of atoms in the molecule.  The 4 atoms are\n  ordered linearly within the dihedral.\n  \n  Impropers section:\n  \n  one line per improper\n  line syntax: ID type atom1 atom2 atom3 atom4\n  type = improper type (1-Nimpropertype)\n  atom1,atom2,atom3,atom4 = IDs of atoms in improper\n  \n  The IDs for the four atoms in each improper should be values from 1 to\n  Natoms, where Natoms = # of atoms in the molecule.  The ordering of\n  the 4 atoms determines the definition of the improper angle used in\n  the formula for the defined improper style.  See\n  the doc pages for individual styles for details.\n  \n  Special Bond Counts section:\n  \n  one line per atom\n  line syntax: ID N1 N2 N3\n  N1 = # of 1-2 bonds\n  N2 = # of 1-3 bonds\n  N3 = # of 1-4 bonds\n  \n  N1, N2, N3 are the number of 1-2, 1-3, 1-4 neighbors respectively of\n  this atom within the topology of the molecule.  See the\n  special_bonds doc page for more discussion of\n  1-2, 1-3, 1-4 neighbors.  If this section appears, the Special Bonds\n  section must also appear.\n  As explained above, LAMMPS will auto-generate this information if this\n  section is not specified.  If specified, this section will\n  override what would be auto-generated.\n  \n  Special Bonds section:\n  \n  one line per atom\n  line syntax: ID a b c d …\n  a,b,c,d,… = IDs of atoms in N1+N2+N3 special bonds\n  \n  A, b, c, d, etc are the IDs of the n1+n2+n3 atoms that are 1-2, 1-3,\n  1-4 neighbors of this atom.  The IDs should be values from 1 to\n  Natoms, where Natoms = # of atoms in the molecule.  The first N1\n  values should be the 1-2 neighbors, the next N2 should be the 1-3\n  neighbors, the last N3 should be the 1-4 neighbors.  No atom ID should\n  appear more than once.  See the special_bonds doc\n  page for more discussion of 1-2, 1-3, 1-4 neighbors.  If this section\n  appears, the Special Bond Counts section must also appear.\n  As explained above, LAMMPS will auto-generate this information if this\n  section is not specified.  If specified, this section will override\n  what would be auto-generated.\n  \n  Shake Flags section:\n  \n  one line per atom\n  line syntax: ID flag\n  flag = 0,1,2,3,4\n  \n  This section is only needed when molecules created using the template\n  will be constrained by SHAKE via the “fix shake” command.  The other\n  two Shake sections must also appear in the file, following this one.\n  The meaning of the flag for each atom is as follows.  See the fix shake doc page for a further description of SHAKE\n  clusters.\n  \n  0 = not part of a SHAKE cluster\n  1 = part of a SHAKE angle cluster (two bonds and the angle they form)\n  2 = part of a 2-atom SHAKE cluster with a single bond\n  3 = part of a 3-atom SHAKE cluster with two bonds\n  4 = part of a 4-atom SHAKE cluster with three bonds\n  \n  \n  Shake Atoms section:\n  \n  one line per atom\n  line syntax: ID a b c d\n  a,b,c,d = IDs of atoms in cluster\n  \n  This section is only needed when molecules created using the template\n  will be constrained by SHAKE via the “fix shake” command.  The other\n  two Shake sections must also appear in the file.\n  The a,b,c,d values are atom IDs (from 1 to Natoms) for all the atoms\n  in the SHAKE cluster that this atom belongs to.  The number of values\n  that must appear is determined by the shake flag for the atom (see the\n  Shake Flags section above).  All atoms in a particular cluster should\n  list their a,b,c,d values identically.\n  If flag = 0, no a,b,c,d values are listed on the line, just the\n  (ignored) ID.\n  If flag = 1, a,b,c are listed, where a = ID of central atom in the\n  angle, and b,c the other two atoms in the angle.\n  If flag = 2, a,b are listed, where a = ID of atom in bond with the\n  lowest ID, and b = ID of atom in bond with the highest ID.\n  If flag = 3, a,b,c are listed, where a = ID of central atom,\n  and b,c = IDs of other two atoms bonded to the central atom.\n  If flag = 4, a,b,c,d are listed, where a = ID of central atom,\n  and b,c,d = IDs of other three atoms bonded to the central atom.\n  See the fix shake doc page for a further description\n  of SHAKE clusters.\n  \n  Shake Bond Types section:\n  \n  one line per atom\n  line syntax: ID a b c\n  a,b,c = bond types (or angle type) of bonds (or angle) in cluster\n  \n  This section is only needed when molecules created using the template\n  will be constrained by SHAKE via the “fix shake” command.  The other\n  two Shake sections must also appear in the file.\n  The a,b,c values are bond types (from 1 to Nbondtypes) for all bonds\n  in the SHAKE cluster that this atom belongs to.  The number of values\n  that must appear is determined by the shake flag for the atom (see the\n  Shake Flags section above).  All atoms in a particular cluster should\n  list their a,b,c values identically.\n  If flag = 0, no a,b,c values are listed on the line, just the\n  (ignored) ID.\n  If flag = 1, a,b,c are listed, where a = bondtype of the bond between\n  the central atom and the first non-central atom (value b in the Shake\n  Atoms section), b = bondtype of the bond between the central atom and\n  the 2nd non-central atom (value c in the Shake Atoms section), and c =\n  the angle type (1 to Nangletypes) of the angle between the 3 atoms.\n  If flag = 2, only a is listed, where a = bondtype of the bond between\n  the 2 atoms in the cluster.\n  If flag = 3, a,b are listed, where a = bondtype of the bond between\n  the central atom and the first non-central atom (value b in the Shake\n  Atoms section), and b = bondtype of the bond between the central atom\n  and the 2nd non-central atom (value c in the Shake Atoms section).\n  If flag = 4, a,b,c are listed, where a = bondtype of the bond between\n  the central atom and the first non-central atom (value b in the Shake\n  Atoms section), b = bondtype of the bond between the central atom and\n  the 2nd non-central atom (value c in the Shake Atoms section), and c =\n  bondtype of the bond between the central atom and the 3rd non-central\n  atom (value d in the Shake Atoms section).\n  See the fix shake doc page for a further description\n  of SHAKE clusters.\n  ",
    "syntax": "molecule ID file1 keyword values ... file2 keyword values ... fileN ...\n  \n  \n  \n  ID = user-assigned name for the molecule template\n  file1,file2,… = names of files containing molecule descriptions\n  zero or more keyword/value pairs may be appended after each file\n  keyword = offset or toff or boff or aoff or doff or ioff or scale\n  offset values = Toff Boff Aoff Doff Ioff\n    Toff = offset to add to atom types\n    Boff = offset to add to bond types\n    Aoff = offset to add to angle types\n    Doff = offset to add to dihedral types\n    Ioff = offset to add to improper types\n  toff value = Toff\n    Toff = offset to add to atom types\n  boff value = Boff\n    Boff = offset to add to bond types\n  aoff value = Aoff\n    Aoff = offset to add to angle types\n  doff value = Doff\n    Doff = offset to add to dihedral types\n  ioff value = Ioff\n    Ioff = offset to add to improper types\n  scale value = sfactor\n    sfactor = scale factor to apply to the size and mass of the molecule\n  \n  \n  ",
    "examples": "molecule 1 mymol.txt\n  molecule 1 co2.txt h2o.txt\n  molecule CO2 co2.txt boff 3 aoff 2\n  molecule 1 mymol.txt offset 6 9 18 23 14\n  molecule objects file.1 scale 1.5 file.1 scale 2.0 file.2 scale 1.3\n  \n  \n  ",
    "restrictions": "This command must come after the simulation box is define by a\n  read_data, read_restart, or\n  create_box command.\n  "
},
{
    "command": "neb",
    "description": "Perform a nudged elastic band (NEB) calculation using multiple\n  replicas of a system.  Two or more replicas must be used; the first\n  and last are the end points of the transition path.\n  NEB is a method for finding both the atomic configurations and height\n  of the energy barrier associated with a transition state, e.g. for an\n  atom to perform a diffusive hop from one energy basin to another in a\n  coordinated fashion with its neighbors.  The implementation in LAMMPS\n  follows the discussion in these 4 papers: (HenkelmanA),\n  (HenkelmanB), (Nakano) and (Maras).\n  Each replica runs on a partition of one or more processors.  Processor\n  partitions are defined at run-time using the -partition command-line switch.  Note that if you have MPI installed, you\n  can run a multi-replica simulation with more replicas (partitions)\n  than you have physical processors, e.g you can run a 10-replica\n  simulation on just one or two processors.  You will simply not get the\n  performance speed-up you would see with one or more physical\n  processors per replica.  See the Howto replica\n  doc page for further discussion.\n  \n  Note\n  As explained below, a NEB calculation performs a damped dynamics\n  minimization across all the replicas.  The minimizer uses whatever\n  timestep you have defined in your input script, via the\n  timestep command.  Often NEB will converge more\n  quickly if you use a timestep about 10x larger than you would normally\n  use for dynamics simulations.\n  \n  When a NEB calculation is performed, it is assumed that each replica\n  is running the same system, though LAMMPS does not check for this.\n  I.e. the simulation domain, the number of atoms, the interaction\n  potentials, and the starting configuration when the neb command is\n  issued should be the same for every replica.\n  In a NEB calculation each replica is connected to other replicas by\n  inter-replica nudging forces.  These forces are imposed by the fix neb command, which must be used in conjunction with the\n  neb command.  The group used to define the fix neb command defines the\n  NEB atoms which are the only ones that inter-replica springs are\n  applied to.  If the group does not include all atoms, then non-NEB\n  atoms have no inter-replica springs and the forces they feel and their\n  motion is computed in the usual way due only to other atoms within\n  their replica.  Conceptually, the non-NEB atoms provide a background\n  force field for the NEB atoms.  They can be allowed to move during the\n  NEB minimization procedure (which will typically induce different\n  coordinates for non-NEB atoms in different replicas), or held fixed\n  using other LAMMPS commands such as fix setforce.\n  Note that the partition command can be used to invoke\n  a command on a subset of the replicas, e.g. if you wish to hold NEB or\n  non-NEB atoms fixed in only the end-point replicas.\n  The initial atomic configuration for each of the replicas can be\n  specified in different manners via the file-style setting, as\n  discussed below.  Only atoms whose initial coordinates should differ\n  from the current configuration need be specified.\n  Conceptually, the initial and final configurations for the first\n  replica should be states on either side of an energy barrier.\n  As explained below, the initial configurations of intermediate\n  replicas can be atomic coordinates interpolated in a linear fashion\n  between the first and last replicas.  This is often adequate for\n  simple transitions.  For more complex transitions, it may lead to slow\n  convergence or even bad results if the minimum energy path (MEP, see\n  below) of states over the barrier cannot be correctly converged to\n  from such an initial path.  In this case, you will want to generate\n  initial states for the intermediate replicas that are geometrically\n  closer to the MEP and read them in.\n  \n  For a file-style setting of final, a filename is specified which\n  contains atomic coordinates for zero or more atoms, in the format\n  described below.  For each atom that appears in the file, the new\n  coordinates are assigned to that atom in the final replica.  Each\n  intermediate replica also assigns a new position to that atom in an\n  interpolated manner.  This is done by using the current position of\n  the atom as the starting point and the read-in position as the final\n  point.  The distance between them is calculated, and the new position\n  is assigned to be a fraction of the distance.  E.g. if there are 10\n  replicas, the 2nd replica will assign a position that is 10% of the\n  distance along a line between the starting and final point, and the\n  9th replica will assign a position that is 90% of the distance along\n  the line.  Note that for this procedure to produce consistent\n  coordinates across all the replicas, the current coordinates need to\n  be the same in all replicas.  LAMMPS does not check for this, but\n  invalid initial configurations will likely result if it is not the\n  case.\n  \n  Note\n  The “distance” between the starting and final point is\n  calculated in a minimum-image sense for a periodic simulation box.\n  This means that if the two positions are on opposite sides of a box\n  (periodic in that dimension), the distance between them will be small,\n  because the periodic image of one of the atoms is close to the other.\n  Similarly, even if the assigned position resulting from the\n  interpolation is outside the periodic box, the atom will be wrapped\n  back into the box when the NEB calculation begins.\n  \n  For a file-style setting of each, a filename is specified which is\n  assumed to be unique to each replica.  This can be done by using a\n  variable in the filename, e.g.\n  variable i equal part\n  neb 0.0 0.001 1000 500 50 each coords.initial.$i\n  \n  \n  which in this case will substitute the partition ID (0 to N-1) for the\n  variable I, which is also effectively the replica ID.  See the\n  variable command for other options, such as using\n  world-, universe-, or uloop-style variables.\n  Each replica (except the first replica) will read its file, formatted\n  as described below, and for any atom that appears in the file, assign\n  the specified coordinates to its atom.  The various files do not need\n  to contain the same set of atoms.\n  For a file-style setting of none, no filename is specified.  Each\n  replica is assumed to already be in its initial configuration at the\n  time the neb command is issued.  This allows each replica to define\n  its own configuration by reading a replica-specific data or restart or\n  dump file, via the read_data,\n  read_restart, or read_dump\n  commands.  The replica-specific names of these files can be specified\n  as in the discussion above for the each file-style.  Also see the\n  section below for how a NEB calculation can produce restart files, so\n  that a long calculation can be restarted if needed.\n  \n  Note\n  None of the file-style settings change the initial\n  configuration of any atom in the first replica.  The first replica\n  must thus be in the correct initial configuration at the time the neb\n  command is issued.\n  \n  \n  A NEB calculation proceeds in two stages, each of which is a\n  minimization procedure, performed via damped dynamics.  To enable\n  this, you must first define a damped dynamics\n  min_style, such as quickmin or fire.  The cg,\n  sd, and hftn styles cannot be used, since they perform iterative\n  line searches in their inner loop, which cannot be easily synchronized\n  across multiple replicas.\n  The minimizer tolerances for energy and force are set by etol and\n  ftol, the same as for the minimize command.\n  A non-zero etol means that the NEB calculation will terminate if the\n  energy criterion is met by every replica.  The energies being compared\n  to etol do not include any contribution from the inter-replica\n  nudging forces, since these are non-conservative.  A non-zero ftol\n  means that the NEB calculation will terminate if the force criterion\n  is met by every replica.  The forces being compared to ftol include\n  the inter-replica nudging forces.\n  The maximum number of iterations in each stage is set by N1 and\n  N2.  These are effectively timestep counts since each iteration of\n  damped dynamics is like a single timestep in a dynamics\n  run.  During both stages, the potential energy of each\n  replica and its normalized distance along the reaction path (reaction\n  coordinate RD) will be printed to the screen and log file every\n  Nevery timesteps.  The RD is 0 and 1 for the first and last replica.\n  For intermediate replicas, it is the cumulative distance (normalized\n  by the total cumulative distance) between adjacent replicas, where\n  “distance” is defined as the length of the 3N-vector of differences in\n  atomic coordinates, where N is the number of NEB atoms involved in the\n  transition.  These outputs allow you to monitor NEB’s progress in\n  finding a good energy barrier.  N1 and N2 must both be multiples\n  of Nevery.\n  In the first stage of NEB, the set of replicas should converge toward\n  a minimum energy path (MEP) of conformational states that transition\n  over a barrier.  The MEP for a transition is defined as a sequence of\n  3N-dimensional states, each of which has a potential energy gradient\n  parallel to the MEP itself.  The configuration of highest energy along\n  a MEP corresponds to a saddle point.  The replica states will also be\n  roughly equally spaced along the MEP due to the inter-replica nudging\n  force added by the fix neb command.\n  In the second stage of NEB, the replica with the highest energy is\n  selected and the inter-replica forces on it are converted to a force\n  that drives its atom coordinates to the top or saddle point of the\n  barrier, via the barrier-climbing calculation described in\n  (HenkelmanB).  As before, the other replicas rearrange\n  themselves along the MEP so as to be roughly equally spaced.\n  When both stages are complete, if the NEB calculation was successful,\n  the configurations of the replicas should be along (close to) the MEP\n  and the replica with the highest energy should be an atomic\n  configuration at (close to) the saddle point of the transition. The\n  potential energies for the set of replicas represents the energy\n  profile of the transition along the MEP.\n  \n  A few other settings in your input script are required or advised to\n  perform a NEB calculation.  See the NOTE about the choice of timestep\n  at the beginning of this doc page.\n  An atom map must be defined which it is not by default for atom_style atomic problems.  The atom_modify map command can be used to do this.\n  The minimizers in LAMMPS operate on all atoms in your system, even\n  non-NEB atoms, as defined above.  To prevent non-NEB atoms from moving\n  during the minimization, you should use the fix setforce command to set the force on each of those\n  atoms to 0.0.  This is not required, and may not even be desired in\n  some cases, but if those atoms move too far (e.g. because the initial\n  state of your system was not well-minimized), it can cause problems\n  for the NEB procedure.\n  The damped dynamics minimizers, such as quickmin\n  and fire), adjust the position and velocity of the atoms via an\n  Euler integration step.  Thus you must define an appropriate\n  timestep to use with NEB.  As mentioned above, NEB\n  will often converge more quickly if you use a timestep about 10x\n  larger than you would normally use for dynamics simulations.\n  \n  Each file read by the neb command containing atomic coordinates used\n  to initialize one or more replicas must be formatted as follows.\n  The file can be ASCII text or a gzipped text file (detected by a .gz\n  suffix).  The file can contain initial blank lines or comment lines\n  starting with “#” which are ignored.  The first non-blank, non-comment\n  line should list N = the number of lines to follow.  The N successive\n  lines contain the following information:\n  ID1 x1 y1 z1\n  ID2 x2 y2 z2\n  ...\n  IDN xN yN zN\n  \n  \n  The fields are the atom ID, followed by the x,y,z coordinates.  The\n  lines can be listed in any order.  Additional trailing information on\n  the line is OK, such as a comment.\n  Note that for a typical NEB calculation you do not need to specify\n  initial coordinates for very many atoms to produce differing starting\n  and final replicas whose intermediate replicas will converge to the\n  energy barrier.  Typically only new coordinates for atoms\n  geometrically near the barrier need be specified.\n  Also note there is no requirement that the atoms in the file\n  correspond to the NEB atoms in the group defined by the fix neb command.  Not every NEB atom need be in the file,\n  and non-NEB atoms can be listed in the file.\n  \n  Four kinds of output can be generated during a NEB calculation: energy\n  barrier statistics, thermodynamic output by each replica, dump files,\n  and restart files.\n  When running with multiple partitions (each of which is a replica in\n  this case), the print-out to the screen and master log.lammps file\n  contains a line of output, printed once every Nevery timesteps.  It\n  contains the timestep, the maximum force per replica, the maximum\n  force per atom (in any replica), potential gradients in the initial,\n  final, and climbing replicas, the forward and backward energy\n  barriers, the total reaction coordinate (RDT), and the normalized\n  reaction coordinate and potential energy of each replica.\n  The “maximum force per replica” is the two-norm of the 3N-length force\n  vector for the atoms in each replica, maximized across replicas, which\n  is what the ftol setting is checking against.  In this case, N is\n  all the atoms in each replica.  The “maximum force per atom” is the\n  maximum force component of any atom in any replica.  The potential\n  gradients are the two-norm of the 3N-length force vector solely due to\n  the interaction potential i.e.  without adding in inter-replica\n  forces.\n  The “reaction coordinate” (RD) for each replica is the two-norm of the\n  3N-length vector of distances between its atoms and the preceding\n  replica’s atoms, added to the RD of the preceding replica. The RD of\n  the first replica RD1 = 0.0; the RD of the final replica RDN = RDT,\n  the total reaction coordinate.  The normalized RDs are divided by RDT,\n  so that they form a monotonically increasing sequence from zero to\n  one. When computing RD, N only includes the atoms being operated on by\n  the fix neb command.\n  The forward (reverse) energy barrier is the potential energy of the\n  highest replica minus the energy of the first (last) replica.\n  Supplementary information for all replicas can be printed out to the\n  screen and master log.lammps file by adding the verbose keyword. This\n  information include the following.  The “path angle” (pathangle) for\n  the replica i which is the angle between the 3N-length vectors (Ri-1 -\n  Ri) and (Ri+1 - Ri) (where Ri is the atomic coordinates of replica\n  i). A “path angle” of 180 indicates that replicas i-1, i and i+1 are\n  aligned.  “angletangrad” is the angle between the 3N-length tangent\n  vector and the 3N-length force vector at image i. The tangent vector\n  is calculated as in (HenkelmanA) for all intermediate\n  replicas and at R2 - R1 and RM - RM-1 for the first and last replica,\n  respectively.  “anglegrad” is the angle between the 3N-length energy\n  gradient vector of replica i and that of replica i+1. It is not\n  defined for the final replica and reads nan.  gradV is the norm of the\n  energy gradient of image i.  ReplicaForce is the two-norm of the\n  3N-length force vector (including nudging forces) for replica i.\n  MaxAtomForce is the maximum force component of any atom in replica i.\n  When a NEB calculation does not converge properly, the supplementary\n  information can help understanding what is going wrong. For instance\n  when the path angle becomes acute, the definition of tangent used in\n  the NEB calculation is questionable and the NEB cannot may diverge\n  (Maras).\n  When running on multiple partitions, LAMMPS produces additional log\n  files for each partition, e.g. log.lammps.0, log.lammps.1, etc.  For a\n  NEB calculation, these contain the thermodynamic output for each\n  replica.\n  If dump commands in the input script define a filename\n  that includes a universe or uloop style variable,\n  then one dump file (per dump command) will be created for each\n  replica.  At the end of the NEB calculation, the final snapshot in\n  each file will contain the sequence of snapshots that transition the\n  system over the energy barrier.  Earlier snapshots will show the\n  convergence of the replicas to the MEP.\n  Likewise, restart filenames can be specified with a\n  universe or uloop style variable, to generate\n  restart files for each replica.  These may be useful if the NEB\n  calculation fails to converge properly to the MEP, and you wish to\n  restart the calculation from an intermediate point with altered\n  parameters.\n  There are 2 Python scripts provided in the tools/python directory,\n  neb_combine.py and neb_final.py, which are useful in analyzing output\n  from a NEB calculation.  Assume a NEB simulation with M replicas, and\n  the NEB atoms labeled with a specific atom type.\n  The neb_combine.py script extracts atom coords for the NEB atoms from\n  all M dump files and creates a single dump file where each snapshot\n  contains the NEB atoms from all the replicas and one copy of non-NEB\n  atoms from the first replica (presumed to be identical in other\n  replicas).  This can be visualized/animated to see how the NEB atoms\n  relax as the NEB calculation proceeds.\n  The neb_final.py script extracts the final snapshot from each of the M\n  dump files to create a single dump file with M snapshots.  This can be\n  visualized to watch the system make its transition over the energy\n  barrier.\n  To illustrate, here are images from the final snapshot produced by the\n  neb_combine.py script run on the dump files produced by the two\n  example input scripts in examples/neb.  Click on them to see a larger\n  image.\n  \n  \n  ",
    "syntax": "neb etol ftol N1 N2 Nevery file-style arg keyword\n  \n  \n  \n  etol = stopping tolerance for energy (energy units)\n  ftol = stopping tolerance for force (force units)\n  N1 = max # of iterations (timesteps) to run initial NEB\n  N2 = max # of iterations (timesteps) to run barrier-climbing NEB\n  Nevery = print replica energies and reaction coordinates every this many timesteps\n  file-style = final or each or none\n  final arg = filename\n    filename = file with initial coords for final replica\n      coords for intermediate replicas are linearly interpolated\n      between first and last replica\n  each arg = filename\n    filename = unique filename for each replica (except first)\n      with its initial coords\n  none arg = no argument all replicas assumed to already have\n      their initial coords\n  \n  \n  keyword = verbose\n  ",
    "examples": "neb 0.1 0.0 1000 500 50 final coords.final\n  neb 0.0 0.001 1000 500 50 each coords.initial.$i\n  neb 0.0 0.001 1000 500 50 none verbose\n  \n  \n  ",
    "restrictions": "This command can only be used if LAMMPS was built with the REPLICA\n  package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "neb/spin",
    "description": "Perform a geodesic nudged elastic band (GNEB) calculation using multiple\n  replicas of a system.  Two or more replicas must be used; the first\n  and last are the end points of the transition path.\n  GNEB is a method for finding both the spin configurations and height\n  of the energy barrier associated with a transition state, e.g.\n  spins to perform a collective rotation from one energy basin to\n  another.\n  The implementation in LAMMPS follows the discussion in the\n  following paper: (BessarabA).\n  Each replica runs on a partition of one or more processors.  Processor\n  partitions are defined at run-time using the -partition command-line switch.  Note that if you have MPI installed, you\n  can run a multi-replica simulation with more replicas (partitions)\n  than you have physical processors, e.g you can run a 10-replica\n  simulation on just one or two processors.  You will simply not get the\n  performance speed-up you would see with one or more physical\n  processors per replica.  See the Howto replica\n  doc page for further discussion.\n  \n  Note\n  As explained below, a GNEB calculation performs a\n  minimization across all the replicas. One of the spin\n  style minimizers has to be defined in your input script.\n  \n  When a GNEB calculation is performed, it is assumed that each replica\n  is running the same system, though LAMMPS does not check for this.\n  I.e. the simulation domain, the number of magnetic atoms, the\n  interaction potentials, and the starting configuration when the neb\n  command is issued should be the same for every replica.\n  In a GNEB calculation each replica is connected to other replicas by\n  inter-replica nudging forces.  These forces are imposed by the fix neb/spin command, which must be used in conjunction\n  with the neb command.\n  The group used to define the fix neb/spin command defines the\n  GNEB magnetic atoms which are the only ones that inter-replica springs\n  are applied to.\n  If the group does not include all magnetic atoms, then non-GNEB\n  magnetic atoms have no inter-replica springs and the torques they feel\n  and their precession motion is computed in the usual way due only\n  to other magnetic atoms within their replica.\n  Conceptually, the non-GNEB atoms provide a background force field for\n  the GNEB atoms.\n  Their magnetic spins can be allowed to evolve during the GNEB\n  minimization procedure.\n  The initial spin configuration for each of the replicas can be\n  specified in different manners via the file-style setting, as\n  discussed below.  Only atomic spins whose initial coordinates should\n  differ from the current configuration need to be specified.\n  Conceptually, the initial and final configurations for the first\n  replica should be states on either side of an energy barrier.\n  As explained below, the initial configurations of intermediate\n  replicas can be spin coordinates interpolated in a linear fashion\n  between the first and last replicas.  This is often adequate for\n  simple transitions.  For more complex transitions, it may lead to slow\n  convergence or even bad results if the minimum energy path (MEP, see\n  below) of states over the barrier cannot be correctly converged to\n  from such an initial path.  In this case, you will want to generate\n  initial states for the intermediate replicas that are geometrically\n  closer to the MEP and read them in.\n  \n  For a file-style setting of final, a filename is specified which\n  contains atomic and spin coordinates for zero or more atoms, in the\n  format described below.\n  For each atom that appears in the file, the new coordinates are\n  assigned to that atom in the final replica.  Each intermediate replica\n  also assigns a new spin to that atom in an interpolated manner.\n  This is done by using the current direction of the spin at the starting\n  point and the read-in direction as the final point.\n  The “angular distance” between them is calculated, and the new direction\n  is assigned to be a fraction of the angular distance.\n  \n  Note\n  The “angular distance” between the starting and final point is\n  evaluated in the geodesic sense, as described in\n  (BessarabA).\n  \n  \n  Note\n  The angular interpolation between the starting and final point\n  is achieved using Rodrigues formula:\n  \n  \n  \\[\\vec{m}_i^{\\nu} = \\vec{m}_i^{I} \\cos(\\omega_i^{\\nu})\n  + (\\vec{k}_i \\times \\vec{m}_i^{I}) \\sin(\\omega_i^{\\nu})\n  + (1.0-\\cos(\\omega_i^{\\nu})) \\vec{k}_i (\\vec{k}_i\\cdot\n  \\vec{m}_i^{I})\\]\n  where \\(\\vec{m}_i^I\\) is the initial spin configuration for\n  spin i, \\(\\omega_i^{\\nu}\\) is a rotation angle defined as:\n  \n  \\[\\omega_i^{\\nu} = (\\nu - 1) \\Delta \\omega_i {\\rm ~~and~~} \\Delta \\omega_i = \\frac{\\omega_i}{Q-1}\\]\n  with \\(\\nu\\) the image number, Q the total number of images, and\n  \\(\\omega_i\\) the total rotation between the initial and final spins.\n  \\(\\vec{k}_i\\) defines a rotation axis such as:\n  \n  \\[\\vec{k}_i =  \\frac{\\vec{m}_i^I \\times \\vec{m}_i^F}{\\left|\\vec{m}_i^I \\times \\vec{m}_i^F\\right|}\\]\n  if the initial and final spins are not aligned.\n  If the initial and final spins are aligned, then their cross\n  product is null, and the expression above does not apply.\n  If they point toward the same direction, the intermediate images\n  conserve the same orientation.\n  If the initial and final spins are aligned, but point toward\n  opposite directions, an arbitrary rotation vector belonging to\n  the plane perpendicular to initial and final spins is chosen.\n  In this case, a warning message is displayed.\n  For a file-style setting of each, a filename is specified which is\n  assumed to be unique to each replica.\n  See the neb documentation page for more information about this\n  option.\n  For a file-style setting of none, no filename is specified.  Each\n  replica is assumed to already be in its initial configuration at the\n  time the neb command is issued.  This allows each replica to define\n  its own configuration by reading a replica-specific data or restart or\n  dump file, via the read_data,\n  read_restart, or read_dump\n  commands.  The replica-specific names of these files can be specified\n  as in the discussion above for the each file-style.  Also see the\n  section below for how a NEB calculation can produce restart files, so\n  that a long calculation can be restarted if needed.\n  \n  Note\n  None of the file-style settings change the initial\n  configuration of any atom in the first replica.  The first replica\n  must thus be in the correct initial configuration at the time the neb\n  command is issued.\n  \n  \n  A NEB calculation proceeds in two stages, each of which is a\n  minimization procedure.  To enable\n  this, you must first define a\n  min_style, using either the spin,\n  spin/cg, or spin/lbfgs style (see\n  min_spin for more information).\n  The other styles cannot be used, since they relax the lattice\n  degrees of freedom instead of the spins.\n  The minimizer tolerances for energy and force are set by etol and\n  ttol, the same as for the minimize command.\n  A non-zero etol means that the GNEB calculation will terminate if the\n  energy criterion is met by every replica.  The energies being compared\n  to etol do not include any contribution from the inter-replica\n  nudging forces, since these are non-conservative.  A non-zero ttol\n  means that the GNEB calculation will terminate if the torque criterion\n  is met by every replica.  The torques being compared to ttol include\n  the inter-replica nudging forces.\n  The maximum number of iterations in each stage is set by N1 and\n  N2.  These are effectively timestep counts since each iteration of\n  damped dynamics is like a single timestep in a dynamics\n  run.  During both stages, the potential energy of each\n  replica and its normalized distance along the reaction path (reaction\n  coordinate RD) will be printed to the screen and log file every\n  Nevery timesteps.  The RD is 0 and 1 for the first and last replica.\n  For intermediate replicas, it is the cumulative angular distance\n  (normalized by the total cumulative angular distance) between adjacent\n  replicas, where “distance” is defined as the length of the 3N-vector of\n  the geodesic distances in spin coordinates, with N the number of\n  GNEB spins involved (see equation (13) in (BessarabA)).\n  These outputs allow you to monitor NEB’s progress in\n  finding a good energy barrier.  N1 and N2 must both be multiples\n  of Nevery.\n  In the first stage of GNEB, the set of replicas should converge toward\n  a minimum energy path (MEP) of conformational states that transition\n  over a barrier.  The MEP for a transition is defined as a sequence of\n  3N-dimensional spin states, each of which has a potential energy\n  gradient parallel to the MEP itself.\n  The configuration of highest energy along a MEP corresponds to a saddle\n  point.  The replica states will also be roughly equally spaced along\n  the MEP due to the inter-replica nudging force added by the\n  fix neb command.\n  In the second stage of GNEB, the replica with the highest energy is\n  selected and the inter-replica forces on it are converted to a force\n  that drives its spin coordinates to the top or saddle point of the\n  barrier, via the barrier-climbing calculation described in\n  (BessarabA).  As before, the other replicas rearrange\n  themselves along the MEP so as to be roughly equally spaced.\n  When both stages are complete, if the GNEB calculation was successful,\n  the configurations of the replicas should be along (close to) the MEP\n  and the replica with the highest energy should be a spin\n  configuration at (close to) the saddle point of the transition. The\n  potential energies for the set of replicas represents the energy\n  profile of the transition along the MEP.\n  \n  An atom map must be defined which it is not by default for atom_style atomic problems.  The atom_modify map command can be used to do this.\n  An initial value can be defined for the timestep. Although, the spin\n  minimization algorithm is an adaptive timestep methodology, so that\n  this timestep is likely to evolve during the calculation.\n  The minimizers in LAMMPS operate on all spins in your system, even\n  non-GNEB atoms, as defined above.\n  \n  Each file read by the neb/spin command containing spin coordinates used\n  to initialize one or more replicas must be formatted as follows.\n  The file can be ASCII text or a gzipped text file (detected by a .gz\n  suffix).  The file can contain initial blank lines or comment lines\n  starting with “#” which are ignored.  The first non-blank, non-comment\n  line should list N = the number of lines to follow.  The N successive\n  lines contain the following information:\n  ID1 g1 x1 y1 z1 sx1 sy1 sz1\n  ID2 g2 x2 y2 z2 sx2 sy2 sz2\n  ...\n  IDN gN yN zN sxN syN szN\n  \n  \n  The fields are the atom ID, the norm of the associated magnetic spin,\n  followed by the x,y,z coordinates and the sx,sy,sz spin coordinates.\n  The lines can be listed in any order.  Additional trailing information on\n  the line is OK, such as a comment.\n  Note that for a typical GNEB calculation you do not need to specify\n  initial spin coordinates for very many atoms to produce differing starting\n  and final replicas whose intermediate replicas will converge to the\n  energy barrier.  Typically only new spin coordinates for atoms\n  geometrically near the barrier need be specified.\n  Also note there is no requirement that the atoms in the file\n  correspond to the GNEB atoms in the group defined by the fix neb command.  Not every GNEB atom need be in the file,\n  and non-GNEB atoms can be listed in the file.\n  \n  Four kinds of output can be generated during a GNEB calculation: energy\n  barrier statistics, thermodynamic output by each replica, dump files,\n  and restart files.\n  When running with multiple partitions (each of which is a replica in\n  this case), the print-out to the screen and master log.lammps file\n  contains a line of output, printed once every Nevery timesteps.  It\n  contains the timestep, the maximum torque per replica, the maximum\n  torque per atom (in any replica), potential gradients in the initial,\n  final, and climbing replicas, the forward and backward energy\n  barriers, the total reaction coordinate (RDT), and the normalized\n  reaction coordinate and potential energy of each replica.\n  The “maximum torque per replica” is the two-norm of the\n  3N-length vector given by the cross product of a spin by its\n  precession vector omega, in each replica, maximized across replicas,\n  which is what the ttol setting is checking against.  In this case, N is\n  all the atoms in each replica.  The “maximum torque per atom” is the\n  maximum torque component of any atom in any replica.  The potential\n  gradients are the two-norm of the 3N-length magnetic precession vector\n  solely due to the interaction potential i.e. without adding in\n  inter-replica forces, and projected along the path tangent (as detailed\n  in Appendix D of (BessarabA)).\n  The “reaction coordinate” (RD) for each replica is the two-norm of the\n  3N-length vector of geodesic distances between its spins and the preceding\n  replica’s spins (see equation (13) of (BessarabA)), added to\n  the RD of the preceding replica. The RD of the first replica RD1 = 0.0;\n  the RD of the final replica RDN = RDT, the total reaction coordinate.\n  The normalized RDs are divided by RDT, so that they form a monotonically\n  increasing sequence from zero to one. When computing RD, N only includes\n  the spins being operated on by the fix neb/spin command.\n  The forward (reverse) energy barrier is the potential energy of the\n  highest replica minus the energy of the first (last) replica.\n  Supplementary information for all replicas can be printed out to the\n  screen and master log.lammps file by adding the verbose keyword. This\n  information include the following.\n  The “GradVidottan” are the projections of the potential gradient for\n  the replica i on its tangent vector (as detailed in Appendix D of\n  (BessarabA)).\n  The “DNi” are the non normalized geodesic distances (see equation (13)\n  of (BessarabA)), between a replica i and the next replica\n  i+1. For the last replica, this distance is not defined and a “NAN”\n  value is the corresponding output.\n  When a NEB calculation does not converge properly, the supplementary\n  information can help understanding what is going wrong.\n  When running on multiple partitions, LAMMPS produces additional log\n  files for each partition, e.g. log.lammps.0, log.lammps.1, etc.  For a\n  GNEB calculation, these contain the thermodynamic output for each\n  replica.\n  If dump commands in the input script define a filename\n  that includes a universe or uloop style variable,\n  then one dump file (per dump command) will be created for each\n  replica.  At the end of the GNEB calculation, the final snapshot in\n  each file will contain the sequence of snapshots that transition the\n  system over the energy barrier.  Earlier snapshots will show the\n  convergence of the replicas to the MEP.\n  Likewise, restart filenames can be specified with a\n  universe or uloop style variable, to generate\n  restart files for each replica.  These may be useful if the GNEB\n  calculation fails to converge properly to the MEP, and you wish to\n  restart the calculation from an intermediate point with altered\n  parameters.\n  A c file script in provided in the tool/spin/interpolate_gneb\n  directory, that interpolates the MEP given the information provided\n  by the verbose output option (as detailed in Appendix D of\n  (BessarabA)).\n  ",
    "syntax": "neb/spin etol ttol N1 N2 Nevery file-style arg keyword\n  \n  \n  \n  etol = stopping tolerance for energy (energy units)\n  ttol = stopping tolerance for torque ( units)\n  N1 = max # of iterations (timesteps) to run initial NEB\n  N2 = max # of iterations (timesteps) to run barrier-climbing NEB\n  Nevery = print replica energies and reaction coordinates every this many timesteps\n  file-style = final or each or none\n  final arg = filename\n    filename = file with initial coords for final replica\n      coords for intermediate replicas are linearly interpolated\n      between first and last replica\n  each arg = filename\n    filename = unique filename for each replica (except first)\n      with its initial coords\n  none arg = no argument all replicas assumed to already have\n      their initial coords\n  \n  keyword = verbose\n  verbose = print supplemental information\n  \n  \n  ",
    "examples": "neb/spin 0.1 0.0 1000 500 50 final coords.final\n  neb/spin 0.0 0.001 1000 500 50 each coords.initial.$i\n  neb/spin 0.0 0.001 1000 500 50 none verbose\n  \n  \n  ",
    "restrictions": "This command can only be used if LAMMPS was built with the SPIN\n  package.  See the Build package doc\n  page for more info.\n  For magnetic GNEB calculations, only the spin_none value for the\n  line keyword can be used when minimization styles spin/cg and\n  spin/lbfgs are employed.\n  "
},
{
    "command": "neigh_modify",
    "description": "This command sets parameters that affect the building and use of\n  pairwise neighbor lists.  Depending on what pair interactions and\n  other commands are defined, a simulation may require one or more\n  neighbor lists.\n  The every, delay, check, and once options affect how often\n  lists are built as a simulation runs.  The delay setting means never\n  build new lists until at least N steps after the previous build.  The\n  every setting means build lists every M steps (after the delay has\n  passed).  If the check setting is no, the lists are built on the\n  first step that satisfies the delay and every settings.  If the\n  check setting is yes, then the every and delay settings\n  determine when a build may possibly be performed, but an actual build\n  only occurs if some atom has moved more than half the skin distance\n  (specified in the neighbor command) since the last\n  build.\n  If the once setting is yes, then the neighbor list is only built\n  once at the beginning of each run, and never rebuilt, except on steps\n  when a restart file is written, or steps when a fix forces a rebuild\n  to occur (e.g. fixes that create or delete atoms, such as fix deposit or fix evaporate).\n  This setting should only be made if you are certain atoms will not\n  move far enough that the neighbor list should be rebuilt, e.g. running\n  a simulation of a cold crystal.  Note that it is not that expensive to\n  check if neighbor lists should be rebuilt.\n  When the rRESPA integrator is used (see the run_style\n  command), the every and delay parameters refer to the longest\n  (outermost) timestep.\n  The cluster option does a sanity test every time neighbor lists are\n  built for bond, angle, dihedral, and improper interactions, to check\n  that each set of 2, 3, or 4 atoms is a cluster of nearby atoms.  It\n  does this by computing the distance between pairs of atoms in the\n  interaction and insuring they are not further apart than half the\n  periodic box length.  If they are, an error is generated, since the\n  interaction would be computed between far-away atoms instead of their\n  nearby periodic images.  The only way this should happen is if the\n  pairwise cutoff is so short that atoms that are part of the same\n  interaction are not communicated as ghost atoms.  This is an unusual\n  model (e.g. no pair interactions at all) and the problem can be fixed\n  by use of the comm_modify cutoff command.  Note\n  that to save time, the default cluster setting is no, so that this\n  check is not performed.\n  The include option limits the building of pairwise neighbor lists to\n  atoms in the specified group.  This can be useful for models where a\n  large portion of the simulation is particles that do not interact with\n  other particles or with each other via pairwise interactions.  The\n  group specified with this option must also be specified via the\n  atom_modify first command.  Note that specifying\n  “all” as the group-ID effectively turns off the include option.\n  The exclude option turns off pairwise interactions between certain\n  pairs of atoms, by not including them in the neighbor list.  These are\n  sample scenarios where this is useful:\n  \n  In crack simulations, pairwise interactions can be shut off between 2\n  slabs of atoms to effectively create a crack.\n  When a large collection of atoms is treated as frozen, interactions\n  between those atoms can be turned off to save needless\n  computation. E.g. Using the fix setforce command\n  to freeze a wall or portion of a bio-molecule.\n  When one or more rigid bodies are specified, interactions within each\n  body can be turned off to save needless computation.  See the fix rigid command for more details.\n  \n  The exclude type option turns off the pairwise interaction if one\n  atom is of type M and the other of type N.  M can equal N.  The\n  exclude group option turns off the interaction if one atom is in the\n  first group and the other is the second.  Group1-ID can equal\n  group2-ID.  The exclude molecule/intra option turns off the\n  interaction if both atoms are in the specified group and in the same\n  molecule, as determined by their molecule ID.  The exclude\n  molecule/inter turns off the interaction between pairs of atoms that\n  have different molecule IDs and are both in the specified group.\n  Each of the exclude options can be specified multiple times.  The\n  exclude type option is the most efficient option to use; it requires\n  only a single check, no matter how many times it has been specified.\n  The other exclude options are more expensive if specified multiple\n  times; they require one check for each time they have been specified.\n  Note that the exclude options only affect pairwise interactions; see\n  the delete_bonds command for information on\n  turning off bond interactions.\n  \n  Note\n  Excluding pairwise interactions will not work correctly when\n  also using a long-range solver via the\n  kspace_style command.  LAMMPS will give a warning\n  to this effect.  This is because the short-range pairwise interaction\n  needs to subtract off a term from the total energy for pairs whose\n  short-range interaction is excluded, to compensate for how the\n  long-range solver treats the interaction.  This is done correctly for\n  pairwise interactions that are excluded (or weighted) via the\n  special_bonds command.  But it is not done for\n  interactions that are excluded via these neigh_modify exclude options.\n  \n  The page and one options affect how memory is allocated for the\n  neighbor lists.  For most simulations the default settings for these\n  options are fine, but if a very large problem is being run or a very\n  long cutoff is being used, these parameters can be tuned.  The indices\n  of neighboring atoms are stored in “pages”, which are allocated one\n  after another as they fill up.  The size of each page is set by the\n  page value.  A new page is allocated when the next atom’s neighbors\n  could potentially overflow the list.  This threshold is set by the\n  one value which tells LAMMPS the maximum number of neighbor’s one\n  atom can have.\n  \n  Note\n  LAMMPS can crash without an error message if the number of\n  neighbors for a single particle is larger than the page setting,\n  which means it is much, much larger than the one setting.  This is\n  because LAMMPS does not error check these limits for every pairwise\n  interaction (too costly), but only after all the particle’s neighbors\n  have been found.  This problem usually means something is very wrong\n  with the way you have setup your problem (particle spacing, cutoff\n  length, neighbor skin distance, etc).  If you really expect that many\n  neighbors per particle, then boost the one and page settings\n  accordingly.\n  \n  The binsize option allows you to specify what size of bins will be\n  used in neighbor list construction to sort and find neighboring atoms.\n  By default, for neighbor style bin, LAMMPS uses bins\n  that are 1/2 the size of the maximum pair cutoff.  For neighbor style multi, the bins are 1/2 the size of the minimum pair\n  cutoff.  Typically these are good values for minimizing the time for\n  neighbor list construction.  This setting overrides the default.\n  If you make it too big, there is little overhead due to\n  looping over bins, but more atoms are checked.  If you make it too\n  small, the optimal number of atoms is checked, but bin overhead goes\n  up.  If you set the binsize to 0.0, LAMMPS will use the default\n  binsize of 1/2 the cutoff.\n  ",
    "syntax": "neigh_modify keyword values ...\n  \n  \n  \n  one or more keyword/value pairs may be listed\n  keyword = delay or every or check or once or cluster or include or exclude or page or one or binsize\n    delay value = N\n      N = delay building until this many steps since last build\n    every value = M\n      M = build neighbor list every this many steps\n    check value = yes or no\n      yes = only build if some atom has moved half the skin distance or more\n      no = always build on 1st step that every and delay are satisfied\n    once\n      yes = only build neighbor list once at start of run and never rebuild\n      no = rebuild neighbor list according to other settings\n    cluster\n      yes = check bond,angle,etc neighbor list for nearby clusters\n      no = do not check bond,angle,etc neighbor list for nearby clusters\n    include value = group-ID\n      group-ID = only build pair neighbor lists for atoms in this group\n    exclude values:\n      type M N\n        M,N = exclude if one atom in pair is type M, other is type N\n      group group1-ID group2-ID\n        group1-ID,group2-ID = exclude if one atom is in 1st group, other in 2nd\n      molecule/intra group-ID\n        group-ID = exclude if both atoms are in the same molecule and in group\n      molecule/inter group-ID\n        group-ID = exclude if both atoms are in different molecules and in group\n      none\n        delete all exclude settings\n    page value = N\n      N = number of pairs stored in a single neighbor page\n    one value = N\n      N = max number of neighbors of one atom\n    binsize value = size\n      size = bin size for neighbor list construction (distance units)\n  \n  \n  ",
    "examples": "neigh_modify every 2 delay 10 check yes page 100000\n  neigh_modify exclude type 2 3\n  neigh_modify exclude group frozen frozen check no\n  neigh_modify exclude group residue1 chain3\n  neigh_modify exclude molecule/intra rigid\n  \n  \n  ",
    "restrictions": "If the “delay” setting is non-zero, then it must be a multiple of the\n  “every” setting.\n  The molecule/intra and molecule/inter exclude options can only be used\n  with atom styles that define molecule IDs.\n  The value of the page setting must be at least 10x larger than the\n  one setting.  This insures neighbor pages are not mostly empty\n  space.\n  "
},
{
    "command": "neighbor",
    "description": "This command sets parameters that affect the building of pairwise\n  neighbor lists.  All atom pairs within a neighbor cutoff distance\n  equal to the their force cutoff plus the skin distance are stored in\n  the list.  Typically, the larger the skin distance, the less often\n  neighbor lists need to be built, but more pairs must be checked for\n  possible force interactions every timestep.  The default value for\n  skin depends on the choice of units for the simulation; see the\n  default values below.\n  The skin distance is also used to determine how often atoms migrate\n  to new processors if the check option of the\n  neigh_modify command is set to yes.  Atoms are\n  migrated (communicated) to new processors on the same timestep that\n  neighbor lists are re-built.\n  The style value selects what algorithm is used to build the list.\n  The bin style creates the list by binning which is an operation that\n  scales linearly with N/P, the number of atoms per processor where N =\n  total number of atoms and P = number of processors.  It is almost\n  always faster than the nsq style which scales as (N/P)^2.  For\n  unsolvated small molecules in a non-periodic box, the nsq choice can\n  sometimes be faster.  Either style should give the same answers.\n  The multi style is a modified binning algorithm that is useful for\n  systems with a wide range of cutoff distances, e.g. due to different\n  size particles.  For the bin style, the bin size is set to 1/2 of\n  the largest cutoff distance between any pair of atom types and a\n  single set of bins is defined to search over for all atom types.  This\n  can be inefficient if one pair of types has a very long cutoff, but\n  other type pairs have a much shorter cutoff.  For style multi the\n  bin size is set to 1/2 of the shortest cutoff distance and multiple\n  sets of bins are defined to search over for different atom types.\n  This imposes some extra setup overhead, but the searches themselves\n  may be much faster for the short-cutoff cases.  See the comm_modify mode multi command for a communication option\n  that may also be beneficial for simulations of this kind.\n  The neigh_modify command has additional options\n  that control how often neighbor lists are built and which pairs are\n  stored in the list.\n  When a run is finished, counts of the number of neighbors stored in\n  the pairwise list and the number of times neighbor lists were built\n  are printed to the screen and log file.  See the Run output doc page for details.\n  ",
    "syntax": "neighbor skin style\n  \n  \n  \n  skin = extra distance beyond force cutoff (distance units)\n  style = bin or nsq or multi\n  \n  ",
    "examples": "neighbor 0.3 bin\n  neighbor 2.0 nsq\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "newton",
    "description": "This command turns Newton’s 3rd law on or off for pairwise and\n  bonded interactions.  For most problems, setting Newton’s 3rd law to\n  on means a modest savings in computation at the cost of two times\n  more communication.  Whether this is faster depends on problem size,\n  force cutoff lengths, a machine’s compute/communication ratio, and how\n  many processors are being used.\n  Setting the pairwise newton flag to off means that if two\n  interacting atoms are on different processors, both processors compute\n  their interaction and the resulting force information is not\n  communicated.  Similarly, for bonded interactions, newton off means\n  that if a bond, angle, dihedral, or improper interaction contains\n  atoms on 2 or more processors, the interaction is computed by each\n  processor.\n  LAMMPS should produce the same answers for any newton flag settings,\n  except for round-off issues.\n  With run_style respa and only bonded interactions\n  (bond, angle, etc) computed in the innermost timestep, it may be\n  faster to turn newton off for bonded interactions, to avoid extra\n  communication in the innermost loop.\n  ",
    "syntax": "newton flag\n  newton flag1 flag2\n  \n  \n  \n  flag = on or off for both pairwise and bonded interactions\n  flag1 = on or off for pairwise interactions\n  flag2 = on or off for bonded interactions\n  \n  ",
    "examples": "newton off\n  newton on off\n  \n  \n  ",
    "restrictions": "The newton bond setting cannot be changed after the simulation box is\n  defined by a read_data or\n  create_box command.\n  "
},
{
    "command": "next",
    "description": "This command is used with variables defined by the\n  variable command.  It assigns the next value to the\n  variable from the list of values defined for that variable by the\n  variable command.  Thus when that variable is\n  subsequently substituted for in an input script command, the new value\n  is used.\n  See the variable command for info on how to define and\n  use different kinds of variables in LAMMPS input scripts.  If a\n  variable name is a single lower-case character from “a” to “z”, it can\n  be used in an input script command as $a or $z.  If it is multiple\n  letters, it can be used as ${myTemp}.\n  If multiple variables are used as arguments to the next command,\n  then all must be of the same variable style: index, loop, file,\n  universe, or uloop.  An exception is that universe- and\n  uloop-style variables can be mixed in the same next command.\n  All the variables specified with the next command are incremented by\n  one value from their respective list of values.  A file-style\n  variable reads the next line from its associated file.  An\n  atomfile-style variable reads the next set of lines (one per atom)\n  from its associated file.  String- or atom- or equal- or\n  world-style variables cannot be used with the next command,\n  since they only store a single value.\n  When any of the variables in the next command has no more values, a\n  flag is set that causes the input script to skip the next\n  jump command encountered.  This enables a loop containing\n  a next command to exit.  As explained in the variable\n  command, the variable that has exhausted its values is also deleted.\n  This allows it to be used and re-defined later in the input script.\n  File-style and atomfile-style variables are exhausted when the\n  end-of-file is reached.\n  When the next command is used with index- or loop-style variables,\n  the next value is assigned to the variable for all processors.  When\n  the next command is used with file-style variables, the next line is\n  read from its file and the string assigned to the variable.  When the\n  next command is used with atomfile-style variables, the next set of\n  per-atom values is read from its file and assigned to the variable.\n  When the next command is used with universe- or uloop-style\n  variables, all universe- or uloop-style variables must be listed\n  in the next command.  This is because of the manner in which the\n  incrementing is done, using a single lock file for all variables.  The\n  next value (for each variable) is assigned to whichever processor\n  partition executes the command first.  All processors in the partition\n  are assigned the same value(s).  Running LAMMPS on multiple partitions\n  of processors via the -partition command-line switch.  Universe- and uloop-style variables are\n  incremented using the files “tmp.lammps.variable” and\n  “tmp.lammps.variable.lock” which you will see in your directory during\n  and after such a LAMMPS run.\n  Here is an example of running a series of simulations using the next\n  command with an index-style variable.  If this input script is named\n  in.polymer, 8 simulations would be run using data files from\n  directories run1 through run8.\n  variable d index run1 run2 run3 run4 run5 run6 run7 run8\n  shell cd $d\n  read_data data.polymer\n  run 10000\n  shell cd ..\n  clear\n  next d\n  jump in.polymer\n  \n  \n  If the variable “d” were of style universe, and the same in.polymer\n  input script were run on 3 partitions of processors, then the first 3\n  simulations would begin, one on each set of processors.  Whichever\n  partition finished first, it would assign variable “d” the 4th value\n  and run another simulation, and so forth until all 8 simulations were\n  finished.\n  Jump and next commands can also be nested to enable multi-level loops.\n  For example, this script will run 15 simulations in a double loop.\n  variable i loop 3\n    variable j loop 5\n    clear\n    ...\n    read_data data.polymer.$i$j\n    print Running simulation $i.$j\n    run 10000\n    next j\n    jump in.script\n  next i\n  jump in.script\n  \n  \n  Here is an example of a double loop which uses the if and\n  jump commands to break out of the inner loop when a\n  condition is met, then continues iterating through the outer loop.\n  label       loopa\n  variable    a loop 5\n    label     loopb\n    variable  b loop 5\n    print     \"A,B = $a,$b\"\n    run       10000\n    if        $b > 2 then \"jump in.script break\"\n    next      b\n    jump      in.script loopb\n  label       break\n  variable    b delete\n  \n  next        a\n  jump        in.script loopa\n  \n  \n  ",
    "syntax": "next variables\n  \n  \n  \n  variables = one or more variable names\n  \n  ",
    "examples": "next x\n  next a t x myTemp\n  \n  \n  ",
    "restrictions": "As described above.\n  "
},
{
    "command": "package",
    "description": "This command invokes package-specific settings for the various\n  accelerator packages available in LAMMPS.  Currently the following\n  packages use settings from this command: GPU, USER-INTEL, KOKKOS, and\n  USER-OMP.\n  If this command is specified in an input script, it must be near the\n  top of the script, before the simulation box has been defined.  This\n  is because it specifies settings that the accelerator packages use in\n  their initialization, before a simulation is defined.\n  This command can also be specified from the command-line when\n  launching LAMMPS, using the “-pk” command-line switch.  The syntax is exactly the same as when used\n  in an input script.\n  Note that all of the accelerator packages require the package command\n  to be specified (except the OPT package), if the package is to be used\n  in a simulation (LAMMPS can be built with an accelerator package\n  without using it in a particular simulation).  However, in all cases,\n  a default version of the command is typically invoked by other\n  accelerator settings.\n  The KOKKOS package requires a “-k on” command-line switch respectively, which invokes a “package\n  kokkos” command with default settings.\n  For the GPU, USER-INTEL, and USER-OMP packages, if a “-sf gpu” or “-sf\n  intel” or “-sf omp” command-line switch is used to\n  auto-append accelerator suffixes to various styles in the input\n  script, then those switches also invoke a “package gpu”, “package\n  intel”, or “package omp” command with default settings.\n  \n  Note\n  A package command for a particular style can be invoked multiple\n  times when a simulation is setup, e.g. by the -c on, -k on, -sf, and -pk command-line switches, and by using this command\n  in an input script.  Each time it is used all of the style options are\n  set, either to default values or to specified settings.  I.e. settings\n  from previous invocations do not persist across multiple invocations.\n  \n  See the Speed packages doc page for more details\n  about using the various accelerator packages for speeding up LAMMPS\n  simulations.\n  \n  The gpu style invokes settings associated with the use of the GPU\n  package.\n  The Ngpu argument sets the number of GPUs per node.  There must be\n  at least as many MPI tasks per node as GPUs, as set by the mpirun or\n  mpiexec command.  If there are more MPI tasks (per node)\n  than GPUs, multiple MPI tasks will share each GPU.\n  Optional keyword/value pairs can also be specified.  Each has a\n  default value as listed below.\n  The neigh keyword specifies where neighbor lists for pair style\n  computation will be built.  If neigh is yes, which is the default,\n  neighbor list building is performed on the GPU.  If neigh is no,\n  neighbor list building is performed on the CPU.  GPU neighbor list\n  building currently cannot be used with a triclinic box.  GPU neighbor\n  lists are not compatible with commands that are not GPU-enabled.  When\n  a non-GPU enabled command requires a neighbor list, it will also be\n  built on the CPU.  In these cases, it will typically be more efficient\n  to only use CPU neighbor list builds.\n  The newton keyword sets the Newton flags for pairwise (not bonded)\n  interactions to off or on, the same as the newton\n  command allows.  Currently, only an off value is allowed, since all\n  the GPU package pair styles require this setting.  This means more\n  computation is done, but less communication.  In the future a value of\n  on may be allowed, so the newton keyword is included as an option\n  for compatibility with the package command for other accelerator\n  styles.  Note that the newton setting for bonded interactions is not\n  affected by this keyword.\n  The binsize keyword sets the size of bins used to bin atoms in\n  neighbor list builds performed on the GPU, if neigh = yes is set.\n  If binsize is set to 0.0 (the default), then bins = the size of the\n  pairwise cutoff + neighbor skin distance.  This is 2x larger than the\n  LAMMPS default used for neighbor list building on the CPU.  This will\n  be close to optimal for the GPU, so you do not normally need to use\n  this keyword.  Note that if you use a longer-than-usual pairwise\n  cutoff, e.g. to allow for a smaller fraction of KSpace work with a\n  long-range Coulombic solver because the GPU is\n  faster at performing pairwise interactions, then it may be optimal to\n  make the binsize smaller than the default.  For example, with a\n  cutoff of 20*sigma in LJ units and a neighbor skin\n  distance of sigma, a binsize = 5.25*sigma can be more efficient than\n  the default.\n  The split keyword can be used for load balancing force calculations\n  between CPU and GPU cores in GPU-enabled pair styles. If 0 < split <\n  1.0, a fixed fraction of particles is offloaded to the GPU while force\n  calculation for the other particles occurs simultaneously on the CPU.\n  If split < 0.0, the optimal fraction (based on CPU and GPU timings)\n  is calculated every 25 timesteps, i.e. dynamic load-balancing across\n  the CPU and GPU is performed.  If split = 1.0, all force\n  calculations for GPU accelerated pair styles are performed on the GPU.\n  In this case, other hybrid pair interactions,\n  bond, angle,\n  dihedral, improper, and\n  long-range calculations can be performed on the\n  CPU while the GPU is performing force calculations for the GPU-enabled\n  pair style.  If all CPU force computations complete before the GPU\n  completes, LAMMPS will block until the GPU has finished before\n  continuing the timestep.\n  As an example, if you have two GPUs per node and 8 CPU cores per node,\n  and would like to run on 4 nodes (32 cores) with dynamic balancing of\n  force calculation across CPU and GPU cores, you could specify\n  mpirun -np 32 -sf gpu -in in.script    # launch command\n  package gpu 2 split -1                 # input script command\n  \n  \n  In this case, all CPU cores and GPU devices on the nodes would be\n  utilized.  Each GPU device would be shared by 4 CPU cores. The CPU\n  cores would perform force calculations for some fraction of the\n  particles at the same time the GPUs performed force calculation for\n  the other particles.\n  The gpuID keyword allows selection of which GPUs on each node will\n  be used for a simulation.  The first and last values specify the\n  GPU IDs to use (from 0 to Ngpu-1).  By default, first = 0 and last =\n  Ngpu-1, so that all GPUs are used, assuming Ngpu is set to the number\n  of physical GPUs.  If you only wish to use a subset, set Ngpu to a\n  smaller number and first/last to a sub-range of the available GPUs.\n  The tpa keyword sets the number of GPU thread per atom used to\n  perform force calculations.  With a default value of 1, the number of\n  threads will be chosen based on the pair style, however, the value can\n  be set explicitly with this keyword to fine-tune performance.  For\n  large cutoffs or with a small number of particles per GPU, increasing\n  the value can improve performance. The number of threads per atom must\n  be a power of 2 and currently cannot be greater than 32.\n  The device keyword can be used to tune parameters optimized for a\n  specific accelerator and platform when using OpenCL. OpenCL supports\n  the concept of a platform, which represents one or more devices that\n  share the same driver (e.g. there would be a different platform for\n  GPUs from different vendors or for CPU based accelerator support).\n  In LAMMPS only one platform can be active at a time and by default\n  the first platform with an accelerator is selected. This is equivalent\n  to using a platform ID of -1. The platform ID is a number corresponding\n  to the output of the ocl_get_devices tool. The platform ID is passed\n  to the GPU library, by prefixing the device keyword with that number\n  separated by a colon. For CUDA, the device keyword is ignored.\n  Currently, the device tuning support is limited to NVIDIA Kepler, NVIDIA\n  Fermi, AMD Cypress, Intel x86_64 CPU, Intel Xeon Phi, or a generic device.\n  More devices may be added later.  The default device type can be\n  specified when building LAMMPS with the GPU library, via setting a\n  variable in the lib/gpu/Makefile that is used.\n  In addition, a device type custom is available, which is followed by\n  13 comma separated numbers, which allows to set those tweakable parameters\n  from the package command. It can be combined with the (colon separated)\n  platform id. The individual settings are:\n  \n  MEM_THREADS\n  THREADS_PER_ATOM\n  THREADS_PER_CHARGE\n  BLOCK_PAIR\n  MAX_SHARED_TYPES\n  BLOCK_NBOR_BUILD\n  BLOCK_BIO_PAIR\n  BLOCK_ELLIPSE\n  WARP_SIZE\n  PPPM_BLOCK_1D\n  BLOCK_CELL_2D\n  BLOCK_CELL_ID\n  MAX_BIO_SHARED_TYPES\n  \n  The blocksize keyword allows you to tweak the number of threads used\n  per thread block. This number should be a multiple of 32 (for GPUs)\n  and its maximum depends on the specific GPU hardware. Typical choices\n  are 64, 128, or 256. A larger block size increases occupancy of\n  individual GPU cores, but reduces the total number of thread blocks,\n  thus may lead to load imbalance.\n  \n  The intel style invokes settings associated with the use of the\n  USER-INTEL package.  All of its settings, except the omp and mode\n  keywords, are ignored if LAMMPS was not built with Xeon Phi\n  co-processor support.  All of its settings, including the omp and\n  mode keyword are applicable if LAMMPS was built with co-processor\n  support.\n  The Nphi argument sets the number of co-processors per node.\n  This can be set to any value, including 0, if LAMMPS was not\n  built with co-processor support.\n  Optional keyword/value pairs can also be specified.  Each has a\n  default value as listed below.\n  The omp keyword determines the number of OpenMP threads allocated\n  for each MPI task when any portion of the interactions computed by a\n  USER-INTEL pair style are run on the CPU.  This can be the case even\n  if LAMMPS was built with co-processor support; see the balance\n  keyword discussion below.  If you are running with less MPI tasks/node\n  than there are CPUs, it can be advantageous to use OpenMP threading on\n  the CPUs.\n  \n  Note\n  The omp keyword has nothing to do with co-processor threads on\n  the Xeon Phi; see the tpc and tptask keywords below for a\n  discussion of co-processor threads.\n  \n  The Nthread value for the omp keyword sets the number of OpenMP\n  threads allocated for each MPI task.  Setting Nthread = 0 (the\n  default) instructs LAMMPS to use whatever value is the default for the\n  given OpenMP environment. This is usually determined via the\n  OMP_NUM_THREADS environment variable or the compiler runtime, which\n  is usually a value of 1.\n  For more details, including examples of how to set the OMP_NUM_THREADS\n  environment variable, see the discussion of the Nthreads setting on\n  this doc page for the “package omp” command.  Nthreads is a required\n  argument for the USER-OMP package.  Its meaning is exactly the same\n  for the USER-INTEL package.\n  \n  Note\n  If you build LAMMPS with both the USER-INTEL and USER-OMP\n  packages, be aware that both packages allow setting of the Nthreads\n  value via their package commands, but there is only a single global\n  Nthreads value used by OpenMP.  Thus if both package commands are\n  invoked, you should insure the two values are consistent.  If they are\n  not, the last one invoked will take precedence, for both packages.\n  Also note that if the -sf hybrid intel omp command-line switch is used, it invokes a “package intel”\n  command, followed by a “package omp” command, both with a setting of\n  Nthreads = 0.\n  \n  The mode keyword determines the precision mode to use for\n  computing pair style forces, either on the CPU or on the co-processor,\n  when using a USER-INTEL supported pair style.  It\n  can take a value of single, mixed which is the default, or\n  double.  Single means single precision is used for the entire\n  force calculation.  Mixed means forces between a pair of atoms are\n  computed in single precision, but accumulated and stored in double\n  precision, including storage of forces, torques, energies, and virial\n  quantities.  Double means double precision is used for the entire\n  force calculation.\n  The lrt keyword can be used to enable “Long Range Thread (LRT)”\n  mode. It can take a value of yes to enable and no to disable.\n  LRT mode generates an extra thread (in addition to any OpenMP threads\n  specified with the OMP_NUM_THREADS environment variable or the omp\n  keyword). The extra thread is dedicated for performing part of the\n  PPPM solver computations and communications. This\n  can improve parallel performance on processors supporting\n  Simultaneous Multithreading (SMT) such as Hyper-Threading (HT) on Intel\n  processors. In this mode, one additional thread is generated per MPI\n  process. LAMMPS will generate a warning in the case that more threads\n  are used than available in SMT hardware on a node. If the PPPM solver\n  from the USER-INTEL package is not used, then the LRT setting is\n  ignored and no extra threads are generated. Enabling LRT will replace\n  the run_style with the verlet/lrt/intel style that\n  is identical to the default verlet style aside from supporting the\n  LRT feature. This feature requires setting the pre-processor flag\n  -DLMP_INTEL_USELRT in the makefile when compiling LAMMPS.\n  The balance keyword sets the fraction of pair style work offloaded to the co-processor for split\n  values between 0.0 and 1.0 inclusive.  While this fraction of work is\n  running on the co-processor, other calculations will run on the host,\n  including neighbor and pair calculations that are not offloaded, as\n  well as angle, bond, dihedral, kspace, and some MPI communications.\n  If split is set to -1, the fraction of work is dynamically adjusted\n  automatically throughout the run.  This typically give performance\n  within 5 to 10 percent of the optimal fixed fraction.\n  The ghost keyword determines whether or not ghost atoms, i.e. atoms\n  at the boundaries of processor sub-domains, are offloaded for neighbor\n  and force calculations.  When the value = “no”, ghost atoms are not\n  offloaded.  This option can reduce the amount of data transfer with\n  the co-processor and can also overlap MPI communication of forces with\n  computation on the co-processor when the newton pair\n  setting is “on”.  When the value = “yes”, ghost atoms are offloaded.\n  In some cases this can provide better performance, especially if the\n  balance fraction is high.\n  The tpc keyword sets the max # of co-processor threads Ntpc that\n  will run on each core of the co-processor.  The default value = 4,\n  which is the number of hardware threads per core supported by the\n  current generation Xeon Phi chips.\n  The tptask keyword sets the max # of co-processor threads (Ntptask*\n  assigned to each MPI task.  The default value = 240, which is the\n  total # of threads an entire current generation Xeon Phi chip can run\n  (240 = 60 cores * 4 threads/core).  This means each MPI task assigned\n  to the Phi will enough threads for the chip to run the max allowed,\n  even if only 1 MPI task is assigned.  If 8 MPI tasks are assigned to\n  the Phi, each will run with 30 threads.  If you wish to limit the\n  number of threads per MPI task, set tptask to a smaller value.\n  E.g. for tptask = 16, if 8 MPI tasks are assigned, each will run\n  with 16 threads, for a total of 128.\n  Note that the default settings for tpc and tptask are fine for\n  most problems, regardless of how many MPI tasks you assign to a Phi.\n  The no_affinity keyword will turn off automatic setting of core\n  affinity for MPI tasks and OpenMP threads on the host when using\n  offload to a co-processor. Affinity settings are used when possible\n  to prevent MPI tasks and OpenMP threads from being on separate NUMA\n  domains and to prevent offload threads from interfering with other\n  processes/threads used for LAMMPS.\n  \n  The kokkos style invokes settings associated with the use of the\n  KOKKOS package.\n  All of the settings are optional keyword/value pairs. Each has a default\n  value as listed below.\n  The neigh keyword determines how neighbor lists are built. A value of\n  half uses a thread-safe variant of half-neighbor lists, the same as\n  used by most pair styles in LAMMPS, which is the default when running on\n  CPUs (i.e. the Kokkos CUDA back end is not enabled).\n  A value of full uses a full neighbor lists and is the default when\n  running on GPUs. This performs twice as much computation as the half\n  option, however that is often a win because it is thread-safe and\n  does not require atomic operations in the calculation of pair forces. For\n  that reason, full is the default setting for GPUs. However, when\n  running on CPUs, a half neighbor list is the default because it are\n  often faster, just as it is for non-accelerated pair styles. Similarly,\n  the neigh/qeq keyword determines how neighbor lists are built for fix qeq/reax/kk. If not explicitly set, the value of\n  neigh/qeq will match neigh.\n  If the neigh/thread keyword is set to off, then the KOKKOS package\n  threads only over atoms. However, for small systems, this may not expose\n  enough parallelism to keep a GPU busy. When this keyword is set to on,\n  the KOKKOS package threads over both atoms and neighbors of atoms. When\n  using neigh/thread on, a full neighbor list must also be used. Using\n  neigh/thread on may be slower for large systems, so this this option\n  is turned on by default only when there are 16K atoms or less owned by\n  an MPI rank and when using a full neighbor list. Not all KOKKOS-enabled\n  potentials support this keyword yet, and only thread over atoms. Many\n  simple pair-wise potentials such as Lennard-Jones do support threading\n  over both atoms and neighbors.\n  The newton keyword sets the Newton flags for pairwise and bonded\n  interactions to off or on, the same as the newton\n  command allows. The default for GPUs is off because this will almost\n  always give better performance for the KOKKOS package. This means more\n  computation is done, but less communication. However, when running on\n  CPUs a value of on is the default since it can often be faster, just\n  as it is for non-accelerated pair styles\n  The binsize keyword sets the size of bins used to bin atoms in\n  neighbor list builds. The same value can be set by the neigh_modify binsize command. Making it an option in the package\n  kokkos command allows it to be set from the command line. The default\n  value for CPUs is 0.0, which means the LAMMPS default will be used,\n  which is bins = 1/2 the size of the pairwise cutoff + neighbor skin\n  distance. This is fine when neighbor lists are built on the CPU. For GPU\n  builds, a 2x larger binsize equal to the pairwise cutoff + neighbor skin\n  is often faster, which is the default. Note that if you use a\n  longer-than-usual pairwise cutoff, e.g. to allow for a smaller fraction\n  of KSpace work with a long-range Coulombic solver\n  because the GPU is faster at performing pairwise interactions, then this\n  rule of thumb may give too large a binsize and the default should be\n  overridden with a smaller value.\n  The comm and comm/exchange and comm/forward and comm/reverse\n  keywords determine whether the host or device performs the packing and\n  unpacking of data when communicating per-atom data between processors.\n  “Exchange” communication happens only on timesteps that neighbor lists\n  are rebuilt. The data is only for atoms that migrate to new processors.\n  “Forward” communication happens every timestep. “Reverse” communication\n  happens every timestep if the newton option is on. The data is for\n  atom coordinates and any other atom properties that needs to be updated\n  for ghost atoms owned by each processor.\n  The comm keyword is simply a short-cut to set the same value for both\n  the comm/exchange and comm/forward and comm/reverse keywords.\n  The value options for all 3 keywords are no or host or device. A\n  value of no means to use the standard non-KOKKOS method of\n  packing/unpacking data for the communication. A value of host means to\n  use the host, typically a multi-core CPU, and perform the\n  packing/unpacking in parallel with threads. A value of device means to\n  use the device, typically a GPU, to perform the packing/unpacking\n  operation.\n  The optimal choice for these keywords depends on the input script and\n  the hardware used. The no value is useful for verifying that the\n  Kokkos-based host and device values are working correctly. It is the\n  default when running on CPUs since it is usually the fastest.\n  When running on CPUs or Xeon Phi, the host and device values work\n  identically. When using GPUs, the device value is the default since it\n  will typically be optimal if all of your styles used in your input\n  script are supported by the KOKKOS package. In this case data can stay\n  on the GPU for many timesteps without being moved between the host and\n  GPU, if you use the device value. If your script uses styles (e.g.\n  fixes) which are not yet supported by the KOKKOS package, then data has\n  to be move between the host and device anyway, so it is typically faster\n  to let the host handle communication, by using the host value. Using\n  host instead of no will enable use of multiple threads to\n  pack/unpack communicated data. When running small systems on a GPU,\n  performing the exchange pack/unpack on the host CPU can give speedup\n  since it reduces the number of CUDA kernel launches.\n  The cuda/aware keyword chooses whether CUDA-aware MPI will be used. When\n  this keyword is set to on, buffers in GPU memory are passed directly\n  through MPI send/receive calls. This reduces overhead of first copying\n  the data to the host CPU. However CUDA-aware MPI is not supported on all\n  systems, which can lead to segmentation faults and would require using a\n  value of off. If LAMMPS can safely detect that CUDA-aware MPI is not\n  available (currently only possible with OpenMPI v2.0.0 or later), then\n  the cuda/aware keyword is automatically set to off by default. When\n  the cuda/aware keyword is set to off while any of the comm\n  keywords are set to device, the value for these comm keywords will\n  be automatically changed to host. This setting has no effect if not\n  running on GPUs or if using only one MPI rank. CUDA-aware MPI is available\n  for OpenMPI 1.8 (or later versions), Mvapich2 1.9 (or later) when the\n  “MV2_USE_CUDA” environment variable is set to “1”, CrayMPI, and IBM\n  Spectrum MPI when the “-gpu” flag is used.\n  \n  The omp style invokes settings associated with the use of the\n  USER-OMP package.\n  The Nthread argument sets the number of OpenMP threads allocated for\n  each MPI task.  For example, if your system has nodes with dual\n  quad-core processors, it has a total of 8 cores per node.  You could\n  use two MPI tasks per node (e.g. using the -ppn option of the mpirun\n  command in MPICH or -npernode in OpenMPI), and set Nthreads = 4.\n  This would use all 8 cores on each node.  Note that the product of MPI\n  tasks * threads/task should not exceed the physical number of cores\n  (on a node), otherwise performance will suffer.\n  Setting Nthread = 0 instructs LAMMPS to use whatever value is the\n  default for the given OpenMP environment. This is usually determined\n  via the OMP_NUM_THREADS environment variable or the compiler\n  runtime.  Note that in most cases the default for OpenMP capable\n  compilers is to use one thread for each available CPU core when\n  OMP_NUM_THREADS is not explicitly set, which can lead to poor\n  performance.\n  Here are examples of how to set the environment variable when\n  launching LAMMPS:\n  env OMP_NUM_THREADS=4 lmp_machine -sf omp -in in.script\n  env OMP_NUM_THREADS=2 mpirun -np 2 lmp_machine -sf omp -in in.script\n  mpirun -x OMP_NUM_THREADS=2 -np 2 lmp_machine -sf omp -in in.script\n  \n  \n  or you can set it permanently in your shell’s start-up script.\n  All three of these examples use a total of 4 CPU cores.\n  Note that different MPI implementations have different ways of passing\n  the OMP_NUM_THREADS environment variable to all MPI processes.  The\n  2nd example line above is for MPICH; the 3rd example line with -x is\n  for OpenMPI.  Check your MPI documentation for additional details.\n  What combination of threads and MPI tasks gives the best performance\n  is difficult to predict and can depend on many components of your\n  input.  Not all features of LAMMPS support OpenMP threading via the\n  USER-OMP package and the parallel efficiency can be very different,\n  too.\n  Optional keyword/value pairs can also be specified.  Each has a\n  default value as listed below.\n  The neigh keyword specifies whether neighbor list building will be\n  multi-threaded in addition to force calculations.  If neigh is set\n  to no then neighbor list calculation is performed only by MPI tasks\n  with no OpenMP threading.  If mode is yes (the default), a\n  multi-threaded neighbor list build is used.  Using neigh = yes is\n  almost always faster and should produce identical neighbor lists at the\n  expense of using more memory.  Specifically, neighbor list pages are\n  allocated for all threads at the same time and each thread works\n  within its own pages.\n  ",
    "syntax": "package style args\n  \n  \n  \n  style = gpu or intel or kokkos or omp\n  args = arguments specific to the style\n  gpu args = Ngpu keyword value ...\n    Ngpu = # of GPUs per node\n    zero or more keyword/value pairs may be appended\n    keywords = neigh or newton or binsize or split or gpuID or tpa or device or blocksize\n      neigh value = yes or no\n        yes = neighbor list build on GPU (default)\n        no = neighbor list build on CPU\n      newton = off or on\n        off = set Newton pairwise flag off (default and required)\n        on = set Newton pairwise flag on (currently not allowed)\n      binsize value = size\n        size = bin size for neighbor list construction (distance units)\n      split = fraction\n        fraction = fraction of atoms assigned to GPU (default = 1.0)\n      gpuID values = first last\n        first = ID of first GPU to be used on each node\n        last = ID of last GPU to be used on each node\n      tpa value = Nthreads\n        Nthreads = # of GPU threads used per atom\n      device value = device_type or platform_id:device_type or platform_id:custom,val1,val2,val3,..,val13\n        platform_id = numerical OpenCL platform id (default: -1)\n        device_type = kepler or fermi or cypress or intel or phi or generic or custom\n        val1,val2,... = custom OpenCL tune parameters (see below for details)\n      blocksize value = size\n        size = thread block size for pair force computation\n  intel args = NPhi keyword value ...\n    Nphi = # of co-processors per node\n    zero or more keyword/value pairs may be appended\n    keywords = mode or omp or lrt or balance or ghost or tpc or tptask or no_affinity\n      mode value = single or mixed or double\n        single = perform force calculations in single precision\n        mixed = perform force calculations in mixed precision\n        double = perform force calculations in double precision\n      omp value = Nthreads\n        Nthreads = number of OpenMP threads to use on CPU (default = 0)\n      lrt value = yes or no\n        yes = use additional thread dedicated for some PPPM calculations\n        no = do not dedicate an extra thread for some PPPM calculations\n      balance value = split\n        split = fraction of work to offload to co-processor, -1 for dynamic\n      ghost value = yes or no\n        yes = include ghost atoms for offload\n        no = do not include ghost atoms for offload\n      tpc value = Ntpc\n        Ntpc = max number of co-processor threads per co-processor core (default = 4)\n      tptask value = Ntptask\n        Ntptask = max number of co-processor threads per MPI task (default = 240)\n      no_affinity values = none\n  kokkos args = keyword value ...\n    zero or more keyword/value pairs may be appended\n    keywords = neigh or neigh/qeq or neigh/thread or newton or binsize or comm or comm/exchange or comm/forward or comm/reverse or cuda/aware\n      neigh value = full or half\n        full = full neighbor list\n        half = half neighbor list built in thread-safe manner\n      neigh/qeq value = full or half\n        full = full neighbor list\n        half = half neighbor list built in thread-safe manner\n      neigh/thread value = off or on\n        off = thread only over atoms\n        on = thread over both atoms and neighbors\n      newton = off or on\n        off = set Newton pairwise and bonded flags off\n        on = set Newton pairwise and bonded flags on\n      binsize value = size\n        size = bin size for neighbor list construction (distance units)\n      comm value = no or host or device\n        use value for comm/exchange and comm/forward and comm/reverse\n      comm/exchange value = no or host or device\n      comm/forward value = no or host or device\n      comm/reverse value = no or host or device\n        no = perform communication pack/unpack in non-KOKKOS mode\n        host = perform pack/unpack on host (e.g. with OpenMP threading)\n        device = perform pack/unpack on device (e.g. on GPU)\n      cuda/aware = off or on\n        off = do not use CUDA-aware MPI\n        on = use CUDA-aware MPI (default)\n  omp args = Nthreads keyword value ...\n    Nthread = # of OpenMP threads to associate with each MPI process\n    zero or more keyword/value pairs may be appended\n    keywords = neigh\n      neigh value = yes or no\n        yes = threaded neighbor list build (default)\n        no = non-threaded neighbor list build\n  \n  \n  ",
    "examples": "package gpu 1\n  package gpu 1 split 0.75\n  package gpu 2 split -1.0\n  package gpu 1 device kepler\n  package gpu 1 device 2:generic\n  package gpu 1 device custom,32,4,8,256,11,128,256,128,32,64,8,128,128\n  package kokkos neigh half comm device\n  package omp 0 neigh no\n  package omp 4\n  package intel 1\n  package intel 2 omp 4 mode mixed balance 0.5\n  \n  \n  ",
    "restrictions": "This command cannot be used after the simulation box is defined by a\n  read_data or create_box command.\n  The gpu style of this command can only be invoked if LAMMPS was built\n  with the GPU package.  See the Build package doc\n  page for more info.\n  The intel style of this command can only be invoked if LAMMPS was\n  built with the USER-INTEL package.  See the Build package doc page for more info.\n  The kk style of this command can only be invoked if LAMMPS was built\n  with the KOKKOS package.  See the Build package\n  doc page for more info.\n  The omp style of this command can only be invoked if LAMMPS was built\n  with the USER-OMP package.  See the Build package\n  doc page for more info.\n  "
},
{
    "command": "pair_coeff",
    "description": "Specify the pairwise force field coefficients for one or more pairs of\n  atom types.  The number and meaning of the coefficients depends on the\n  pair style.  Pair coefficients can also be set in the data file read\n  by the read_data command or in a restart file.\n  I and J can be specified in one of two ways.  Explicit numeric values\n  can be used for each, as in the 1st example above.  I <= J is\n  required.  LAMMPS sets the coefficients for the symmetric J,I\n  interaction to the same values.\n  A wildcard asterisk can be used in place of or in conjunction with the\n  I,J arguments to set the coefficients for multiple pairs of atom\n  types.  This takes the form “*” or “*n” or “n*” or “m*n”.  If N = the\n  number of atom types, then an asterisk with no numeric values means all\n  types from 1 to N.  A leading asterisk means all types from 1 to n\n  (inclusive).  A trailing asterisk means all types from n to N\n  (inclusive).  A middle asterisk means all types from m to n\n  (inclusive).  Note that only type pairs with I <= J are considered; if\n  asterisks imply type pairs where J < I, they are ignored.\n  Note that a pair_coeff command can override a previous setting for the\n  same I,J pair.  For example, these commands set the coeffs for all I,J\n  pairs, then overwrite the coeffs for just the I,J = 2,3 pair:\n  pair_coeff * * 1.0 1.0 2.5\n  pair_coeff 2 3 2.0 1.0 1.12\n  \n  \n  A line in a data file that specifies pair coefficients uses the exact\n  same format as the arguments of the pair_coeff command in an input\n  script, with the exception of the I,J type arguments.  In each line of\n  the “Pair Coeffs” section of a data file, only a single type I is\n  specified, which sets the coefficients for type I interacting with\n  type I.  This is because the section has exactly N lines, where N =\n  the number of atom types.  For this reason, the wild-card asterisk\n  should also not be used as part of the I argument.  Thus in a data\n  file, the line corresponding to the 1st example above would be listed\n  as\n  2 1.0 1.0 2.5\n  \n  \n  For many potentials, if coefficients for type pairs with I != J are\n  not set explicitly by a pair_coeff command, the values are inferred\n  from the I,I and J,J settings by mixing rules; see the\n  pair_modify command for a discussion.  Details on\n  this option as it pertains to individual potentials are described on\n  the doc page for the potential.\n  Many pair styles, typically for many-body potentials, use tabulated\n  potential files as input, when specifying the pair_coeff command.\n  Potential files provided with LAMMPS are in the potentials directory\n  of the distribution.  For some potentials, such as EAM, other archives\n  of suitable files can be found on the Web.  They can be used with\n  LAMMPS so long as they are in the format LAMMPS expects, as discussed\n  on the individual doc pages.\n  When a pair_coeff command using a potential file is specified, LAMMPS\n  looks for the potential file in 2 places.  First it looks in the\n  location specified.  E.g. if the file is specified as “niu3.eam”, it\n  is looked for in the current working directory.  If it is specified as\n  “../potentials/niu3.eam”, then it is looked for in the potentials\n  directory, assuming it is a sister directory of the current working\n  directory.  If the file is not found, it is then looked for in the\n  directory specified by the LAMMPS_POTENTIALS environment variable.\n  Thus if this is set to the potentials directory in the LAMMPS distribution,\n  then you can use those files from anywhere on your system, without\n  copying them into your working directory.  Environment variables are\n  set in different ways for different shells.  Here are example settings\n  for\n  csh, tcsh:\n  % setenv LAMMPS_POTENTIALS /path/to/lammps/potentials\n  \n  \n  bash:\n  % export LAMMPS_POTENTIALS=/path/to/lammps/potentials\n  \n  \n  Windows:\n  % set LAMMPS_POTENTIALS=\"C:\\Path to LAMMPS\\Potentials\"\n  \n  The alphabetic list of pair styles defined in LAMMPS is given on the\n  pair_style doc page.  They are also listed in more\n  compact form on the Commands pair doc page.\n  Click on the style to display the formula it computes and its\n  coefficients as specified by the associated pair_coeff command.\n  ",
    "syntax": "pair_coeff I J args\n  \n  \n  \n  I,J = atom types (see asterisk form below)\n  args = coefficients for one or more pairs of atom types\n  \n  ",
    "examples": "pair_coeff 1 2 1.0 1.0 2.5\n  pair_coeff 2 * 1.0 1.0\n  pair_coeff 3* 1*2 1.0 1.0 2.5\n  pair_coeff * * 1.0 1.0\n  pair_coeff * * nialhjea 1 1 2\n  pair_coeff * 3 morse.table ENTRY1\n  pair_coeff 1 2 lj/cut 1.0 1.0 2.5 (for pair_style hybrid)\n  \n  \n  ",
    "restrictions": "This command must come after the simulation box is defined by a\n  read_data, read_restart, or\n  create_box command.\n  "
},
{
    "command": "pair_modify",
    "description": "Modify the parameters of the currently defined pair style.  If the\n  pair style is hybrid or hybrid/overlay, then the\n  specified parameters are by default modified for all the hybrid sub-styles.\n  \n  Note\n  The behavior for hybrid pair styles can be changed by using the pair\n  keyword, which allows selection of a specific sub-style to apply all\n  remaining keywords to.\n  The special and compute/tally keywords can only be\n  used in conjunction with the pair keyword.  See further details about\n  these 3 keywords below.\n  \n  The mix keyword affects pair coefficients for interactions between\n  atoms of type I and J, when I != J and the coefficients are not\n  explicitly set in the input script.  Note that coefficients for I = J\n  must be set explicitly, either in the input script via the\n  pair_coeff command or in the “Pair Coeffs” section of the\n  data file.  For some pair styles it is not\n  necessary to specify coefficients when I != J, since a “mixing” rule\n  will create them from the I,I and J,J settings.  The pair_modify\n  mix value determines what formulas are used to compute the mixed\n  coefficients.  In each case, the cutoff distance is mixed the same way\n  as sigma.\n  Note that not all pair styles support mixing and some mix options\n  are not available for certain pair styles. Also, there are additional\n  restrictions when using pair style hybrid or hybrid/overlay.\n  See the doc page for individual pair styles for those restrictions.  Note also that the\n  pair_coeff command also can be used to directly set\n  coefficients for a specific I != J pairing, in which case no mixing is\n  performed.\n  \n  mix geometric\n  \n  \\[\\begin{split}\\epsilon_{ij} = & \\sqrt{\\epsilon_i  \\epsilon_j} \\\\\n  \\sigma_{ij}   = & \\sqrt{\\sigma_i  \\sigma_j}\\end{split}\\]\n  \n  mix arithmetic\n  \n  \\[\\begin{split}\\epsilon_{ij} = & \\sqrt{\\epsilon_i  \\epsilon_j} \\\\\n  \\sigma_{ij}   = & \\frac{1}{2} (\\sigma_i + \\sigma_j)\\end{split}\\]\n  \n  mix sixthpower\n  \n  \\[\\begin{split}\\epsilon_{ij} = & \\frac{2 \\sqrt{\\epsilon_i \\epsilon_j} \\sigma_i^3 \\sigma_j^3}{\\sigma_i^6 + \\sigma_j^6} \\\\\n  \\sigma_{ij} =   & \\left(\\frac{1}{2} (\\sigma_i^6 + \\sigma_j^6) \\right)^{\\frac{1}{6}}\\end{split}\\]\n  \n  \n  The shift keyword determines whether a Lennard-Jones potential is\n  shifted at its cutoff to 0.0.  If so, this adds an energy term to each\n  pairwise interaction which will be included in the thermodynamic\n  output, but does not affect pair forces or atom trajectories.  See the\n  doc page for individual pair styles to see which ones support this\n  option.\n  The table and table/disp keywords apply to pair styles with a\n  long-range Coulombic term or long-range dispersion term respectively;\n  see the doc page for individual styles to see which potentials support\n  these options.  If N is non-zero, a table of length 2^N is\n  pre-computed for forces and energies, which can shrink their\n  computational cost by up to a factor of 2.  The table is indexed via a\n  bit-mapping technique (Wolff) and a linear\n  interpolation is performed between adjacent table values.  In our\n  experiments with different table styles (lookup, linear, spline), this\n  method typically gave the best performance in terms of speed and\n  accuracy.\n  The choice of table length is a tradeoff in accuracy versus speed.  A\n  larger N yields more accurate force computations, but requires more\n  memory which can slow down the computation due to cache misses.  A\n  reasonable value of N is between 8 and 16.  The default value of 12\n  (table of length 4096) gives approximately the same accuracy as the\n  no-table (N = 0) option.  For N = 0, forces and energies are computed\n  directly, using a polynomial fit for the needed erfc() function\n  evaluation, which is what earlier versions of LAMMPS did.  Values\n  greater than 16 typically slow down the simulation and will not\n  improve accuracy; values from 1 to 8 give unreliable results.\n  The tabinner and tabinner/disp keywords set an inner cutoff above\n  which the pairwise computation is done by table lookup (if tables are\n  invoked), for the corresponding Coulombic and dispersion tables\n  discussed with the table and table/disp keywords.  The smaller the\n  cutoff is set, the less accurate the table becomes (for a given number\n  of table values), which can require use of larger tables.  The default\n  cutoff value is sqrt(2.0) distance units which means nearly all\n  pairwise interactions are computed via table lookup for simulations\n  with “real” units, but some close pairs may be computed directly\n  (non-table) for simulations with “lj” units.\n  When the tail keyword is set to yes, certain pair styles will\n  add a long-range VanderWaals tail “correction” to the energy and\n  pressure.  These corrections are bookkeeping terms which do not affect\n  dynamics, unless a constant-pressure simulation is being performed.\n  See the doc page for individual styles to see which support this\n  option.  These corrections are included in the calculation and\n  printing of thermodynamic quantities (see the thermo_style command).  Their effect will also be included in\n  constant NPT or NPH simulations where the pressure influences the\n  simulation box dimensions (e.g. the fix npt and\n  fix nph commands).  The formulas used for the\n  long-range corrections come from equation 5 of (Sun).\n  \n  Note\n  The tail correction terms are computed at the beginning of each\n  run, using the current atom counts of each atom type.  If atoms are\n  deleted (or lost) or created during a simulation, e.g. via the\n  fix gcmc command, the correction factors are not\n  re-computed.  If you expect the counts to change dramatically, you\n  can break a run into a series of shorter runs so that the\n  correction factors are re-computed more frequently.\n  \n  Several additional assumptions are inherent in using tail corrections,\n  including the following:\n  \n  The simulated system is a 3d bulk homogeneous liquid. This option\n  should not be used for systems that are non-liquid, 2d, have a slab\n  geometry (only 2d periodic), or inhomogeneous.\n  G(r), the radial distribution function (rdf), is unity beyond the\n  cutoff, so a fairly large cutoff should be used (i.e. 2.5 sigma for\n  an LJ fluid), and it is probably a good idea to verify this\n  assumption by checking the rdf.  The rdf is not exactly unity beyond\n  the cutoff for each pair of interaction types, so the tail\n  correction is necessarily an approximation.\n  The tail corrections are computed at the beginning of each\n  simulation run.  If the number of atoms changes during the run,\n  e.g. due to atoms leaving the simulation domain, or use of the\n  fix gcmc command, then the corrections are not\n  updated to reflect the changed atom count.  If this is a large\n  effect in your simulation, you should break the long run into\n  several short runs, so that the correction factors are re-computed\n  multiple times.\n  \n  Thermophysical properties obtained from calculations with this\n  option enabled will not be thermodynamically consistent with the\n  truncated force-field that was used.  In other words, atoms do not\n  feel any LJ pair interactions beyond the cutoff, but the energy and\n  pressure reported by the simulation include an estimated\n  contribution from those interactions.\n  \n  The compute keyword allows pairwise computations to be turned off,\n  even though a pair_style is defined.  This is not\n  useful for running a real simulation, but can be useful for debugging\n  purposes or for performing a rerun simulation, when you\n  only wish to compute partial forces that do not include the pairwise\n  contribution.\n  Two examples are as follows.  First, this option allows you to perform\n  a simulation with pair_style hybrid with only a\n  subset of the hybrid sub-styles enabled.  Second, this option allows\n  you to perform a simulation with only long-range interactions but no\n  short-range pairwise interactions.  Doing this by simply not defining\n  a pair style will not work, because the kspace_style command requires a Kspace-compatible pair style be\n  defined.\n  The nofdotr keyword allows to disable an optimization that computes\n  the global stress tensor from the total forces and atom positions\n  rather than from summing forces between individual pairs of atoms.\n  \n  The pair keyword can only be used with the hybrid and\n  hybrid/overlay pair styles.  If used, it must appear\n  first in the list of keywords.\n  Its meaning is that all the following parameters will only be modified\n  for the specified sub-style.  If the sub-style is defined multiple\n  times, then an additional numeric argument N must also be specified,\n  which is a number from 1 to M where M is the number of times the\n  sub-style was listed in the pair_style hybrid\n  command.  The extra number indicates which instance of the sub-style\n  the remaining keywords will be applied to.\n  The special and compute/tally keywords can only be used in\n  conjunction with the pair keyword and they must directly follow it.\n  I.e. any other keyword, must appear after pair, special, and\n  compute/tally.\n  The special keyword overrides the global special_bonds\n  1-2, 1-3, 1-4 exclusion settings (weights) for the sub-style selected\n  by the pair keyword.\n  Similar to the special_bonds command, it takes\n  4 arguments.  The which argument can be lj to change only the\n  non-Coulomb weights (e.g. Lennard-Jones or Buckingham), coul to change\n  only the Coulombic settings, or lj/coul to change both to the same\n  values.  The wt1,wt2,wt3 values are numeric weights from 0.0 to 1.0\n  inclusive, for the 1-2, 1-3, and 1-4 bond topology neighbors, respectively.\n  The special keyword can be used multiple times, e.g. to set the lj\n  and coul settings to different values.\n  \n  Note\n  The special keyword is not compatible with pair styles from the\n  GPU or the USER-INTEL package and attempting to use it will cause\n  an error.\n  \n  \n  Note\n  Weights of exactly 0.0 or 1.0 in the special_bonds\n  command have implications on the neighbor list construction, which\n  means that they cannot be overridden by using the special keyword.\n  One workaround for this restriction is to use the special_bonds\n  command with weights like 1.0e-10 or 0.999999999 instead of 0.0 or 1.0,\n  respectively, which enables to reset each them to any value between 0.0\n  and 1.0 inclusively.  Otherwise you can set all global weights to\n  an arbitrary number between 0.0 or 1.0, like 0.5, and then you have\n  to override all special settings for all sub-styles which use\n  the 1-2, 1-3, and 1-4 exclusion weights in their force/energy computation.\n  \n  The compute/tally keyword disables or enables registering compute\n  */tally computes for the sub-style specified by\n  the pair keyword.  Use no to disable, or yes to enable.\n  \n  Note\n  The “pair_modify pair compute/tally” command must be issued\n  before the corresponding compute style is defined.\n  \n  ",
    "syntax": "pair_modify keyword values ...\n  \n  \n  \n  one or more keyword/value pairs may be listed\n  keyword = pair or shift or mix or table or table/disp or tabinner\n  or tabinner/disp or tail or compute or nofdotr or special or\n  compute/tally\n  pair value = sub-style N\n    sub-style = sub-style of pair hybrid\n    N = which instance of sub-style (1 to M), only specify if sub-style is used multiple times\n  mix value = geometric or arithmetic or sixthpower\n  shift value = yes or no\n  table value = N\n    2^N = # of values in table\n  table/disp value = N\n    2^N = # of values in table\n  tabinner value = cutoff\n    cutoff = inner cutoff at which to begin table (distance units)\n  tabinner/disp value = cutoff\n    cutoff = inner cutoff at which to begin table (distance units)\n  tail value = yes or no\n  compute value = yes or no\n  nofdotr value = none\n  special values = which wt1 wt2 wt3\n     which = lj/coul or lj or coul\n     w1,w2,w3 = 1-2, 1-3, 1-4 weights from 0.0 to 1.0 inclusive\n  compute/tally value = yes or no\n  \n  \n  ",
    "examples": "pair_modify shift yes mix geometric\n  pair_modify tail yes\n  pair_modify table 12\n  pair_modify pair lj/cut compute no\n  pair_modify pair tersoff compute/tally no\n  pair_modify pair lj/cut/coul/long 1 special lj/coul 0.0 0.0 0.0\n  pair_modify pair lj/cut/coul/long special lj 0.0 0.0 0.5 special coul 0.0 0.0 0.8333333\n  \n  \n  ",
    "restrictions": "You cannot use shift yes with tail yes, since those are\n  conflicting options.  You cannot use tail yes with 2d simulations.\n  You cannot use special with pair styles from the GPU or\n  USER-INTEL package.\n  "
},
{
    "command": "pair_style",
    "description": "Set the formula(s) LAMMPS uses to compute pairwise interactions.  In\n  LAMMPS, pair potentials are defined between pairs of atoms that are\n  within a cutoff distance and the set of active interactions typically\n  changes over time.  See the bond_style command to\n  define potentials between pairs of bonded atoms, which typically\n  remain in place for the duration of a simulation.\n  In LAMMPS, pairwise force fields encompass a variety of interactions,\n  some of which include many-body effects, e.g. EAM, Stillinger-Weber,\n  Tersoff, REBO potentials.  They are still classified as “pairwise”\n  potentials because the set of interacting atoms changes with time\n  (unlike molecular bonds) and thus a neighbor list is used to find\n  nearby interacting atoms.\n  Hybrid models where specified pairs of atom types interact via\n  different pair potentials can be setup using the hybrid pair style.\n  The coefficients associated with a pair style are typically set for\n  each pair of atom types, and are specified by the\n  pair_coeff command or read from a file by the\n  read_data or read_restart\n  commands.\n  The pair_modify command sets options for mixing of\n  type I-J interaction coefficients and adding energy offsets or tail\n  corrections to Lennard-Jones potentials.  Details on these options as\n  they pertain to individual potentials are described on the doc page\n  for the potential.  Likewise, info on whether the potential\n  information is stored in a restart file is listed\n  on the potential doc page.\n  In the formulas listed for each pair style, E is the energy of a\n  pairwise interaction between two atoms separated by a distance r.\n  The force between the atoms is the negative derivative of this\n  expression.\n  If the pair_style command has a cutoff argument, it sets global\n  cutoffs for all pairs of atom types.  The distance(s) can be smaller\n  or larger than the dimensions of the simulation box.\n  Typically, the global cutoff value can be overridden for a specific\n  pair of atom types by the pair_coeff command.  The\n  pair style settings (including global cutoffs) can be changed by a\n  subsequent pair_style command using the same style.  This will reset\n  the cutoffs for all atom type pairs, including those previously set\n  explicitly by a pair_coeff command.  The exceptions\n  to this are that pair_style table and hybrid settings cannot be\n  reset.  A new pair_style command for these styles will wipe out all\n  previously specified pair_coeff values.\n  \n  Here is an alphabetic list of pair styles defined in LAMMPS.  They are\n  also listed in more compact form on the Commands pair doc page.\n  Click on the style to display the formula it computes, any additional\n  arguments specified in the pair_style command, and coefficients\n  specified by the associated pair_coeff command.\n  There are also additional accelerated pair styles included in the\n  LAMMPS distribution for faster performance on CPUs, GPUs, and KNLs.\n  The individual style names on the Commands pair\n  doc page are followed by one or more of (g,i,k,o,t) to indicate which\n  accelerated styles exist.\n  \n  none - turn off pairwise interactions\n  hybrid - multiple styles of pairwise interactions\n  hybrid/overlay - multiple styles of superposed pairwise interactions\n  zero - neighbor list but no interactions\n  adp - angular dependent potential (ADP) of Mishin\n  agni - machine learned potential mapping atomic environment to forces\n  airebo - AIREBO potential of Stuart\n  airebo/morse - AIREBO with Morse instead of LJ\n  atm - Axilrod-Teller-Muto potential\n  awpmd/cut - Antisymmetrized Wave Packet MD potential for atoms and electrons\n  beck - Beck potential\n  body/nparticle - interactions between body particles\n  body/rounded/polygon - granular-style 2d polygon potential\n  body/rounded/polyhedron - granular-style 3d polyhedron potential\n  bop - BOP potential of Pettifor\n  born - Born-Mayer-Huggins potential\n  born/coul/dsf - Born with damped-shifted-force model\n  born/coul/dsf/cs - Born with damped-shifted-force and core/shell model\n  born/coul/long - Born with long-range Coulombics\n  born/coul/long/cs - Born with long-range Coulombics and core/shell\n  born/coul/msm - Born with long-range MSM Coulombics\n  born/coul/wolf - Born with Wolf potential for Coulombics\n  born/coul/wolf/cs - Born with Wolf potential for Coulombics and core/shell model\n  brownian - Brownian potential for Fast Lubrication Dynamics\n  brownian/poly - Brownian potential for Fast Lubrication Dynamics with polydispersity\n  buck - Buckingham potential\n  buck/coul/cut - Buckingham with cutoff Coulomb\n  buck/coul/long - Buckingham with long-range Coulombics\n  buck/coul/long/cs - Buckingham with long-range Coulombics and core/shell\n  buck/coul/msm - Buckingham with long-range MSM Coulombics\n  buck/long/coul/long - long-range Buckingham with long-range Coulombics\n  buck/mdf - Buckingham with a taper function\n  buck6d/coul/gauss/dsf - dispersion-damped Buckingham with damped-shift-force model\n  buck6d/coul/gauss/long - dispersion-damped Buckingham with long-range Coulombics\n  colloid - integrated colloidal potential\n  comb - charge-optimized many-body (COMB) potential\n  comb3 - charge-optimized many-body (COMB3) potential\n  cosine/squared - Cooke-Kremer-Deserno membrane model potential\n  coul/cut - cutoff Coulombic potential\n  coul/cut/soft - Coulombic potential with a soft core\n  coul/debye - cutoff Coulombic potential with Debye screening\n  coul/diel - Coulomb potential with dielectric permittivity\n  coul/dsf - Coulombics with damped-shifted-force model\n  coul/long - long-range Coulombic potential\n  coul/long/cs - long-range Coulombic potential and core/shell\n  coul/long/soft - long-range Coulombic potential with a soft core\n  coul/msm - long-range MSM Coulombics\n  coul/slater/cut - smeared out Coulombics\n  coul/slater/long - long-range smeared out Coulombics\n  coul/shield - Coulombics for boron nitride for use with ilp/graphene/hbn potential\n  coul/streitz - Coulombics via Streitz/Mintmire Slater orbitals\n  coul/wolf - Coulombics via Wolf potential\n  coul/wolf/cs - ditto with core/shell adjustments\n  dpd - dissipative particle dynamics (DPD)\n  dpd/fdt - DPD for constant temperature and pressure\n  dpd/fdt/energy - DPD for constant energy and enthalpy\n  dpd/tstat - pair-wise DPD thermostatting\n  dsmc - Direct Simulation Monte Carlo (DSMC)\n  e3b - Explicit-three body (E3B) water model\n  drip - Dihedral-angle-corrected registry-dependent interlayer potential (DRIP)\n  eam - embedded atom method (EAM)\n  eam/alloy - alloy EAM\n  eam/cd - concentration-dependent EAM\n  eam/cd/old - older two-site model for concentration-dependent EAM\n  eam/fs - Finnis-Sinclair EAM\n  edip - three-body EDIP potential\n  edip/multi - multi-element EDIP potential\n  edpd - eDPD particle interactions\n  eff/cut - electron force field with a cutoff\n  eim - embedded ion method (EIM)\n  exp6/rx - reactive DPD potential\n  extep - extended Tersoff potential\n  gauss - Gaussian potential\n  gauss/cut - generalized Gaussian potential\n  gayberne - Gay-Berne ellipsoidal potential\n  granular - Generalized granular potential\n  gran/hertz/history - granular potential with Hertzian interactions\n  gran/hooke - granular potential with history effects\n  gran/hooke/history - granular potential without history effects\n  gw - Gao-Weber potential\n  gw/zbl - Gao-Weber potential with a repulsive ZBL core\n  hbond/dreiding/lj - DREIDING hydrogen bonding LJ potential\n  hbond/dreiding/morse - DREIDING hydrogen bonding Morse potential\n  ilp/graphene/hbn - registry-dependent interlayer potential (ILP)\n  kim - interface to potentials provided by KIM project\n  kolmogorov/crespi/full - Kolmogorov-Crespi (KC) potential with no simplifications\n  kolmogorov/crespi/z - Kolmogorov-Crespi (KC) potential with normals along z-axis\n  lcbop - long-range bond-order potential (LCBOP)\n  lebedeva/z - Lebedeva interlayer potential for graphene with normals along z-axis\n  lennard/mdf - LJ potential in A/B form with a taper function\n  line/lj - LJ potential between line segments\n  list - potential between pairs of atoms explicitly listed in an input file\n  lj/charmm/coul/charmm - CHARMM potential with cutoff Coulomb\n  lj/charmm/coul/charmm/implicit - CHARMM for implicit solvent\n  lj/charmm/coul/long - CHARMM with long-range Coulomb\n  lj/charmm/coul/long/soft - CHARMM with long-range Coulomb and a soft core\n  lj/charmm/coul/msm - CHARMM with long-range MSM Coulombics\n  lj/charmmfsw/coul/charmmfsh - CHARMM with force switching and shifting\n  lj/charmmfsw/coul/long - CHARMM with force switching and long-rnage Coulombics\n  lj/class2 - COMPASS (class 2) force field with no Coulomb\n  lj/class2/coul/cut - COMPASS with cutoff Coulomb\n  lj/class2/coul/cut/soft - COMPASS with cutoff Coulomb with a soft core\n  lj/class2/coul/long - COMPASS with long-range Coulomb\n  lj/class2/coul/long/soft - COMPASS with long-range Coulomb with a soft core\n  lj/class2/soft - COMPASS (class 2) force field with no Coulomb with a soft core\n  lj/cubic - LJ with cubic after inflection point\n  lj/cut - cutoff Lennard-Jones potential with no Coulomb\n  lj/cut/coul/cut - LJ with cutoff Coulomb\n  lj/cut/coul/cut/soft - LJ with cutoff Coulomb with a soft core\n  lj/cut/coul/debye - LJ with Debye screening added to Coulomb\n  lj/cut/coul/dsf - LJ with Coulombics via damped shifted forces\n  lj/cut/coul/long - LJ with long-range Coulombics\n  lj/cut/coul/long/cs - ditto with core/shell adjustments\n  lj/cut/coul/long/soft - LJ with long-range Coulombics with a soft core\n  lj/cut/coul/msm - LJ with long-range MSM Coulombics\n  lj/cut/coul/wolf - LJ with Coulombics via Wolf potential\n  lj/cut/dipole/cut - point dipoles with cutoff\n  lj/cut/dipole/long - point dipoles with long-range Ewald\n  lj/cut/soft - LJ with a soft core\n  lj/cut/thole/long - LJ with Coulombics with thole damping\n  lj/cut/tip4p/cut - LJ with cutoff Coulomb for TIP4P water\n  lj/cut/tip4p/long - LJ with long-range Coulomb for TIP4P water\n  lj/cut/tip4p/long/soft - LJ with cutoff Coulomb for TIP4P water with a soft core\n  lj/expand - Lennard-Jones for variable size particles\n  lj/expand/coul/long - Lennard-Jones for variable size particles with long-range Coulombics\n  lj/gromacs - GROMACS-style Lennard-Jones potential\n  lj/gromacs/coul/gromacs - GROMACS-style LJ and Coulombic potential\n  lj/long/coul/long - long-range LJ and long-range Coulombics\n  lj/long/dipole/long - long-range LJ and long-range point dipoles\n  lj/long/tip4p/long - long-range LJ and long-range Coulombics for TIP4P water\n  lj/mdf - LJ potential with a taper function\n  lj/sdk - LJ for SDK coarse-graining\n  lj/sdk/coul/long - LJ for SDK coarse-graining with long-range Coulombics\n  lj/sdk/coul/msm - LJ for SDK coarse-graining with long-range Coulombics via MSM\n  lj/sf/dipole/sf - LJ with dipole interaction with shifted forces\n  lj/smooth - smoothed Lennard-Jones potential\n  lj/smooth/linear - linear smoothed LJ potential\n  lj/switch3/coulgauss/long - smoothed LJ vdW potential with Gaussian electrostatics\n  lj96/cut - Lennard-Jones 9/6 potential\n  local/density - generalized basic local density potential\n  lubricate - hydrodynamic lubrication forces\n  lubricate/poly - hydrodynamic lubrication forces with polydispersity\n  lubricateU - hydrodynamic lubrication forces for Fast Lubrication Dynamics\n  lubricateU/poly - hydrodynamic lubrication forces for Fast Lubrication with polydispersity\n  mdpd - mDPD particle interactions\n  mdpd/rhosum - mDPD particle interactions for mass density\n  meam/c - modified embedded atom method (MEAM) in C\n  meam/spline - splined version of MEAM\n  meam/sw/spline - splined version of MEAM with a Stillinger-Weber term\n  mesocnt - mesoscale model for (carbon) nanotubes\n  mgpt - simplified model generalized pseudopotential theory (MGPT) potential\n  mie/cut - Mie potential\n  mm3/switch3/coulgauss/long - smoothed MM3 vdW potential with Gaussian electrostatics\n  momb - Many-Body Metal-Organic (MOMB) force field\n  morse - Morse potential\n  morse/smooth/linear - linear smoothed Morse potential\n  morse/soft - Morse potential with a soft core\n  multi/lucy - DPD potential with density-dependent force\n  multi/lucy/rx - reactive DPD potential with density-dependent force\n  nb3b/harmonic - non-bonded 3-body harmonic potential\n  nm/cut - N-M potential\n  nm/cut/coul/cut - N-M potential with cutoff Coulomb\n  nm/cut/coul/long - N-M potential with long-range Coulombics\n  oxdna/coaxstk -\n  oxdna/excv -\n  oxdna/hbond -\n  oxdna/stk -\n  oxdna/xstk -\n  oxdna2/coaxstk -\n  oxdna2/dh -\n  oxdna2/excv -\n  oxdna2/hbond -\n  oxdna2/stk -\n  oxdna2/xstk -\n  oxrna2/coaxstk -\n  oxrna2/dh -\n  oxrna2/excv -\n  oxrna2/hbond -\n  oxrna2/stk -\n  oxrna2/xstk -\n  peri/eps - peridynamic EPS potential\n  peri/lps - peridynamic LPS potential\n  peri/pmb - peridynamic PMB potential\n  peri/ves - peridynamic VES potential\n  polymorphic - polymorphic 3-body potential\n  python -\n  quip -\n  reax/c - ReaxFF potential in C\n  rebo - 2nd generation REBO potential of Brenner\n  resquared - Everaers RE-Squared ellipsoidal potential\n  sdpd/taitwater/isothermal - smoothed dissipative particle dynamics for water at isothermal conditions\n  smd/hertz -\n  smd/tlsph -\n  smd/tri_surface -\n  smd/ulsph -\n  smtbq -\n  snap - SNAP quantum-accurate potential\n  soft - Soft (cosine) potential\n  sph/heatconduction -\n  sph/idealgas -\n  sph/lj -\n  sph/rhosum -\n  sph/taitwater -\n  sph/taitwater/morris -\n  spin/dipole/cut -\n  spin/dipole/long -\n  spin/dmi -\n  spin/exchange -\n  spin/magelec -\n  spin/neel -\n  srp -\n  sw - Stillinger-Weber 3-body potential\n  table - tabulated pair potential\n  table/rx -\n  tdpd - tDPD particle interactions\n  tersoff - Tersoff 3-body potential\n  tersoff/mod - modified Tersoff 3-body potential\n  tersoff/mod/c -\n  tersoff/table -\n  tersoff/zbl - Tersoff/ZBL 3-body potential\n  thole - Coulomb interactions with thole damping\n  tip4p/cut - Coulomb for TIP4P water w/out LJ\n  tip4p/long - long-range Coulombics for TIP4P water w/out LJ\n  tip4p/long/soft -\n  tri/lj - LJ potential between triangles\n  ufm -\n  vashishta - Vashishta 2-body and 3-body potential\n  vashishta/table -\n  yukawa - Yukawa potential\n  yukawa/colloid - screened Yukawa potential for finite-size particles\n  zbl - Ziegler-Biersack-Littmark potential\n  \n  ",
    "syntax": "pair_style style args\n  \n  \n  \n  style = one of the styles from the list below\n  args = arguments used by a particular style\n  \n  ",
    "examples": "pair_style lj/cut 2.5\n  pair_style eam/alloy\n  pair_style hybrid lj/charmm/coul/long 10.0 eam\n  pair_style table linear 1000\n  pair_style none\n  \n  \n  ",
    "restrictions": "This command must be used before any coefficients are set by the\n  pair_coeff, read_data, or\n  read_restart commands.\n  Some pair styles are part of specific packages.  They are only enabled\n  if LAMMPS was built with that package.  See the Build package doc page for more info.  The doc pages for\n  individual pair potentials tell if it is part of a package.\n  "
},
{
    "command": "pair_write",
    "description": "Write energy and force values to a file as a function of distance for\n  the currently defined pair potential.  This is useful for plotting the\n  potential function or otherwise debugging its values.  If the file\n  already exists, the table of values is appended to the end of the file\n  to allow multiple tables of energy and force to be included in one\n  file.\n  The energy and force values are computed at distances from inner to\n  outer for 2 interacting atoms of type itype and jtype, using the\n  appropriate pair_coeff coefficients.  If the style\n  is r, then N distances are used, evenly spaced in r; if the style is\n  rsq, N distances are used, evenly spaced in r^2.\n  For example, for N = 7, style = r, inner = 1.0, and outer = 4.0,\n  values are computed at r = 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0.\n  If the style is bitmap, then 2^N values are written to the file in a\n  format and order consistent with how they are read in by the\n  pair_coeff command for pair style table.  For\n  reasonable accuracy in a bitmapped table, choose N >= 12, an inner\n  value that is smaller than the distance of closest approach of 2\n  atoms, and an outer value <= cutoff of the potential.\n  If the pair potential is computed between charged atoms, the charges\n  of the pair of interacting atoms can optionally be specified.  If not\n  specified, values of Qi = Qj = 1.0 are used.\n  The file is written in the format used as input for the\n  pair_style table option with keyword as the\n  section name.  Each line written to the file lists an index number\n  (1-N), a distance (in distance units), an energy (in energy units),\n  and a force (in force units).\n  ",
    "syntax": "pair_write itype jtype N style inner outer file keyword Qi Qj\n  \n  \n  \n  itype,jtype = 2 atom types\n  N = # of values\n  style = r or rsq or bitmap\n  inner,outer = inner and outer cutoff (distance units)\n  file = name of file to write values to\n  keyword = section name in file for this set of tabulated values\n  Qi,Qj = 2 atom charges (charge units) (optional)\n  \n  ",
    "examples": "pair_write 1 3 500 r 1.0 10.0 table.txt LJ\n  pair_write 1 1 1000 rsq 2.0 8.0 table.txt Yukawa_1_1 -0.5 0.5\n  \n  \n  ",
    "restrictions": "All force field coefficients for pair and other kinds of interactions\n  must be set before this command can be invoked.\n  Due to how the pairwise force is computed, an inner value > 0.0 must\n  be specified even if the potential has a finite value at r = 0.0.\n  For EAM potentials, the pair_write command only tabulates the\n  pairwise portion of the potential, not the embedding portion.\n  "
},
{
    "command": "partition",
    "description": "This command invokes the specified command on a subset of the\n  partitions of processors you have defined via the -partition command-line switch.\n  Normally, every input script command in your script is invoked by\n  every partition.  This behavior can be modified by defining world- or\n  universe-style variables that have different values\n  for each partition.  This mechanism can be used to cause your script\n  to jump to different input script files on different partitions, if\n  such a variable is used in a jump command.\n  The “partition” command is another mechanism for having as input\n  script operate differently on different partitions.  It is basically a\n  prefix on any LAMMPS command.  The command will only be invoked on\n  the partition(s) specified by the style and N arguments.\n  If the style is yes, the command will be invoked on any partition\n  which matches the N argument.  If the style is no the command\n  will be invoked on all the partitions which do not match the Np\n  argument.\n  Partitions are numbered from 1 to Np, where Np is the number of\n  partitions specified by the -partition command-line switch.\n  N can be specified in one of two ways.  An explicit numeric value\n  can be used, as in the 1st example above.  Or a wild-card asterisk can\n  be used to span a range of partition numbers.  This takes the form “*”\n  or “*n” or “n*” or “m*n”.  An asterisk with no numeric values means\n  all partitions from 1 to Np.  A leading asterisk means all partitions\n  from 1 to n (inclusive).  A trailing asterisk means all partitions\n  from n to Np (inclusive).  A middle asterisk means all partitions from\n  m to n (inclusive).\n  This command can be useful for the “run_style verlet/split” command\n  which imposed requirements on how the processors\n  command lays out a 3d grid of processors in each of 2 partitions.\n  ",
    "syntax": "partition style N command ...\n  \n  \n  \n  style = yes or no\n  N = partition number (see asterisk form below)\n  command = any LAMMPS command\n  \n  ",
    "examples": "partition yes 1 processors 4 10 6\n  partition no 5 print \"Active partition\"\n  partition yes *5 fix all nve\n  partition yes 6* fix all nvt temp 1.0 1.0 0.1\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "prd",
    "description": "Run a parallel replica dynamics (PRD) simulation using multiple\n  replicas of a system.  One or more replicas can be used.  The total\n  number of steps N to run can be interpreted in one of two ways; see\n  discussion of the time keyword below.\n  PRD is described in (Voter1998) by Art Voter.  Similar to\n  global or local hyperdynamics (HD), PRD is a method for performing\n  accelerated dynamics that is suitable for infrequent-event systems\n  that obey first-order kinetics.  A good overview of accelerated\n  dynamics methods for such systems in given in this review paper\n  (Voter2002) from Art’s group.  To quote from the\n  paper: “The dynamical evolution is characterized by vibrational\n  excursions within a potential basin, punctuated by occasional\n  transitions between basins.”  The transition probability is\n  characterized by p(t) = k*exp(-kt) where k is the rate constant.\n  Running multiple replicas gives an effective enhancement in the\n  timescale spanned by the multiple simulations, while waiting for an\n  event to occur.\n  Both PRD and HD produce a time-accurate trajectory that effectively\n  extends the timescale over which a system can be simulated, but they\n  do it differently.  PRD creates Nr replicas of the system and runs\n  dynamics on each independently with a normal unbiased potential until\n  an event occurs in one of the replicas.  The time between events is\n  reduced by a factor of Nr replicas.  HD uses a single replica of the\n  system and accelerates time by biasing the interaction potential in a\n  manner such that each timestep is effectively longer.  For both\n  methods, per CPU second, more physical time elapses and more events\n  occur.  See the hyper doc page for more info about HD.\n  In PRD, each replica runs on a partition of one or more processors.\n  Processor partitions are defined at run-time using the -partition command-line switch.  Note that if you have MPI\n  installed, you can run a multi-replica simulation with more replicas\n  (partitions) than you have physical processors, e.g you can run a\n  10-replica simulation on one or two processors.  However for PRD, this\n  makes little sense, since running a replica on virtual instead of\n  physical processors,offers no effective parallel speed-up in searching\n  for infrequent events.  See the Howto replica doc\n  page for further discussion.\n  When a PRD simulation is performed, it is assumed that each replica is\n  running the same model, though LAMMPS does not check for this.\n  I.e. the simulation domain, the number of atoms, the interaction\n  potentials, etc should be the same for every replica.\n  A PRD run has several stages, which are repeated each time an “event”\n  occurs in one of the replicas, as explained below.  The logic for a\n  PRD run is as follows:\n  while (time remains):\n    dephase for n_dephase*t_dephase steps\n    until (event occurs on some replica):\n      run dynamics for t_event steps\n      quench\n      check for uncorrelated event on any replica\n    until (no correlated event occurs):\n      run dynamics for t_correlate steps\n      quench\n      check for correlated event on this replica\n    event replica shares state with all replicas\n  Before this loop begins, the state of the system on replica 0 is\n  shared with all replicas, so that all replicas begin from the same\n  initial state. The first potential energy basin is identified by\n  quenching (an energy minimization, see below) the initial state and\n  storing the resulting coordinates for reference.\n  In the first stage, dephasing is performed by each replica\n  independently to eliminate correlations between replicas.  This is\n  done by choosing a random set of velocities, based on the\n  random_seed that is specified, and running t_dephase timesteps of\n  dynamics.  This is repeated n_dephase times.  At each of the\n  n_dephase stages, if an event occurs during the t_dephase steps of\n  dynamics for a particular replica, the replica repeats the stage until\n  no event occurs.\n  If the temp keyword is not specified, the target temperature for\n  velocity randomization for each replica is the current temperature of\n  that replica.  Otherwise, it is the specified Tdephase temperature.\n  The style of velocity randomization is controlled using the keyword\n  vel with arguments that have the same meaning as their counterparts\n  in the velocity command.\n  In the second stage, each replica runs dynamics continuously, stopping\n  every t_event steps to check if a transition event has occurred.\n  This check is performed by quenching the system and comparing the\n  resulting atom coordinates to the coordinates from the previous basin.\n  The first time through the PRD loop, the “previous basin” is the set\n  of quenched coordinates from the initial state of the system.\n  A quench is an energy minimization and is performed by whichever\n  algorithm has been defined by the min_style command.\n  Minimization parameters may be set via the\n  min_modify command and by the min keyword of the\n  PRD command.  The latter are the settings that would be used with the\n  minimize command.  Note that typically, you do not\n  need to perform a highly-converged minimization to detect a transition\n  event, though you may need to in order to prevent a set of atoms in\n  the system from relaxing to a saddle point.\n  The event check is performed by a compute with the specified\n  compute-ID.  Currently there is only one compute that works with the\n  PRD command, which is the compute event/displace command.  Other\n  event-checking computes may be added.  Compute event/displace checks whether any atom in\n  the compute group has moved further than a specified threshold\n  distance.  If so, an “event” has occurred.\n  In the third stage, the replica on which the event occurred (event\n  replica) continues to run dynamics to search for correlated events.\n  This is done by running dynamics for t_correlate steps, quenching\n  every t_event steps, and checking if another event has occurred.\n  The first time no correlated event occurs, the final state of the\n  event replica is shared with all replicas, the new basin reference\n  coordinates are updated with the quenched state, and the outer loop\n  begins again. While the replica event is searching for correlated\n  events, all the other replicas also run dynamics and event checking\n  with the same schedule, but the final states are always overwritten by\n  the state of the event replica.\n  The outer loop of the pseudo-code above continues until N steps of\n  dynamics have been performed.  Note that N only includes the\n  dynamics of stages 2 and 3, not the steps taken during dephasing or\n  the minimization iterations of quenching.  The specified N is\n  interpreted in one of two ways, depending on the time keyword.  If\n  the time value is steps, which is the default, then each replica\n  runs for N timesteps.  If the time value is clock, then the\n  simulation runs until N aggregate timesteps across all replicas have\n  elapsed.  This aggregate time is the “clock” time defined below, which\n  typically advances nearly M times faster than the timestepping on a\n  single replica, where M is the number of replicas.\n  \n  Four kinds of output can be generated during a PRD run: event\n  statistics, thermodynamic output by each replica, dump files, and\n  restart files.\n  When running with multiple partitions (each of which is a replica in\n  this case), the print-out to the screen and master log.lammps file is\n  limited to event statistics.  Note that if a PRD run is performed on\n  only a single replica then the event statistics will be intermixed\n  with the usual thermodynamic output discussed below.\n  The quantities printed each time an event occurs are the timestep, CPU\n  time, clock, event number, a correlation flag, the number of\n  coincident events, and the replica number of the chosen event.\n  The timestep is the usual LAMMPS timestep, except that time does not\n  advance during dephasing or quenches, but only during dynamics.  Note\n  that are two kinds of dynamics in the PRD loop listed above that\n  contribute to this timestepping.  The first is when all replicas are\n  performing independent dynamics, waiting for an event to occur.  The\n  second is when correlated events are being searched for, but only one\n  replica is running dynamics.\n  The CPU time is the total elapsed time on each processor, since the\n  start of the PRD run.\n  The clock is the same as the timestep except that it advances by M\n  steps per timestep during the first kind of dynamics when the M\n  replicas are running independently.  The clock advances by only 1 step\n  per timestep during the second kind of dynamics, when only a single\n  replica is checking for a correlated event.  Thus “clock” time\n  represents the aggregate time (in steps) that has effectively elapsed\n  during a PRD simulation on M replicas.  If most of the PRD run is\n  spent in the second stage of the loop above, searching for infrequent\n  events, then the clock will advance nearly M times faster than it\n  would if a single replica was running.  Note the clock time between\n  successive events should be drawn from p(t).\n  The event number is a counter that increments with each event, whether\n  it is uncorrelated or correlated.\n  The correlation flag will be 0 when an uncorrelated event occurs\n  during the second stage of the loop listed above, i.e. when all\n  replicas are running independently.  The correlation flag will be 1\n  when a correlated event occurs during the third stage of the loop\n  listed above, i.e. when only one replica is running dynamics.\n  When more than one replica detects an event at the end of the same\n  event check (every t_event steps) during the second stage, then\n  one of them is chosen at random.  The number of coincident events is\n  the number of replicas that detected an event.  Normally, this value\n  should be 1.  If it is often greater than 1, then either the number of\n  replicas is too large, or t_event is too large.\n  The replica number is the ID of the replica (from 0 to M-1) in which\n  the event occurred.\n  \n  When running on multiple partitions, LAMMPS produces additional log\n  files for each partition, e.g. log.lammps.0, log.lammps.1, etc.  For\n  the PRD command, these contain the thermodynamic output for each\n  replica.  You will see short runs and minimizations corresponding to\n  the dynamics and quench operations of the loop listed above.  The\n  timestep will be reset appropriately depending on whether the\n  operation advances time or not.\n  After the PRD command completes, timing statistics for the PRD run are\n  printed in each replica’s log file, giving a breakdown of how much CPU\n  time was spent in each stage (dephasing, dynamics, quenching, etc).\n  \n  Any dump files defined in the input script, will be\n  written to during a PRD run at timesteps corresponding to both\n  uncorrelated and correlated events.  This means the requested dump\n  frequency in the dump command is ignored.  There will be\n  one dump file (per dump command) created for all partitions.\n  The atom coordinates of the dump snapshot are those of the minimum\n  energy configuration resulting from quenching following a transition\n  event.  The timesteps written into the dump files correspond to the\n  timestep at which the event occurred and NOT the clock.  A dump\n  snapshot corresponding to the initial minimum state used for event\n  detection is written to the dump file at the beginning of each PRD\n  run.\n  \n  If the restart command is used, a single restart file\n  for all the partitions is generated, which allows a PRD run to be\n  continued by a new input script in the usual manner.\n  The restart file is generated at the end of the loop listed above.  If\n  no correlated events are found, this means it contains a snapshot of\n  the system at time T + t_correlate, where T is the time at which the\n  uncorrelated event occurred.  If correlated events were found, then it\n  contains a snapshot of the system at time T + t_correlate, where T\n  is the time of the last correlated event.\n  The restart frequency specified in the restart command\n  is interpreted differently when performing a PRD run.  It does not\n  mean the timestep interval between restart files.  Instead it means an\n  event interval for uncorrelated events.  Thus a frequency of 1 means\n  write a restart file every time an uncorrelated event occurs.  A\n  frequency of 10 means write a restart file every 10th uncorrelated\n  event.\n  When an input script reads a restart file from a previous PRD run, the\n  new script can be run on a different number of replicas or processors.\n  However, it is assumed that t_correlate in the new PRD command is\n  the same as it was previously.  If not, the calculation of the “clock”\n  value for the first event in the new run will be slightly off.\n  ",
    "syntax": "prd N t_event n_dephase t_dephase t_correlate compute-ID seed keyword value ...\n  \n  \n  \n  N = # of timesteps to run (not including dephasing/quenching)\n  t_event = timestep interval between event checks\n  n_dephase = number of velocity randomizations to perform in each dephase run\n  t_dephase = number of timesteps to run dynamics after each velocity randomization during dephase\n  t_correlate = number of timesteps within which 2 consecutive events are considered to be correlated\n  compute-ID = ID of the compute used for event detection\n  random_seed = random # seed (positive integer)\n  zero or more keyword/value pairs may be appended\n  keyword = min or temp or vel\n  min values = etol ftol maxiter maxeval\n    etol = stopping tolerance for energy, used in quenching\n    ftol = stopping tolerance for force, used in quenching\n    maxiter = max iterations of minimize, used in quenching\n    maxeval = max number of force/energy evaluations, used in quenching\n  temp value = Tdephase\n    Tdephase = target temperature for velocity randomization, used in dephasing\n  vel values = loop dist\n    loop = all or local or geom, used in dephasing\n    dist = uniform or gaussian, used in dephasing\n  time value = steps or clock\n    steps = simulation runs for N timesteps on each replica (default)\n    clock = simulation runs for N timesteps across all replicas\n  \n  \n  ",
    "examples": "prd 5000 100 10 10 100 1 54982\n  prd 5000 100 10 10 100 1 54982 min 0.1 0.1 100 200\n  \n  \n  ",
    "restrictions": "This command can only be used if LAMMPS was built with the REPLICA\n  package.  See the Build package doc\n  page for more info.\n  The N and t_correlate settings must be integer multiples of\n  t_event.\n  Runs restarted from restart file written during a PRD run will not\n  produce identical results due to changes in the random numbers used\n  for dephasing.\n  This command cannot be used when any fixes are defined that keep track\n  of elapsed time to perform time-dependent operations.  Examples\n  include the “ave” fixes such as fix ave/chunk.\n  Also fix dt/reset and fix deposit.\n  "
},
{
    "command": "print",
    "description": "Print a text string to the screen and logfile.  The text string must\n  be a single argument, so if it is one line but more than one word, it\n  should be enclosed in single or double quotes.  To generate multiple\n  lines of output, the string can be enclosed in triple quotes, as in\n  the last example above.  If the text string contains variables, they\n  will be evaluated and their current values printed.\n  If the file or append keyword is used, a filename is specified to\n  which the output will be written.  If file is used, then the\n  filename is overwritten if it already exists.  If append is used,\n  then the filename is appended to if it already exists, or created if\n  it does not exist.\n  If the screen keyword is used, output to the screen and logfile can\n  be turned on or off as desired.\n  If the universe keyword is used, output to the global screen and\n  logfile can be turned on or off as desired. In multi-partition\n  calculations, the screen option and the corresponding output only\n  apply to the screen and logfile of the individual partition.\n  If you want the print command to be executed multiple times (with\n  changing variable values), there are 3 options.  First, consider using\n  the fix print command, which will print a string\n  periodically during a simulation.  Second, the print command can be\n  used as an argument to the every option of the run\n  command.  Third, the print command could appear in a section of the\n  input script that is looped over (see the jump and\n  next commands).\n  See the variable command for a description of equal\n  style variables which are typically the most useful ones to use with\n  the print command.  Equal-style variables can calculate formulas\n  involving mathematical operations, atom properties, group properties,\n  thermodynamic properties, global values calculated by a\n  compute or fix, or references to other\n  variables.\n  ",
    "syntax": "print string keyword value\n  \n  \n  \n  string = text string to print, which may contain variables\n  zero or more keyword/value pairs may be appended\n  keyword = file or append or screen or universe\n  file value = filename\n  append value = filename\n  screen value = yes or no\n  universe value = yes or no\n  \n  \n  ",
    "examples": "print \"Done with equilibration\" file info.dat\n  print Vol=$v append info.dat screen no\n  print \"The system volume is now $v\"\n  print 'The system volume is now $v'\n  print \"NEB calculation 1 complete\" screen no universe yes\n  print \"\"\"\n  System volume = $v\n  System temperature = $t\n  \"\"\"\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "processors",
    "description": "Specify how processors are mapped as a regular 3d grid to the global\n  simulation box.  The mapping involves 2 steps.  First if there are P\n  processors it means choosing a factorization P = Px by Py by Pz so\n  that there are Px processors in the x dimension, and similarly for the\n  y and z dimensions.  Second, the P processors are mapped to the\n  regular 3d grid.  The arguments to this command control each of these\n  2 steps.\n  The Px, Py, Pz parameters affect the factorization.  Any of the 3\n  parameters can be specified with an asterisk “*”, which means LAMMPS\n  will choose the number of processors in that dimension of the grid.\n  It will do this based on the size and shape of the global simulation\n  box so as to minimize the surface-to-volume ratio of each processor’s\n  sub-domain.\n  Choosing explicit values for Px or Py or Pz can be used to override\n  the default manner in which LAMMPS will create the regular 3d grid of\n  processors, if it is known to be sub-optimal for a particular problem.\n  E.g. a problem where the extent of atoms will change dramatically in a\n  particular dimension over the course of the simulation.\n  The product of Px, Py, Pz must equal P, the total # of processors\n  LAMMPS is running on.  For a 2d simulation, Pz must\n  equal 1.\n  Note that if you run on a prime number of processors P, then a grid\n  such as 1 x P x 1 will be required, which may incur extra\n  communication costs due to the high surface area of each processor’s\n  sub-domain.\n  Also note that if multiple partitions are being used then P is the\n  number of processors in this partition; see the -partition command-line switch doc page for details.  Also note\n  that you can prefix the processors command with the\n  partition command to easily specify different\n  Px,Py,Pz values for different partitions.\n  You can use the partition command to specify\n  different processor grids for different partitions, e.g.\n  partition yes 1 processors 4 4 4\n  partition yes 2 processors 2 3 2\n  \n  \n  \n  Note\n  This command only affects the initial regular 3d grid created\n  when the simulation box is first specified via a\n  create_box or read_data or\n  read_restart command.  Or if the simulation box is\n  re-created via the replicate command.  The same\n  regular grid is initially created, regardless of which\n  comm_style command is in effect.\n  \n  If load-balancing is never invoked via the balance or\n  fix balance commands, then the initial regular grid\n  will persist for all simulations.  If balancing is performed, some of\n  the methods invoked by those commands retain the logical topology of\n  the initial 3d grid, and the mapping of processors to the grid\n  specified by the processors command.  However the grid spacings in\n  different dimensions may change, so that processors own sub-domains of\n  different sizes.  If the comm_style tiled command is\n  used, methods invoked by the balancing commands may discard the 3d\n  grid of processors and tile the simulation domain with sub-domains of\n  different sizes and shapes which no longer have a logical 3d\n  connectivity.  If that occurs, all the information specified by the\n  processors command is ignored.\n  \n  The grid keyword affects the factorization of P into Px,Py,Pz and it\n  can also affect how the P processor IDs are mapped to the 3d grid of\n  processors.\n  The onelevel style creates a 3d grid that is compatible with the\n  Px,Py,Pz settings, and which minimizes the surface-to-volume ratio of\n  each processor’s sub-domain, as described above.  The mapping of\n  processors to the grid is determined by the map keyword setting.\n  The twolevel style can be used on machines with multicore nodes to\n  minimize off-node communication.  It insures that contiguous\n  sub-sections of the 3d grid are assigned to all the cores of a node.\n  For example if Nc is 4, then 2x2x1 or 2x1x2 or 1x2x2 sub-sections of\n  the 3d grid will correspond to the cores of each node.  This affects\n  both the factorization and mapping steps.\n  The Cx, Cy, Cz settings are similar to the Px, Py, Pz\n  settings, only their product should equal Nc.  Any of the 3\n  parameters can be specified with an asterisk “*”, which means LAMMPS\n  will choose the number of cores in that dimension of the node’s\n  sub-grid.  As with Px,Py,Pz, it will do this based on the size and\n  shape of the global simulation box so as to minimize the\n  surface-to-volume ratio of each processor’s sub-domain.\n  \n  Note\n  For the twolevel style to work correctly, it assumes the MPI\n  ranks of processors LAMMPS is running on are ordered by core and then\n  by node.  E.g. if you are running on 2 quad-core nodes, for a total of\n  8 processors, then it assumes processors 0,1,2,3 are on node 1, and\n  processors 4,5,6,7 are on node 2.  This is the default rank ordering\n  for most MPI implementations, but some MPIs provide options for this\n  ordering, e.g. via environment variable settings.\n  \n  The numa style operates similar to the twolevel keyword except\n  that it auto-detects which cores are running on which nodes.\n  Currently, it does this in only 2 levels, but it may be extended in\n  the future to account for socket topology and other non-uniform memory\n  access (NUMA) costs.  It also uses a different algorithm than the\n  twolevel keyword for doing the two-level factorization of the\n  simulation box into a 3d processor grid to minimize off-node\n  communication, and it does its own MPI-based mapping of nodes and\n  cores to the regular 3d grid.  Thus it may produce a different layout\n  of the processors than the twolevel options.\n  The numa style will give an error if the number of MPI processes is\n  not divisible by the number of cores used per node, or any of the Px\n  or Py of Pz values is greater than 1.\n  \n  Note\n  Unlike the twolevel style, the numa style does not require\n  any particular ordering of MPI ranks i norder to work correctly.  This\n  is because it auto-detects which processes are running on which nodes.\n  \n  The custom style uses the file infile to define both the 3d\n  factorization and the mapping of processors to the grid.\n  The file should have the following format.  Any number of initial\n  blank or comment lines (starting with a “#” character) can be present.\n  The first non-blank, non-comment line should have\n  3 values:\n  Px Py Py\n  \n  \n  These must be compatible with the total number of processors\n  and the Px, Py, Pz settings of the processors command.\n  This line should be immediately followed by\n  P = Px*Py*Pz lines of the form:\n  ID I J K\n  \n  \n  where ID is a processor ID (from 0 to P-1) and I,J,K are the\n  processors location in the 3d grid.  I must be a number from 1 to Px\n  (inclusive) and similarly for J and K.  The P lines can be listed in\n  any order, but no processor ID should appear more than once.\n  \n  The map keyword affects how the P processor IDs (from 0 to P-1) are\n  mapped to the 3d grid of processors.  It is only used by the\n  onelevel and twolevel grid settings.\n  The cart style uses the family of MPI Cartesian functions to perform\n  the mapping, namely MPI_Cart_create(), MPI_Cart_get(),\n  MPI_Cart_shift(), and MPI_Cart_rank().  It invokes the\n  MPI_Cart_create() function with its reorder flag = 0, so that MPI is\n  not free to reorder the processors.\n  The cart/reorder style does the same thing as the cart style\n  except it sets the reorder flag to 1, so that MPI can reorder\n  processors if it desires.\n  The xyz, xzy, yxz, yzx, zxy, and zyx styles are all\n  similar.  If the style is IJK, then it maps the P processors to the\n  grid so that the processor ID in the I direction varies fastest, the\n  processor ID in the J direction varies next fastest, and the processor\n  ID in the K direction varies slowest.  For example, if you select\n  style xyz and you have a 2x2x2 grid of 8 processors, the assignments\n  of the 8 octants of the simulation domain will be:\n  proc 0 = lo x, lo y, lo z octant\n  proc 1 = hi x, lo y, lo z octant\n  proc 2 = lo x, hi y, lo z octant\n  proc 3 = hi x, hi y, lo z octant\n  proc 4 = lo x, lo y, hi z octant\n  proc 5 = hi x, lo y, hi z octant\n  proc 6 = lo x, hi y, hi z octant\n  proc 7 = hi x, hi y, hi z octant\n  \n  \n  Note that, in principle, an MPI implementation on a particular machine\n  should be aware of both the machine’s network topology and the\n  specific subset of processors and nodes that were assigned to your\n  simulation.  Thus its MPI_Cart calls can optimize the assignment of\n  MPI processes to the 3d grid to minimize communication costs.  In\n  practice, however, few if any MPI implementations actually do this.\n  So it is likely that the cart and cart/reorder styles simply give\n  the same result as one of the IJK styles.\n  Also note, that for the twolevel grid style, the map setting is\n  used to first map the nodes to the 3d grid, then again to the cores\n  within each node.  For the latter step, the cart and cart/reorder\n  styles are not supported, so an xyz style is used in their place.\n  \n  The part keyword affects the factorization of P into Px,Py,Pz.\n  It can be useful when running in multi-partition mode, e.g. with the\n  run_style verlet/split command.  It specifies a\n  dependency between a sending partition Psend and a receiving\n  partition Precv which is enforced when each is setting up their own\n  mapping of their processors to the simulation box.  Each of Psend\n  and Precv must be integers from 1 to Np, where Np is the number of\n  partitions you have defined via the -partition command-line switch.\n  A “dependency” means that the sending partition will create its\n  regular 3d grid as Px by Py by Pz and after it has done this, it will\n  send the Px,Py,Pz values to the receiving partition.  The receiving\n  partition will wait to receive these values before creating its own\n  regular 3d grid and will use the sender’s Px,Py,Pz values as a\n  constraint.  The nature of the constraint is determined by the\n  cstyle argument.\n  For a cstyle of multiple, each dimension of the sender’s processor\n  grid is required to be an integer multiple of the corresponding\n  dimension in the receiver’s processor grid.  This is a requirement of\n  the run_style verlet/split command.\n  For example, assume the sending partition creates a 4x6x10 grid = 240\n  processor grid.  If the receiving partition is running on 80\n  processors, it could create a 4x2x10 grid, but it will not create a\n  2x4x10 grid, since in the y-dimension, 6 is not an integer multiple of\n  4.\n  \n  Note\n  If you use the partition command to invoke\n  different “processors” commands on different partitions, and you also\n  use the part keyword, then you must insure that both the sending and\n  receiving partitions invoke the “processors” command that connects the\n  2 partitions via the part keyword.  LAMMPS cannot easily check for\n  this, but your simulation will likely hang in its setup phase if this\n  error has been made.\n  \n  \n  The file keyword writes the mapping of the factorization of P\n  processors and their mapping to the 3d grid to the specified file\n  outfile.  This is useful to check that you assigned physical\n  processors in the manner you desired, which can be tricky to figure\n  out, especially when running on multiple partitions or on, a multicore\n  machine or when the processor ranks were reordered by use of the\n  -reorder command-line switch or due to use of\n  MPI-specific launch options such as a config file.\n  If you have multiple partitions you should insure that each one writes\n  to a different file, e.g. using a world-style variable\n  for the filename.  The file has a self-explanatory header, followed by\n  one-line per processor in this format:\n  world-ID universe-ID original-ID: I J K: name\n  The IDs are the processor’s rank in this simulation (the world), the\n  universe (of multiple simulations), and the original MPI communicator\n  used to instantiate LAMMPS, respectively.  The world and universe IDs\n  will only be different if you are running on more than one partition;\n  see the -partition command-line switch.  The\n  universe and original IDs will only be different if you used the\n  -reorder command-line switch to reorder the\n  processors differently than their rank in the original communicator\n  LAMMPS was instantiated with.\n  I,J,K are the indices of the processor in the regular 3d grid, each\n  from 1 to Nd, where Nd is the number of processors in that dimension\n  of the grid.\n  The name is what is returned by a call to MPI_Get_processor_name()\n  and should represent an identifier relevant to the physical processors\n  in your machine.  Note that depending on the MPI implementation,\n  multiple cores can have the same name.\n  ",
    "syntax": "processors Px Py Pz keyword args ...\n  \n  \n  \n  Px,Py,Pz = # of processors in each dimension of 3d grid overlaying the simulation domain\n  zero or more keyword/arg pairs may be appended\n  keyword = grid or map or part or file\n  grid arg = gstyle params ...\n    gstyle = onelevel or twolevel or numa or custom\n      onelevel params = none\n      twolevel params = Nc Cx Cy Cz\n        Nc = number of cores per node\n        Cx,Cy,Cz = # of cores in each dimension of 3d sub-grid assigned to each node\n      numa params = none\n      custom params = infile\n        infile = file containing grid layout\n  map arg = cart or cart/reorder or xyz or xzy or yxz or yzx or zxy or zyx\n     cart = use MPI_Cart() methods to map processors to 3d grid with reorder = 0\n     cart/reorder = use MPI_Cart() methods to map processors to 3d grid with reorder = 1\n     xyz,xzy,yxz,yzx,zxy,zyx = map processors to 3d grid in IJK ordering\n  numa arg = none\n  part args = Psend Precv cstyle\n    Psend = partition # (1 to Np) which will send its processor layout\n    Precv = partition # (1 to Np) which will recv the processor layout\n    cstyle = multiple\n      multiple = Psend grid will be multiple of Precv grid in each dimension\n  file arg = outfile\n    outfile = name of file to write 3d grid of processors to\n  \n  \n  ",
    "examples": "processors * * 5\n  processors 2 4 4\n  processors * * 8 map xyz\n  processors * * * grid numa\n  processors * * * grid twolevel 4 * * 1\n  processors 4 8 16 grid custom myfile\n  processors * * * part 1 2 multiple\n  \n  \n  ",
    "restrictions": "This command cannot be used after the simulation box is defined by a\n  read_data or create_box command.\n  It can be used before a restart file is read to change the 3d\n  processor grid from what is specified in the restart file.\n  The grid numa keyword only currently works with the map cart\n  option.\n  The part keyword (for the receiving partition) only works with the\n  grid onelevel or grid twolevel options.\n  "
},
{
    "command": "python",
    "description": "Define a Python function or execute a previously defined function or\n  execute some arbitrary python code.\n  Arguments, including LAMMPS variables, can be passed to the function\n  from the LAMMPS input script and a value returned by the Python\n  function to a LAMMPS variable.  The Python code for the function can\n  be included directly in the input script or in a separate Python file.\n  The function can be standard Python code or it can make “callbacks” to\n  LAMMPS through its library interface to query or set internal values\n  within LAMMPS.  This is a powerful mechanism for performing complex\n  operations in a LAMMPS input script that are not possible with the\n  simple input script and variable syntax which LAMMPS defines.  Thus\n  your input script can operate more like a true programming language.\n  Use of this command requires building LAMMPS with the PYTHON package\n  which links to the Python library so that the Python interpreter is\n  embedded in LAMMPS.  More details about this process are given below.\n  There are two ways to invoke a Python function once it has been\n  defined.  One is using the invoke keyword.  The other is to assign\n  the function to a python-style variable defined in\n  your input script.  Whenever the variable is evaluated, it will\n  execute the Python function to assign a value to the variable.  Note\n  that variables can be evaluated in many different ways within LAMMPS.\n  They can be substituted for directly in an input script.  Or they can\n  be passed to various commands as arguments, so that the variable is\n  evaluated during a simulation run.\n  A broader overview of how Python can be used with LAMMPS is given on\n  the Python doc page.  There is an examples/python\n  directory which illustrates use of the python command.\n  \n  The func setting specifies the name of the Python function.  The\n  code for the function is defined using the file or here keywords\n  as explained below. In case of the source keyword, the name of\n  the function is ignored.\n  If the invoke keyword is used, no other keywords can be used, and a\n  previous python command must have defined the Python function\n  referenced by this command.  This invokes the Python function with the\n  previously defined arguments and return value processed as explained\n  below.  You can invoke the function as many times as you wish in your\n  input script.\n  If the source keyword is used, no other keywords can be used.\n  The argument can be a filename or a string with python commands,\n  either on a single line enclosed in quotes, or as multiple lines\n  enclosed in triple quotes. These python commands will be passed\n  to the python interpreter and executed immediately without registering\n  a python function for future execution.\n  The input keyword defines how many arguments N the Python function\n  expects.  If it takes no arguments, then the input keyword should\n  not be used.  Each argument can be specified directly as a value,\n  e.g. 6 or 3.14159 or abc (a string of characters).  The type of each\n  argument is specified by the format keyword as explained below, so\n  that Python will know how to interpret the value.  If the word SELF is\n  used for an argument it has a special meaning.  A pointer is passed to\n  the Python function which it converts into a reference to LAMMPS\n  itself.  This enables the function to call back to LAMMPS through its\n  library interface as explained below.  This allows the Python function\n  to query or set values internal to LAMMPS which can affect the\n  subsequent execution of the input script.  A LAMMPS variable can also\n  be used as an argument, specified as v_name, where “name” is the name\n  of the variable.  Any style of LAMMPS variable can be used, as defined\n  by the variable command.  Each time the Python\n  function is invoked, the LAMMPS variable is evaluated and its value is\n  passed to the Python function.\n  The return keyword is only needed if the Python function returns a\n  value.  The specified varReturn must be of the form v_name, where\n  “name” is the name of a python-style LAMMPS variable, defined by the\n  variable command.  The Python function can return a\n  numeric or string value, as specified by the format keyword.\n  As explained on the variable doc page, the definition\n  of a python-style variable associates a Python function name with the\n  variable.  This must match the func setting for this command.  For\n  example these two commands would be self-consistent:\n  variable foo python myMultiply\n  python myMultiply return v_foo format f file funcs.py\n  \n  \n  The two commands can appear in either order in the input script so\n  long as both are specified before the Python function is invoked for\n  the first time.\n  The format keyword must be used if the input or return keyword\n  is used.  It defines an fstring with M characters, where M = sum of\n  number of inputs and outputs.  The order of characters corresponds to\n  the N inputs, followed by the return value (if it exists).  Each\n  character must be one of the following: “i” for integer, “f” for\n  floating point, “s” for string, or “p” for SELF.  Each character\n  defines the type of the corresponding input or output value of the\n  Python function and affects the type conversion that is performed\n  internally as data is passed back and forth between LAMMPS and Python.\n  Note that it is permissible to use a python-style variable in a LAMMPS command that allows for an\n  equal-style variable as an argument, but only if the output of the\n  Python function is flagged as a numeric value (“i” or “f”) via the\n  format keyword.\n  If the return keyword is used and the format keyword specifies the\n  output as a string, then the default maximum length of that string is\n  63 characters (64-1 for the string terminator).  If you want to return\n  a longer string, the length keyword can be specified with its Nlen\n  value set to a larger number (the code allocates space for Nlen+1 to\n  include the string terminator).  If the Python function generates a\n  string longer than the default 63 or the specified Nlen, it will be\n  truncated.\n  \n  Either the file, here, or exists keyword must be used, but only\n  one of them.  These keywords specify what Python code to load into the\n  Python interpreter.  The file keyword gives the name of a file,\n  which should end with a “.py” suffix, which contains Python code.  The\n  code will be immediately loaded into and run in the “main” module of\n  the Python interpreter.  Note that Python code which contains a\n  function definition does not “execute” the function when it is run; it\n  simply defines the function so that it can be invoked later.\n  The here keyword does the same thing, except that the Python code\n  follows as a single argument to the here keyword.  This can be done\n  using triple quotes as delimiters, as in the examples above.  This\n  allows Python code to be listed verbatim in your input script, with\n  proper indentation, blank lines, and comments, as desired.  See the\n  Commands parse doc page, for an explanation of\n  how triple quotes can be used as part of input script syntax.\n  The exists keyword takes no argument.  It means that Python code\n  containing the required Python function defined by the func setting,\n  is assumed to have been previously loaded by another python command.\n  Note that the Python code that is loaded and run must contain a\n  function with the specified func name.  To operate properly when\n  later invoked, the function code must match the input and\n  return and format keywords specified by the python command.\n  Otherwise Python will generate an error.\n  \n  This section describes how Python code can be written to work with\n  LAMMPS.\n  Whether you load Python code from a file or directly from your input\n  script, via the file and here keywords, the code can be identical.\n  It must be indented properly as Python requires.  It can contain\n  comments or blank lines.  If the code is in your input script, it\n  cannot however contain triple-quoted Python strings, since that will\n  conflict with the triple-quote parsing that the LAMMPS input script\n  performs.\n  All the Python code you specify via one or more python commands is\n  loaded into the Python “main” module, i.e. __main__.  The code can\n  define global variables or statements that are outside of function\n  definitions.  It can contain multiple functions, only one of which\n  matches the func setting in the python command.  This means you can\n  use the file keyword once to load several functions, and the\n  exists keyword thereafter in subsequent python commands to access\n  the other functions previously loaded.\n  A Python function you define (or more generally, the code you load)\n  can import other Python modules or classes, it can make calls to other\n  system functions or functions you define, and it can access or modify\n  global variables (in the “main” module) which will persist between\n  successive function calls.  The latter can be useful, for example, to\n  prevent a function from being invoke multiple times per timestep by\n  different commands in a LAMMPS input script that access the returned\n  python-style variable associated with the function.  For example,\n  consider this function loaded with two global variables defined\n  outside the function:\n  nsteplast = -1\n  nvaluelast = 0\n  \n  def expensive(nstep):\n    global nsteplast,nvaluelast\n    if nstep == nsteplast: return nvaluelast\n    nsteplast = nstep\n    # perform complicated calculation\n    nvalue = ...\n    nvaluelast = nvalue\n    return nvalue\n  \n  \n  Nsteplast stores the previous timestep the function was invoked\n  (passed as an argument to the function).  Nvaluelast stores the return\n  value computed on the last function invocation.  If the function is\n  invoked again on the same timestep, the previous value is simply\n  returned, without re-computing it.  The “global” statement inside the\n  Python function allows it to overwrite the global variables.\n  Note that if you load Python code multiple times (via multiple python\n  commands), you can overwrite previously loaded variables and functions\n  if you are not careful.  E.g. if the code above were loaded twice, the\n  global variables would be re-initialized, which might not be what you\n  want.  Likewise, if a function with the same name exists in two chunks\n  of Python code you load, the function loaded second will override the\n  function loaded first.\n  It’s important to realize that if you are running LAMMPS in parallel,\n  each MPI task will load the Python interpreter and execute a local\n  copy of the Python function(s) you define.  There is no connection\n  between the Python interpreters running on different processors.\n  This implies three important things.\n  First, if you put a print statement in your Python function, you will\n  see P copies of the output, when running on P processors.  If the\n  prints occur at (nearly) the same time, the P copies of the output may\n  be mixed together.  Welcome to the world of parallel programming and\n  debugging.\n  Second, if your Python code loads modules that are not pre-loaded by\n  the Python library, then it will load the module from disk.  This may\n  be a bottleneck if 1000s of processors try to load a module at the\n  same time.  On some large supercomputers, loading of modules from disk\n  by Python may be disabled.  In this case you would need to pre-build a\n  Python library that has the required modules pre-loaded and link\n  LAMMPS with that library.\n  Third, if your Python code calls back to LAMMPS (discussed in the\n  next section) and causes LAMMPS to perform an MPI operation requires\n  global communication (e.g. via MPI_Allreduce), such as computing the\n  global temperature of the system, then you must insure all your Python\n  functions (running independently on different processors) call back to\n  LAMMPS.  Otherwise the code may hang.\n  \n  Your Python function can “call back” to LAMMPS through its\n  library interface, if you use the SELF input to pass Python\n  a pointer to LAMMPS.  The mechanism for doing this in your\n  Python function is as follows:\n  def foo(lmpptr,...):\n    from lammps import lammps\n    lmp = lammps(ptr=lmpptr)\n    lmp.command('print \"Hello from inside Python\"')\n    ...\n  \n  \n  The function definition must include a variable (lmpptr in this case)\n  which corresponds to SELF in the python command.  The first line of the\n  function imports the Python module lammps.py in the python directory of\n  the distribution.  The second line creates a Python object “lmp” which\n  wraps the instance of LAMMPS that called the function.  The “ptr=lmpptr”\n  argument is what makes that happen.  The third line invokes the\n  command() function in the LAMMPS library interface.  It takes a single\n  string argument which is a LAMMPS input script command for LAMMPS to\n  execute, the same as if it appeared in your input script.  In this case,\n  LAMMPS should output\n  Hello from inside Python\n  \n  \n  to the screen and log file.  Note that since the LAMMPS print command\n  itself takes a string in quotes as its argument, the Python string\n  must be delimited with a different style of quotes.\n  The Python library doc page describes the syntax\n  for how Python wraps the various functions included in the LAMMPS\n  library interface.\n  A more interesting example is in the examples/python/in.python script\n  which loads and runs the following function from examples/python/funcs.py:\n  def loop(N,cut0,thresh,lmpptr):\n    print \"LOOP ARGS\",N,cut0,thresh,lmpptr\n    from lammps import lammps\n    lmp = lammps(ptr=lmpptr)\n    natoms = lmp.get_natoms()\n  \n    for i in range(N):\n      cut = cut0 + i*0.1\n  \n      lmp.set_variable(\"cut\",cut)                 # set a variable in LAMMPS\n      lmp.command(\"pair_style lj/cut ${cut}\")     # LAMMPS command\n      #lmp.command(\"pair_style lj/cut %d\" % cut)  # LAMMPS command option\n  \n      lmp.command(\"pair_coeff * * 1.0 1.0\")       # ditto\n      lmp.command(\"run 10\")                       # ditto\n      pe = lmp.extract_compute(\"thermo_pe\",0,0)   # extract total PE from LAMMPS\n      print \"PE\",pe/natoms,thresh\n      if pe/natoms < thresh: return\n  \n  \n  with these input script commands:\n  python          loop input 4 10 1.0 -4.0 SELF format iffp file funcs.py\n  python          loop invoke\n  \n  \n  This has the effect of looping over a series of 10 short runs (10\n  timesteps each) where the pair style cutoff is increased from a value\n  of 1.0 in distance units, in increments of 0.1.  The looping stops\n  when the per-atom potential energy falls below a threshold of -4.0 in\n  energy units.  More generally, Python can be used to implement a loop\n  with complex logic, much more so than can be created using the LAMMPS\n  jump and if commands.\n  Several LAMMPS library functions are called from the loop function.\n  Get_natoms() returns the number of atoms in the simulation, so that it\n  can be used to normalize the potential energy that is returned by\n  extract_compute() for the “thermo_pe” compute that is defined by\n  default for LAMMPS thermodynamic output.  Set_variable() sets the\n  value of a string variable defined in LAMMPS.  This library function\n  is a useful way for a Python function to return multiple values to\n  LAMMPS, more than the single value that can be passed back via a\n  return statement.  This cutoff value in the “cut” variable is then\n  substituted (by LAMMPS) in the pair_style command that is executed\n  next.  Alternatively, the “LAMMPS command option” line could be used\n  in place of the 2 preceding lines, to have Python insert the value\n  into the LAMMPS command string.\n  \n  Note\n  When using the callback mechanism just described, recognize that\n  there are some operations you should not attempt because LAMMPS cannot\n  execute them correctly.  If the Python function is invoked between\n  runs in the LAMMPS input script, then it should be OK to invoke any\n  LAMMPS input script command via the library interface command() or\n  file() functions, so long as the command would work if it were\n  executed in the LAMMPS input script directly at the same point.\n  \n  However, a Python function can also be invoked during a run, whenever\n  an associated LAMMPS variable it is assigned to is evaluated.  If the\n  variable is an input argument to another LAMMPS command (e.g. fix setforce), then the Python function will be invoked\n  inside the class for that command, in one of its methods that is\n  invoked in the middle of a timestep.  You cannot execute arbitrary\n  input script commands from the Python function (again, via the\n  command() or file() functions) at that point in the run and expect it\n  to work.  Other library functions such as those that invoke computes\n  or other variables may have hidden side effects as well.  In these\n  cases, LAMMPS has no simple way to check that something illogical is\n  being attempted.\n  The same applies to Python functions called during a simulation run at\n  each time step using fix python/invoke.\n  \n  If you run Python code directly on your workstation, either\n  interactively or by using Python to launch a Python script stored in a\n  file, and your code has an error, you will typically see informative\n  error messages.  That is not the case when you run Python code from\n  LAMMPS using an embedded Python interpreter.  The code will typically\n  fail silently.  LAMMPS will catch some errors but cannot tell you\n  where in the Python code the problem occurred.  For example, if the\n  Python code cannot be loaded and run because it has syntax or other\n  logic errors, you may get an error from Python pointing to the\n  offending line, or you may get one of these generic errors from\n  LAMMPS:\n  Could not process Python file\n  Could not process Python string\n  \n  \n  When the Python function is invoked, if it does not return properly,\n  you will typically get this generic error from LAMMPS:\n  Python function evaluation failed\n  \n  \n  Here are three suggestions for debugging your Python code while\n  running it under LAMMPS.\n  First, don’t run it under LAMMPS, at least to start with!  Debug it\n  using plain Python.  Load and invoke your function, pass it arguments,\n  check return values, etc.\n  Second, add Python print statements to the function to check how far\n  it gets and intermediate values it calculates.  See the discussion\n  above about printing from Python when running in parallel.\n  Third, use Python exception handling.  For example, say this statement\n  in your Python function is failing, because you have not initialized the\n  variable foo:\n  foo += 1\n  \n  \n  If you put one (or more) statements inside a “try” statement,\n  like this:\n  import exceptions\n  print \"Inside simple function\"\n  try:\n    foo += 1      # one or more statements here\n  except Exception, e:\n    print \"FOO error:\",e\n  \n  \n  then you will get this message printed to the screen:\n  FOO error: local variable 'foo' referenced before assignment\n  \n  \n  If there is no error in the try statements, then nothing is printed.\n  Either way the function continues on (unless you put a return or\n  sys.exit() in the except clause).\n  ",
    "syntax": "python func keyword args ...\n  \n  \n  \n  func = name of Python function\n  one or more keyword/args pairs must be appended\n  keyword = invoke or input or return or format or length or file or here or exists or source\n    invoke arg = none = invoke the previously defined Python function\n    input args = N i1 i2 ... iN\n      N = # of inputs to function\n      i1,...,iN = value, SELF, or LAMMPS variable name\n        value = integer number, floating point number, or string\n        SELF = reference to LAMMPS itself which can be accessed by Python function\n        variable = v_name, where name = name of LAMMPS variable, e.g. v_abc\n    return arg = varReturn\n      varReturn = v_name  = LAMMPS variable name which return value of function will be assigned to\n    format arg = fstring with M characters\n      M = N if no return value, where N = # of inputs\n      M = N+1 if there is a return value\n      fstring = each character (i,f,s,p) corresponds in order to an input or return value\n      'i' = integer, 'f' = floating point, 's' = string, 'p' = SELF\n    length arg = Nlen\n      Nlen = max length of string returned from Python function\n    file arg = filename\n      filename = file of Python code, which defines func\n    here arg = inline\n      inline = one or more lines of Python code which defines func\n               must be a single argument, typically enclosed between triple quotes\n    exists arg = none = Python code has been loaded by previous python command\n    source arg = filename or inline\n      filename = file of Python code which will be executed immediately\n      inline = one or more lines of Python code which will be executed immediately\n               must be a single argument, typically enclosed between triple quotes\n  \n  \n  ",
    "examples": "python pForce input 2 v_x 20.0 return v_f format fff file force.py\n  python pForce invoke\n  \n  python factorial input 1 myN return v_fac format ii here \"\"\"\n  def factorial(n):\n    if n == 1: return n\n    return n * factorial(n-1)\n   \"\"\"\n  \n  python loop input 1 SELF return v_value format pf here \"\"\"\n  def loop(lmpptr,N,cut0):\n    from lammps import lammps\n    lmp = lammps(ptr=lmpptr)\n  \n    # loop N times, increasing cutoff each time\n  \n    for i in range(N):\n      cut = cut0 + i*0.1\n      lmp.set_variable(\"cut\",cut)               # set a variable in LAMMPS\n      lmp.command(\"pair_style lj/cut ${cut}\")   # LAMMPS commands\n      lmp.command(\"pair_coeff * * 1.0 1.0\")\n      lmp.command(\"run 100\")\n   \"\"\"\n  \n  \n  ",
    "restrictions": "This command is part of the PYTHON package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  Building LAMMPS with the PYTHON package will link LAMMPS with the\n  Python library on your system.  Settings to enable this are in the\n  lib/python/Makefile.lammps file.  See the lib/python/README file for\n  information on those settings.\n  If you use Python code which calls back to LAMMPS, via the SELF input\n  argument explained above, there is an extra step required when\n  building LAMMPS.  LAMMPS must also be built as a shared library and\n  your Python function must be able to load the Python module in\n  python/lammps.py that wraps the LAMMPS library interface.  These are\n  the same steps required to use Python by itself to wrap LAMMPS.\n  Details on these steps are explained on the Python\n  doc page.  Note that it is important that the stand-alone LAMMPS\n  executable and the LAMMPS shared library be consistent (built from the\n  same source code files) in order for this to work.  If the two have\n  been built at different times using different source files, problems\n  may occur.\n  "
},
{
    "command": "quit",
    "description": "This command causes LAMMPS to exit, after shutting down all output\n  cleanly.\n  It can be used as a debug statement in an input script, to terminate\n  the script at some intermediate point.\n  It can also be used as an invoked command inside the “then” or “else”\n  portion of an if command.\n  The optional status argument is an integer which signals the return\n  status to a program calling LAMMPS.  A return status of 0 usually\n  indicates success.  A status != 0 is failure, where the specified\n  value can be used to distinguish the kind of error, e.g. where in the\n  input script the quit was invoked.  If not specified, a status of 0 is\n  returned.\n  ",
    "syntax": "quit status\n  \n  \n  status = numerical exit status (optional)\n  ",
    "examples": "quit\n  if \"$n > 10000\" then \"quit 1\"\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "read_data",
    "description": "Read in a data file containing information LAMMPS needs to run a\n  simulation.  The file can be ASCII text or a gzipped text file\n  (detected by a .gz suffix).  This is one of 3 ways to specify initial\n  atom coordinates; see the read_restart and\n  create_atoms commands for alternative methods.\n  Also see the explanation of the -restart command-line switch which can convert a restart file to a data\n  file.\n  This command can be used multiple times to add new atoms and their\n  properties to an existing system by using the add, offset, and\n  shift keywords.  See more details below, which includes the use case\n  for the extra keywords.\n  The group keyword adds all the atoms in the data file to the\n  specified group-ID.  The group will be created if it does not already\n  exist.  This is useful if you are reading multiple data files and wish\n  to put sets of atoms into different groups so they can be operated on\n  later.  E.g. a group of added atoms can be moved to new positions via\n  the displace_atoms command.  Note that atoms\n  read from the data file are also always added to the “all” group.  The\n  group command discusses atom groups, as used in LAMMPS.\n  The nocoeff keyword tells read_data to ignore force field parameters.\n  The various Coeff sections are still read and have to have the correct\n  number of lines, but they are not applied. This also allows to read a\n  data file without having any pair, bond, angle, dihedral or improper\n  styles defined, or to read a data file for a different force field.\n  The use of the fix keyword is discussed below.\n  \n  Reading multiple data files\n  The read_data command can be used multiple times with the same or\n  different data files to build up a complex system from components\n  contained in individual data files.  For example one data file could\n  contain fluid in a confined domain; a second could contain wall atoms,\n  and the second file could be read a third time to create a wall on the\n  other side of the fluid.  The third set of atoms could be rotated to\n  an opposing direction using the displace_atoms\n  command, after the third read_data command is used.\n  The add, offset, shift, extra, and group keywords are\n  useful in this context.\n  If a simulation box does not yet exist, the add keyword\n  cannot be used; the read_data command is being used for the first\n  time.  If a simulation box does exist, due to using the\n  create_box command, or a previous read_data command,\n  then the add keyword must be used.\n  \n  Note\n  The simulation box size (xlo to xhi, ylo to yhi, zlo to zhi) in\n  the new data file will be merged with the existing simulation box to\n  create a large enough box in each dimension to contain both the\n  existing and new atoms.  Each box dimension never shrinks due to this\n  merge operation, it only stays the same or grows. Care must be used if\n  you are growing the existing simulation box in a periodic dimension.\n  If there are existing atoms with bonds that straddle that periodic\n  boundary, then the atoms may become far apart if the box size grows.\n  This will separate the atoms in the bond, which can lead to “lost”\n  bond atoms or bad dynamics.\n  \n  The three choices for the add argument affect how the atom IDs and\n  molecule IDs of atoms in the data file are treated.  If append is\n  specified, atoms in the data file are added to the current system,\n  with their atom IDs reset so that an atom-ID = M in the data file\n  becomes atom-ID = N+M, where N is the largest atom ID in the current\n  system.  This rule is applied to all occurrences of atom IDs in the\n  data file, e.g. in the Velocity or Bonds section. This is also done\n  for molecule IDs, if the atom style does support molecule IDs or\n  they are enabled via fix property/atom. If IDoffset is specified,\n  then IDoffset is a numeric value is given, e.g. 1000, so that an\n  atom-ID = M in the data file becomes atom-ID = 1000+M. For systems\n  with enabled molecule IDs, another numerical argument MOLoffset\n  is required representing the equivalent offset for molecule IDs.\n  If merge is specified, the data file atoms\n  are added to the current system without changing their IDs.  They are\n  assumed to merge (without duplication) with the currently defined\n  atoms.  It is up to you to insure there are no multiply defined atom\n  IDs, as LAMMPS only performs an incomplete check that this is the case\n  by insuring the resulting max atom-ID >= the number of atoms. For\n  molecule IDs, there is no check done at all.\n  The offset and shift keywords can only be used if the add\n  keyword is also specified.\n  The offset keyword adds the specified offset values to the atom\n  types, bond types, angle types, dihedral types, and improper types as\n  they are read from the data file.  E.g. if toff = 2, and the file\n  uses atom types 1,2,3, then the added atoms will have atom types\n  3,4,5.  These offsets apply to all occurrences of types in the data\n  file, e.g. for the Atoms or Masses or Pair Coeffs or Bond Coeffs\n  sections.  This makes it easy to use atoms and molecules and their\n  attributes from a data file in different simulations, where you want\n  their types (atom, bond, angle, etc) to be different depending on what\n  other types already exist.  All five offset values must be specified,\n  but individual values will be ignored if the data file does not use\n  that attribute (e.g. no bonds).\n  The shift keyword can be used to specify an (Sx, Sy, Sz)\n  displacement applied to the coordinates of each atom.  Sz must be 0.0\n  for a 2d simulation.  This is a mechanism for adding structured\n  collections of atoms at different locations within the simulation box,\n  to build up a complex geometry.  It is up to you to insure atoms do\n  not end up overlapping unphysically which would lead to bad dynamics.\n  Note that the displace_atoms command can be used\n  to move a subset of atoms after they have been read from a data file.\n  Likewise, the delete_atoms command can be used to\n  remove overlapping atoms.  Note that the shift values (Sx, Sy, Sz) are\n  also added to the simulation box information (xlo, xhi, ylo, yhi, zlo,\n  zhi) in the data file to shift its boundaries.  E.g. xlo_new = xlo +\n  Sx, xhi_new = xhi + Sx.\n  The extra keywords can only be used the first time the read_data\n  command is used.  They are useful if you intend to add new atom, bond,\n  angle, etc types later with additional read_data commands.  This is\n  because the maximum number of allowed atom, bond, angle, etc types is\n  set by LAMMPS when the system is first initialized.  If you do not use\n  the extra keywords, then the number of these types will be limited\n  to what appears in the first data file you read.  For example, if the\n  first data file is a solid substrate of Si, it will likely specify a\n  single atom type.  If you read a second data file with a different\n  material (water molecules) that sit on top of the substrate, you will\n  want to use different atom types for those atoms.  You can only do\n  this if you set the extra/atom/types keyword to a sufficiently large\n  value when reading the substrate data file.  Note that use of the\n  extra keywords also allows each data file to contain sections like\n  Masses or Pair Coeffs or Bond Coeffs which are sized appropriately for\n  the number of types in that data file.  If the offset keyword is\n  used appropriately when each data file is read, the values in those\n  sections will be stored correctly in the larger data structures\n  allocated by the use of the extra keywords.  E.g. the substrate file\n  can list mass and pair coefficients for type 1 silicon atoms.  The\n  water file can list mass and pair coefficients for type 1 and type 2\n  hydrogen and oxygen atoms.  Use of the extra and offset keywords\n  will store those mass and pair coefficient values appropriately in\n  data structures that allow for 3 atom types (Si, H, O).  Of course,\n  you would still need to specify coefficients for H/Si and O/Si\n  interactions in your input script to have a complete pairwise\n  interaction model.\n  An alternative to using the extra keywords with the read_data\n  command, is to use the create_box command to\n  initialize the simulation box and all the various type limits you need\n  via its extra keywords.  Then use the read_data command one or more\n  times to populate the system with atoms, bonds, angles, etc, using the\n  offset keyword if desired to alter types used in the various data\n  files you read.\n  \n  Format of a data file\n  The structure of the data file is important, though many settings and\n  sections are optional or can come in any order.  See the examples\n  directory for sample data files for different problems.\n  A data file has a header and a body.  The header appears first.  The\n  first line of the header is always skipped; it typically contains a\n  description of the file.  Then lines are read one at a time.  Lines\n  can have a trailing comment starting with ‘#’ that is ignored.  If the\n  line is blank (only white-space after comment is deleted), it is\n  skipped.  If the line contains a header keyword, the corresponding\n  value(s) is read from the line.  If it does not contain a header\n  keyword, the line begins the body of the file.\n  The body of the file contains zero or more sections.  The first line\n  of a section has only a keyword.  This line can have a trailing\n  comment starting with ‘#’ that is either ignored or can be used to\n  check for a style match, as described below.  The next line is\n  skipped.  The remaining lines of the section contain values.  The\n  number of lines depends on the section keyword as described below.\n  Zero or more blank lines can be used between sections.  Sections can\n  appear in any order, with a few exceptions as noted below.\n  The keyword fix can be used one or more times.  Each usage specifies\n  a fix that will be used to process a specific portion of the data\n  file.  Any header line containing header-string and any section with\n  a name containing section-string will be passed to the specified\n  fix.  See the fix property/atom command for\n  an example of a fix that operates in this manner.  The doc page for\n  the fix defines the syntax of the header line(s) and section(s) that\n  it reads from the data file.  Note that the header-string can be\n  specified as NULL, in which case no header lines are passed to the\n  fix.  This means that it can infer the length of its Section from\n  standard header settings, such as the number of atoms.\n  The formatting of individual lines in the data file (indentation,\n  spacing between words and numbers) is not important except that header\n  and section keywords (e.g. atoms, xlo xhi, Masses, Bond Coeffs) must\n  be capitalized as shown and can’t have extra white-space between their\n  words - e.g. two spaces or a tab between the 2 words in “xlo xhi” or\n  the 2 words in “Bond Coeffs”, is not valid.\n  \n  Format of the header of a data file\n  These are the recognized header keywords.  Header lines can come in\n  any order.  The value(s) are read from the beginning of the line.\n  Thus the keyword atoms should be in a line like “1000 atoms”; the\n  keyword ylo yhi should be in a line like “-10.0 10.0 ylo yhi”; the\n  keyword xy xz yz should be in a line like “0.0 5.0 6.0 xy xz yz”.\n  All these settings have a default value of 0, except the lo/hi box\n  size defaults are -0.5 and 0.5.  A line need only appear if the value\n  is different than the default.\n  \n  atoms = # of atoms in system\n  bonds = # of bonds in system\n  angles = # of angles in system\n  dihedrals = # of dihedrals in system\n  impropers = # of impropers in system\n  atom types = # of atom types in system\n  bond types = # of bond types in system\n  angle types = # of angle types in system\n  dihedral types = # of dihedral types in system\n  improper types = # of improper types in system\n  extra bond per atom = leave space for this many new bonds per atom (deprecated, use extra/bond/per/atom keyword)\n  extra angle per atom = leave space for this many new angles per atom (deprecated, use extra/angle/per/atom keyword)\n  extra dihedral per atom = leave space for this many new dihedrals per atom (deprecated, use extra/dihedral/per/atom keyword)\n  extra improper per atom = leave space for this many new impropers per atom (deprecated, use extra/improper/per/atom keyword)\n  extra special per atom = leave space for this many new special bonds per atom (deprecated, use extra/special/per/atom keyword)\n  ellipsoids = # of ellipsoids in system\n  lines = # of line segments in system\n  triangles = # of triangles in system\n  bodies = # of bodies in system\n  xlo xhi = simulation box boundaries in x dimension\n  ylo yhi = simulation box boundaries in y dimension\n  zlo zhi = simulation box boundaries in z dimension\n  xy xz yz = simulation box tilt factors for triclinic system\n  \n  The initial simulation box size is determined by the lo/hi settings.\n  In any dimension, the system may be periodic or non-periodic; see the\n  boundary command.  When the simulation box is created\n  it is also partitioned into a regular 3d grid of rectangular bricks,\n  one per processor, based on the number of processors being used and\n  the settings of the processors command.  The\n  partitioning can later be changed by the balance or\n  fix balance commands.\n  If the xy xz yz line does not appear, LAMMPS will set up an\n  axis-aligned (orthogonal) simulation box.  If the line does appear,\n  LAMMPS creates a non-orthogonal simulation domain shaped as a\n  parallelepiped with triclinic symmetry.  The parallelepiped has its\n  “origin” at (xlo,ylo,zlo) and is defined by 3 edge vectors starting\n  from the origin given by A = (xhi-xlo,0,0); B = (xy,yhi-ylo,0); C =\n  (xz,yz,zhi-zlo).  Xy,xz,yz can be 0.0 or positive or negative values\n  and are called “tilt factors” because they are the amount of\n  displacement applied to faces of an originally orthogonal box to\n  transform it into the parallelepiped.\n  By default, the tilt factors (xy,xz,yz) can not skew the box more than\n  half the distance of the corresponding parallel box length.  For\n  example, if xlo = 2 and xhi = 12, then the x box length is 10 and the\n  xy tilt factor must be between -5 and 5.  Similarly, both xz and yz\n  must be between -(xhi-xlo)/2 and +(yhi-ylo)/2.  Note that this is not\n  a limitation, since if the maximum tilt factor is 5 (as in this\n  example), then configurations with tilt = …, -15, -5, 5, 15, 25,\n  … are all geometrically equivalent.  If you wish to define a box\n  with tilt factors that exceed these limits, you can use the box tilt command, with a setting of large; a setting of\n  small is the default.\n  See the Howto triclinic doc page for a\n  geometric description of triclinic boxes, as defined by LAMMPS, and\n  how to transform these parameters to and from other commonly used\n  triclinic representations.\n  When a triclinic system is used, the simulation domain should normally\n  be periodic in the dimension that the tilt is applied to, which is\n  given by the second dimension of the tilt factor (e.g. y for xy tilt).\n  This is so that pairs of atoms interacting across that boundary will\n  have one of them shifted by the tilt factor.  Periodicity is set by\n  the boundary command.  For example, if the xy tilt\n  factor is non-zero, then the y dimension should be periodic.\n  Similarly, the z dimension should be periodic if xz or yz is non-zero.\n  LAMMPS does not require this periodicity, but you may lose atoms if\n  this is not the case.\n  Also note that if your simulation will tilt the box, e.g. via the fix deform command, the simulation box must be setup to\n  be triclinic, even if the tilt factors are initially 0.0.  You can\n  also change an orthogonal box to a triclinic box or vice versa by\n  using the change box command with its ortho and\n  triclinic options.\n  For 2d simulations, the zlo zhi values should be set to bound the z\n  coords for atoms that appear in the file; the default of -0.5 0.5 is\n  valid if all z coords are 0.0.  For 2d triclinic simulations, the xz\n  and yz tilt factors must be 0.0.\n  If the system is periodic (in a dimension), then atom coordinates can\n  be outside the bounds (in that dimension); they will be remapped (in a\n  periodic sense) back inside the box.  Note that if the add option is\n  being used to add atoms to a simulation box that already exists, this\n  periodic remapping will be performed using simulation box bounds that\n  are the union of the existing box and the box boundaries in the new\n  data file.\n  \n  Note\n  If the system is non-periodic (in a dimension), then all atoms\n  in the data file must have coordinates (in that dimension) that are\n  “greater than or equal to” the lo value and “less than or equal to”\n  the hi value.  If the non-periodic dimension is of style “fixed” (see\n  the boundary command), then the atom coords must be\n  strictly “less than” the hi value, due to the way LAMMPS assign atoms\n  to processors.  Note that you should not make the lo/hi values\n  radically smaller/larger than the extent of the atoms.  For example,\n  if your atoms extend from 0 to 50, you should not specify the box\n  bounds as -10000 and 10000.  This is because LAMMPS uses the specified\n  box size to layout the 3d grid of processors.  A huge (mostly empty)\n  box will be sub-optimal for performance when using “fixed” boundary\n  conditions (see the boundary command).  When using\n  “shrink-wrap” boundary conditions (see the boundary\n  command), a huge (mostly empty) box may cause a parallel simulation to\n  lose atoms when LAMMPS shrink-wraps the box around the atoms.  The\n  read_data command will generate an error in this case.\n  \n  The “extra bond per atom” setting (angle, dihedral, improper) is only\n  needed if new bonds (angles, dihedrals, impropers) will be added to\n  the system when a simulation runs, e.g. by using the fix bond/create command. Using this header flag\n  is deprecated; please use the extra/bond/per/atom keyword (and\n  correspondingly for angles, dihedrals and impropers) in the read_data\n  command instead. Either will pre-allocate space in LAMMPS data\n  structures for storing the new bonds (angles, dihedrals, impropers).\n  The “extra special per atom” setting is typically only needed if new\n  bonds/angles/etc will be added to the system, e.g. by using the fix bond/create command.  Or if entire new molecules\n  will be added to the system, e.g. by using the\n  fix deposit or fix pour commands,\n  which will have more special 1-2,1-3,1-4 neighbors than any other\n  molecules defined in the data file.  Using this header flag is\n  deprecated; please use the extra/special/per/atom keyword instead.\n  Using this setting will pre-allocate space in the LAMMPS data\n  structures for storing these neighbors.  See the\n  special_bonds and molecule doc\n  pages for more discussion of 1-2,1-3,1-4 neighbors.\n  \n  Note\n  All of the “extra” settings are only applied in the first data\n  file read and when no simulation box has yet been created; as soon as\n  the simulation box is created (and read_data implies that), these\n  settings are locked and cannot be changed anymore. Please see the\n  description of the add keyword above for reading multiple data files.\n  If they appear in later data files, they are ignored.\n  \n  The “ellipsoids” and “lines” and “triangles” and “bodies” settings are\n  only used with atom_style ellipsoid or line or tri or body and specify how many of the atoms are\n  finite-size ellipsoids or lines or triangles or bodies; the remainder\n  are point particles.  See the discussion of ellipsoidflag and the\n  Ellipsoids section below.  See the discussion of lineflag and the\n  Lines section below.  See the discussion of triangleflag and the\n  Triangles section below.  See the discussion of bodyflag and the\n  Bodies section below.\n  \n  Note\n  For atom_style template, the molecular\n  topology (bonds,angles,etc) is contained in the molecule templates\n  read-in by the molecule command.  This means you\n  cannot set the bonds, angles, etc header keywords in the data\n  file, nor can you define Bonds, Angles, etc sections as discussed\n  below.  You can set the bond types, angle types, etc header\n  keywords, though it is not necessary.  If specified, they must match\n  the maximum values defined in any of the template molecules.\n  \n  \n  Format of the body of a data file\n  These are the section keywords for the body of the file.\n  \n  Atoms, Velocities, Masses, Ellipsoids, Lines, Triangles, Bodies = atom-property sections\n  Bonds, Angles, Dihedrals, Impropers = molecular topology sections\n  Pair Coeffs, PairIJ Coeffs, Bond Coeffs, Angle Coeffs, Dihedral Coeffs,    Improper Coeffs = force field sections\n  BondBond Coeffs, BondAngle Coeffs, MiddleBondTorsion Coeffs,    EndBondTorsion Coeffs, AngleTorsion Coeffs, AngleAngleTorsion Coeffs,    BondBond13 Coeffs, AngleAngle Coeffs = class 2 force field sections\n  \n  These keywords will check an appended comment for a match with the\n  currently defined style:\n  \n  Atoms, Pair Coeffs, PairIJ Coeffs, Bond Coeffs, Angle Coeffs, Dihedral Coeffs, Improper Coeffs\n  \n  For example, these lines:\n  Atoms # sphere\n  Pair Coeffs # lj/cut\n  \n  \n  will check if the currently-defined atom_style is\n  sphere, and the current pair_style is lj/cut.\n  If not, LAMMPS will issue a warning to indicate that the data file\n  section likely does not contain the correct number or type of\n  parameters expected for the currently-defined style.\n  Each section is listed below in alphabetic order.  The format of each\n  section is described including the number of lines it must contain and\n  rules (if any) for where it can appear in the data file.\n  Any individual line in the various sections can have a trailing\n  comment starting with “#” for annotation purposes.  E.g. in the\n  Atoms section:\n  10 1 17 -1.0 10.0 5.0 6.0   # salt ion\n  \n  \n  \n  Angle Coeffs section:\n  \n  one line per angle type\n  line syntax: ID coeffs\n  ID = angle type (1-N)\n  coeffs = list of coeffs\n  \n  \n  \n  example:\n  6 70 108.5 0 0\n  \n  \n  \n  \n  The number and meaning of the coefficients are specific to the defined\n  angle style.  See the angle_style and\n  angle_coeff commands for details.  Coefficients can\n  also be set via the angle_coeff command in the\n  input script.\n  \n  AngleAngle Coeffs section:\n  \n  one line per improper type\n  line syntax: ID coeffs\n  ID = improper type (1-N)\n  coeffs = list of coeffs (see improper_coeff)\n  \n  \n  \n  AngleAngleTorsion Coeffs section:\n  \n  one line per dihedral type\n  line syntax: ID coeffs\n  ID = dihedral type (1-N)\n  coeffs = list of coeffs (see dihedral_coeff)\n  \n  \n  \n  Angles section:\n  \n  one line per angle\n  line syntax: ID type atom1 atom2 atom3\n  ID = number of angle (1-Nangles)\n  type = angle type (1-Nangletype)\n  atom1,atom2,atom3 = IDs of 1st,2nd,3rd atoms in angle\n  \n  \n  \n  \n  example:\n  \n  2 2 17 29 430\n  \n  \n  \n  The 3 atoms are ordered linearly within the angle.  Thus the central\n  atom (around which the angle is computed) is the atom2 in the list.\n  E.g. H,O,H for a water molecule.  The Angles section must appear\n  after the Atoms section.  All values in this section must be\n  integers (1, not 1.0).\n  \n  AngleTorsion Coeffs section:\n  \n  one line per dihedral type\n  line syntax: ID coeffs\n  ID = dihedral type (1-N)\n  coeffs = list of coeffs (see dihedral_coeff)\n  \n  \n  \n  Atoms section:\n  \n  one line per atom\n  line syntax: depends on atom style\n  \n  An Atoms section must appear in the data file if natoms > 0 in the\n  header section.  The atoms can be listed in any order.  These are the\n  line formats for each atom style in LAMMPS.  As\n  discussed below, each line can optionally have 3 flags (nx,ny,nz)\n  appended to it, which indicate which image of a periodic simulation\n  box the atom is in.  These may be important to include for some kinds\n  of analysis.\n  \n  \n  \n  \n  \n  \n  angle\n  atom-ID molecule-ID atom-type x y z\n  \n  atomic\n  atom-ID atom-type x y z\n  \n  body\n  atom-ID atom-type bodyflag mass x y z\n  \n  bond\n  atom-ID molecule-ID atom-type x y z\n  \n  charge\n  atom-ID atom-type q x y z\n  \n  dipole\n  atom-ID atom-type q x y z mux muy muz\n  \n  dpd\n  atom-ID atom-type theta x y z\n  \n  edpd\n  atom-ID atom-type edpd_temp edpd_cv x y z\n  \n  mdpd\n  atom-ID atom-type rho x y z\n  \n  tdpd\n  atom-ID atom-type x y z cc1 cc2 … ccNspecies\n  \n  electron\n  atom-ID atom-type q spin eradius x y z\n  \n  ellipsoid\n  atom-ID atom-type ellipsoidflag density x y z\n  \n  full\n  atom-ID molecule-ID atom-type q x y z\n  \n  line\n  atom-ID molecule-ID atom-type lineflag density x y z\n  \n  meso\n  atom-ID atom-type rho e cv x y z\n  \n  molecular\n  atom-ID molecule-ID atom-type x y z\n  \n  peri\n  atom-ID atom-type volume density x y z\n  \n  smd\n  atom-ID atom-type molecule volume mass kernel-radius contact-radius x y z\n  \n  sphere\n  atom-ID atom-type diameter density x y z\n  \n  spin\n  atom-ID atom-type sp x y z spx spy spz\n  \n  template\n  atom-ID molecule-ID template-index template-atom atom-type x y z\n  \n  tri\n  atom-ID molecule-ID atom-type triangleflag density x y z\n  \n  wavepacket\n  atom-ID atom-type charge spin eradius etag cs_re cs_im x y z\n  \n  hybrid\n  atom-ID atom-type x y z sub-style1 sub-style2 …\n  \n  \n  \n  The per-atom values have these meanings and units, listed alphabetically:\n  \n  atom-ID = integer ID of atom\n  atom-type = type of atom (1-Ntype)\n  bodyflag = 1 for body particles, 0 for point particles\n  cc = chemical concentration for tDPD particles for each species (mole/volume units)\n  contact-radius = ??? (distance units)\n  cs_re,cs_im = real/imaginary parts of wave packet coefficients\n  cv = heat capacity (need units) for SPH particles\n  density = density of particle (mass/distance^3 or mass/distance^2 or mass/distance units, depending on dimensionality of particle)\n  diameter = diameter of spherical atom (distance units)\n  e = energy (need units) for SPH particles\n  edpd_temp = temperature for eDPD particles (temperature units)\n  edpd_cv = volumetric heat capacity for eDPD particles (energy/temperature/volume units)\n  ellipsoidflag = 1 for ellipsoidal particles, 0 for point particles\n  eradius = electron radius (or fixed-core radius)\n  etag = integer ID of electron that each wave packet belongs to\n  kernel-radius = ??? (distance units)\n  lineflag = 1 for line segment particles, 0 for point or spherical particles\n  mass = mass of particle (mass units)\n  molecule-ID = integer ID of molecule the atom belongs to\n  mux,muy,muz = components of dipole moment of atom (dipole units)\n  q = charge on atom (charge units)\n  rho = density (need units) for SPH particles\n  spin = electron spin (+1/-1), 0 = nuclei, 2 = fixed-core, 3 = pseudo-cores (i.e. ECP)\n  sp = norm of magnetic spin of atom (in number of Bohr magnetons)\n  spx,spy,spz = components of magnetic spin of atom (adim normalized vector)\n  template-atom = which atom within a template molecule the atom is\n  template-index = which molecule within the molecule template the atom is part of\n  theta = internal temperature of a DPD particle\n  triangleflag = 1 for triangular particles, 0 for point or spherical particles\n  volume = volume of Peridynamic particle (distance^3 units)\n  x,y,z = coordinates of atom (distance units)\n  \n  The units for these quantities depend on the unit style; see the\n  units command for details.\n  For 2d simulations specify z as 0.0, or a value within the zlo zhi\n  setting in the data file header.\n  The atom-ID is used to identify the atom throughout the simulation and\n  in dump files.  Normally, it is a unique value from 1 to Natoms for\n  each atom.  Unique values larger than Natoms can be used, but they\n  will cause extra memory to be allocated on each processor, if an atom\n  map array is used, but not if an atom map hash is used; see the\n  atom_modify command for details.  If an atom map is\n  not used (e.g. an atomic system with no bonds), and you don’t care if\n  unique atom IDs appear in dump files, then the atom-IDs can all be set\n  to 0.\n  The molecule ID is a 2nd identifier attached to an atom.  Normally, it\n  is a number from 1 to N, identifying which molecule the atom belongs\n  to.  It can be 0 if it is a non-bonded atom or if you don’t care to\n  keep track of molecule assignments.\n  The diameter specifies the size of a finite-size spherical particle.\n  It can be set to 0.0, which means that atom is a point particle.\n  The ellipsoidflag, lineflag, triangleflag, and bodyflag determine\n  whether the particle is a finite-size ellipsoid or line or triangle or\n  body of finite size, or whether the particle is a point particle.\n  Additional attributes must be defined for each ellipsoid, line,\n  triangle, or body in the corresponding Ellipsoids, Lines,\n  Triangles, or Bodies section.\n  The template-index and template-atom are only defined used by\n  atom_style template.  In this case the\n  molecule command is used to define a molecule template\n  which contains one or more molecules.  If an atom belongs to one of\n  those molecules, its template-index and template-atom are both set\n  to positive integers; if not the values are both 0.  The\n  template-index is which molecule (1 to Nmols) the atom belongs to.\n  The template-atom is which atom (1 to Natoms) within the molecule\n  the atom is.\n  Some pair styles and fixes and computes that operate on finite-size\n  particles allow for a mixture of finite-size and point particles.  See\n  the doc pages of individual commands for details.\n  For finite-size particles, the density is used in conjunction with the\n  particle volume to set the mass of each particle as mass = density *\n  volume.  In this context, volume can be a 3d quantity (for spheres or\n  ellipsoids), a 2d quantity (for triangles), or a 1d quantity (for line\n  segments).  If the volume is 0.0, meaning a point particle, then the\n  density value is used as the mass.  One exception is for the body atom\n  style, in which case the mass of each particle (body or point\n  particle) is specified explicitly.  This is because the volume of the\n  body is unknown.\n  Note that for 2d simulations of spheres, this command will treat them\n  as spheres when converting density to mass.  However, they can also be\n  modeled as 2d discs (circles) if the set density/disc\n  command is used to reset their mass after the read_data command is\n  used.  A disc keyword can also be used with time integration fixes,\n  such as fix nve/sphere and fix nvt/sphere to time integrate their motion as 2d\n  discs (not 3d spheres), by changing their moment of inertia.\n  For atom_style hybrid, following the 5 initial values (ID,type,x,y,z),\n  specific values for each sub-style must be listed.  The order of the\n  sub-styles is the same as they were listed in the\n  atom_style command.  The sub-style specific values\n  are those that are not the 5 standard ones (ID,type,x,y,z).  For\n  example, for the “charge” sub-style, a “q” value would appear.  For\n  the “full” sub-style, a “molecule-ID” and “q” would appear.  These are\n  listed in the same order they appear as listed above.  Thus if\n  atom_style hybrid charge sphere\n  \n  \n  were used in the input script, each atom line would have these fields:\n  atom-ID atom-type x y z q diameter density\n  \n  \n  Note that if a non-standard value is defined by multiple sub-styles,\n  it must appear multiple times in the atom line.  E.g. the atom line\n  for atom_style hybrid dipole full would list “q” twice:\n  atom-ID atom-type x y z q mux muy myz molecule-ID q\n  \n  \n  Atom lines specify the (x,y,z) coordinates of atoms.  These can be\n  inside or outside the simulation box.  When the data file is read,\n  LAMMPS wraps coordinates outside the box back into the box for\n  dimensions that are periodic.  As discussed above, if an atom is\n  outside the box in a non-periodic dimension, it will be lost.\n  LAMMPS always stores atom coordinates as values which are inside the\n  simulation box.  It also stores 3 flags which indicate which image of\n  the simulation box (in each dimension) the atom would be in if its\n  coordinates were unwrapped across periodic boundaries.  An image flag\n  of 0 means the atom is still inside the box when unwrapped.  A value\n  of 2 means add 2 box lengths to get the unwrapped coordinate.  A value\n  of -1 means subtract 1 box length to get the unwrapped coordinate.\n  LAMMPS updates these flags as atoms cross periodic boundaries during\n  the simulation.  The dump command can output atom\n  coordinates in wrapped or unwrapped form, as well as the 3 image\n  flags.\n  In the data file, atom lines (all lines or none of them) can\n  optionally list 3 trailing integer values (nx,ny,nz), which are used\n  to initialize the atom’s image flags.  If nx,ny,nz values are not\n  listed in the data file, LAMMPS initializes them to 0.  Note that the\n  image flags are immediately updated if an atom’s coordinates need to\n  wrapped back into the simulation box.\n  It is only important to set image flags correctly in a data file if a\n  simulation model relies on unwrapped coordinates for some calculation;\n  otherwise they can be left unspecified.  Examples of LAMMPS commands\n  that use unwrapped coordinates internally are as follows:\n  \n  Atoms in a rigid body (see fix rigid, fix rigid/small) must have consistent image flags, so that\n  when the atoms are unwrapped, they are near each other, i.e. as a\n  single body.\n  If the replicate command is used to generate a larger\n  system, image flags must be consistent for bonded atoms when the bond\n  crosses a periodic boundary.  I.e. the values of the image flags\n  should be different by 1 (in the appropriate dimension) for the two\n  atoms in such a bond.\n  If you plan to dump image flags and perform post-analysis\n  that will unwrap atom coordinates, it may be important that a\n  continued run (restarted from a data file) begins with image flags\n  that are consistent with the previous run.\n  \n  \n  Note\n  If your system is an infinite periodic crystal with bonds then\n  it is impossible to have fully consistent image flags.  This is because\n  some bonds will cross periodic boundaries and connect two atoms with the\n  same image flag.\n  \n  Atom velocities and other atom quantities not defined above are set to\n  0.0 when the Atoms section is read.  Velocities can be set later by\n  a Velocities section in the data file or by a\n  velocity or set command in the input\n  script.\n  \n  Bodies section:\n  \n  one or more lines per body\n  first line syntax: atom-ID Ninteger Ndouble\n  Ninteger = # of integer quantities for this particle\n  Ndouble = # of floating-point quantities for this particle\n  \n  \n  \n  0 or more integer lines with total of Ninteger values\n  0 or more double lines with total of Ndouble values\n  example:\n  12 3 6\n  2 3 2\n  1.0 2.0 3.0 1.0 2.0 4.0\n  \n  \n  \n  example:\n  12 0 14\n  1.0 2.0 3.0 1.0 2.0 4.0 1.0\n  2.0 3.0 1.0 2.0 4.0 4.0 2.0\n  \n  \n  \n  \n  The Bodies section must appear if atom_style body\n  is used and any atoms listed in the Atoms section have a bodyflag =\n  1.  The number of bodies should be specified in the header section via\n  the “bodies” keyword.\n  Each body can have a variable number of integer and/or floating-point\n  values.  The number and meaning of the values is defined by the body\n  style, as described in the Howto body doc page.  The\n  body style is given as an argument to the atom_style body command.\n  The Ninteger and Ndouble values determine how many integer and\n  floating-point values are specified for this particle.  Ninteger and\n  Ndouble can be as large as needed and can be different for every body.\n  Integer values are then listed next on subsequent lines.  Lines are\n  read one at a time until Ninteger values are read.  Floating-point\n  values follow on subsequent lines, Again lines are read one at a time\n  until Ndouble values are read.  Note that if there are no values of a\n  particular type, no lines appear for that type.\n  The Bodies section must appear after the Atoms section.\n  \n  Bond Coeffs section:\n  \n  one line per bond type\n  line syntax: ID coeffs\n  ID = bond type (1-N)\n  coeffs = list of coeffs\n  \n  \n  \n  example:\n  4 250 1.49\n  \n  \n  \n  \n  The number and meaning of the coefficients are specific to the defined\n  bond style.  See the bond_style and\n  bond_coeff commands for details.  Coefficients can\n  also be set via the bond_coeff command in the input\n  script.\n  \n  BondAngle Coeffs section:\n  \n  one line per angle type\n  line syntax: ID coeffs\n  ID = angle type (1-N)\n  coeffs = list of coeffs (see class 2 section of angle_coeff)\n  \n  \n  \n  BondBond Coeffs section:\n  \n  one line per angle type\n  line syntax: ID coeffs\n  ID = angle type (1-N)\n  coeffs = list of coeffs (see class 2 section of angle_coeff)\n  \n  \n  \n  BondBond13 Coeffs section:\n  \n  one line per dihedral type\n  line syntax: ID coeffs\n  ID = dihedral type (1-N)\n  coeffs = list of coeffs (see class 2 section of dihedral_coeff)\n  \n  \n  \n  Bonds section:\n  \n  one line per bond\n  line syntax: ID type atom1 atom2\n  ID = bond number (1-Nbonds)\n  type = bond type (1-Nbondtype)\n  atom1,atom2 = IDs of 1st,2nd atoms in bond\n  \n  \n  \n  example:\n  12 3 17 29\n  \n  \n  \n  \n  The Bonds section must appear after the Atoms section.  All values\n  in this section must be integers (1, not 1.0).\n  \n  Dihedral Coeffs section:\n  \n  one line per dihedral type\n  line syntax: ID coeffs\n  ID = dihedral type (1-N)\n  coeffs = list of coeffs\n  \n  \n  \n  example:\n  3 0.6 1 0 1\n  \n  \n  \n  \n  The number and meaning of the coefficients are specific to the defined\n  dihedral style.  See the dihedral_style and\n  dihedral_coeff commands for details.\n  Coefficients can also be set via the\n  dihedral_coeff command in the input script.\n  \n  Dihedrals section:\n  \n  one line per dihedral\n  line syntax: ID type atom1 atom2 atom3 atom4\n  ID = number of dihedral (1-Ndihedrals)\n  type = dihedral type (1-Ndihedraltype)\n  atom1,atom2,atom3,atom4 = IDs of 1st,2nd,3rd,4th atoms in dihedral\n  \n  \n  \n  example:\n  12 4 17 29 30 21\n  \n  \n  \n  \n  The 4 atoms are ordered linearly within the dihedral.  The Dihedrals\n  section must appear after the Atoms section.  All values in this\n  section must be integers (1, not 1.0).\n  \n  Ellipsoids section:\n  \n  one line per ellipsoid\n  line syntax: atom-ID shapex shapey shapez quatw quati quatj quatk\n  atom-ID = ID of atom which is an ellipsoid\n  shapex,shapey,shapez = 3 diameters of ellipsoid (distance units)\n  quatw,quati,quatj,quatk = quaternion components for orientation of atom\n  \n  \n  \n  example:\n  12 1 2 1 1 0 0 0\n  \n  \n  \n  \n  The Ellipsoids section must appear if atom_style ellipsoid is used and any atoms are listed in the\n  Atoms section with an ellipsoidflag = 1.  The number of ellipsoids\n  should be specified in the header section via the “ellipsoids”\n  keyword.\n  The 3 shape values specify the 3 diameters or aspect ratios of a\n  finite-size ellipsoidal particle, when it is oriented along the 3\n  coordinate axes.  They must all be non-zero values.\n  The values quatw, quati, quatj, and quatk set the orientation\n  of the atom as a quaternion (4-vector).  Note that the shape\n  attributes specify the aspect ratios of an ellipsoidal particle, which\n  is oriented by default with its x-axis along the simulation box’s\n  x-axis, and similarly for y and z.  If this body is rotated (via the\n  right-hand rule) by an angle theta around a unit vector (a,b,c), then\n  the quaternion that represents its new orientation is given by\n  (cos(theta/2), a*sin(theta/2), b*sin(theta/2), c*sin(theta/2)).  These\n  4 components are quatw, quati, quatj, and quatk as specified above.\n  LAMMPS normalizes each atom’s quaternion in case (a,b,c) is not\n  specified as a unit vector.\n  The Ellipsoids section must appear after the Atoms section.\n  \n  EndBondTorsion Coeffs section:\n  \n  one line per dihedral type\n  line syntax: ID coeffs\n  ID = dihedral type (1-N)\n  coeffs = list of coeffs (see class 2 section of dihedral_coeff)\n  \n  \n  \n  Improper Coeffs section:\n  \n  one line per improper type\n  line syntax: ID coeffs\n  ID = improper type (1-N)\n  coeffs = list of coeffs\n  \n  \n  \n  example:\n  2 20 0.0548311\n  \n  \n  \n  \n  The number and meaning of the coefficients are specific to the defined\n  improper style.  See the improper_style and\n  improper_coeff commands for details.\n  Coefficients can also be set via the\n  improper_coeff command in the input script.\n  \n  Impropers section:\n  \n  one line per improper\n  line syntax: ID type atom1 atom2 atom3 atom4\n  ID = number of improper (1-Nimpropers)\n  type = improper type (1-Nimpropertype)\n  atom1,atom2,atom3,atom4 = IDs of 1st,2nd,3rd,4th atoms in improper\n  \n  \n  \n  example:\n  12 3 17 29 13 100\n  \n  \n  \n  \n  The ordering of the 4 atoms determines the definition of the improper\n  angle used in the formula for each improper style.  See the doc pages for individual styles\n  for details.\n  The Impropers section must appear after the Atoms section.  All\n  values in this section must be integers (1, not 1.0).\n  \n  Lines section:\n  \n  one line per line segment\n  line syntax: atom-ID x1 y1 x2 y2\n  atom-ID = ID of atom which is a line segment\n  x1,y1 = 1st end point\n  x2,y2 = 2nd end point\n  \n  \n  \n  example:\n  12 1.0 0.0 2.0 0.0\n  \n  \n  \n  \n  The Lines section must appear if atom_style line\n  is used and any atoms are listed in the Atoms section with a\n  lineflag = 1.  The number of lines should be specified in the header\n  section via the “lines” keyword.\n  The 2 end points are the end points of the line segment.  The ordering\n  of the 2 points should be such that using a right-hand rule to cross\n  the line segment with a unit vector in the +z direction, gives an\n  “outward” normal vector perpendicular to the line segment.\n  I.e. normal = (c2-c1) x (0,0,1).  This orientation may be important\n  for defining some interactions.\n  The Lines section must appear after the Atoms section.\n  \n  Masses section:\n  \n  one line per atom type\n  line syntax: ID mass\n  ID = atom type (1-N)\n  mass = mass value\n  \n  \n  \n  example:\n  3 1.01\n  \n  \n  \n  \n  This defines the mass of each atom type.  This can also be set via the\n  mass command in the input script.  This section cannot be\n  used for atom styles that define a mass for individual atoms -\n  e.g. atom_style sphere.\n  \n  MiddleBondTorsion Coeffs section:\n  \n  one line per dihedral type\n  line syntax: ID coeffs\n  ID = dihedral type (1-N)\n  coeffs = list of coeffs (see class 2 section of dihedral_coeff)\n  \n  \n  \n  Pair Coeffs section:\n  \n  one line per atom type\n  line syntax: ID coeffs\n  ID = atom type (1-N)\n  coeffs = list of coeffs\n  \n  \n  \n  example:\n  3 0.022 2.35197 0.022 2.35197\n  \n  \n  \n  \n  The number and meaning of the coefficients are specific to the defined\n  pair style.  See the pair_style and\n  pair_coeff commands for details.  Since pair\n  coefficients for types I != J are not specified, these will be\n  generated automatically by the pair style’s mixing rule.  See the\n  individual pair_style doc pages and the pair_modify mix command for details.  Pair coefficients can also\n  be set via the pair_coeff command in the input\n  script.\n  \n  PairIJ Coeffs section:\n  \n  one line per pair of atom types for all I,J with I <= J\n  line syntax: ID1 ID2 coeffs\n  ID1 = atom type I = 1-N\n  ID2 = atom type J = I-N, with I <= J\n  coeffs = list of coeffs\n  \n  \n  \n  examples:\n  3 3 0.022 2.35197 0.022 2.35197\n  3 5 0.022 2.35197 0.022 2.35197\n  \n  \n  \n  \n  This section must have N*(N+1)/2 lines where N = # of atom types.  The\n  number and meaning of the coefficients are specific to the defined\n  pair style.  See the pair_style and\n  pair_coeff commands for details.  Since pair\n  coefficients for types I != J are all specified, these values will\n  turn off the default mixing rule defined by the pair style.  See the\n  individual pair_style doc pages and the pair_modify mix command for details.  Pair coefficients can also\n  be set via the pair_coeff command in the input\n  script.\n  \n  Triangles section:\n  \n  one line per triangle\n  line syntax: atom-ID x1 y1 z1 x2 y2 z2 x3 y3 z3\n  atom-ID = ID of atom which is a line segment\n  x1,y1,z1 = 1st corner point\n  x2,y2,z2 = 2nd corner point\n  x3,y3,z3 = 3rd corner point\n  \n  \n  \n  example:\n  12 0.0 0.0 0.0 2.0 0.0 1.0 0.0 2.0 1.0\n  \n  \n  \n  \n  The Triangles section must appear if atom_style tri is used and any atoms are listed in the Atoms\n  section with a triangleflag = 1.  The number of lines should be\n  specified in the header section via the “triangles” keyword.\n  The 3 corner points are the corner points of the triangle.  The\n  ordering of the 3 points should be such that using a right-hand rule\n  to go from point1 to point2 to point3 gives an “outward” normal vector\n  to the face of the triangle.  I.e. normal = (c2-c1) x (c3-c1).  This\n  orientation may be important for defining some interactions.\n  The Triangles section must appear after the Atoms section.\n  \n  Velocities section:\n  \n  one line per atom\n  line syntax: depends on atom style\n  \n  \n  \n  \n  \n  \n  \n  all styles except those listed\n  atom-ID vx vy vz\n  \n  electron\n  atom-ID vx vy vz ervel\n  \n  ellipsoid\n  atom-ID vx vy vz lx ly lz\n  \n  sphere\n  atom-ID vx vy vz wx wy wz\n  \n  hybrid\n  atom-ID vx vy vz sub-style1 sub-style2 …\n  \n  \n  \n  where the keywords have these meanings:\n  vx,vy,vz = translational velocity of atom\n  lx,ly,lz = angular momentum of aspherical atom\n  wx,wy,wz = angular velocity of spherical atom\n  ervel = electron radial velocity (0 for fixed-core):ul\n  The velocity lines can appear in any order.  This section can only be\n  used after an Atoms section.  This is because the Atoms section\n  must have assigned a unique atom ID to each atom so that velocities\n  can be assigned to them.\n  Vx, vy, vz, and ervel are in units of velocity.  Lx, ly,\n  lz are in units of angular momentum (distance-velocity-mass).  Wx, Wy,\n  Wz are in units of angular velocity (radians/time).\n  For atom_style hybrid, following the 4 initial values (ID,vx,vy,vz),\n  specific values for each sub-style must be listed.  The order of the\n  sub-styles is the same as they were listed in the\n  atom_style command.  The sub-style specific values\n  are those that are not the 5 standard ones (ID,vx,vy,vz).  For\n  example, for the “sphere” sub-style, “wx”, “wy”, “wz” values would\n  appear.  These are listed in the same order they appear as listed\n  above.  Thus if\n  atom_style hybrid electron sphere\n  \n  \n  were used in the input script, each velocity line would have these\n  fields:\n  atom-ID vx vy vz ervel wx wy wz\n  \n  \n  Translational velocities can also be set by the\n  velocity command in the input script.\n  ",
    "syntax": "read_data file keyword args ...\n  \n  \n  \n  file = name of data file to read in\n  zero or more keyword/arg pairs may be appended\n  keyword = add or offset or shift or extra/atom/types or extra/bond/types or extra/angle/types or extra/dihedral/types or extra/improper/types or extra/bond/per/atom or extra/angle/per/atom or extra/dihedral/per/atom or extra/improper/per/atom or group or nocoeff or fix\n  add arg = append or IDoffset or IDoffset MOLoffset or merge\n    append = add new atoms with atom IDs appended to current IDs\n    IDoffset = add new atoms with atom IDs having IDoffset added\n    MOLoffset = add new atoms with molecule IDs having MOLoffset added (only when molecule IDs are enabled)\n    merge = add new atoms with their atom IDs (and molecule IDs) unchanged\n  offset args = toff boff aoff doff ioff\n    toff = offset to add to atom types\n    boff = offset to add to bond types\n    aoff = offset to add to angle types\n    doff = offset to add to dihedral types\n    ioff = offset to add to improper types\n  shift args = Sx Sy Sz\n    Sx,Sy,Sz = distance to shift atoms when adding to system (distance units)\n  extra/atom/types arg = # of extra atom types\n  extra/bond/types arg = # of extra bond types\n  extra/angle/types arg = # of extra angle types\n  extra/dihedral/types arg = # of extra dihedral types\n  extra/improper/types arg = # of extra improper types\n  extra/bond/per/atom arg = leave space for this many new bonds per atom\n  extra/angle/per/atom arg = leave space for this many new angles per atom\n  extra/dihedral/per/atom arg = leave space for this many new dihedrals per atom\n  extra/improper/per/atom arg = leave space for this many new impropers per atom\n  extra/special/per/atom arg = leave space for extra 1-2,1-3,1-4 interactions per atom\n  group args = groupID\n    groupID = add atoms in data file to this group\n  nocoeff = ignore force field parameters\n  fix args = fix-ID header-string section-string\n    fix-ID = ID of fix to process header lines and sections of data file\n    header-string = header lines containing this string will be passed to fix\n    section-string = section names with this string will be passed to fix\n  \n  \n  ",
    "examples": "read_data data.lj\n  read_data ../run7/data.polymer.gz\n  read_data data.protein fix mycmap crossterm CMAP\n  read_data data.water add append offset 3 1 1 1 1 shift 0.0 0.0 50.0\n  read_data data.water add merge 1 group solvent\n  \n  \n  ",
    "restrictions": "To read gzipped data files, you must compile LAMMPS with the\n  -DLAMMPS_GZIP option.  See the Build settings\n  doc page for details.\n  "
},
{
    "command": "read_dump",
    "description": "Read atom information from a dump file to overwrite the current atom\n  coordinates, and optionally the atom velocities and image flags and\n  the simulation box dimensions.  This is useful for restarting a run\n  from a particular snapshot in a dump file.  See the\n  read_restart and read_data\n  commands for alternative methods to do this.  Also see the\n  rerun command for a means of reading multiple snapshots\n  from a dump file.\n  Note that a simulation box must already be defined before using the\n  read_dump command.  This can be done by the\n  create_box, read_data, or\n  read_restart commands.  The read_dump command can\n  reset the simulation box dimensions, as explained below.\n  Also note that reading per-atom information from a dump snapshot is\n  limited to the atom coordinates, velocities and image flags, as\n  explained below.  Other atom properties, which may be necessary to run\n  a valid simulation, such as atom charge, or bond topology information\n  for a molecular system, are not read from (or even contained in) dump\n  files.  Thus this auxiliary information should be defined in the usual\n  way, e.g. in a data file read in by a read_data\n  command, before using the read_dump command, or by the set\n  command, after the dump snapshot is read.\n  \n  If the dump filename specified as file ends with “.gz”, the dump\n  file is read in gzipped format.  You cannot (yet) read a dump file\n  that was written in binary format with a “.bin” suffix.\n  You can read dump files that were written (in parallel) to multiple\n  files via the “%” wild-card character in the dump file name.  If any\n  specified dump file name contains a “%”, they must all contain it.\n  See the dump command for details.\n  The “%” wild-card character is only supported by the native format\n  for dump files, described next.\n  If reading parallel dump files, you must also use the nfile keyword\n  to tell LAMMPS how many parallel files exist, via its specified\n  Nfiles value.\n  The format of the dump file is selected through the format keyword.\n  If specified, it must be the last keyword used, since all remaining\n  arguments are passed on to the dump reader.  The native format is\n  for native LAMMPS dump files, written with a dump atom or\n  dump custom command.  The xyz format is for generic XYZ\n  formatted dump files.  These formats take no additional values.\n  The molfile format supports reading data through using the VMD\n  molfile plugin interface. This dump reader format is only available,\n  if the USER-MOLFILE package has been installed when compiling\n  LAMMPS.\n  The molfile format takes one or two additional values.  The style\n  value determines the file format to be used and can be any format that\n  the molfile plugins support, such as DCD or XYZ.  Note that DCD dump\n  files can be written by LAMMPS via the dump dcd command.\n  The path value specifies a list of directories which LAMMPS will\n  search for the molfile plugins appropriate to the specified style.\n  The syntax of the path value is like other search paths: it can\n  contain multiple directories separated by a colon (or semi-colon on\n  windows).  The path keyword is optional and defaults to “.”,\n  i.e. the current directory.\n  The adios format supports reading data that was written by the\n  dump adios command. The\n  entire dump is read in parallel across all the processes, dividing\n  the atoms evenly among the processes. The number of writers that\n  has written the dump file does not matter. Using the adios style for\n  dump and read_dump is a convenient way to dump all atoms from N\n  writers and read it back by M readers. If one is running two\n  LAMMPS instances concurrently where one dumps data and the other is\n  reading it with the rerun command, the timeout option can be specified\n  to wait on the reader side for the arrival of the requested step.\n  Support for other dump format readers may be added in the future.\n  \n  Global information is first read from the dump file, namely timestep\n  and box information.\n  The dump file is scanned for a snapshot with a timestamp that matches\n  the specified Nstep.  This means the LAMMPS timestep the dump file\n  snapshot was written on for the native or adios formats.\n  The list of timestamps available in an adios .bp file is stored in the\n  variable ntimestep:\n  $ bpls dump.bp -d ntimestep\n    uint64_t  ntimestep  5*scalar\n      (0)    0 50 100 150 200\n  \n  \n  Note that the xyz\n  and molfile formats do not store the timestep.  For these formats,\n  timesteps are numbered logically, in a sequential manner, starting\n  from 0.  Thus to access the 10th snapshot in an xyz or mofile\n  formatted dump file, use Nstep = 9.\n  The dimensions of the simulation box for the selected snapshot are\n  also read; see the box keyword discussion below.  For the native\n  format, an error is generated if the snapshot is for a triclinic box\n  and the current simulation box is orthogonal or vice versa.  A warning\n  will be generated if the snapshot box boundary conditions (periodic,\n  shrink-wrapped, etc) do not match the current simulation boundary\n  conditions, but the boundary condition information in the snapshot is\n  otherwise ignored.  See the “boundary” command for more details. The\n  adios reader does the same as the native format reader.\n  For the xyz format, no information about the box is available, so\n  you must set the box flag to no.  See details below.\n  For the molfile format, reading simulation box information is\n  typically supported, but the location of the simulation box origin is\n  lost and no explicit information about periodicity or\n  orthogonal/triclinic box shape is available.  The USER-MOLFILE package\n  makes a best effort to guess based on heuristics, but this may not\n  always work perfectly.\n  \n  Per-atom information from the dump file snapshot is then read from the\n  dump file snapshot.  This corresponds to the specified fields listed\n  in the read_dump command.  It is an error to specify a z-dimension\n  field, namely z, vz, or iz, for a 2d simulation.\n  For dump files in native format, each column of per-atom data has a\n  text label listed in the file.  A matching label for each field must\n  appear, e.g. the label “vy” for the field vy.  For the x, y, z\n  fields any of the following labels are considered a match:\n  x, xs, xu, xsu for field x\n  y, ys, yu, ysu for field y\n  z, zs, zu, zsu for field z\n  The meaning of xs (scaled), xu (unwrapped), and xsu (scaled and\n  unwrapped) is explained on the dump command doc page.\n  These labels are searched for in the list of column labels in the dump\n  file, in order, until a match is found.\n  The dump file must also contain atom IDs, with a column label of “id”.\n  If the add keyword is specified with a value of yes or keep, as\n  discussed below, the dump file must contain atom types, with a column\n  label of “type”.\n  If a column label you want to read from the dump file is not a match\n  to a specified field, the label keyword can be used to specify the\n  specific column label from the dump file to associate with that field.\n  An example is if a time-averaged coordinate is written to the dump\n  file via the fix ave/atom command.  The column\n  will then have a label corresponding to the fix-ID rather than “x” or\n  “xs”.  The label keyword can also be used to specify new column\n  labels for fields id and type.\n  For dump files in xyz format, only the x, y, and z fields are\n  supported.  The dump file does not store atom IDs, so these are\n  assigned consecutively to the atoms as they appear in the dump file,\n  starting from 1.  Thus you should insure that order of atoms is\n  consistent from snapshot to snapshot in the XYZ dump file.  See\n  the dump_modify sort command if the XYZ dump file\n  was written by LAMMPS.\n  For dump files in molfile format, the x, y, z, vx, vy, and\n  vz fields can be specified.  However, not all molfile formats store\n  velocities, or their respective plugins may not support reading of\n  velocities.  The molfile dump files do not store atom IDs, so these\n  are assigned consecutively to the atoms as they appear in the dump\n  file, starting from 1.  Thus you should insure that order of atoms are\n  consistent from snapshot to snapshot in the molfile dump file.\n  See the dump_modify sort command if the dump file\n  was written by LAMMPS.\n  The adios format supports all fields that the native format supports\n  except for the q charge field.\n  The list of fields stored in an adios .bp file is recorded in the attributes\n  columns (array of short strings) and columnstr (space-separated single string).\n  $ bpls -la dump.bp column*\n    string    columns            attr   = {\"id\", \"type\", \"x\", \"y\", \"z\", \"vx\", \"vy\", \"vz\"}\n    string    columnstr          attr   = \"id type x y z vx vy vz \"\n  \n  \n  \n  Information from the dump file snapshot is used to overwrite or\n  replace properties of the current system.  There are various options\n  for how this is done, determined by the specified fields and optional\n  keywords.\n  The timestep of the snapshot becomes the current timestep for the\n  simulation.  See the reset_timestep command if\n  you wish to change this after the dump snapshot is read.\n  If the box keyword is specified with a yes value, then the current\n  simulation box dimensions are replaced by the dump snapshot box\n  dimensions.  If the box keyword is specified with a no value, the\n  current simulation box is unchanged.\n  If the purge keyword is specified with a yes value, then all\n  current atoms in the system are deleted before any of the operations\n  invoked by the replace, trim, or add keywords take place.\n  If the replace keyword is specified with a yes value, then atoms\n  with IDs that are in both the current system and the dump snapshot\n  have their properties overwritten by field values.  If the replace\n  keyword is specified with a no value, atoms with IDs that are in\n  both the current system and the dump snapshot are not modified.\n  If the trim keyword is specified with a yes value, then atoms with\n  IDs that are in the current system but not in the dump snapshot are\n  deleted.  These atoms are unaffected if the trim keyword is\n  specified with a no value.\n  If the add keyword is specified with a no value (default), then\n  dump file atoms with IDs that are not in the current system are not\n  added to the system.  They are simply ignored.\n  If a yes value is specified, the atoms with new IDs are added to the\n  system but their atom IDs are not preserved.  Instead, after all the\n  atoms are added, new IDs are assigned to them in the same manner as is\n  described for the create_atoms command.  Basically\n  the largest existing atom ID in the system is identified, and all the\n  added atoms are assigned IDs that consecutively follow the largest ID.\n  If a keep value is specified, the atoms with new IDs are added to\n  the system and their atom IDs are preserved.  This may lead to\n  non-contiguous IDs for the combined system.\n  Note that atoms added via the add keyword will only have the\n  attributes read from the dump file due to the field arguments.  For\n  example, if x or y or z or q is not specified as a field, a\n  value of 0.0 is used for added atoms.  Added atoms must have an atom\n  type, so this value must appear in the dump file.\n  Any other attributes (e.g. charge or particle diameter for spherical\n  particles) will be set to default values, the same as if the\n  create_atoms command were used.\n  \n  Atom coordinates read from the dump file are first converted into\n  unscaled coordinates, relative to the box dimensions of the snapshot.\n  These coordinates are then be assigned to an existing or new atom in\n  the current simulation.  The coordinates will then be remapped to the\n  simulation box, whether it is the original box or the dump snapshot\n  box.  If periodic boundary conditions apply, this means the atom will\n  be remapped back into the simulation box if necessary.  If shrink-wrap\n  boundary conditions apply, the new coordinates may change the\n  simulation box dimensions.  If fixed boundary conditions apply, the\n  atom will be lost if it is outside the simulation box.\n  For native format dump files, the 3 xyz image flags for an atom in\n  the dump file are set to the corresponding values appearing in the\n  dump file if the ix, iy, iz fields are specified.  If not\n  specified, the image flags for replaced atoms are not changed and\n  image flags for new atoms are set to default values.  If coordinates\n  read from the dump file are in unwrapped format (e.g. xu) then the\n  image flags for read-in atoms are also set to default values.  The\n  remapping procedure described in the previous paragraph will then\n  change images flags for all atoms (old and new) if periodic boundary\n  conditions are applied to remap an atom back into the simulation box.\n  \n  Note\n  If you get a warning about inconsistent image flags after\n  reading in a dump snapshot, it means one or more pairs of bonded atoms\n  now have inconsistent image flags.  As discussed on the Errors common doc page this may or may not cause problems\n  for subsequent simulations.  One way this can happen is if you read\n  image flag fields from the dump file but do not also use the dump file\n  box parameters.\n  \n  LAMMPS knows how to compute unscaled and remapped coordinates for the\n  snapshot column labels discussed above, e.g. x, xs, xu, xsu.\n  If another column label is assigned to the x or y or z field via\n  the label keyword, e.g. for coordinates output by the fix ave/atom command, then LAMMPS needs to know whether\n  the coordinate information in the dump file is scaled and/or wrapped.\n  This can be set via the scaled and wrapped keywords.  Note that\n  the value of the scaled and wrapped keywords is ignored for fields\n  x or y or z if the label keyword is not used to assign a\n  column label to that field.\n  The scaled/unscaled and wrapped/unwrapped setting must be identical\n  for any of the x, y, z fields that are specified.  Thus you\n  cannot read xs and yu from the dump file.  Also, if the dump file\n  coordinates are scaled and the simulation box is triclinic, then all 3\n  of the x, y, z fields must be specified, since they are all\n  needed to generate absolute, unscaled coordinates.\n  ",
    "syntax": "read_dump file Nstep field1 field2 ... keyword values ...\n  \n  \n  \n  file = name of dump file to read\n  Nstep = snapshot timestep to read from file\n  one or more fields may be appended\n  field = x or y or z or vx or vy or vz or q or ix or iy or iz or fx or fy or fz\n    x,y,z = atom coordinates\n    vx,vy,vz = velocity components\n    q = charge\n    ix,iy,iz = image flags in each dimension\n    fx,fy,fz = force components\n  \n  zero or more keyword/value pairs may be appended\n  keyword = nfile or box or replace or purge or trim or add or label or scaled or wrapped or format\n  nfile value = Nfiles = how many parallel dump files exist\n  box value = yes or no = replace simulation box with dump box\n  replace value = yes or no = overwrite atoms with dump atoms\n  purge value = yes or no = delete all atoms before adding dump atoms\n  trim value = yes or no = trim atoms not in dump snapshot\n  add value = yes or keep or no = add new dump atoms to system\n  label value = field column\n    field = one of the listed fields or id or type\n    column = label on corresponding column in dump file\n  scaled value = yes or no = coords in dump file are scaled/unscaled\n  wrapped value = yes or no = coords in dump file are wrapped/unwrapped\n  format values = format of dump file, must be last keyword if used\n    native = native LAMMPS dump file\n    xyz = XYZ file\n    adios [timeout value] = dump file written by the dump adios command\n      timeout = specify waiting time for the arrival of the timestep when running concurrently.\n                The value is a float number and is interpreted in seconds.\n    molfile style path = VMD molfile plugin interface\n      style = dcd or xyz or others supported by molfile plugins\n      path = optional path for location of molfile plugins\n  \n  \n  ",
    "examples": "read_dump dump.file 5000 x y z\n  read_dump dump.xyz 5 x y z box no format xyz\n  read_dump dump.xyz 10 x y z box no format molfile xyz \"../plugins\"\n  read_dump dump.dcd 0 x y z box yes format molfile dcd\n  read_dump dump.file 1000 x y z vx vy vz box yes format molfile lammpstrj /usr/local/lib/vmd/plugins/LINUXAMD64/plugins/molfile\n  read_dump dump.file 5000 x y vx vy trim yes\n  read_dump ../run7/dump.file.gz 10000 x y z box yes\n  read_dump dump.xyz 10 x y z box no format molfile xyz ../plugins\n  read_dump dump.dcd 0 x y z format molfile dcd\n  read_dump dump.file 1000 x y z vx vy vz format molfile lammpstrj /usr/local/lib/vmd/plugins/LINUXAMD64/plugins/molfile\n  read_dump dump.bp 5000 x y z vx vy vz format adios\n  read_dump dump.bp 5000 x y z vx vy vz format adios timeout 60.0\n  \n  \n  ",
    "restrictions": "To read gzipped dump files, you must compile LAMMPS with the\n  -DLAMMPS_GZIP option.  See the Build settings\n  doc page for details.\n  The molfile dump file formats are part of the USER-MOLFILE package.\n  They are only enabled if LAMMPS was built with that packages.  See the\n  Build package doc page for more info.\n  To write and read adios .bp files, you must compile LAMMPS with the\n  USER-ADIOS package.\n  "
},
{
    "command": "read_restart",
    "description": "Read in a previously saved system configuration from a restart file.\n  This allows continuation of a previous run.  Details about what\n  information is stored (and not stored) in a restart file is given\n  below.  Basically this operation will re-create the simulation box\n  with all its atoms and their attributes as well as some related global\n  settings, at the point in time it was written to the restart file by a\n  previous simulation.  The simulation box will be partitioned into a\n  regular 3d grid of rectangular bricks, one per processor, based on the\n  number of processors in the current simulation and the settings of the\n  processors command.  The partitioning can later be\n  changed by the balance or fix balance commands.\n  \n  Note\n  Normally, restart files are written by the\n  restart or write_restart commands\n  so that all atoms in the restart file are inside the simulation box.\n  If this is not the case, the read_restart command will print an error\n  that atoms were “lost” when the file is read.  This error should be\n  reported to the LAMMPS developers so the invalid writing of the\n  restart file can be fixed.  If you still wish to use the restart file,\n  the optional remap flag can be appended to the read_restart command.\n  This should avoid the error, by explicitly remapping each atom back\n  into the simulation box, updating image flags for the atom\n  appropriately.\n  \n  Restart files are saved in binary format to enable exact restarts,\n  meaning that the trajectories of a restarted run will precisely match\n  those produced by the original run had it continued on.\n  Several things can prevent exact restarts due to round-off effects, in\n  which case the trajectories in the 2 runs will slowly diverge.  These\n  include running on a different number of processors or changing\n  certain settings such as those set by the newton or\n  processors commands.  LAMMPS will issue a warning in\n  these cases.\n  Certain fixes will not restart exactly, though they should provide\n  statistically similar results.  These include fix shake and fix langevin.\n  Certain pair styles will not restart exactly, though they should\n  provide statistically similar results.  This is because the forces\n  they compute depend on atom velocities, which are used at half-step\n  values every timestep when forces are computed.  When a run restarts,\n  forces are initially evaluated with a full-step velocity, which is\n  different than if the run had continued.  These pair styles include\n  granular pair styles, pair dpd, and\n  pair lubricate.\n  If a restarted run is immediately different than the run which\n  produced the restart file, it could be a LAMMPS bug, so consider\n  reporting it if you think the behavior is a bug.\n  Because restart files are binary, they may not be portable to other\n  machines.  In this case, you can use the -restart command-line switch to convert a restart file to a data file.\n  Similar to how restart files are written (see the\n  write_restart and restart\n  commands), the restart filename can contain two wild-card characters.\n  If a “*” appears in the filename, the directory is searched for all\n  filenames that match the pattern where “*” is replaced with a timestep\n  value.  The file with the largest timestep value is read in.  Thus,\n  this effectively means, read the latest restart file.  It’s useful if\n  you want your script to continue a run from where it left off.  See\n  the run command and its “upto” option for how to specify\n  the run command so it does not need to be changed either.\n  If a “%” character appears in the restart filename, LAMMPS expects a\n  set of multiple files to exist.  The restart and\n  write_restart commands explain how such sets are\n  created.  Read_restart will first read a filename where “%” is\n  replaced by “base”.  This file tells LAMMPS how many processors\n  created the set and how many files are in it.  Read_restart then reads\n  the additional files.  For example, if the restart file was specified\n  as save.% when it was written, then read_restart reads the files\n  save.base, save.0, save.1, … save.P-1, where P is the number of\n  processors that created the restart file.\n  Note that P could be the total number of processors in the previous\n  simulation, or some subset of those processors, if the fileper or\n  nfile options were used when the restart file was written; see the\n  restart and write_restart commands\n  for details.  The processors in the current LAMMPS simulation share\n  the work of reading these files; each reads a roughly equal subset of\n  the files.  The number of processors which created the set can be\n  different the number of processors in the current LAMMPS simulation.\n  This can be a fast mode of input on parallel machines that support\n  parallel I/O.\n  A restart file can also be read in parallel as one large binary file\n  via the MPI-IO library, assuming it was also written with MPI-IO.\n  MPI-IO is part of the MPI standard for versions 2.0 and above.  Using\n  MPI-IO requires two steps.  First, build LAMMPS with its MPIIO package\n  installed, e.g.\n  make yes-mpiio    # installs the MPIIO package\n  make mpi          # build LAMMPS for your platform\n  \n  \n  Second, use a restart filename which contains “.mpiio”.  Note that it\n  does not have to end in “.mpiio”, just contain those characters.\n  Unlike MPI-IO dump files, a particular restart file must be both\n  written and read using MPI-IO.\n  \n  Here is the list of information included in a restart file, which\n  means these quantities do not need to be re-specified in the input\n  script that reads the restart file, though you can redefine many of\n  these settings after the restart file is read.\n  \n  units\n  newton bond (see discussion of newton command below)\n  atom style and atom_modify settings id, map, sort\n  comm style and comm_modify settings mode, cutoff, vel\n  timestep\n  simulation box size and shape and boundary settings\n  atom group definitions\n  per-type atom settings such as mass\n  per-atom attributes including their group assignments and molecular topology attributes (bonds, angles, etc)\n  force field styles (pair, bond, angle, etc)\n  force field coefficients (pair, bond, angle, etc) in some cases (see below)\n  pair_modify settings, except the compute option\n  special_bonds settings\n  \n  Here is a list of information not stored in a restart file, which\n  means you must re-issue these commands in your input script, after\n  reading the restart file.\n  \n  newton pair (see discussion of newton command below)\n  fix commands (see below)\n  compute commands (see below)\n  variable commands\n  region commands\n  neighbor list criteria including neigh_modify settings\n  kspace_style and kspace_modify settings\n  info for thermodynamic, dump, or restart output\n  \n  The newton command has two settings, one for pairwise\n  interactions, the other for bonded.  Both settings are stored in the\n  restart file.  For the bond setting, the value in the file will\n  overwrite the current value (at the time the read_restart command is\n  issued) and warn if the two values are not the same and the current\n  value is not the default.  For the pair setting, the value in the file\n  will not overwrite the current value (so that you can override the\n  previous run’s value), but a warning is issued if the two values are\n  not the same and the current value is not the default.\n  Note that some force field styles (pair, bond, angle, etc) do not\n  store their coefficient info in restart files.  Typically these are\n  many-body or tabulated potentials which read their parameters from\n  separate files.  In these cases you will need to re-specify the\n  pair_coeff, bond_coeff, etc\n  commands in your restart input script.  The doc pages for individual\n  force field styles mention if this is the case.  This is also true of\n  pair_style hybrid (bond hybrid, angle hybrid, etc)\n  commands; they do not store coefficient info.\n  As indicated in the above list, the fixes used for a\n  simulation are not stored in the restart file.  This means the new\n  input script should specify all fixes it will use.  However, note that\n  some fixes store an internal “state” which is written to the restart\n  file.  This allows the fix to continue on with its calculations in a\n  restarted simulation.  To re-enable such a fix, the fix command in the\n  new input script must be of the same style and use the same fix-ID as\n  was used in the input script that wrote the restart file.\n  If a match is found, LAMMPS prints a message indicating that the fix\n  is being re-enabled.  If no match is found before the first run or\n  minimization is performed by the new script, the “state” information\n  for the saved fix is discarded.  At the time the discard occurs,\n  LAMMPS will also print a list of fixes for which the information is\n  being discarded.  See the doc pages for individual fixes for info on\n  which ones can be restarted in this manner.  Note that fixes which are\n  created internally by other LAMMPS commands (computes, fixes, etc)\n  will have style names which are all-capitalized, and IDs which are\n  generated internally.\n  Likewise, the computes used for a simulation are not stored\n  in the restart file.  This means the new input script should specify\n  all computes it will use.  However, some computes create a fix\n  internally to store “state” information that persists from timestep to\n  timestep.  An example is the compute msd command\n  which uses a fix to store a reference coordinate for each atom, so\n  that a displacement can be calculated at any later time.  If the\n  compute command in the new input script uses the same compute-ID and\n  group-ID as was used in the input script that wrote the restart file,\n  then it will create the same fix in the restarted run.  This means the\n  re-created fix will be re-enabled with the stored state information as\n  described in the previous paragraph, so that the compute can continue\n  its calculations in a consistent manner.\n  \n  Note\n  There are a handful of commands which can be used before or\n  between runs which may require a system initialization.  Examples\n  include the “balance”, “displace_atoms”, “delete_atoms”, “set” (some\n  options), and “velocity” (some options) commands.  This is because\n  they can migrate atoms to new processors.  Thus they will also discard\n  unused “state” information from fixes.  You will know the discard has\n  occurred because a list of discarded fixes will be printed to the\n  screen and log file, as explained above.  This means that if you wish\n  to retain that info in a restarted run, you must re-specify the\n  relevant fixes and computes (which create fixes) before those commands\n  are used.\n  \n  Some pair styles, like the granular pair styles, also\n  use a fix to store “state” information that persists from timestep to\n  timestep.  In the case of granular potentials, it is contact\n  information between pairs of touching particles.  This info will also\n  be re-enabled in the restart script, assuming you re-use the same\n  granular pair style.\n  LAMMPS allows bond interactions (angle, etc) to be turned off or\n  deleted in various ways, which can affect how their info is stored in\n  a restart file.\n  If bonds (angles, etc) have been turned off by the fix shake or delete_bonds command,\n  their info will be written to a restart file as if they are turned on.\n  This means they will need to be turned off again in a new run after\n  the restart file is read.\n  Bonds that are broken (e.g. by a bond-breaking potential) are written\n  to the restart file as broken bonds with a type of 0.  Thus these\n  bonds will still be broken when the restart file is read.\n  Bonds that have been broken by the fix bond/break command have disappeared from the\n  system.  No information about these bonds is written to the restart\n  file.\n  ",
    "syntax": "read_restart file flag\n  \n  \n  \n  file = name of binary restart file to read in\n  flag = remap (optional)\n  \n  ",
    "examples": "read_restart save.10000\n  read_restart save.10000 remap\n  read_restart restart.*\n  read_restart restart.*.mpiio\n  read_restart poly.*.% remap\n  \n  \n  ",
    "restrictions": "To write and read restart files in parallel with MPI-IO, the MPIIO\n  package must be installed.\n  "
},
{
    "command": "region",
    "description": "This command defines a geometric region of space.  Various other\n  commands use regions.  For example, the region can be filled with\n  atoms via the create_atoms command.  Or a bounding\n  box around the region, can be used to define the simulation box via\n  the create_box command.  Or the atoms in the region\n  can be identified as a group via the group command, or\n  deleted via the delete_atoms command.  Or the\n  surface of the region can be used as a boundary wall via the fix wall/region command.\n  Commands which use regions typically test whether an atom’s position\n  is contained in the region or not.  For this purpose, coordinates\n  exactly on the region boundary are considered to be interior to the\n  region.  This means, for example, for a spherical region, an atom on\n  the sphere surface would be part of the region if the sphere were\n  defined with the side in keyword, but would not be part of the\n  region if it were defined using the side out keyword.  See more\n  details on the side keyword below.\n  Normally, regions in LAMMPS are “static”, meaning their geometric\n  extent does not change with time.  If the move or rotate keyword\n  is used, as described below, the region becomes “dynamic”, meaning\n  it’s location or orientation changes with time.  This may be useful,\n  for example, when thermostatting a region, via the compute temp/region\n  command, or when the fix wall/region command uses a region surface as\n  a bounding wall on particle motion, i.e. a rotating container.\n  The delete style removes the named region.  Since there is little\n  overhead to defining extra regions, there is normally no need to do\n  this, unless you are defining and discarding large numbers of regions\n  in your input script.\n  The lo/hi values for block or cone or cylinder or prism styles\n  can be specified as EDGE or INF.  EDGE means they extend all the way\n  to the global simulation box boundary.  Note that this is the current\n  box boundary; if the box changes size during a simulation, the region\n  does not.  INF means a large negative or positive number (1.0e20), so\n  it should encompass the simulation box even if it changes size.  If a\n  region is defined before the simulation box has been created (via\n  create_box or read_data or\n  read_restart commands), then an EDGE or INF\n  parameter cannot be used.  For a prism region, a non-zero tilt\n  factor in any pair of dimensions cannot be used if both the lo/hi\n  values in either of those dimensions are INF.  E.g. if the xy tilt is\n  non-zero, then xlo and xhi cannot both be INF, nor can ylo and yhi.\n  \n  Note\n  Regions in LAMMPS do not get wrapped across periodic boundaries,\n  as specified by the boundary command.  For example, a\n  spherical region that is defined so that it overlaps a periodic\n  boundary is not treated as 2 half-spheres, one on either side of the\n  simulation box.\n  \n  \n  Note\n  Regions in LAMMPS are always 3d geometric objects, regardless of\n  whether the dimension of a simulation is 2d or 3d.\n  Thus when using regions in a 2d simulation, you should be careful to\n  define the region so that its intersection with the 2d x-y plane of\n  the simulation has the 2d geometric extent you want.\n  \n  For style cone, an axis-aligned cone is defined which is like a\n  cylinder except that two different radii (one at each end) can be\n  defined.  Either of the radii (but not both) can be 0.0.\n  For style cone and cylinder, the c1,c2 params are coordinates in\n  the 2 other dimensions besides the cylinder axis dimension.  For dim =\n  x, c1/c2 = y/z; for dim = y, c1/c2 = x/z; for dim = z, c1/c2 = x/y.\n  Thus the third example above specifies a cylinder with its axis in the\n  y-direction located at x = 2.0 and z = 3.0, with a radius of 5.0, and\n  extending in the y-direction from -5.0 to the upper box boundary.\n  For style plane, a plane is defined which contain the point\n  (px,py,pz) and has a normal vector (nx,ny,nz).  The normal vector does\n  not have to be of unit length.  The “inside” of the plane is the\n  half-space in the direction of the normal vector; see the discussion\n  of the side option below.\n  For style prism, a parallelepiped is defined (it’s too hard to spell\n  parallelepiped in an input script!).  The parallelepiped has its\n  “origin” at (xlo,ylo,zlo) and is defined by 3 edge vectors starting\n  from the origin given by A = (xhi-xlo,0,0); B = (xy,yhi-ylo,0); C =\n  (xz,yz,zhi-zlo).  Xy,xz,yz can be 0.0 or positive or negative values\n  and are called “tilt factors” because they are the amount of\n  displacement applied to faces of an originally orthogonal box to\n  transform it into the parallelepiped.\n  A prism region that will be used with the create_box\n  command to define a triclinic simulation box must have tilt factors\n  (xy,xz,yz) that do not skew the box more than half the distance of\n  corresponding the parallel box length.  For example, if xlo = 2 and\n  xhi = 12, then the x box length is 10 and the xy tilt factor must be\n  between -5 and 5.  Similarly, both xz and yz must be between\n  -(xhi-xlo)/2 and +(yhi-ylo)/2.  Note that this is not a limitation,\n  since if the maximum tilt factor is 5 (as in this example), then\n  configurations with tilt = …, -15, -5, 5, 15, 25, … are all\n  geometrically equivalent.\n  The radius value for style sphere and cylinder can be specified\n  as an equal-style variable.  If the value is a\n  variable, it should be specified as v_name, where name is the variable\n  name.  In this case, the variable will be evaluated each timestep, and\n  its value used to determine the radius of the region. For style sphere\n  also the x-, y-, and z- coordinate of the center of the sphere and for\n  style cylinder the two center positions c1 and c2 for the location of\n  the cylinder axes can be a variable with the same kind of effect and\n  requirements than for the radius.\n  Equal-style variables can specify formulas with various mathematical\n  functions, and include thermo_style command\n  keywords for the simulation box parameters and timestep and elapsed\n  time.  Thus it is easy to specify a time-dependent radius or have\n  a time dependent position of the sphere or cylinder region.\n  See the Howto tricilinc doc page for a\n  geometric description of triclinic boxes, as defined by LAMMPS, and\n  how to transform these parameters to and from other commonly used\n  triclinic representations.\n  The union style creates a region consisting of the volume of all the\n  listed regions combined.  The intersect style creates a region\n  consisting of the volume that is common to all the listed regions.\n  \n  Note\n  The union and intersect regions operate by invoking methods\n  from their list of sub-regions.  Thus you cannot delete the\n  sub-regions after defining a union or intersection region.\n  \n  \n  The side keyword determines whether the region is considered to be\n  inside or outside of the specified geometry.  Using this keyword in\n  conjunction with union and intersect regions, complex geometries\n  can be built up.  For example, if the interior of two spheres were\n  each defined as regions, and a union style with side = out was\n  constructed listing the region-IDs of the 2 spheres, the resulting\n  region would be all the volume in the simulation box that was outside\n  both of the spheres.\n  The units keyword determines the meaning of the distance units used\n  to define the region for any argument above listed as having distance\n  units.  It also affects the scaling of the velocity vector specified\n  with the vel keyword, the amplitude vector specified with the\n  wiggle keyword, and the rotation point specified with the rotate\n  keyword, since they each involve a distance metric.\n  A box value selects standard distance units as defined by the\n  units command, e.g. Angstroms for units = real or metal.\n  A lattice value means the distance units are in lattice spacings.\n  The lattice command must have been previously used to\n  define the lattice spacings which are used as follows:\n  \n  For style block, the lattice spacing in dimension x is applied to\n  xlo and xhi, similarly the spacings in dimensions y,z are applied to\n  ylo/yhi and zlo/zhi.\n  For style cone, the lattice spacing in argument dim is applied to\n  lo and hi.  The spacings in the two radial dimensions are applied to\n  c1 and c2.  The two cone radii are scaled by the lattice\n  spacing in the dimension corresponding to c1.\n  For style cylinder, the lattice spacing in argument dim is applied\n  to lo and hi.  The spacings in the two radial dimensions are applied\n  to c1 and c2.  The cylinder radius is scaled by the lattice\n  spacing in the dimension corresponding to c1.\n  For style plane, the lattice spacing in dimension x is applied to\n  px and nx, similarly the spacings in dimensions y,z are applied to\n  py/ny and pz/nz.\n  For style prism, the lattice spacing in dimension x is applied to\n  xlo and xhi, similarly for ylo/yhi and zlo/zhi.  The lattice spacing\n  in dimension x is applied to xy and xz, and the spacing in dimension y\n  to yz.\n  For style sphere, the lattice spacing in dimensions x,y,z are\n  applied to the sphere center x,y,z.  The spacing in dimension x is\n  applied to the sphere radius.\n  \n  \n  If the move or rotate keywords are used, the region is “dynamic”,\n  meaning its location or orientation changes with time.  These keywords\n  cannot be used with a union or intersect style region.  Instead,\n  the keywords should be used to make the individual sub-regions of the\n  union or intersect region dynamic.  Normally, each sub-region\n  should be “dynamic” in the same manner (e.g. rotate around the same\n  point), though this is not a requirement.\n  The move keyword allows one or more equal-style variables to be used to specify the x,y,z displacement\n  of the region, typically as a function of time.  A variable is\n  specified as v_name, where name is the variable name.  Any of the\n  three variables can be specified as NULL, in which case no\n  displacement is calculated in that dimension.\n  Note that equal-style variables can specify formulas with various\n  mathematical functions, and include thermo_style\n  command keywords for the simulation box parameters and timestep and\n  elapsed time.  Thus it is easy to specify a region displacement that\n  change as a function of time or spans consecutive runs in a continuous\n  fashion.  For the latter, see the start and stop keywords of the\n  run command and the elaplong keyword of thermo_style custom for details.\n  For example, these commands would displace a region from its initial\n  position, in the positive x direction, effectively at a constant\n  velocity:\n  variable dx equal ramp(0,10)\n  region 2 sphere 10.0 10.0 0.0 5 move v_dx NULL NULL\n  \n  \n  Note that the initial displacement is 0.0, though that is not required.\n  Either of these variables would “wiggle” the region back and forth in\n  the y direction:\n  variable dy equal swiggle(0,5,100)\n  variable dysame equal 5*sin(2*PI*elaplong*dt/100)\n  region 2 sphere 10.0 10.0 0.0 5 move NULL v_dy NULL\n  \n  \n  The rotate keyword rotates the region around a rotation axis R =\n  (Rx,Ry,Rz) that goes through a point P = (Px,Py,Pz).  The rotation\n  angle is calculated, presumably as a function of time, by a variable\n  specified as v_theta, where theta is the variable name.  The variable\n  should generate its result in radians.  The direction of rotation for\n  the region around the rotation axis is consistent with the right-hand\n  rule: if your right-hand thumb points along R, then your fingers\n  wrap around the axis in the direction of rotation.\n  The move and rotate keywords can be used together.  In this case,\n  the displacement specified by the move keyword is applied to the P\n  point of the rotate keyword.\n  \n  The open keyword can be used (multiple times) to indicate that one\n  or more faces of the region are ignored for purposes of particle/wall\n  interactions.  This keyword is only relevant for regions used by the\n  fix wall/region and fix wall/gran/region commands.  It can be used\n  to create “open” containers where only some of the region faces are\n  walls.  For example, a funnel can be created with a cone style\n  region that has an open face at the smaller radius for particles to\n  flow out, or at the larger radius for pouring particles into the cone,\n  or both.\n  Note that using the open keyword partly overrides the side\n  keyword, since both exterior and interior surfaces of an open region\n  are tested for particle contacts.  The exception to this is a union\n  or intersect region which includes an open sub-region.  In that case\n  the side keyword is still used to define the union/intersect region\n  volume, and the open settings are only applied to the individual\n  sub-regions that use them.\n  The indices specified as part of the open keyword have the following\n  meanings:\n  For style block, indices 1-6 correspond to the xlo, xhi, ylo, yhi,\n  zlo, zhi surfaces of the block.  I.e. 1 is the yz plane at x = xlo, 2\n  is the yz-plane at x = xhi, 3 is the xz plane at y = ylo, 4 is the xz\n  plane at y = yhi, 5 is the xy plane at z = zlo, 6 is the xy plane at z\n  = zhi).  In the second-to-last example above, the region is a box open\n  at both xy planes.\n  For style prism, values 1-6 have the same mapping as for style\n  block.  I.e. in an untilted prism, open indices correspond to\n  the xlo, xhi, ylo, yhi, zlo, zhi surfaces.\n  For style cylinder, index 1 corresponds to the flat end cap at the\n  low coordinate along the cylinder axis, index 2 corresponds to the\n  high-coordinate flat end cap along the cylinder axis, and index 3 is\n  the curved cylinder surface.  For example, a cylinder region with\n  open 1 open 2 keywords will be open at both ends (e.g. a section of\n  pipe), regardless of the cylinder orientation.\n  For style cone, the mapping is the same as for style cylinder.\n  Index 1 is the low-coordinate flat end cap, index 2 is the\n  high-coordinate flat end cap, and index 3 is the curved cone surface.\n  In the last example above, a cone region is defined along the z-axis\n  that is open at the zlo value (e.g. for use as a funnel).\n  For all other styles, the open keyword is ignored.  As indicated\n  above, this includes the intersect and union regions, though their\n  sub-regions can be defined with the open keyword.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  The code using the region (such as a fix or compute) must also be supported\n  by Kokkos or no acceleration will occur. Currently, only block style\n  regions are supported by Kokkos.\n  These accelerated styles are part of the Kokkos package.  They are\n  only enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "region ID style args keyword arg ...\n  \n  \n  \n  ID = user-assigned name for the region\n  style = delete or block or cone or cylinder or plane or prism or sphere or union or intersect\n  delete = no args\n  block args = xlo xhi ylo yhi zlo zhi\n    xlo,xhi,ylo,yhi,zlo,zhi = bounds of block in all dimensions (distance units)\n  cone args = dim c1 c2 radlo radhi lo hi\n    dim = x or y or z = axis of cone\n    c1,c2 = coords of cone axis in other 2 dimensions (distance units)\n    radlo,radhi = cone radii at lo and hi end (distance units)\n    lo,hi = bounds of cone in dim (distance units)\n  cylinder args = dim c1 c2 radius lo hi\n    dim = x or y or z = axis of cylinder\n    c1,c2 = coords of cylinder axis in other 2 dimensions (distance units)\n    radius = cylinder radius (distance units)\n      c1,c2, and radius can be a variable (see below)\n    lo,hi = bounds of cylinder in dim (distance units)\n  plane args = px py pz nx ny nz\n    px,py,pz = point on the plane (distance units)\n    nx,ny,nz = direction normal to plane (distance units)\n  prism args = xlo xhi ylo yhi zlo zhi xy xz yz\n    xlo,xhi,ylo,yhi,zlo,zhi = bounds of untilted prism (distance units)\n    xy = distance to tilt y in x direction (distance units)\n    xz = distance to tilt z in x direction (distance units)\n    yz = distance to tilt z in y direction (distance units)\n  sphere args = x y z radius\n    x,y,z = center of sphere (distance units)\n    radius = radius of sphere (distance units)\n      x,y,z, and radius can be a variable (see below)\n  union args = N reg-ID1 reg-ID2 ...\n    N = # of regions to follow, must be 2 or greater\n    reg-ID1,reg-ID2, ... = IDs of regions to join together\n  intersect args = N reg-ID1 reg-ID2 ...\n    N = # of regions to follow, must be 2 or greater\n    reg-ID1,reg-ID2, ... = IDs of regions to intersect\n  \n  zero or more keyword/arg pairs may be appended\n  keyword = side or units or move or rotate or open\n  side value = in or out\n    in = the region is inside the specified geometry\n    out = the region is outside the specified geometry\n  units value = lattice or box\n    lattice = the geometry is defined in lattice units\n    box = the geometry is defined in simulation box units\n  move args = v_x v_y v_z\n    v_x,v_y,v_z = equal-style variables for x,y,z displacement of region over time\n  rotate args = v_theta Px Py Pz Rx Ry Rz\n    v_theta = equal-style variable for rotaton of region over time (in radians)\n    Px,Py,Pz = origin for axis of rotation (distance units)\n    Rx,Ry,Rz = axis of rotation vector\n  open value = integer from 1-6 corresponding to face index (see below)\n  \n  accelerated styles (with same args) = block/kk\n  \n  ",
    "examples": "region 1 block -3.0 5.0 INF 10.0 INF INF\n  region 2 sphere 0.0 0.0 0.0 5 side out\n  region void cylinder y 2 3 5 -5.0 EDGE units box\n  region 1 prism 0 10 0 10 0 10 2 0 0\n  region outside union 4 side1 side2 side3 side4\n  region 2 sphere 0.0 0.0 0.0 5 side out move v_left v_up NULL\n  region openbox block 0 10 0 10 0 10 open 5 open 6 units box\n  region funnel cone z 10 10 2 5 0 10 open 1 units box\n  \n  \n  ",
    "restrictions": "A prism cannot be of 0.0 thickness in any dimension; use a small z\n  thickness for 2d simulations.  For 2d simulations, the xz and yz\n  parameters must be 0.0.\n  "
},
{
    "command": "replicate",
    "description": "Replicate the current simulation one or more times in each dimension.\n  For example, replication factors of 2,2,2 will create a simulation\n  with 8x as many atoms by doubling the simulation domain in each\n  dimension.  A replication factor of 1 in a dimension leaves the\n  simulation domain unchanged.  When the new simulation box is created\n  it is also partitioned into a regular 3d grid of rectangular bricks,\n  one per processor, based on the number of processors being used and\n  the settings of the processors command.  The\n  partitioning can later be changed by the balance or\n  fix balance commands.\n  All properties of the atoms are replicated, including their\n  velocities, which may or may not be desirable.  New atom IDs are\n  assigned to new atoms, as are molecule IDs.  Bonds and other topology\n  interactions are created between pairs of new atoms as well as between\n  old and new atoms.  This is done by using the image flag for each atom\n  to “unwrap” it out of the periodic box before replicating it.\n  This means that any molecular bond you specify in the original data\n  file that crosses a periodic boundary should be between two atoms with\n  image flags that differ by 1.  This will allow the bond to be\n  unwrapped appropriately.\n  The optional keyword bbox uses a bounding box to only check atoms in\n  replicas that overlap with a processor’s sub-domain when assigning\n  atoms to processors.  It typically results in a substantial speedup\n  when using the replicate command on a large number of processors.  It\n  does require temporary use of more memory, specifically that each\n  processor can store all atoms in the entire system before it is\n  replicated.\n  ",
    "syntax": "replicate nx ny nz keyword\n  nx,ny,nz = replication factors in each dimension\n  \n  optional keyword = bbox\n  bbox = only check atoms in replicas that overlap with a processor's sub-domain\n  \n  \n  ",
    "examples": "replicate 2 3 2\n  \n  \n  ",
    "restrictions": "A 2d simulation cannot be replicated in the z dimension.\n  If a simulation is non-periodic in a dimension, care should be used\n  when replicating it in that dimension, as it may put atoms nearly on\n  top of each other.\n  \n  Note\n  You cannot use the replicate command on a system which has a\n  molecule that spans the box and is bonded to itself across a periodic\n  boundary, so that the molecule is effectively a loop.  A simple\n  example would be a linear polymer chain that spans the simulation box\n  and bonds back to itself across the periodic boundary.  More realistic\n  examples would be a CNT (meant to be an infinitely long CNT) or a\n  graphene sheet or a bulk periodic crystal where there are explicit\n  bonds specified between near neighbors.  (Note that this only applies\n  to systems that have permanent bonds as specified in the data file.  A\n  CNT that is just atoms modeled with the AIREBO potential has no such permanent bonds, so it can be\n  replicated.)  The reason replication does not work with those systems\n  is that the image flag settings described above cannot be made\n  consistent.  I.e. it is not possible to define images flags so that\n  when every pair of bonded atoms is unwrapped (using the image flags),\n  they will be close to each other.  The only way the replicate command\n  could work in this scenario is for it to break a bond, insert more\n  atoms, and re-connect the loop for the larger simulation box.  But it\n  is not clever enough to do this.  So you will have to construct a\n  larger version of your molecule as a pre-processing step and input a\n  new data file to LAMMPS.\n  \n  If the current simulation was read in from a restart file (before a\n  run is performed), there must not be any fix information stored in\n  the file for individual atoms.  Similarly, no fixes can be defined at\n  the time the replicate command is used that require vectors of atom\n  information to be stored.  This is because the replicate command does\n  not know how to replicate that information for new atoms it creates.\n  To work around this restriction, restart files may be converted into\n  data files and fixes may be undefined via the unfix\n  command before and redefined after the replicate command.\n  Related commands: none\n  Default: none\n  "
},
{
    "command": "rerun",
    "description": "Perform a pseudo simulation run where atom information is read one\n  snapshot at a time from a dump file(s), and energies and forces are\n  computed on the shapshot to produce thermodynamic or other output.\n  This can be useful in the following kinds of scenarios, after an\n  initial simulation produced the dump file:\n  \n  Compute the energy and forces of snapshots using a different potential.\n  Calculate one or more diagnostic quantities on the snapshots that\n  were not computed in the initial run.  These can also be computed with\n  settings not used in the initial run, e.g. computing an RDF via the\n  compute rdf command with a longer cutoff than was\n  used initially.\n  Calculate the portion of per-atom forces resulting from a subset of\n  the potential.  E.g. compute only Coulombic forces.  This can be done\n  by only defining only a Coulombic pair style in the rerun script.\n  Doing this in the original script would result in different (bad)\n  dynamics.\n  \n  Conceptually, using the rerun command is like running an input script\n  that has a loop in it (see the next and jump\n  commands).  Each iteration of the loop reads one snapshot from the\n  dump file via the read_dump command, sets the\n  timestep to the appropriate value, and then invokes a run\n  command for zero timesteps to simply compute energy and forces, and\n  any other thermodynamic output or diagnostic info\n  you have defined.  This computation also invokes any fixes you have\n  defined that apply constraints to the system, such as fix shake or fix indent.\n  Note that a simulation box must already be defined before using the\n  rerun command.  This can be done by the create_box,\n  read_data, or read_restart\n  commands.\n  Also note that reading per-atom information from dump snapshots is\n  limited to the atom coordinates, velocities and image flags as\n  explained in the read_dump command.  Other atom\n  properties, which may be necessary to compute energies and forces,\n  such as atom charge, or bond topology information for a molecular\n  system, are not read from (or even contained in) dump files.  Thus\n  this auxiliary information should be defined in the usual way, e.g. in\n  a data file read in by a read_data command, before\n  using the rerun command.\n  Also note that the frequency of thermodynamic or dump output from the\n  rerun simulation will depend on settings made in the rerun script, the\n  same as for output from any LAMMPS simulation.  See further info below\n  as to what that means if the timesteps for snapshots read from dump\n  files do not match the specified output frequency.\n  \n  If more than one dump file is specified, the dump files are read one\n  after the other.  It is assumed that snapshot timesteps will be in\n  ascending order.  If a snapshot is encountered that is not in\n  ascending order, it will skip the snapshot until it reads one that is.\n  This allows skipping of a duplicate snapshot (same timestep),\n  e.g. that appeared at the end of one file and beginning of the next.\n  However if you specify a series of dump files in an incorrect order\n  (with respect to the timesteps they contain), you may skip large\n  numbers of snapshots\n  Note that the dump files specified as part of the dump keyword can be\n  parallel files, i.e. written as multiple files either per processor\n  and/or per snapshot.  If that is the case they will also be read in\n  parallel which can make the rerun command operate dramatically faster\n  for large systems.  See the doc page for the read_dump and dump commands which describe how to read\n  and write parallel dump files.\n  The first, last, every, skip keywords determine which\n  snapshots are read from the dump file(s).  Snapshots are skipped until\n  they have a timestamp >= Nfirst.  When a snapshot with a timestamp >\n  Nlast is encountered, the rerun command finishes.  Note below that\n  the defaults for first and last are to read all snapshots.  If the\n  every keyword is set to a value > 0, then only snapshots with\n  timestamps that are a multiple of Nevery are read (the first\n  snapshot is always read).  If Nevery = 0, then this criterion is\n  ignored, i.e. every snapshot is read that meets the other criteria.\n  If the skip keyword is used, then after the first snapshot is read,\n  every Nth snapshot is read, where N = Nskip.  E.g. if Nskip = 3,\n  then only 1 out of every 3 snapshots is read, assuming the snapshot\n  timestamp is also consistent with the other criteria.\n  The start and stop keywords do not affect which snapshots are read\n  from the dump file(s).  Rather, they have the same meaning that they\n  do for the run command.  They only need to be defined if\n  (a) you are using a fix command that changes some value\n  over time, and (b) you want the reference point for elapsed time (from\n  start to stop) to be different than the first and last settings.\n  See the doc page for individual fixes to see which ones can be used\n  with the start/stop keywords.  Note that if you define neither of\n  the start/stop or first/last keywords, then LAMMPS treats the\n  pseudo run as going from 0 to a huge value (effectively infinity).\n  This means that any quantity that a fix scales as a fraction of\n  elapsed time in the run, will essentially remain at its initial value.\n  Also note that an error will occur if you read a snapshot from the\n  dump file with a timestep value larger than the stop setting you\n  have specified.\n  The dump keyword is required and must be the last keyword specified.\n  Its arguments are passed internally to the read_dump\n  command.  The first argument following the dump keyword should be\n  the field1 argument of the read_dump command.  See\n  the read_dump doc page for details on the various\n  options it allows for extracting information from the dump file\n  snapshots, and for using that information to alter the LAMMPS\n  simulation.\n  \n  In general, a LAMMPS input script that uses a rerun command can\n  include and perform all the usual operations of an input script that\n  uses the run command.  There are a few exceptions and\n  points to consider, as discussed here.\n  Fixes that perform time integration, such as fix nve or\n  fix npt are not invoked, since no time integration is\n  performed.  Fixes that perturb or constrain the forces on atoms will\n  be invoked, just as they would during a normal run.  Examples are fix indent and fix langevin.  So you\n  should think carefully as to whether that makes sense for the manner\n  in which you are reprocessing the dump snapshots.\n  If you only want the rerun script to perform an analysis that does\n  not involve pair interactions, such as use compute msd to calculated\n  displacements over time, you do not need to define a pair style, which may also mean neighbor lists will not\n  need to be calculated which saves time.  The comm_modify cutoff command can also be used to insure ghost\n  atoms are acquired from far enough away for operations like bond and\n  angle evaluations, if no pair style is being used.\n  Every time a snapshot is read, the timestep for the simulation is\n  reset, as if the reset_timestep command were\n  used.  This command has some restrictions as to what fixes can be\n  defined.  See its doc page for details.  For example, the fix deposit and fix dt/reset fixes\n  are in this category.  They also make no sense to use with a rerun\n  command.\n  If time-averaging fixes like fix ave/time are\n  used, they are invoked on timesteps that are a function of their\n  Nevery, Nrepeat, and Nfreq settings.  As an example, see the\n  fix ave/time doc page for details.  You must\n  insure those settings are consistent with the snapshot timestamps that\n  are read from the dump file(s).  If an averaging fix is not invoked on\n  a timestep it expects to be, LAMMPS will flag an error.\n  The various forms of LAMMPS output, as defined by the\n  thermo_style, thermo,\n  dump, and restart commands occur with\n  specified frequency, e.g. every N steps.  If the timestep for a dump\n  snapshot is not a multiple of N, then it will be read and processed,\n  but no output will be produced.  If you want output for every dump\n  snapshot, you can simply use N=1 for an output frequency, e.g. for\n  thermodynamic output or new dump file output.\n  ",
    "syntax": "rerun file1 file2 ... keyword args ...\n  \n  \n  \n  file1,file2,… = dump file(s) to read\n  one or more keywords may be appended, keyword dump must appear and be last\n  keyword = first or last or every or skip or start or stop or dump\n   first args = Nfirst\n     Nfirst = dump timestep to start on\n   last args = Nlast\n     Nlast = dumptimestep to stop on\n   every args = Nevery\n     Nevery = read snapshots matching every this many timesteps\n   skip args = Nskip\n     Nskip = read one out of every Nskip snapshots\n   start args = Nstart\n     Nstart = timestep on which pseudo run will start\n   stop args = Nstop\n     Nstop = timestep to which pseudo run will end\n   dump args = same as read_dump command starting with its field arguments\n  \n  \n  ",
    "examples": "rerun dump.file dump x y z vx vy vz\n  rerun dump1.txt dump2.txt first 10000 every 1000 dump x y z\n  rerun dump.vels dump x y z vx vy vz box yes format molfile lammpstrj\n  rerun dump.dcd dump x y z box no format molfile dcd\n  rerun ../run7/dump.file.gz skip 2 dump x y z box yes\n  rerun dump.bp dump x y z box no format adios\n  rerun dump.bp dump x y z vx vy vz format adios timeout 10.0\n  \n  \n  ",
    "restrictions": "To read gzipped dump files, you must compile LAMMPS with the\n  -DLAMMPS_GZIP option.  See the Build settings\n  doc page for details.\n  "
},
{
    "command": "reset_ids",
    "description": "Reset atom IDs for the system, including all the global IDs stored\n  for bond, angle, dihedral, improper topology data.  This will\n  create a set of IDs that are numbered contiguously from 1 to N\n  for a N atoms system.\n  This can be useful to do after performing a “delete_atoms” command for\n  a molecular system.  The delete_atoms compress yes option will not\n  perform this operation due to the existence of bond topology.  It can\n  also be useful to do after any simulation which has lost atoms,\n  e.g. due to atoms moving outside a simulation box with fixed\n  boundaries (see the “boundary command”), or due to evaporation (see\n  the “fix evaporate” command).\n  Note that the resetting of IDs is not really a compression, where gaps\n  in atom IDs are removed by decrementing atom IDs that are larger.\n  Instead the IDs for all atoms are erased, and new IDs are assigned so\n  that the atoms owned by an individual processor have consecutive IDs,\n  as the create_atoms command explains.\n  \n  Note\n  If this command is used before a pair style is\n  defined, an error about bond topology atom IDs not being found may\n  result.  This is because the cutoff distance for ghost atom\n  communication was not sufficient to find atoms in bonds, angles, etc\n  that are owned by other processors.  The comm_modify cutoff command can be used to correct this issue.\n  Or you can define a pair style before using this command.  If you do\n  the former, you should unset the comm_modify cutoff after using\n  reset_ids so that subsequent communication is not inefficient.\n  \n  ",
    "syntax": "reset_ids\n  \n  \n  ",
    "examples": "reset_ids\n  \n  \n  ",
    "restrictions": "none\n  "
},
{
    "command": "reset_timestep",
    "description": "Set the timestep counter to the specified value.  This command\n  normally comes after the timestep has been set by reading a restart\n  file via the read_restart command, or a previous\n  simulation advanced the timestep.\n  The read_data and create_box\n  commands set the timestep to 0; the read_restart\n  command sets the timestep to the value it had when the restart file\n  was written.\n  ",
    "syntax": "reset_timestep N\n  \n  \n  \n  N = timestep number\n  \n  ",
    "examples": "reset_timestep 0\n  reset_timestep 4000000\n  \n  \n  ",
    "restrictions": "none\n  This command cannot be used when any fixes are defined that keep track\n  of elapsed time to perform certain kinds of time-dependent operations.\n  Examples are the fix deposit and fix dt/reset commands.  The former adds atoms on\n  specific timesteps.  The latter keeps track of accumulated time.\n  Various fixes use the current timestep to calculate related\n  quantities.  If the timestep is reset, this may produce unexpected\n  behavior, but LAMMPS allows the fixes to be defined even if the\n  timestep is reset.  For example, commands which thermostat the system,\n  e.g. fix nvt, allow you to specify a target temperature\n  which ramps from Tstart to Tstop which may persist over several runs.\n  If you change the timestep, you may induce an instantaneous change in\n  the target temperature.\n  Resetting the timestep clears flags for computes that\n  may have calculated some quantity from a previous run.  This means\n  these quantity cannot be accessed by a variable in between runs until\n  a new run is performed.  See the variable command for\n  more details.\n  "
},
{
    "command": "restart",
    "description": "Write out a binary restart file with the current state of the\n  simulation every so many timesteps, in either or both of two modes, as\n  a run proceeds.  A value of 0 means do not write out any restart\n  files.  The two modes are as follows.  If one filename is specified, a\n  series of filenames will be created which include the timestep in the\n  filename.  If two filenames are specified, only 2 restart files will\n  be created, with those names.  LAMMPS will toggle between the 2 names\n  as it writes successive restart files.\n  Note that you can specify the restart command twice, once with a\n  single filename and once with two filenames.  This would allow you,\n  for example, to write out archival restart files every 100000 steps\n  using a single filename, and more frequent temporary restart files\n  every 1000 steps, using two filenames.  Using restart 0 will turn off\n  both modes of output.\n  Similar to dump files, the restart filename(s) can contain\n  two wild-card characters.\n  If a “*” appears in the single filename, it is replaced with the\n  current timestep value.  This is only recognized when a single\n  filename is used (not when toggling back and forth).  Thus, the 3rd\n  example above creates restart files as follows: restart.1000.equil,\n  restart.2000.equil, etc.  If a single filename is used with no “*”,\n  then the timestep value is appended.  E.g. the 2nd example above\n  creates restart files as follows: poly.restart.1000,\n  poly.restart.2000, etc.\n  If a “%” character appears in the restart filename(s), then one file\n  is written for each processor and the “%” character is replaced with\n  the processor ID from 0 to P-1.  An additional file with the “%”\n  replaced by “base” is also written, which contains global information.\n  For example, the files written on step 1000 for filename restart.%\n  would be restart.base.1000, restart.0.1000, restart.1.1000, …,\n  restart.P-1.1000.  This creates smaller files and can be a fast mode\n  of output and subsequent input on parallel machines that support\n  parallel I/O.  The optional fileper and nfile keywords discussed\n  below can alter the number of files written.\n  The restart file can also be written in parallel as one large binary\n  file via the MPI-IO library, which is part of the MPI standard for\n  versions 2.0 and above.  Using MPI-IO requires two steps.  First,\n  build LAMMPS with its MPIIO package installed, e.g.\n  make yes-mpiio    # installs the MPIIO package\n  make mpi          # build LAMMPS for your platform\n  \n  \n  Second, use a restart filename which contains “.mpiio”.  Note that it\n  does not have to end in “.mpiio”, just contain those characters.\n  Unlike MPI-IO dump files, a particular restart file must be both\n  written and read using MPI-IO.\n  Restart files are written on timesteps that are a multiple of N but\n  not on the first timestep of a run or minimization.  You can use the\n  write_restart command to write a restart file\n  before a run begins.  A restart file is not written on the last\n  timestep of a run unless it is a multiple of N.  A restart file is\n  written on the last timestep of a minimization if N > 0 and the\n  minimization converges.\n  Instead of a numeric value, N can be specified as an equal-style variable, which should be specified as v_name, where\n  name is the variable name.  In this case, the variable is evaluated at\n  the beginning of a run to determine the next timestep at which a\n  restart file will be written out.  On that timestep, the variable will\n  be evaluated again to determine the next timestep, etc.  Thus the\n  variable should return timestep values.  See the stagger() and\n  logfreq() and stride() math functions for equal-style variables, as examples of useful functions to use in\n  this context.  Other similar math functions could easily be added as\n  options for equal-style variables.\n  For example, the following commands will write restart files\n  every step from 1100 to 1200, and could be useful for debugging\n  a simulation where something goes wrong at step 1163:\n  variable       s equal stride(1100,1200,1)\n  restart        v_s tmp.restart\n  \n  \n  \n  See the read_restart command for information about\n  what is stored in a restart file.\n  Restart files can be read by a read_restart\n  command to restart a simulation from a particular state.  Because the\n  file is binary (to enable exact restarts), it may not be readable on\n  another machine.  In this case, you can use the -r command-line switch to convert a restart file to a data file.\n  \n  Note\n  Although the purpose of restart files is to enable restarting a\n  simulation from where it left off, not all information about a\n  simulation is stored in the file.  For example, the list of fixes that\n  were specified during the initial run is not stored, which means the\n  new input script must specify any fixes you want to use.  Even when\n  restart information is stored in the file, as it is for some fixes,\n  commands may need to be re-specified in the new input script, in order\n  to re-use that information.  See the read_restart\n  command for information about what is stored in a restart file.\n  \n  \n  The optional nfile or fileper keywords can be used in conjunction\n  with the “%” wildcard character in the specified restart file name(s).\n  As explained above, the “%” character causes the restart file to be\n  written in pieces, one piece for each of P processors.  By default P =\n  the number of processors the simulation is running on.  The nfile or\n  fileper keyword can be used to set P to a smaller value, which can\n  be more efficient when running on a large number of processors.\n  The nfile keyword sets P to the specified Nf value.  For example, if\n  Nf = 4, and the simulation is running on 100 processors, 4 files will\n  be written, by processors 0,25,50,75.  Each will collect information\n  from itself and the next 24 processors and write it to a restart file.\n  For the fileper keyword, the specified value of Np means write one\n  file for every Np processors.  For example, if Np = 4, every 4th\n  processor (0,4,8,12,etc) will collect information from itself and the\n  next 3 processors and write it to a restart file.\n  ",
    "syntax": "restart 0\n  restart N root keyword value ...\n  restart N file1 file2 keyword value ...\n  \n  \n  \n  N = write a restart file every this many timesteps\n  N can be a variable (see below)\n  root = filename to which timestep # is appended\n  file1,file2 = two full filenames, toggle between them when writing file\n  zero or more keyword/value pairs may be appended\n  keyword = fileper or nfile\n  fileper arg = Np\n    Np = write one file for every this many processors\n  nfile arg = Nf\n    Nf = write this many files, one from each of Nf processors\n  \n  \n  ",
    "examples": "restart 0\n  restart 1000 poly.restart\n  restart 1000 poly.restart.mpiio\n  restart 1000 restart.\\*.equil\n  restart 10000 poly.%.1 poly.%.2 nfile 10\n  restart v_mystep poly.restart\n  \n  \n  ",
    "restrictions": "To write and read restart files in parallel with MPI-IO, the MPIIO\n  package must be installed.\n  "
},
{
    "command": "run",
    "description": "Run or continue dynamics for a specified number of timesteps.\n  When the run style is respa, N refers to outer\n  loop (largest) timesteps.\n  A value of N = 0 is acceptable; only the thermodynamics of the system\n  are computed and printed without taking a timestep.\n  The upto keyword means to perform a run starting at the current\n  timestep up to the specified timestep.  E.g. if the current timestep\n  is 10,000 and “run 100000 upto” is used, then an additional 90,000\n  timesteps will be run.  This can be useful for very long runs on a\n  machine that allocates chunks of time and terminate your job when time\n  is exceeded.  If you need to restart your script multiple times\n  (reading in the last restart file), you can keep restarting your\n  script with the same run command until the simulation finally\n  completes.\n  The start or stop keywords can be used if multiple runs are being\n  performed and you want a fix command that changes some\n  value over time (e.g. temperature) to make the change across the\n  entire set of runs and not just a single run.  See the doc page for\n  individual fixes to see which ones can be used with the start/stop\n  keywords.\n  For example, consider this fix followed by 10 run commands:\n  fix         1 all nvt 200.0 300.0 1.0\n  run         1000 start 0 stop 10000\n  run         1000 start 0 stop 10000\n  ...\n  run         1000 start 0 stop 10000\n  \n  \n  The NVT fix ramps the target temperature from 200.0 to 300.0 during a\n  run.  If the run commands did not have the start/stop keywords (just\n  “run 1000”), then the temperature would ramp from 200.0 to 300.0\n  during the 1000 steps of each run.  With the start/stop keywords, the\n  ramping takes place over the 10000 steps of all runs together.\n  The pre and post keywords can be used to streamline the setup,\n  clean-up, and associated output to the screen that happens before and\n  after a run.  This can be useful if you wish to do many short runs in\n  succession (e.g. LAMMPS is being called as a library which is doing\n  other computations between successive short LAMMPS runs).\n  By default (pre and post = yes), LAMMPS creates neighbor lists,\n  computes forces, and imposes fix constraints before every run.  And\n  after every run it gathers and prints timings statistics.  If a run is\n  just a continuation of a previous run (i.e. no settings are changed),\n  the initial computation is not necessary; the old neighbor list is\n  still valid as are the forces.  So if pre is specified as “no” then\n  the initial setup is skipped, except for printing thermodynamic info.\n  Note that if pre is set to “no” for the very 1st run LAMMPS\n  performs, then it is overridden, since the initial setup computations\n  must be done.\n  \n  Note\n  If your input script changes the system between 2 runs, then the\n  initial setup must be performed to insure the change is recognized by\n  all parts of the code that are affected.  Examples are adding a\n  fix or dump or compute, changing\n  a neighbor list parameter, or writing restart file\n  which can migrate atoms between processors.  LAMMPS has no easy way to\n  check if this has happened, but it is an error to use the pre no\n  option in this case.\n  \n  If post is specified as “no”, the full timing summary is skipped;\n  only a one-line summary timing is printed.\n  The every keyword provides a means of breaking a LAMMPS run into a\n  series of shorter runs.  Optionally, one or more LAMMPS commands (c1,\n  c2, …, cN) will be executed in between the short runs.  If used, the\n  every keyword must be the last keyword, since it has a variable\n  number of arguments.  Each of the trailing arguments is a single\n  LAMMPS command, and each command should be enclosed in quotes, so that\n  the entire command will be treated as a single argument.  This will\n  also prevent any variables in the command from being evaluated until\n  it is executed multiple times during the run.  Note that if a command\n  itself needs one of its arguments quoted (e.g. the print\n  command), then you can use a combination of single and double quotes,\n  as in the example above or below.\n  The every keyword is a means to avoid listing a long series of runs\n  and interleaving commands in your input script.  For example, a\n  print command could be invoked or a fix could\n  be redefined, e.g. to reset a thermostat temperature.  Or this could\n  be useful for invoking a command you have added to LAMMPS that wraps\n  some other code (e.g. as a library) to perform a computation\n  periodically during a long LAMMPS run.  See the Modify\n  doc page for info about how to add new commands to LAMMPS.  See the\n  Howto couple doc page for ideas about how to\n  couple LAMMPS to other codes.\n  With the every option, N total steps are simulated, in shorter runs\n  of M steps each.  After each M-length run, the specified commands are\n  invoked.  If only a single command is specified as NULL, then no\n  command is invoked.  Thus these lines:\n  variable q equal x[100]\n  run 6000 every 2000 \"print 'Coord = $q'\"\n  \n  \n  are the equivalent of:\n  variable q equal x[100]\n  run 2000\n  print \"Coord = $q\"\n  run 2000\n  print \"Coord = $q\"\n  run 2000\n  print \"Coord = $q\"\n  \n  \n  which does 3 runs of 2000 steps and prints the x-coordinate of a\n  particular atom between runs.  Note that the variable “$q” will\n  be evaluated afresh each time the print command is executed.\n  Note that by using the line continuation character “&”, the run every\n  command can be spread across many lines, though it is still a single\n  command:\n  run 100000 every 1000 &\n    \"print 'Minimum value = $a'\" &\n    \"print 'Maximum value = $b'\" &\n    \"print 'Temp = $c'\" &\n    \"print 'Press = $d'\"\n  \n  \n  If the pre and post options are set to “no” when used with the\n  every keyword, then the 1st run will do the full setup and the last\n  run will print the full timing summary, but these operations will be\n  skipped for intermediate runs.\n  \n  Note\n  You might wish to specify a command that exits the run by\n  jumping out of the loop, e.g.\n  \n  variable t equal temp\n  run 10000 every 100 \"if '$t < 300.0' then 'jump SELF afterrun'\"\n  \n  \n  However, this will not work.  The run command simply executes each\n  command one at a time each time it pauses, then continues the run.\n  Instead, you should use the fix halt command, which\n  has additional options for how to exit the run.\n  ",
    "syntax": "run N keyword values ...\n  \n  \n  \n  N = # of timesteps\n  zero or more keyword/value pairs may be appended\n  keyword = upto or start or stop or pre or post or every\n  upto value = none\n  start value = N1\n    N1 = timestep at which 1st run started\n  stop value = N2\n    N2 = timestep at which last run will end\n  pre value = no or yes\n  post value = no or yes\n  every values = M c1 c2 ...\n    M = break the run into M-timestep segments and invoke one or more commands between each segment\n    c1,c2,...,cN = one or more LAMMPS commands, each enclosed in quotes\n    c1 = NULL means no command will be invoked\n  \n  \n  ",
    "examples": "run 10000\n  run 1000000 upto\n  run 100 start 0 stop 1000\n  run 1000 pre no post yes\n  run 100000 start 0 stop 1000000 every 1000 \"print 'Protein Rg = $r'\"\n  run 100000 every 1000 NULL\n  \n  \n  ",
    "restrictions": "When not using the upto keyword, the number of specified timesteps N\n  must fit in a signed 32-bit integer, so you are limited to slightly\n  more than 2 billion steps (2^31) in a single run.  When using upto,\n  N can be larger than a signed 32-bit integer, however the difference\n  between N and the current timestep must still be no larger than\n  2^31 steps.\n  However, with or without the upto keyword, you can perform\n  successive runs to run a simulation for any number of steps (ok, up to\n  2^63 total steps).  I.e. the timestep counter within LAMMPS is a\n  64-bit signed integer.\n  "
},
{
    "command": "run_style",
    "description": "Choose the style of time integrator used for molecular dynamics\n  simulations performed by LAMMPS.\n  The verlet style is a standard velocity-Verlet integrator.\n  \n  The verlet/split style is also a velocity-Verlet integrator, but it\n  splits the force calculation within each timestep over 2 partitions of\n  processors.  See the -partition command-line switch\n  for info on how to run LAMMPS with multiple partitions.\n  Specifically, this style performs all computation except the\n  kspace_style portion of the force field on the 1st\n  partition.  This include the pair style, bond style, neighbor list building,\n  fixes including time integration, and output.  The\n  kspace_style portion of the calculation is\n  performed on the 2nd partition.\n  This is most useful for the PPPM kspace_style when its performance on\n  a large number of processors degrades due to the cost of communication\n  in its 3d FFTs.  In this scenario, splitting your P total processors\n  into 2 subsets of processors, P1 in the 1st partition and P2 in the\n  2nd partition, can enable your simulation to run faster.  This is\n  because the long-range forces in PPPM can be calculated at the same\n  time as pair-wise and bonded forces are being calculated, and the FFTs\n  can actually speed up when running on fewer processors.\n  To use this style, you must define 2 partitions where P1 is a multiple\n  of P2.  Typically having P1 be 3x larger than P2 is a good choice.\n  The 3d processor layouts in each partition must overlay in the\n  following sense.  If P1 is a Px1 by Py1 by Pz1 grid, and P2 = Px2 by\n  Py2 by Pz2, then Px1 must be an integer multiple of Px2, and similarly\n  for Py1 a multiple of Py2, and Pz1 a multiple of Pz2.\n  Typically the best way to do this is to let the 1st partition choose\n  its onn optimal layout, then require the 2nd partition’s layout to\n  match the integer multiple constraint.  See the\n  processors command with its part keyword for a way\n  to control this, e.g.\n  processors * * * part 1 2 multiple\n  \n  \n  You can also use the partition command to explicitly\n  specify the processor layout on each partition.  E.g. for 2 partitions\n  of 60 and 15 processors each:\n  partition yes 1 processors 3 4 5\n  partition yes 2 processors 3 1 5\n  \n  \n  When you run in 2-partition mode with the verlet/split style, the\n  thermodynamic data for the entire simulation will be output to the log\n  and screen file of the 1st partition, which are log.lammps.0 and\n  screen.0 by default; see the -plog and -pscreen command-line switches to change this.  The log and screen file\n  for the 2nd partition will not contain thermodynamic output beyond the\n  1st timestep of the run.\n  See the Speed packages doc page for performance\n  details of the speed-up offered by the verlet/split style.  One\n  important performance consideration is the assignment of logical\n  processors in the 2 partitions to the physical cores of a parallel\n  machine.  The processors command has options to\n  support this, and strategies are discussed in Section 5 of the manual.\n  \n  The respa style implements the rRESPA multi-timescale integrator\n  (Tuckerman) with N hierarchical levels, where level 1 is\n  the innermost loop (shortest timestep) and level N is the outermost\n  loop (largest timestep).  The loop factor arguments specify what the\n  looping factor is between levels.  N1 specifies the number of\n  iterations of level 1 for a single iteration of level 2, N2 is the\n  iterations of level 2 per iteration of level 3, etc.  N-1 looping\n  parameters must be specified.\n  Thus with a 4-level respa setting of “2 2 2” for the 3 loop factors,\n  you could choose to have bond interactions computed 8x per large\n  timestep, angle interactions computed 4x, pair interactions computed\n  2x, and long-range interactions once per large timestep.\n  The timestep command sets the large timestep for the\n  outermost rRESPA level.  Thus if the 3 loop factors are “2 2 2” for\n  4-level rRESPA, and the outer timestep is set to 4.0 fmsec, then the\n  inner timestep would be 8x smaller or 0.5 fmsec.  All other LAMMPS\n  commands that specify number of timesteps (e.g. thermo\n  for thermo output every N steps, neigh_modify delay/every parameters, dump every N\n  steps, etc) refer to the outermost timesteps.\n  The rRESPA keywords enable you to specify at what level of the\n  hierarchy various forces will be computed.  If not specified, the\n  defaults are that bond forces are computed at level 1 (innermost\n  loop), angle forces are computed where bond forces are, dihedral\n  forces are computed where angle forces are, improper forces are\n  computed where dihedral forces are, pair forces are computed at the\n  outermost level, and kspace forces are computed where pair forces are.\n  The inner, middle, outer forces have no defaults.\n  For fixes that support it, the rRESPA level at which a given fix is\n  active, can be selected through the fix_modify command.\n  The inner and middle keywords take additional arguments for\n  cutoffs that are used by the pairwise force computations.  If the 2\n  cutoffs for inner are 5.0 and 6.0, this means that all pairs up to\n  6.0 apart are computed by the inner force.  Those between 5.0 and 6.0\n  have their force go ramped to 0.0 so the overlap with the next regime\n  (middle or outer) is smooth.  The next regime (middle or outer) will\n  compute forces for all pairs from 5.0 outward, with those from 5.0 to\n  6.0 having their value ramped in an inverse manner.\n  Note that you can use inner and outer without using middle to\n  split the pairwise computations into two portions instead of three.\n  Unless you are using a very long pairwise cutoff, a 2-way split is\n  often faster than a 3-way split, since it avoids too much duplicate\n  computation of pairwise interactions near the intermediate cutoffs.\n  Also note that only a few pair potentials support the use of the\n  inner and middle and outer keywords.  If not, only the pair\n  keyword can be used with that pair style, meaning all pairwise forces\n  are computed at the same rRESPA level.  See the doc pages for\n  individual pair styles for details.\n  Another option for using pair potentials with rRESPA is with the\n  hybrid keyword, which requires the use of the pair_style hybrid or hybrid/overlay command.  In this scenario, different\n  sub-styles of the hybrid pair style are evaluated at different rRESPA\n  levels.  This can be useful, for example, to set different timesteps\n  for hybrid coarse-grained/all-atom models.  The hybrid keyword\n  requires as many level assignments as there are hybrid sub-styles,\n  which assigns each sub-style to a rRESPA level, following their order\n  of definition in the pair_style command. Since the hybrid keyword\n  operates on pair style computations, it is mutually exclusive with\n  either the pair or the inner/middle/outer keywords.\n  When using rRESPA (or for any MD simulation) care must be taken to\n  choose a timestep size(s) that insures the Hamiltonian for the chosen\n  ensemble is conserved.  For the constant NVE ensemble, total energy\n  must be conserved.  Unfortunately, it is difficult to know a priori\n  how well energy will be conserved, and a fairly long test simulation\n  (~10 ps) is usually necessary in order to verify that no long-term\n  drift in energy occurs with the trial set of parameters.\n  With that caveat, a few rules-of-thumb may be useful in selecting\n  respa settings.  The following applies mostly to biomolecular\n  simulations using the CHARMM or a similar all-atom force field, but\n  the concepts are adaptable to other problems.  Without SHAKE, bonds\n  involving hydrogen atoms exhibit high-frequency vibrations and require\n  a timestep on the order of 0.5 fmsec in order to conserve energy.  The\n  relatively inexpensive force computations for the bonds, angles,\n  impropers, and dihedrals can be computed on this innermost 0.5 fmsec\n  step.  The outermost timestep cannot be greater than 4.0 fmsec without\n  risking energy drift.  Smooth switching of forces between the levels\n  of the rRESPA hierarchy is also necessary to avoid drift, and a 1-2\n  angstrom “healing distance” (the distance between the outer and inner\n  cutoffs) works reasonably well.  We thus recommend the following\n  settings for use of the respa style without SHAKE in biomolecular\n  simulations:\n  timestep  4.0\n  run_style respa 4 2 2 2 inner 2 4.5 6.0 middle 3 8.0 10.0 outer 4\n  \n  \n  With these settings, users can expect good energy conservation and\n  roughly a 2.5 fold speedup over the verlet style with a 0.5 fmsec\n  timestep.\n  If SHAKE is used with the respa style, time reversibility is lost,\n  but substantially longer time steps can be achieved.  For biomolecular\n  simulations using the CHARMM or similar all-atom force field, bonds\n  involving hydrogen atoms exhibit high frequency vibrations and require\n  a time step on the order of 0.5 fmsec in order to conserve energy.\n  These high frequency modes also limit the outer time step sizes since\n  the modes are coupled.  It is therefore desirable to use SHAKE with\n  respa in order to freeze out these high frequency motions and increase\n  the size of the time steps in the respa hierarchy.  The following\n  settings can be used for biomolecular simulations with SHAKE and\n  rRESPA:\n  fix             2 all shake 0.000001 500 0 m 1.0 a 1\n  timestep        4.0\n  run_style       respa 2 2 inner 1 4.0 5.0 outer 2\n  \n  \n  With these settings, users can expect good energy conservation and\n  roughly a 1.5 fold speedup over the verlet style with SHAKE and a\n  2.0 fmsec timestep.\n  For non-biomolecular simulations, the respa style can be\n  advantageous if there is a clear separation of time scales - fast and\n  slow modes in the simulation.  For example, a system of slowly-moving\n  charged polymer chains could be setup as follows:\n  timestep 4.0\n  run_style respa 2 8\n  \n  \n  This is two-level rRESPA with an 8x difference between the short and\n  long timesteps.  The bonds, angles, dihedrals will be computed every\n  0.5 fs (assuming real units), while the pair and kspace interactions\n  will be computed once every 4 fs.  These are the default settings for\n  each kind of interaction, so no additional keywords are necessary.\n  Even a LJ system can benefit from rRESPA if the interactions are\n  divided by the inner, middle and outer keywords.  A 2-fold or more\n  speedup can be obtained while maintaining good energy conservation.\n  In real units, for a pure LJ fluid at liquid density, with a sigma of\n  3.0 angstroms, and epsilon of 0.1 Kcal/mol, the following settings\n  seem to work well:\n  timestep  36.0\n  run_style respa 3 3 4 inner 1 3.0 4.0 middle 2 6.0 7.0 outer 3\n  \n  \n  \n  The respa/omp style is a variant of respa adapted for use with\n  pair, bond, angle, dihedral, improper, or kspace styles with an omp\n  suffix. It is functionally equivalent to respa but performs\n  additional operations required for managing omp styles.  For more on\n  omp styles see the Speed omp doc page.  Accelerated\n  styles take the same arguments and should produce the same results,\n  except for round-off and precision issues.\n  You can specify respa/omp explicitly in your input script, or you\n  can use the -suffix command-line switch when you\n  invoke LAMMPS, or you can use the suffix command in your\n  input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "run_style style args\n  \n  \n  \n  style = verlet or verlet/split or respa or respa/omp\n  verlet args = none\n  verlet/split args = none\n  respa args = N n1 n2 ... keyword values ...\n    N = # of levels of rRESPA\n    n1, n2, ... = loop factors between rRESPA levels (N-1 values)\n    zero or more keyword/value pairings may be appended to the loop factors\n    keyword = bond or angle or dihedral or improper or\n              pair or inner or middle or outer or hybrid or kspace\n      bond value = M\n        M = which level (1-N) to compute bond forces in\n      angle value = M\n        M = which level (1-N) to compute angle forces in\n      dihedral value = M\n        M = which level (1-N) to compute dihedral forces in\n      improper value = M\n        M = which level (1-N) to compute improper forces in\n      pair value = M\n        M = which level (1-N) to compute pair forces in\n      inner values = M cut1 cut2\n        M = which level (1-N) to compute pair inner forces in\n        cut1 = inner cutoff between pair inner and\n               pair middle or outer  (distance units)\n        cut2 = outer cutoff between pair inner and\n               pair middle or outer  (distance units)\n      middle values = M cut1 cut2\n        M = which level (1-N) to compute pair middle forces in\n        cut1 = inner cutoff between pair middle and pair outer (distance units)\n        cut2 = outer cutoff between pair middle and pair outer (distance units)\n      outer value = M\n        M = which level (1-N) to compute pair outer forces in\n      hybrid values = M1 M2 ... (as many values as there are hybrid sub-styles\n        M1 = which level (1-N) to compute the first pair_style hybrid sub-style in\n        M2 = which level (1-N) to compute the second pair_style hybrid sub-style in\n        M3,etc\n      kspace value = M\n        M = which level (1-N) to compute kspace forces in\n  \n  \n  ",
    "examples": "run_style verlet\n  run_style respa 4 2 2 2 bond 1 dihedral 2 pair 3 kspace 4\n  run_style respa 4 2 2 2 bond 1 dihedral 2 inner 3 5.0 6.0 outer 4 kspace 4\n  run_style respa 3 4 2 bond 1 hybrid 2 2 1 kspace 3\n  \n  \n  ",
    "restrictions": "The verlet/split style can only be used if LAMMPS was built with the\n  REPLICA package. Correspondingly the respa/omp style is available\n  only if the USER-OMP package was included. See the Build package doc page for more info.\n  Whenever using rRESPA, the user should experiment with trade-offs in\n  speed and accuracy for their system, and verify that they are\n  conserving energy to adequate precision.\n  "
},
{
    "command": "server",
    "description": "This command starts LAMMPS running in “server” mode, where it receives\n  messages from a separate “client” code and responds by sending a reply\n  message back to the client.  The specified protocol determines the\n  format and content of messages LAMMPS expects to receive and how it\n  responds.\n  The Howto client/server doc page gives an\n  overview of client/server coupling of LAMMPS with another code where\n  one code is the “client” and sends request messages to a “server”\n  code.  The server responds to each request with a reply message.  This\n  enables the two codes to work in tandem to perform a simulation.\n  When this command is invoked, LAMMPS will run in server mode in an\n  endless loop, waiting for messages from the client code.  The client\n  signals when it is done sending messages to LAMMPS, at which point the\n  loop will exit, and the remainder of the LAMMPS input script will be\n  processed.\n  The protocol argument defines the format and content of messages\n  that will be exchanged between the two codes.  The current options\n  are:\n  \n  md = run dynamics with another code\n  mc = perform Monte Carlo moves with another code\n  \n  For protocol md, LAMMPS can be either a client (via the fix client/md command) or server.  See the server md doc page for details on the protocol.\n  For protocol mc, LAMMPS can be the server.  See the server mc doc page for details on the protocol.\n  ",
    "syntax": "server protocol\n  \n  \n  \n  protocol = md or mc\n  \n  ",
    "examples": "server md\n  \n  \n  ",
    "restrictions": "This command is part of the MESSAGE package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  A script that uses this command must also use the\n  message command to setup the messaging protocol with\n  the other client code.\n  "
},
{
    "command": "server mc",
    "description": "This command starts LAMMPS running in “server” mode, where it will\n  expect messages from a separate “client” code that match the mc\n  protocol for format and content explained below.  For each message\n  LAMMPS receives it will send a message back to the client.\n  The Howto client/server doc page gives an\n  overview of client/server coupling of LAMMPS with another code where\n  one code is the “client” and sends request messages to a “server”\n  code.  The server responds to each request with a reply message.  This\n  enables the two codes to work in tandem to perform a simulation.\n  When this command is invoked, LAMMPS will run in server mode in an\n  endless loop, waiting for messages from the client code.  The client\n  signals when it is done sending messages to LAMMPS, at which point the\n  loop will exit, and the remainder of the LAMMPS script will be\n  processed.\n  The server doc page gives other options for using LAMMPS\n  See an example of how this command is used in\n  examples/COUPLE/lammps_mc/in.server.\n  \n  When using this command, LAMMPS (as the server code) receives\n  instructions from a Monte Carlo (MC) driver to displace random atoms,\n  compute the energy before and after displacement, and run dynamics to\n  equilibrate the system.\n  The MC driver performs the random displacements on random atoms,\n  accepts or rejects the move in an MC sense, and orchestrates the MD\n  runs.\n  The format and content of the exchanged messages are explained here in\n  a conceptual sense.  Python-style pseudo code for the library calls to\n  the CSlib is shown, which performs the actual message exchange between\n  the two codes.  See the CSlib website doc\n  pages for more details on the actual library syntax.  The “cs” object\n  in this pseudo code is a pointer to an instance of the CSlib.\n  See the src/MESSAGE/server_mc.cpp file for details on how LAMMPS uses\n  these messages.  See the examples/COUPLE/lammps_mc/mc.cpp file for an\n  example of how an MC driver code can use these messages.\n  Define NATOMS=1, EINIT=2, DISPLACE=3, ACCEPT=4, RUN=5.\n  Client sends one of these kinds of message:\n  cs->send(NATOMS,0)      # msgID = 1 with no fields\n  \n  cs->send(EINIT,0)       # msgID = 2 with no fields\n  \n  cs->send(DISPLACE,2)    # msgID = 3 with 2 fields\n  cs->pack_int(1,ID)        # 1st field = ID of atom to displace\n  cs->pack(2,3,xnew)      # 2nd field = new xyz coords of displaced atom\n  \n  cs->send(ACCEPT,1)      # msgID = 4 with 1 field\n  cs->pack_int(1,flag)    # 1st field = accept/reject flag\n  \n  cs->send(RUN,1)         # msgID = 5 with 1 field\n  cs->pack_int(1,nsteps)  # 1st field = # of timesteps to run MD\n  \n  \n  Server replies:\n  cs->send(NATOMS,1)      # msgID = 1 with 1 field\n  cs->pack_int(1,natoms)  # 1st field = number of atoms\n  \n  cs->send(EINIT,2)         # msgID = 2 with 2 fields\n  cs->pack_double(1,poteng) # 1st field = potential energy of system\n  cs->pack(2,3*natoms,x)    # 2nd field = 3N coords of Natoms\n  \n  cs->send(DISPLACE,1)      # msgID = 3 with 1 field\n  cs->pack_double(1,poteng) # 1st field = new potential energy of system\n  \n  cs->send(ACCEPT,0)      # msgID = 4 with no fields\n  \n  cs->send(RUN,0)         # msgID = 5 with no fields\n  ",
    "syntax": "server mc\n  \n  \n  mc = the protocol argument to the server command\n  ",
    "examples": "server mc\n  \n  \n  ",
    "restrictions": "This command is part of the MESSAGE package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  A script that uses this command must also use the\n  message command to setup the messaging protocol with\n  the other client code.\n  "
},
{
    "command": "server md",
    "description": "This command starts LAMMPS running in “server” mode, where it will\n  expect messages from a separate “client” code that match the md\n  protocol for format and content explained below.  For each message\n  LAMMPS receives it will send a message back to the client.\n  The Howto client/server doc page gives an\n  overview of client/server coupling of LAMMPS with another code where\n  one code is the “client” and sends request messages to a “server”\n  code.  The server responds to each request with a reply message.  This\n  enables the two codes to work in tandem to perform a simulation.\n  When this command is invoked, LAMMPS will run in server mode in an\n  endless loop, waiting for messages from the client code.  The client\n  signals when it is done sending messages to LAMMPS, at which point the\n  loop will exit, and the remainder of the LAMMPS script will be\n  processed.\n  The server doc page gives other options for using LAMMPS\n  in server mode.  See an example of how this command is used in\n  examples/message/in.message.server.\n  \n  When using this command, LAMMPS (as the server code) receives the\n  current coordinates of all particles from the client code each\n  timestep, computes their interaction, and returns the energy, forces,\n  and pressure for the interacting particles to the client code, so it\n  can complete the timestep.  This command could also be used with a\n  client code that performs energy minimization, using the server to\n  compute forces and energy each iteration of its minimizer.\n  When using the fix client/md command, LAMMPS (as\n  the client code) does the timestepping and receives needed energy,\n  forces, and pressure values from the server code.\n  The format and content of the exchanged messages are explained here in\n  a conceptual sense.  Python-style pseudo code for the library calls to\n  the CSlib is shown, which performs the actual message exchange between\n  the two codes.  See the CSlib website doc\n  pages for more details on the actual library syntax.  The “cs” object\n  in this pseudo code is a pointer to an instance of the CSlib.\n  See the src/MESSAGE/server_md.cpp and src/MESSAGE/fix_client_md.cpp\n  files for details on how LAMMPS uses these messages.  See the\n  examples/COUPLE/lammps_vasp/vasp_wrap.py or\n  examples/COUPLE/lammps_nwchem/nwchem_wrap.py files for examples of how\n  a quantum code (VASP or NWChem) can use these messages.\n  The following pseudo-code uses these values, defined as enums.\n  Define:\n  SETUP=1, STEP=2\n  DIM=1, PERIODICITY=2, ORIGIN=3, BOX=4, NATOMS=5, NTYPES=6, TYPES=7, COORDS=8, UNITS-9, CHARGE=10\n  FORCES=1, ENERGY=2, PRESSURE=3, ERROR=4\n  \n  \n  Client sends 2 kinds of messages:\n  # required fields: DIM, PERIODICTY, ORIGIN, BOX, NATOMS, NTYPES, TYPES, COORDS\n  # optional fields: UNITS, CHARGE\n  \n  cs->send(SETUP,nfields)        # msgID with nfields\n  \n  cs->pack_int(DIM,dim)          # dimension (2,3) of simulation\n  cs->pack(PERIODICITY,3,xyz)    # periodicity flags in 3 dims\n  cs->pack(ORIGIN,3,origin)      # lower-left corner of simulation box\n  cs->pack(BOX,9,box)            # 3 edge vectors of simulation box\n  cs->pack_int(NATOMS,natoms)    # total number of atoms\n  cs->pack_int(NTYPES,ntypes)    # number of atom types\n  cs->pack(TYPES,natoms,type)    # vector of per-atom types\n  cs->pack(COORDS,3*natoms,x)    # vector of 3N atom coords\n  cs->pack_string(UNITS,units)   # units = \"lj\", \"real\", \"metal\", etc\n  cs->pack(CHARGE,natoms,q)      # vector of per-atom charge\n  \n  # required fields: COORDS\n  # optional fields: ORIGIN, BOX\n  \n  cs->send(STEP,nfields)         # msgID with nfields\n  \n  cs->pack(COORDS,3*natoms,x)    # vector of 3N atom coords\n  cs->pack(ORIGIN,3,origin)      # lower-left corner of simulation box\n  cs->pack(BOX,9,box)            # 3 edge vectors of simulation box\n  Server replies to either kind of message:\n  # required fields: FORCES, ENERGY, PRESSURE\n  # optional fields: ERROR\n  \n  cs->send(msgID,nfields)      # msgID with nfields\n  cs->pack(FORCES,3*Natoms,f)  # vector of 3N forces on atoms\n  cs->pack(ENERGY,1,poteng)    # total potential energy of system\n  cs->pack(PRESSURE,6,press)   # global pressure tensor (6-vector)\n  cs->pack_int(ERROR,flag)     # server had an error (e.g. DFT non-convergence)\n  \n  The units for various quantities that are sent and received iva\n  messages are defined for atomic-scale simulations in the table below.\n  The client and server codes (including LAMMPS) can use internal units\n  different than these (e.g. real units in LAMMPS), so long\n  as they convert to these units for messaging.\n  \n  COORDS, ORIGIN, BOX = Angstroms\n  CHARGE = multiple of electron charge (1.0 is a proton)\n  ENERGY = eV\n  FORCES = eV/Angstrom\n  PRESSURE = bars\n  \n  Note that these are metal units in LAMMPS.\n  If you wish to run LAMMPS in another its non-atomic units, e.g. lj units, then the client and server should exchange a UNITS\n  message as indicated above, and both the client and server should\n  agree on the units for the data they exchange.\n  ",
    "syntax": "server md\n  \n  \n  md = the protocol argument to the server command\n  ",
    "examples": "server md\n  \n  \n  ",
    "restrictions": "This command is part of the MESSAGE package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "set",
    "description": "Set one or more properties of one or more atoms.  Since atom\n  properties are initially assigned by the read_data,\n  read_restart or create_atoms\n  commands, this command changes those assignments.  This can be useful\n  for overriding the default values assigned by the\n  create_atoms command (e.g. charge = 0.0).  It can\n  be useful for altering pairwise and molecular force interactions,\n  since force-field coefficients are defined in terms of types.  It can\n  be used to change the labeling of atoms by atom type or molecule ID\n  when they are output in dump files.  It can also be useful\n  for debugging purposes; i.e. positioning an atom at a precise location\n  to compute subsequent forces or energy.\n  Note that the style and ID arguments determine which atoms have\n  their properties reset.  The remaining keywords specify which\n  properties to reset and what the new values are.  Some strings like\n  type or mol can be used as a style and/or a keyword.\n  \n  This section describes how to select which atoms to change\n  the properties of, via the style and ID arguments.\n  The style atom selects all the atoms in a range of atom IDs.  The\n  style type selects all the atoms in a range of types.  The style\n  mol selects all the atoms in a range of molecule IDs.\n  In each of the range cases, the range can be specified as a single\n  numeric value, or a wildcard asterisk can be used to specify a range\n  of values.  This takes the form “*” or “*n” or “n*” or “m*n”.  For\n  example, for the style type, if N = the number of atom types, then\n  an asterisk with no numeric values means all types from 1 to N.  A\n  leading asterisk means all types from 1 to n (inclusive).  A trailing\n  asterisk means all types from n to N (inclusive).  A middle asterisk\n  means all types from m to n (inclusive).  For all the styles except\n  mol, the lowest value for the wildcard is 1; for mol it is 0.\n  The style group selects all the atoms in the specified group.  The\n  style region selects all the atoms in the specified geometric\n  region.  See the group and region commands\n  for details of how to specify a group or region.\n  \n  This section describes the keyword options for which properties to\n  change, for the selected atoms.\n  Note that except where explicitly prohibited below, all of the\n  keywords allow an atom-style or atomfile-style variable to be used as the specified value(s).  If the value is a\n  variable, it should be specified as v_name, where name is the\n  variable name.  In this case, the variable will be evaluated, and its\n  resulting per-atom value used to determine the value assigned to each\n  selected atom.  Note that the per-atom value from the variable will be\n  ignored for atoms that are not selected via the style and ID\n  settings explained above.  A simple way to use per-atom values from\n  the variable to reset a property for all atoms is to use style atom\n  with ID = “*”; this selects all atom IDs.\n  Atom-style variables can specify formulas with various mathematical\n  functions, and include thermo_style command\n  keywords for the simulation box parameters and timestep and elapsed\n  time.  They can also include per-atom values, such as atom\n  coordinates.  Thus it is easy to specify a time-dependent or\n  spatially-dependent set of per-atom values.  As explained on the\n  variable doc page, atomfile-style variables can be\n  used in place of atom-style variables, and thus as arguments to the\n  set command.  Atomfile-style variables read their per-atoms values\n  from a file.\n  \n  Note\n  Atom-style and atomfile-style variables return floating point\n  per-atom values.  If the values are assigned to an integer variable,\n  such as the molecule ID, then the floating point value is truncated to\n  its integer portion, e.g. a value of 2.6 would become 2.\n  \n  Keyword type sets the atom type for all selected atoms.  The\n  specified value must be from 1 to ntypes, where ntypes was set by the\n  create_box command or the atom types field in the\n  header of the data file read by the read_data\n  command.\n  Keyword type/fraction sets the atom type for a fraction of the\n  selected atoms.  The actual number of atoms changed is not guaranteed\n  to be exactly the specified fraction (0 <= fraction <= 1), but\n  should be statistically close.  Random numbers are used in such a way\n  that a particular atom is changed or not changed, regardless of how\n  many processors are being used.  This keyword does not allow use of an\n  atom-style variable.\n  Keywords type/ratio and type/subset also set the atom type for a\n  fraction of the selected atoms.  The actual number of atoms changed\n  will be exactly the requested number.  For type/ratio the specified\n  fraction (0 <= fraction <= 1) determines the number.  For\n  type/subset, the specified Nsubset is the number.  An iterative\n  algorithm is used which insures the correct number of atoms are\n  selected, in a perfectly random fashion.  Which atoms are selected\n  will change with the number of processors used.  These keywords do not\n  allow use of an atom-style variable.\n  Keyword mol sets the molecule ID for all selected atoms.  The\n  atom style being used must support the use of\n  molecule IDs.\n  Keywords x, y, z, and charge set the coordinates or\n  charge of all selected atoms.  For charge, the atom style being used must support the use of atomic\n  charge. Keywords vx, vy, and vz set the velocities of all\n  selected atoms.\n  Keyword dipole uses the specified x,y,z values as components of a\n  vector to set as the orientation of the dipole moment vectors of the\n  selected atoms.  The magnitude of the dipole moment is set by the\n  length of this orientation vector.\n  Keyword dipole/random randomizes the orientation of the dipole\n  moment vectors for the selected atoms and sets the magnitude of each\n  to the specified Dlen value.  For 2d systems, the z component of the\n  orientation is set to 0.0.  Random numbers are used in such a way that\n  the orientation of a particular atom is the same, regardless of how\n  many processors are being used.  This keyword does not allow use of an\n  atom-style variable.\n  Keyword spin uses the specified g value to set the magnitude of the\n  magnetic spin vectors, and the x,y,z values as components of a vector\n  to set as the orientation of the magnetic spin vectors of the selected\n  atoms.\n  Keyword spin/random randomizes the orientation of the magnetic spin\n  vectors for the selected atoms and sets the magnitude of each to the\n  specified Dlen value.\n  Keyword quat uses the specified values to create a quaternion\n  (4-vector) that represents the orientation of the selected atoms.  The\n  particles must define a quaternion for their orientation\n  (e.g. ellipsoids, triangles, body particles) as defined by the\n  atom_style command.  Note that particles defined by\n  atom_style ellipsoid have 3 shape parameters.  The 3\n  values must be non-zero for each particle set by this command.  They\n  are used to specify the aspect ratios of an ellipsoidal particle,\n  which is oriented by default with its x-axis along the simulation\n  box’s x-axis, and similarly for y and z.  If this body is rotated (via\n  the right-hand rule) by an angle theta around a unit rotation vector\n  (a,b,c), then the quaternion that represents its new orientation is\n  given by (cos(theta/2), a*sin(theta/2), b*sin(theta/2),\n  c*sin(theta/2)).  The theta and a,b,c values are the arguments to the\n  quat keyword.  LAMMPS normalizes the quaternion in case (a,b,c) was\n  not specified as a unit vector.  For 2d systems, the a,b,c values are\n  ignored, since a rotation vector of (0,0,1) is the only valid choice.\n  Keyword quat/random randomizes the orientation of the quaternion for\n  the selected atoms.  The particles must define a quaternion for their\n  orientation (e.g. ellipsoids, triangles, body particles) as defined by\n  the atom_style command.  Random numbers are used in\n  such a way that the orientation of a particular atom is the same,\n  regardless of how many processors are being used.  For 2d systems,\n  only orientations in the xy plane are generated.  As with keyword\n  quat, for ellipsoidal particles, the 3 shape values must be non-zero\n  for each particle set by this command.  This keyword does not allow\n  use of an atom-style variable.\n  Keyword diameter sets the size of the selected atoms.  The particles\n  must be finite-size spheres as defined by the atom_style sphere command.  The diameter of a particle can be\n  set to 0.0, which means they will be treated as point particles.  Note\n  that this command does not adjust the particle mass, even if it was\n  defined with a density, e.g. via the read_data\n  command.\n  Keyword shape sets the size and shape of the selected atoms.  The\n  particles must be ellipsoids as defined by the atom_style ellipsoid command.  The Sx, Sy, Sz settings are\n  the 3 diameters of the ellipsoid in each direction.  All 3 can be set\n  to the same value, which means the ellipsoid is effectively a sphere.\n  They can also all be set to 0.0 which means the particle will be\n  treated as a point particle.  Note that this command does not adjust\n  the particle mass, even if it was defined with a density, e.g. via the\n  read_data command.\n  Keyword length sets the length of selected atoms.  The particles\n  must be line segments as defined by the atom_style line command.  If the specified value is non-zero the\n  line segment is (re)set to a length = the specified value, centered\n  around the particle position, with an orientation along the x-axis.\n  If the specified value is 0.0, the particle will become a point\n  particle.  Note that this command does not adjust the particle mass,\n  even if it was defined with a density, e.g. via the\n  read_data command.\n  Keyword tri sets the size of selected atoms.  The particles must be\n  triangles as defined by the atom_style tri command.\n  If the specified value is non-zero the triangle is (re)set to be an\n  equilateral triangle in the xy plane with side length = the specified\n  value, with a centroid at the particle position, with its base\n  parallel to the x axis, and the y-axis running from the center of the\n  base to the top point of the triangle.  If the specified value is 0.0,\n  the particle will become a point particle.  Note that this command\n  does not adjust the particle mass, even if it was defined with a\n  density, e.g. via the read_data command.\n  Keyword theta sets the orientation of selected atoms.  The particles\n  must be line segments as defined by the atom_style line command.  The specified value is used to set the\n  orientation angle of the line segments with respect to the x axis.\n  Keyword theta/random randomizes the orientation of theta for the\n  selected atoms.  The particles must be line segments as defined by the\n  atom_style line command.  Random numbers are used in\n  such a way that the orientation of a particular atom is the same,\n  regardless of how many processors are being used.  This keyword does\n  not allow use of an atom-style variable.\n  Keyword angmom sets the angular momentum of selected atoms.  The\n  particles must be ellipsoids as defined by the atom_style ellipsoid command or triangles as defined by the\n  atom_style tri command.  The angular momentum vector\n  of the particles is set to the 3 specified components.\n  Keyword omega sets the angular velocity of selected atoms.  The\n  particles must be spheres as defined by the\n  atom_style sphere command.  The angular velocity\n  vector of the particles is set to the 3 specified components.\n  Keyword mass sets the mass of all selected particles.  The particles\n  must have a per-atom mass attribute, as defined by the\n  atom_style command.  See the “mass” command for how\n  to set mass values on a per-type basis.\n  Keyword density or density/disc also sets the mass of all selected\n  particles, but in a different way.  The particles must have a per-atom\n  mass attribute, as defined by the atom_style\n  command.  If the atom has a radius attribute (see atom_style sphere) and its radius is non-zero, its mass is set\n  from the density and particle volume for 3d systems (the input density\n  is assumed to be in mass/distance^3 units).  For 2d, the default is\n  for LAMMPS to model particles with a radius attribute as spheres.\n  However, if the density/disc keyword is used, then they can be\n  modeled as 2d discs (circles).  Their mass is set from the density and\n  particle area (the input density is assumed to be in mass/distance^2\n  units).\n  If the atom has a shape attribute (see atom_style ellipsoid) and its 3 shape parameters are non-zero,\n  then its mass is set from the density and particle volume (the input\n  density is assumed to be in mass/distance^3 units).  The\n  density/disc keyword has no effect; it does not (yet) treat 3d\n  ellipsoids as 2d ellipses.\n  If the atom has a length attribute (see atom_style line) and its length is non-zero, then its mass is\n  set from the density and line segment length (the input density is\n  assumed to be in mass/distance units).  If the atom has an area\n  attribute (see atom_style tri) and its area is\n  non-zero, then its mass is set from the density and triangle area (the\n  input density is assumed to be in mass/distance^2 units).\n  If none of these cases are valid, then the mass is set to the density\n  value directly (the input density is assumed to be in mass units).\n  Keyword volume sets the volume of all selected particles.\n  Currently, only the atom_style peri command defines\n  particles with a volume attribute.  Note that this command does not\n  adjust the particle mass.\n  Keyword image sets which image of the simulation box the atom is\n  considered to be in.  An image of 0 means it is inside the box as\n  defined.  A value of 2 means add 2 box lengths to get the true value.\n  A value of -1 means subtract 1 box length to get the true value.\n  LAMMPS updates these flags as atoms cross periodic boundaries during\n  the simulation.  The flags can be output with atom snapshots via the\n  dump command.  If a value of NULL is specified for any of\n  nx,ny,nz, then the current image value for that dimension is unchanged.\n  For non-periodic dimensions only a value of 0 can be specified.\n  This command can be useful after a system has been equilibrated and\n  atoms have diffused one or more box lengths in various directions.\n  This command can then reset the image values for atoms so that they\n  are effectively inside the simulation box, e.g if a diffusion\n  coefficient is about to be measured via the compute msd command.  Care should be taken not to reset the\n  image flags of two atoms in a bond to the same value if the bond\n  straddles a periodic boundary (rather they should be different by +/-\n  1).  This will not affect the dynamics of a simulation, but may mess\n  up analysis of the trajectories if a LAMMPS diagnostic or your own\n  analysis relies on the image flags to unwrap a molecule which\n  straddles the periodic box.\n  Keywords bond, angle, dihedral, and improper, set the bond\n  type (angle type, etc) of all bonds (angles, etc) of selected atoms to\n  the specified value from 1 to nbondtypes (nangletypes, etc).  All\n  atoms in a particular bond (angle, etc) must be selected atoms in\n  order for the change to be made.  The value of nbondtype (nangletypes,\n  etc) was set by the bond types (angle types, etc) field in the\n  header of the data file read by the read_data\n  command.  These keywords do not allow use of an atom-style variable.\n  Keywords meso/e, meso/cv, and meso/rho set the energy, heat\n  capacity, and density of smoothed particle hydrodynamics (SPH)\n  particles.  See this PDF guide to\n  using SPH in LAMMPS.\n  Keyword smd/mass/density sets the mass of all selected particles,\n  but it is only applicable to the Smooth Mach Dynamics package\n  USER-SMD.  It assumes that the particle volume has already been\n  correctly set and calculates particle mass from the provided mass\n  density value.\n  Keyword smd/contact/radius only applies to simulations with the\n  Smooth Mach Dynamics package USER-SMD.  Itsets an interaction radius\n  for computing short-range interactions, e.g. repulsive forces to\n  prevent different individual physical bodies from penetrating each\n  other. Note that the SPH smoothing kernel diameter used for computing\n  long range, nonlocal interactions, is set using the diameter\n  keyword.\n  Keyword dpd/theta sets the internal temperature of a DPD particle as\n  defined by the USER-DPD package.  If the specified value is a number\n  it must be >= 0.0.  If the specified value is NULL, then the kinetic\n  temperature Tkin of each particle is computed as 3/2 k Tkin = KE = 1/2\n  m v^2 = 1/2 m (vx*vx+vy*vy+vz*vz).  Each particle’s internal\n  temperature is set to Tkin.  If the specified value is an atom-style\n  variable, then the variable is evaluated for each particle.  If a\n  value >= 0.0, the internal temperature is set to that value.  If it is\n  < 0.0, the computation of Tkin is performed and the internal\n  temperature is set to that value.\n  Keywords edpd/temp and edpd/cv set the temperature and volumetric\n  heat capacity of an eDPD particle as defined by the USER-MESODPD package.\n  Currently, only atom_style edpd defines particles\n  with these attributes. The values for the temperature and heat\n  capacity must be positive.\n  Keyword cc sets the chemical concentration of a tDPD particle for a\n  specified species as defined by the USER-MESODPD package. Currently, only\n  atom_style tdpd defines particles with this\n  attribute. An integer for “index” selects a chemical species (1 to\n  Nspecies) where Nspecies is set by the atom_style command. The value\n  for the chemical concentration must be >= 0.0.\n  Keywords i_name and d_name refer to custom integer and\n  floating-point properties that have been added to each atom via the\n  fix property/atom command.  When that command\n  is used specific names are given to each attribute which are what is\n  specified as the “name” portion of i_name or d_name.\n  ",
    "syntax": "set style ID keyword values ...\n  \n  \n  \n  style = atom or type or mol or group or region\n  ID = atom ID range or type range or mol ID range or group ID or region ID\n  one or more keyword/value pairs may be appended\n  keyword = type or type/fraction or type/ratio or type/subset or mol or x or y or z or           charge or dipole or dipole/random or quat or           spin or spin/random or quat or           quat/random or diameter or shape or           length or tri or theta or theta/random or           angmom or omega or           mass or density or density/disc or volume or image or           bond or angle or dihedral or improper or           meso/e or meso/cv or meso/rho or           smd/contact/radius or smd/mass/density or dpd/theta or           edpd/temp or edpd/cv or cc or i_name or d_name\n  type value = atom type\n    value can be an atom-style variable (see below)\n  type/fraction values = type fraction seed\n    type = new atom type\n    fraction = approximate fraction of selected atoms to set to new atom type\n    seed = random # seed (positive integer)\n  type/ratio values = type fraction seed\n    type = new atom type\n    fraction = exact fraction of selected atoms to set to new atom type\n    seed = random # seed (positive integer)\n  type/subset values = type Nsubset seed\n    type = new atom type\n    Nsubset = exact number of selected atoms to set to new atom type\n    seed = random # seed (positive integer)\n  mol value = molecule ID\n    value can be an atom-style variable (see below)\n  x,y,z value = atom coordinate (distance units)\n    value can be an atom-style variable (see below)\n  vx,vy,vz value = atom velocity (velocity units)\n    value can be an atom-style variable (see below)\n  charge value = atomic charge (charge units)\n    value can be an atom-style variable (see below)\n  dipole values = x y z\n    x,y,z = orientation of dipole moment vector\n    any of x,y,z can be an atom-style variable (see below)\n  dipole/random value = seed Dlen\n    seed = random # seed (positive integer) for dipole moment orientations\n    Dlen = magnitude of dipole moment (dipole units)\n  spin values = g x y z\n    g = magnitude of magnetic spin vector (in Bohr magneton's unit)\n    x,y,z = orientation of magnetic spin vector\n    any of x,y,z can be an atom-style variable (see below)\n  spin/random value = seed Dlen\n    seed = random # seed (positive integer) for magnetic spin orientations\n    Dlen = magnitude of magnetic spin vector (in Bohr magneton's unit)\n  quat values = a b c theta\n    a,b,c = unit vector to rotate particle around via right-hand rule\n    theta = rotation angle (degrees)\n    any of a,b,c,theta can be an atom-style variable (see below)\n  quat/random value = seed\n    seed = random # seed (positive integer) for quaternion orientations\n  diameter value = diameter of spherical particle (distance units)\n    value can be an atom-style variable (see below)\n  shape value = Sx Sy Sz\n    Sx,Sy,Sz = 3 diameters of ellipsoid (distance units)\n  length value = len\n    len = length of line segment (distance units)\n    len can be an atom-style variable (see below)\n  tri value = side\n    side = side length of equilateral triangle (distance units)\n    side can be an atom-style variable (see below)\n  theta value = angle (degrees)\n    angle = orientation of line segment with respect to x-axis\n    angle can be an atom-style variable (see below)\n  theta/random value = seed\n    seed = random # seed (positive integer) for line segment orienations\n  angmom values = Lx Ly Lz\n    Lx,Ly,Lz = components of angular momentum vector (distance-mass-velocity units)\n    any of Lx,Ly,Lz can be an atom-style variable (see below)\n  omega values = Wx Wy Wz\n    Wx,Wy,Wz = components of angular velocity vector (radians/time units)\n    any of wx,wy,wz can be an atom-style variable (see below)\n  mass value = per-atom mass (mass units)\n    value can be an atom-style variable (see below)\n  density value = particle density for a sphere or ellipsoid (mass/distance^3 units), or for a triangle (mass/distance^2 units) or line (mass/distance units) particle\n    value can be an atom-style variable (see below)\n  density/disc value = particle density for a 2d disc or ellipse (mass/distance^2 units)\n    value can be an atom-style variable (see below)\n  volume value = particle volume for Peridynamic particle (distance^3 units)\n    value can be an atom-style variable (see below)\n  image nx ny nz\n    nx,ny,nz = which periodic image of the simulation box the atom is in\n    any of nx,ny,nz can be an atom-style variable (see below)\n  bond value = bond type for all bonds between selected atoms\n  angle value = angle type for all angles between selected atoms\n  dihedral value = dihedral type for all dihedrals between selected atoms\n  improper value = improper type for all impropers between selected atoms\n  meso/e value = energy of SPH particles (need units)\n    value can be an atom-style variable (see below)\n  meso/cv value = heat capacity of SPH particles (need units)\n    value can be an atom-style variable (see below)\n  meso/rho value = density of SPH particles (need units)\n    value can be an atom-style variable (see below)\n  smd/contact/radius = radius for short range interactions, i.e. contact and friction\n    value can be an atom-style variable (see below)\n  smd/mass/density = set particle mass based on volume by providing a mass density\n    value can be an atom-style variable (see below)\n  dpd/theta value = internal temperature of DPD particles (temperature units)\n    value can be an atom-style variable (see below)\n    value can be NULL which sets internal temp of each particle to KE temp\n  edpd/temp value = temperature of eDPD particles (temperature units)\n    value can be an atom-style variable (see below)\n  edpd/cv value = volumetric heat capacity of eDPD particles (energy/temperature/volume units)\n    value can be an atom-style variable (see below)\n  cc values = index cc\n    index = index of a chemical species (1 to Nspecies)\n    cc = chemical concentration of tDPD particles for a species (mole/volume units)\n  i_name value = value for custom integer vector with name\n  d_name value = value for custom floating-point vector with name\n  \n  \n  ",
    "examples": "set group solvent type 2\n  set group solvent type/fraction 2 0.5 12393\n  set group edge bond 4\n  set region half charge 0.5\n  set type 3 charge 0.5\n  set type 1*3 charge 0.5\n  set atom * charge v_atomfile\n  set atom 100*200 x 0.5 y 1.0\n  set atom 100 vx 0.0 vy 0.0 vz -1.0\n  set atom 1492 type 3\n  \n  \n  ",
    "restrictions": "You cannot set an atom attribute (e.g. mol or q or volume) if\n  the atom_style does not have that attribute.\n  This command requires inter-processor communication to coordinate the\n  setting of bond types (angle types, etc).  This means that your system\n  must be ready to perform a simulation before using one of these\n  keywords (force fields set, atom mass set, etc).  This is not\n  necessary for other keywords.\n  Using the region style with the bond (angle, etc) keywords can give\n  unpredictable results if there are bonds (angles, etc) that straddle\n  periodic boundaries.  This is because the region may only extend up to\n  the boundary and partner atoms in the bond (angle, etc) may have\n  coordinates outside the simulation box if they are ghost atoms.\n  "
},
{
    "command": "shell",
    "description": "Execute a shell command.  A few simple file-based shell commands are\n  supported directly, in Unix-style syntax.  Any command not listed\n  above is passed as-is to the C-library system() call, which invokes\n  the command in a shell.\n  This is means to invoke other commands from your input script.  For\n  example, you can move files around in preparation for the next section\n  of the input script.  Or you can run a program that pre-processes data\n  for input into LAMMPS.  Or you can run a program that post-processes\n  LAMMPS output data.\n  With the exception of cd, all commands, including ones invoked via a\n  system() call, are executed by only a single processor, so that\n  files/directories are not being manipulated by multiple processors.\n  The cd command executes the Unix “cd” command to change the working\n  directory.  All subsequent LAMMPS commands that read/write files will\n  use the new directory.  All processors execute this command.\n  The mkdir command executes the Unix “mkdir” command to create one or\n  more directories.\n  The mv command executes the Unix “mv” command to rename a file and/or\n  move it to a new directory.\n  The rm command executes the Unix “rm” command to remove one or more\n  files.\n  The rmdir command executes the Unix “rmdir” command to remove one or\n  more directories.  A directory must be empty to be successfully\n  removed.\n  The putenv command defines or updates an environment variable directly.\n  Since this command does not pass through the shell, no shell variable\n  expansion or globbing is performed, only the usual substitution for\n  LAMMPS variables defined with the variable command is\n  performed.  The resulting string is then used literally.\n  Any other command is passed as-is to the shell along with its arguments as\n  one string, invoked by the C-library system() call.  For example,\n  these lines in your input script:\n  variable n equal 10\n  variable foo string file2\n  shell my_setup file1 $n ${foo}\n  \n  \n  would be the same as invoking\n  % my_setup file1 10 file2\n  \n  \n  from a command-line prompt.  The executable program “my_setup” is run\n  with 3 arguments: file1 10 file2.\n  ",
    "syntax": "shell command args\n  \n  \n  \n  command = cd or mkdir or mv or rm or rmdir or putenv or arbitrary command\n  cd arg = dir\n    dir = directory to change to\n  mkdir args = dir1 dir2 ...\n    dir1,dir2 = one or more directories to create\n  mv args = old new\n    old = old filename\n    new = new filename\n  rm args = file1 file2 ...\n    file1,file2 = one or more filenames to delete\n  rmdir args = dir1 dir2 ...\n    dir1,dir2 = one or more directories to delete\n  putenv args = var1=value1 var2=value2\n    var=value = one of more definitions of environment variables\n  anything else is passed as a command to the shell for direct execution\n  \n  \n  ",
    "examples": "shell cd sub1\n  shell cd ..\n  shell mkdir tmp1 tmp2 tmp3\n  shell rmdir tmp1\n  shell mv log.lammps hold/log.1\n  shell rm TMP/file1 TMP/file2\n  shell putenv LAMMPS_POTENTIALS=../../potentials\n  shell my_setup file1 10 file2\n  shell my_post_process 100 dump.out\n  \n  \n  ",
    "restrictions": "LAMMPS does not detect errors or print warnings when any of these\n  commands execute.  E.g. if the specified directory does not exist,\n  executing the cd command will silently do nothing.\n  Related commands: none\n  Default: none\n  "
},
{
    "command": "special_bonds",
    "description": "Set weighting coefficients for pairwise energy and force contributions\n  between pairs of atoms that are also permanently bonded to each other,\n  either directly or via one or two intermediate bonds.  These weighting\n  factors are used by nearly all pair styles in LAMMPS\n  that compute simple pairwise interactions.  Permanent bonds between\n  atoms are specified by defining the bond topology in the data file\n  read by the read_data command.  Typically a\n  bond_style command is also used to define a bond\n  potential.  The rationale for using these weighting factors is that\n  the interaction between a pair of bonded atoms is all (or mostly)\n  specified by the bond, angle, dihedral potentials, and thus the\n  non-bonded Lennard-Jones or Coulombic interaction between the pair of\n  atoms should be excluded (or reduced by a weighting factor).\n  \n  Note\n  These weighting factors are NOT used by pair styles that compute many-body interactions, since the\n  “bonds” that result from such interactions are not permanent, but are\n  created and broken dynamically as atom conformations change.  Examples\n  of pair styles in this category are EAM, MEAM, Stillinger-Weber,\n  Tersoff, COMB, AIREBO, and ReaxFF.  In fact, it generally makes no\n  sense to define permanent bonds between atoms that interact via these\n  potentials, though such bonds may exist elsewhere in your system,\n  e.g. when using the pair_style hybrid command.\n  Thus LAMMPS ignores special_bonds settings when many-body potentials\n  are calculated.  Please note, that the existence of explicit bonds\n  for atoms that are described by a many-body potential will alter the\n  neighbor list and thus can render the computation of those interactions\n  invalid, since those pairs are not only used to determine direct\n  pairwise interactions but also neighbors of neighbors and more.\n  The recommended course of action is to remove such bonds, or - if\n  that is not possible - use a special bonds setting of 1.0 1.0 1.0.\n  \n  \n  Note\n  Unlike some commands in LAMMPS, you cannot use this command\n  multiple times in an incremental fashion: e.g. to first set the LJ\n  settings and then the Coulombic ones.  Each time you use this command\n  it sets all the coefficients to default values and only overrides the\n  one you specify, so you should set all the options you need each time\n  you use it.  See more details at the bottom of this page.\n  \n  The Coulomb factors are applied to any Coulomb (charge interaction)\n  term that the potential calculates.  The LJ factors are applied to the\n  remaining terms that the potential calculates, whether they represent\n  LJ interactions or not.  The weighting factors are a scaling\n  pre-factor on the energy and force between the pair of atoms.  A value\n  of 1.0 means include the full interaction; a value of 0.0 means\n  exclude it completely.\n  The 1st of the 3 coefficients (LJ or Coulombic) is the weighting\n  factor on 1-2 atom pairs, which are pairs of atoms directly bonded to\n  each other.  The 2nd coefficient is the weighting factor on 1-3 atom\n  pairs which are those separated by 2 bonds (e.g. the two H atoms in a\n  water molecule).  The 3rd coefficient is the weighting factor on 1-4\n  atom pairs which are those separated by 3 bonds (e.g. the 1st and 4th\n  atoms in a dihedral interaction).  Thus if the 1-2 coefficient is set\n  to 0.0, then the pairwise interaction is effectively turned off for\n  all pairs of atoms bonded to each other.  If it is set to 1.0, then\n  that interaction will be at full strength.\n  \n  Note\n  For purposes of computing weighted pairwise interactions, 1-3\n  and 1-4 interactions are not defined from the list of angles or\n  dihedrals used by the simulation.  Rather, they are inferred\n  topologically from the set of bonds specified when the simulation is\n  defined from a data or restart file (see read_data or\n  read_restart commands).  Thus the set of\n  1-2,1-3,1-4 interactions that the weights apply to is the same whether\n  angle and dihedral potentials are computed or not, and remains the\n  same even if bonds are constrained, or turned off, or removed during a\n  simulation.\n  \n  The two exceptions to this rule are (a) if the angle or dihedral\n  keywords are set to yes (see below), or (b) if the\n  delete_bonds command is used with the special\n  option that re-computes the 1-2,1-3,1-4 topologies after bonds are\n  deleted; see the delete_bonds command for more\n  details.\n  The amber keyword sets the 3 coefficients to 0.0, 0.0, 0.5 for LJ\n  interactions and to 0.0, 0.0, 0.8333 for Coulombic interactions, which\n  is the default for a commonly used version of the AMBER force field,\n  where the last value is really 5/6.  See (Cornell) for a\n  description of the AMBER force field.\n  The charmm keyword sets the 3 coefficients to 0.0, 0.0, 0.0 for both\n  LJ and Coulombic interactions, which is the default for a commonly\n  used version of the CHARMM force field.  Note that in pair styles\n  lj/charmm/coul/charmm and lj/charmm/coul/long the 1-4 coefficients\n  are defined explicitly, and these pairwise contributions are computed\n  as part of the charmm dihedral style - see the\n  pair_coeff and dihedral_style\n  commands for more information.  See (MacKerell) for a\n  description of the CHARMM force field.\n  The dreiding keyword sets the 3 coefficients to 0.0, 0.0, 1.0 for both\n  LJ and Coulombic interactions, which is the default for the Dreiding\n  force field, as discussed in (Mayo).\n  The fene keyword sets the 3 coefficients to 0.0, 1.0, 1.0 for both\n  LJ and Coulombic interactions, which is consistent with a\n  coarse-grained polymer model with FENE bonds.  See\n  (Kremer) for a description of FENE bonds.\n  The lj/coul, lj, and coul keywords allow the 3 coefficients to\n  be set explicitly.  The lj/coul keyword sets both the LJ and\n  Coulombic coefficients to the same 3 values.  The lj and coul\n  keywords only set either the LJ or Coulombic coefficients.  Use both\n  of them if you wish to set the LJ coefficients to different values\n  than the Coulombic coefficients.\n  The angle keyword allows the 1-3 weighting factor to be ignored for\n  individual atom pairs if they are not listed as the first and last\n  atoms in any angle defined in the simulation or as 1,3 or 2,4 atoms in\n  any dihedral defined in the simulation.  For example, imagine the 1-3\n  weighting factor is set to 0.5 and you have a linear molecule with 4\n  atoms and bonds as follows: 1-2-3-4.  If your data file defines 1-2-3\n  as an angle, but does not define 2-3-4 as an angle or 1-2-3-4 as a\n  dihedral, then the pairwise interaction between atoms 1 and 3 will\n  always be weighted by 0.5, but different force fields use different\n  rules for weighting the pairwise interaction between atoms 2 and 4.\n  If the angle keyword is specified as yes, then the pairwise\n  interaction between atoms 2 and 4 will be unaffected (full weighting\n  of 1.0).  If the angle keyword is specified as no which is the\n  default, then the 2,4 interaction will also be weighted by 0.5.\n  The dihedral keyword allows the 1-4 weighting factor to be ignored\n  for individual atom pairs if they are not listed as the first and last\n  atoms in any dihedral defined in the simulation.  For example, imagine\n  the 1-4 weighting factor is set to 0.5 and you have a linear molecule\n  with 5 atoms and bonds as follows: 1-2-3-4-5.  If your data file\n  defines 1-2-3-4 as a dihedral, but does not define 2-3-4-5 as a\n  dihedral, then the pairwise interaction between atoms 1 and 4 will\n  always be weighted by 0.5, but different force fields use different\n  rules for weighting the pairwise interaction between atoms 2 and 5.\n  If the dihedral keyword is specified as yes, then the pairwise\n  interaction between atoms 2 and 5 will be unaffected (full weighting\n  of 1.0).  If the dihedral keyword is specified as no which is the\n  default, then the 2,5 interaction will also be weighted by 0.5.\n  \n  \n  Note\n  LAMMPS stores and maintains a data structure with a list of the\n  1st, 2nd, and 3rd neighbors of each atom (within the bond topology of\n  the system).  If new bonds are created (or molecules added containing\n  atoms with more special neighbors), the size of this list needs to\n  grow.  Note that adding a single bond always adds a new 1st neighbor\n  but may also induce *many* new 2nd and 3rd neighbors, depending on the\n  molecular topology of your system.  Using the extra/special/per/atom\n  keyword to either read_data or create_box\n  reserves empty space in the list for this N additional 1st, 2nd, or 3rd\n  neighbors to be added.  If you do not do this, you may get an error\n  when bonds (or molecules) are added.\n  \n  \n  \n  Note\n  If you reuse this command in an input script, you should set all\n  the options you need each time.  This command cannot be used a 2nd\n  time incrementally.  E.g. these two commands:\n  \n  special_bonds lj 0.0 1.0 1.0\n  special_bonds coul 0.0 0.0 1.0\n  \n  \n  are not the same as\n  special_bonds lj 0.0 1.0 1.0 coul 0.0 0.0 1.0\n  \n  \n  In the first case you end up with (after the 2nd command):\n  LJ: 0.0 0.0 0.0\n  Coul: 0.0 0.0 1.0\n  \n  \n  while only in the second case, you get the desired settings of:\n  LJ: 0.0 1.0 1.0\n  Coul: 0.0 0.0 1.0\n  \n  \n  This happens because the LJ (and Coul) settings are reset to\n  their default values before modifying them, each time the\n  special_bonds command is issued.\n  ",
    "syntax": "special_bonds keyword values ...\n  \n  \n  \n  one or more keyword/value pairs may be appended\n  keyword = amber or charmm or dreiding or fene or lj/coul or lj or coul or angle or dihedral\n  amber values = none\n  charmm values = none\n  dreiding values = none\n  fene values = none\n  lj/coul values = w1,w2,w3\n    w1,w2,w3 = weights (0.0 to 1.0) on pairwise Lennard-Jones and Coulombic interactions\n  lj values = w1,w2,w3\n    w1,w2,w3 = weights (0.0 to 1.0) on pairwise Lennard-Jones interactions\n  coul values = w1,w2,w3\n    w1,w2,w3 = weights (0.0 to 1.0) on pairwise Coulombic interactions\n  angle value = yes or no\n  dihedral value = yes or no\n  \n  \n  Examples:\n  special_bonds amber\n  special_bonds charmm\n  special_bonds fene dihedral no\n  special_bonds lj/coul 0.0 0.0 0.5 angle yes dihedral yes\n  special_bonds lj 0.0 0.0 0.5 coul 0.0 0.0 0.0 dihedral yes\n  \n  \n  ",
    "examples": "shell cd sub1\n  shell cd ..\n  shell mkdir tmp1 tmp2 tmp3\n  shell rmdir tmp1\n  shell mv log.lammps hold/log.1\n  shell rm TMP/file1 TMP/file2\n  shell putenv LAMMPS_POTENTIALS=../../potentials\n  shell my_setup file1 10 file2\n  shell my_post_process 100 dump.out\n  \n  \n  ",
    "restrictions": "none\n  "
},
{
    "command": "suffix",
    "description": "This command allows you to use variants of various styles if they\n  exist.  In that respect it operates the same as the -suffix command-line switch.  It also has options to turn\n  off or back on any suffix setting made via the command line.\n  The specified style can be gpu, intel, kk, omp, opt or\n  hybrid. These refer to optional packages that LAMMPS can be built\n  with, as described on the Build package doc page.\n  The “gpu” style corresponds to the GPU package, the “intel” style to\n  the USER-INTEL package, the “kk” style to the KOKKOS package, the\n  “omp” style to the USER-OMP package, and the “opt” style to the OPT\n  package.\n  These are the variants these packages provide:\n  \n  GPU = a handful of pair styles and the PPPM kspace_style, optimized to\n  run on one or more GPUs or multicore CPU/GPU nodes\n  USER-INTEL = a collection of pair styles and neighbor routines\n  optimized to run in single, mixed, or double precision on CPUs and\n  Intel(R) Xeon Phi(TM) co-processors.\n  KOKKOS = a collection of atom, pair, and fix styles optimized to run\n  using the Kokkos library on various kinds of hardware, including GPUs\n  via CUDA and many-core chips via OpenMP or threading.\n  USER-OMP = a collection of pair, bond, angle, dihedral, improper,\n  kspace, compute, and fix styles with support for OpenMP\n  multi-threading\n  OPT = a handful of pair styles, cache-optimized for faster CPU\n  performance\n  HYBRID = a combination of two packages can be specified (see below)\n  \n  As an example, all of the packages provide a pair_style lj/cut variant, with style names lj/cut/opt, lj/cut/omp,\n  lj/cut/gpu, lj/cut/intel, or lj/cut/kk.  A variant styles\n  can be specified explicitly in your input script, e.g. pair_style\n  lj/cut/gpu. If the suffix command is used with the appropriate style,\n  you do not need to modify your input script.  The specified suffix\n  (opt,omp,gpu,intel,kk) is automatically appended whenever your\n  input script command creates a new atom,\n  pair, bond,\n  angle, dihedral,\n  improper, kspace,\n  fix, compute, or run style.\n  If the variant version does not exist, the standard version is\n  created.\n  For “hybrid”, two packages are specified. The first is used whenever\n  available. If a style with the first suffix is not available, the style\n  with the suffix for the second package will be used if available. For\n  example, “hybrid intel omp” will use styles from the USER-INTEL package\n  as a first choice and styles from the USER-OMP package as a second choice\n  if no USER-INTEL variant is available.\n  If the specified style is off, then any previously specified suffix\n  is temporarily disabled, whether it was specified by a command-line\n  switch or a previous suffix command.  If the specified style is on,\n  a disabled suffix is turned back on.  The use of these 2 commands lets\n  your input script use a standard LAMMPS style (i.e. a non-accelerated\n  variant), which can be useful for testing or benchmarking purposes.\n  Of course this is also possible by not using any suffix commands, and\n  explicitly appending or not appending the suffix to the relevant\n  commands in your input script.\n  \n  Note\n  The default run_style verlet is invoked prior to\n  reading the input script and is therefore not affected by a suffix command\n  in the input script. The KOKKOS package requires “run_style verlet/kk”,\n  so when using the KOKKOS package it is necessary to either use the command\n  line “-sf kk” command or add an explicit “run_style verlet” command to the\n  input script.\n  \n  ",
    "syntax": "suffix style args\n  \n  \n  \n  style = off or on or gpu or intel or kk or omp or opt or hybrid\n  args = for hybrid style, default suffix to be used and alternative suffix\n  \n  ",
    "examples": "suffix off\n  suffix on\n  suffix gpu\n  suffix intel\n  suffix hybrid intel omp\n  suffix kk\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "tad",
    "description": "Run a temperature accelerated dynamics (TAD) simulation. This method\n  requires two or more partitions to perform NEB transition state\n  searches.\n  TAD is described in this paper by Art Voter.  It is a method\n  that uses accelerated dynamics at an elevated temperature to generate\n  results at a specified lower temperature.  A good overview of\n  accelerated dynamics methods for such systems is given in this review paper from the same group. In general, these methods assume\n  that the long-time dynamics is dominated by infrequent events i.e. the\n  system is confined to low energy basins for long periods,\n  punctuated by brief, randomly-occurring transitions to adjacent\n  basins.  TAD is suitable for infrequent-event systems, where in\n  addition, the transition kinetics are well-approximated by harmonic\n  transition state theory (hTST). In hTST, the temperature dependence of\n  transition rates follows the Arrhenius relation.  As a consequence a\n  set of event times generated in a high-temperature simulation can be\n  mapped to a set of much longer estimated times in the low-temperature\n  system. However, because this mapping involves the energy barrier of\n  the transition event, which is different for each event, the first\n  event at the high temperature may not be the earliest event at the low\n  temperature. TAD handles this by first generating a set of possible\n  events from the current basin. After each event, the simulation is\n  reflected backwards into the current basin.  This is repeated until\n  the stopping criterion is satisfied, at which point the event with the\n  earliest low-temperature occurrence time is selected.  The stopping\n  criterion is that the confidence measure be greater than\n  1-delta. The confidence measure is the probability that no earlier\n  low-temperature event will occur at some later time in the\n  high-temperature simulation.  hTST provides an lower bound for this\n  probability, based on the user-specified minimum pre-exponential\n  factor (reciprocal of tmax).\n  In order to estimate the energy barrier for each event, the TAD method\n  invokes the NEB method. Each NEB replica runs on a\n  partition of processors. The current NEB implementation in LAMMPS\n  restricts you to having exactly one processor per replica. For more\n  information, see the documentation for the neb command.  In\n  the current LAMMPS implementation of TAD, all the non-NEB TAD\n  operations are performed on the first partition, while the other\n  partitions remain idle. See the Howto replica doc\n  page for further discussion of multi-replica simulations.\n  A TAD run has several stages, which are repeated each time an event is\n  performed.  The logic for a TAD run is as follows:\n  while (time remains):\n    while (time < tstop):\n      until (event occurs):\n        run dynamics for t_event steps\n        quench\n      run neb calculation using all replicas\n      compute tlo from energy barrier\n      update earliest event\n      update tstop\n      reflect back into current basin\n    execute earliest event\n  \n  \n  Before this outer loop begins, the initial potential energy basin is\n  identified by quenching (an energy minimization, see below) the\n  initial state and storing the resulting coordinates for reference.\n  Inside the inner loop, dynamics is run continuously according to\n  whatever integrator has been specified by the user, stopping every\n  t_event steps to check if a transition event has occurred.  This\n  check is performed by quenching the system and comparing the resulting\n  atom coordinates to the coordinates from the previous basin.\n  A quench is an energy minimization and is performed by whichever\n  algorithm has been defined by the min_style command;\n  its default is the CG minimizer.  The tolerances and limits for each\n  quench can be set by the min keyword.  Note that typically, you do\n  not need to perform a highly-converged minimization to detect a\n  transition event.\n  The event check is performed by a compute with the specified\n  compute-ID.  Currently there is only one compute that works with the\n  TAD command, which is the compute event/displace command.  Other\n  event-checking computes may be added.  Compute event/displace checks whether any atom in\n  the compute group has moved further than a specified threshold\n  distance.  If so, an “event” has occurred.\n  The NEB calculation is similar to that invoked by the neb\n  command, except that the final state is generated internally, instead\n  of being read in from a file.  The style of minimization performed by\n  NEB is determined by the neb_style keyword and must be a damped\n  dynamics minimizer.  The tolerances and limits for each NEB\n  calculation can be set by the neb keyword.  As discussed on the\n  neb, it is often advantageous to use a larger timestep for\n  NEB than for normal dynamics.  Since the size of the timestep set by\n  the timestep command is used by TAD for performing\n  dynamics, there is a neb_step keyword which can be used to set a\n  larger timestep for each NEB calculation if desired.\n  \n  A key aspect of the TAD method is setting the stopping criterion\n  appropriately.  If this criterion is too conservative, then many\n  events must be generated before one is finally executed.  Conversely,\n  if this criterion is too aggressive, high-entropy high-barrier events\n  will be over-sampled, while low-entropy low-barrier events will be\n  under-sampled. If the lowest pre-exponential factor is known fairly\n  accurately, then it can be used to estimate tmax, and the value of\n  delta can be set to the desired confidence level e.g. delta = 0.05\n  corresponds to 95% confidence. However, for systems where the dynamics\n  are not well characterized (the most common case), it will be\n  necessary to experiment with the values of delta and tmax to get a\n  good trade-off between accuracy and performance.\n  A second key aspect is the choice of t_hi. A larger value greatly\n  increases the rate at which new events are generated.  However, too\n  large a value introduces errors due to anharmonicity (not accounted\n  for within hTST). Once again, for any given system, experimentation is\n  necessary to determine the best value of t_hi.\n  \n  Five kinds of output can be generated during a TAD run: event\n  statistics, NEB statistics, thermodynamic output by each replica, dump\n  files, and restart files.\n  Event statistics are printed to the screen and master log.lammps file\n  each time an event is executed. The quantities are the timestep, CPU\n  time, global event number N, local event number M, event status,\n  energy barrier, time margin, t_lo and delt_lo.  The timestep is\n  the usual LAMMPS timestep, which corresponds to the high-temperature\n  time at which the event was detected, in units of timestep.  The CPU\n  time is the total processor time since the start of the TAD run.  The\n  global event number N is a counter that increments with each\n  executed event. The local event number M is a counter that resets to\n  zero upon entering each new basin.  The event status is E when an\n  event is executed, and is D for an event that is detected, while\n  DF is for a detected event that is also the earliest (first) event\n  at the low temperature.\n  The time margin is the ratio of the high temperature time in the\n  current basin to the stopping time. This last number can be used to\n  judge whether the stopping time is too short or too long (see above).\n  t_lo is the low-temperature event time when the current basin was\n  entered, in units of timestep.  del*t_lo* is the time of each detected\n  event, measured relative to t_lo.  delt_lo is equal to the\n  high-temperature time since entering the current basin, scaled by an\n  exponential factor that depends on the hi/lo temperature ratio and the\n  energy barrier for that event.\n  On lines for executed events, with status E, the global event number\n  is incremented by one,\n  the local event number and time margin are reset to zero,\n  while the global event number, energy barrier, and\n  delt_lo match the last event with status DF\n  in the immediately preceding block of detected events.\n  The low-temperature event time t_lo is incremented by delt_lo.\n  NEB statistics are written to the file specified by the neb_log\n  keyword. If the keyword value is “none”, then no NEB statistics are\n  printed out. The statistics are written every Nevery timesteps.  See\n  the neb command for a full description of the NEB\n  statistics. When invoked from TAD, NEB statistics are never printed to\n  the screen.\n  Because the NEB calculation must run on multiple partitions, LAMMPS\n  produces additional screen and log files for each partition,\n  e.g. log.lammps.0, log.lammps.1, etc. For the TAD command, these\n  contain the thermodynamic output of each NEB replica. In addition, the\n  log file for the first partition, log.lammps.0, will contain\n  thermodynamic output from short runs and minimizations corresponding\n  to the dynamics and quench operations, as well as a line for each new\n  detected event, as described above.\n  After the TAD command completes, timing statistics for the TAD run are\n  printed in each replica’s log file, giving a breakdown of how much CPU\n  time was spent in each stage (NEB, dynamics, quenching, etc).\n  Any dump files defined in the input script will be written\n  to during a TAD run at timesteps when an event is executed.  This\n  means the requested dump frequency in the dump command\n  is ignored.  There will be one dump file (per dump command) created\n  for all partitions.  The atom coordinates of the dump snapshot are\n  those of the minimum energy configuration resulting from quenching\n  following the executed event.  The timesteps written into the dump\n  files correspond to the timestep at which the event occurred and NOT\n  the clock.  A dump snapshot corresponding to the initial minimum state\n  used for event detection is written to the dump file at the beginning\n  of each TAD run.\n  If the restart command is used, a single restart file\n  for all the partitions is generated, which allows a TAD run to be\n  continued by a new input script in the usual manner.  The restart file\n  is generated after an event is executed. The restart file contains a\n  snapshot of the system in the new quenched state, including the event\n  number and the low-temperature time.  The restart frequency specified\n  in the restart command is interpreted differently when\n  performing a TAD run.  It does not mean the timestep interval between\n  restart files.  Instead it means an event interval for executed\n  events.  Thus a frequency of 1 means write a restart file every time\n  an event is executed.  A frequency of 10 means write a restart file\n  every 10th executed event.  When an input script reads a restart file\n  from a previous TAD run, the new script can be run on a different\n  number of replicas or processors.\n  Note that within a single state, the dynamics will typically\n  temporarily continue beyond the event that is ultimately chosen, until\n  the stopping criterion is satisfied.  When the event is eventually\n  executed, the timestep counter is reset to the value when the event\n  was detected. Similarly, after each quench and NEB minimization, the\n  timestep counter is reset to the value at the start of the\n  minimization. This means that the timesteps listed in the replica log\n  files do not always increase monotonically. However, the timestep\n  values printed to the master log file, dump files, and restart files\n  are always monotonically increasing.\n  ",
    "syntax": "tad N t_event T_lo T_hi delta tmax compute-ID keyword value ...\n  \n  \n  \n  N = # of timesteps to run (not including dephasing/quenching)\n  t_event = timestep interval between event checks\n  T_lo = temperature at which event times are desired\n  T_hi = temperature at which MD simulation is performed\n  delta = desired confidence level for stopping criterion\n  tmax = reciprocal of lowest expected pre-exponential factor (time units)\n  compute-ID = ID of the compute used for event detection\n  zero or more keyword/value pairs may be appended\n  keyword = min or neb or min_style or neb_style or neb_log\n  min values = etol ftol maxiter maxeval\n    etol = stopping tolerance for energy (energy units)\n    ftol = stopping tolerance for force (force units)\n    maxiter = max iterations of minimize\n    maxeval = max number of force/energy evaluations\n  neb values = ftol N1 N2 Nevery\n    etol = stopping tolerance for energy (energy units)\n    ftol = stopping tolerance for force (force units)\n    N1 = max # of iterations (timesteps) to run initial NEB\n    N2 = max # of iterations (timesteps) to run barrier-climbing NEB\n    Nevery = print NEB statistics every this many timesteps\n  neb_style value = quickmin or fire\n  neb_step value = dtneb\n    dtneb = timestep for NEB damped dynamics minimization\n  neb_log value = file where NEB statistics are printed\n  \n  \n  ",
    "examples": "tad 2000 50 1800 2300 0.01 0.01 event\n  tad 2000 50 1800 2300 0.01 0.01 event &\n      min 1e-05 1e-05 100 100 &\n      neb 0.0 0.01 200 200 20 &\n      min_style cg &\n      neb_style fire &\n      neb_log log.neb\n  \n  \n  ",
    "restrictions": "This command can only be used if LAMMPS was built with the REPLICA\n  package.  See the Build package doc\n  page for more info.\n  N setting must be integer multiple of t_event.\n  Runs restarted from restart files written during a TAD run will only\n  produce identical results if the user-specified integrator supports\n  exact restarts. So fix nvt will produce an exact\n  restart, but fix langevin will not.\n  This command cannot be used when any fixes are defined that keep track\n  of elapsed time to perform time-dependent operations.  Examples\n  include the “ave” fixes such as fix ave/chunk.\n  Also fix dt/reset and fix deposit.\n  "
},
{
    "command": "temper",
    "description": "Run a parallel tempering or replica exchange simulation using multiple\n  replicas (ensembles) of a system.  Two or more replicas must be used.\n  Each replica runs on a partition of one or more processors.  Processor\n  partitions are defined at run-time using the -partition command-line switch.  Note that if you have MPI installed, you\n  can run a multi-replica simulation with more replicas (partitions)\n  than you have physical processors, e.g you can run a 10-replica\n  simulation on one or two processors.  You will simply not get the\n  performance speed-up you would see with one or more physical\n  processors per replica.  See the Howto replica\n  doc page for further discussion.\n  Each replica’s temperature is controlled at a different value by a fix\n  with fix-ID that controls temperature. Most thermostat fix styles\n  (with and without included time integration) are supported. The command\n  will print an error message and abort, if the chosen fix is unsupported.\n  The desired temperature is specified by temp, which is typically a\n  variable previously set in the input script, so that each partition is\n  assigned a different temperature.  See the variable\n  command for more details.  For example:\n  variable t world 300.0 310.0 320.0 330.0\n  fix myfix all nvt temp $t $t 100.0\n  temper 100000 100 $t myfix 3847 58382\n  \n  \n  would define 4 temperatures, and assign one of them to the thermostat\n  used by each replica, and to the temper command.\n  As the tempering simulation runs for N timesteps, a temperature swap\n  between adjacent ensembles will be attempted every M timesteps.  If\n  seed1 is 0, then the swap attempts will alternate between odd and\n  even pairings.  If seed1 is non-zero then it is used as a seed in a\n  random number generator to randomly choose an odd or even pairing each\n  time.  Each attempted swap of temperatures is either accepted or\n  rejected based on a Boltzmann-weighted Metropolis criterion which uses\n  seed2 in the random number generator.\n  As a tempering run proceeds, multiple log files and screen output\n  files are created, one per replica.  By default these files are named\n  log.lammps.M and screen.M where M is the replica number from 0 to N-1,\n  with N = # of replicas.  See the -log and -screen command-line swiches for info on how to change these names.\n  The main screen and log file (log.lammps) will list information about\n  which temperature is assigned to each replica at each thermodynamic\n  output timestep.  E.g. for a simulation with 16 replicas:\n  Running on 16 partitions of processors\n  Step T0 T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15\n  0    0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n  500  1 0 3 2 5 4 6 7 8 9 10 11 12 13 14 15\n  1000 2 0 4 1 5 3 6 7 8 9 10 11 12 14 13 15\n  1500 2 1 4 0 5 3 6 7 9 8 10 11 12 14 13 15\n  2000 2 1 3 0 6 4 5 7 10 8 9 11 12 14 13 15\n  2500 2 1 3 0 6 4 5 7 11 8 9 10 12 14 13 15\n  ...\n  \n  \n  The column headings T0 to TN-1 mean which temperature is currently\n  assigned to the replica 0 to N-1.  Thus the columns represent replicas\n  and the value in each column is its temperature (also numbered 0 to\n  N-1).  For example, a 0 in the 4th column (column T3, step 2500) means\n  that the 4th replica is assigned temperature 0, i.e. the lowest\n  temperature.  You can verify this time sequence of temperature\n  assignments for the Nth replica by comparing the Nth column of screen\n  output to the thermodynamic data in the corresponding log.lammps.N or\n  screen.N files as time proceeds.\n  You can have each replica create its own dump file in the following\n  manner:\n  variable rep world 0 1 2 3 4 5 6 7\n  dump 1 all atom 1000 dump.temper.${rep}\n  \n  \n  \n  Note\n  Each replica’s dump file will contain a continuous trajectory\n  for its atoms where the temperature varies over time as swaps take\n  place involving that replica.  If you want a series of dump files,\n  each with snapshots (from all replicas) that are all at a single\n  temperature, then you will need to post-process the dump files using\n  the information from the log.lammps file.  E.g. you could produce one\n  dump file with snapshots at 300K (from all replicas), another with\n  snapshots at 310K, etc.  Note that these new dump files will not\n  contain “continuous trajectories” for individual atoms, because two\n  successive snapshots (in time) may be from different replicas. The\n  reorder_remd_traj python script can do the reordering for you\n  (and additionally also calculated configurational log-weights of\n  trajectory snapshots in the canonical ensemble). The script can be found\n  in the tools/replica directory while instructions on how to use it is\n  available in doc/Tools (in brief) and as a README file in tools/replica\n  (in detail).\n  \n  The last argument index in the temper command is optional and is\n  used when restarting a tempering run from a set of restart files (one\n  for each replica) which had previously swapped to new temperatures.\n  The index value (from 0 to N-1, where N is the # of replicas)\n  identifies which temperature the replica was simulating on the\n  timestep the restart files were written.  Obviously, this argument\n  must be a variable so that each partition has the correct value.  Set\n  the variable to the N values listed in the log file for the previous\n  run for the replica temperatures at that timestep.  For example if the\n  log file listed the following for a simulation with 5 replicas:\n  500000 2 4 0 1 3\n  \n  \n  then a setting of\n  variable w world 2 4 0 1 3\n  \n  \n  would be used to restart the run with a tempering command like the\n  example above with $w as the last argument.\n  ",
    "syntax": "temper N M temp fix-ID seed1 seed2 index\n  \n  \n  \n  N = total # of timesteps to run\n  M = attempt a tempering swap every this many steps\n  temp = initial temperature for this ensemble\n  fix-ID = ID of the fix that will control temperature during the run\n  seed1 = random # seed used to decide on adjacent temperature to partner with\n  seed2 = random # seed for Boltzmann factor in Metropolis swap\n  index = which temperature (0 to N-1) I am simulating (optional)\n  \n  ",
    "examples": "temper 100000 100 $t tempfix 0 58728\n  temper 40000 100 $t tempfix 0 32285 $w\n  \n  \n  ",
    "restrictions": "This command can only be used if LAMMPS was built with the REPLICA\n  package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "temper/grem",
    "description": "Run a parallel tempering or replica exchange simulation in LAMMPS\n  partition mode using multiple generalized replicas (ensembles) of a\n  system defined by fix grem, which stands for the\n  generalized replica exchange method (gREM) originally developed by\n  (Kim).  It uses non-Boltzmann ensembles to sample over first\n  order phase transitions. The is done by defining replicas with an\n  enthalpy dependent effective temperature\n  Two or more replicas must be used.  See the temper\n  command for an explanation of how to run replicas on multiple\n  partitions of one or more processors.\n  This command is a modification of the temper command and\n  has the same dependencies, restraints, and input variables which are\n  discussed there in greater detail.\n  Instead of temperature, this command performs replica exchanges in\n  lambda as per the generalized ensemble enforced by fix grem.  The desired lambda is specified by lambda, which is\n  typically a variable previously set in the input script, so that each\n  partition is assigned a different temperature.  See the variable command for more details.  For example:\n  variable lambda world 400 420 440 460\n  fix fxnvt all nvt temp 300.0 300.0 100.0\n  fix fxgREM all grem ${lambda} -0.05 -50000 fxnvt\n  temper/grem 100000 100 ${lambda} fxgREM fxnvt 3847 58382\n  \n  \n  would define 4 lambdas with constant kinetic temperature but unique\n  generalized temperature, and assign one of them to fix grem used by each replica, and to the grem command.\n  As the gREM simulation runs for N timesteps, a swap between adjacent\n  ensembles will be attempted every M timesteps.  If seed1 is 0,\n  then the swap attempts will alternate between odd and even pairings.\n  If seed1 is non-zero then it is used as a seed in a random number\n  generator to randomly choose an odd or even pairing each time.  Each\n  attempted swap of temperatures is either accepted or rejected based on\n  a Metropolis criterion, derived for gREM by (Kim), which uses\n  seed2 in the random number generator.\n  File management works identical to the temper command.\n  Dump files created by this fix contain continuous trajectories and\n  require post-processing to obtain per-replica information.\n  The last argument index in the grem command is optional and is used\n  when restarting a run from a set of restart files (one for each\n  replica) which had previously swapped to new lambda.  This is done\n  using a variable. For example if the log file listed the following for\n  a simulation with 5 replicas:\n  500000 2 4 0 1 3\n  \n  \n  then a setting of\n  variable walkers world 2 4 0 1 3\n  \n  \n  would be used to restart the run with a grem command like the example\n  above with ${walkers} as the last argument. This functionality is\n  identical to temper.\n  ",
    "syntax": "temper/grem N M lambda fix-ID thermostat-ID seed1 seed2 index\n  \n  \n  \n  N = total # of timesteps to run\n  M = attempt a tempering swap every this many steps\n  lambda = initial lambda for this ensemble\n  fix-ID = ID of fix grem\n  thermostat-ID = ID of the thermostat that controls kinetic temperature\n  seed1 = random # seed used to decide on adjacent temperature to partner with\n  seed2 = random # seed for Boltzmann factor in Metropolis swap\n  index = which temperature (0 to N-1) I am simulating (optional)\n  \n  ",
    "examples": "temper/grem 100000 1000 ${lambda} fxgREM fxnvt 0 58728\n  temper/grem 40000 100 ${lambda} fxgREM fxnpt 0 32285 ${walkers}\n  \n  \n  ",
    "restrictions": "This command can only be used if LAMMPS was built with the USER-MISC\n  package.  See the Build package doc\n  page for more info.\n  This command must be used with fix grem.\n  "
},
{
    "command": "temper/npt",
    "description": "Run a parallel tempering or replica exchange simulation using multiple\n  replicas (ensembles) of a system in the isothermal-isobaric (NPT)\n  ensemble.  The command temper/npt works like temper but\n  requires running replicas in the NPT ensemble instead of the canonical\n  (NVT) ensemble and allows for pressure to be set in the ensembles.\n  These multiple ensembles can run in parallel at different temperatures\n  or different pressures.  The acceptance criteria for temper/npt is\n  specific to the NPT ensemble and can be found in references\n  (Okabe) and (Mori).\n  Apart from the difference in acceptance criteria and the specification\n  of pressure, this command works much like the temper\n  command. See the documentation on temper for information\n  on how the parallel tempering is handled in general.\n  ",
    "syntax": "temper/npt  N M temp fix-ID seed1 seed2 pressure index\n  \n  \n  \n  N = total # of timesteps to run\n  M = attempt a tempering swap every this many steps\n  temp = initial temperature for this ensemble\n  fix-ID = ID of the fix that will control temperature and pressure during the run\n  seed1 = random # seed used to decide on adjacent temperature to partner with\n  seed2 = random # seed for Boltzmann factor in Metropolis swap\n  pressure = setpoint pressure for the ensemble\n  index = which temperature (0 to N-1) I am simulating (optional)\n  \n  ",
    "examples": "temper/npt 100000 100 $t nptfix 0 58728 1\n  temper/npt 2500000 1000 300 nptfix  0 32285 $p\n  temper/npt 5000000 2000 $t nptfix 0 12523 1 $w\n  \n  \n  ",
    "restrictions": "This command can only be used if LAMMPS was built with the USER-MISC\n  package.  See the Build package doc page for more\n  info.\n  This command should be used with a fix that maintains the\n  isothermal-isobaric (NPT) ensemble.\n  "
},
{
    "command": "thermo",
    "description": "Compute and print thermodynamic info (e.g. temperature, energy,\n  pressure) on timesteps that are a multiple of N and at the beginning\n  and end of a simulation.  A value of 0 will only print thermodynamics\n  at the beginning and end.\n  The content and format of what is printed is controlled by the\n  thermo_style and\n  thermo_modify commands.\n  Instead of a numeric value, N can be specified as an equal-style variable, which should be specified as v_name, where\n  name is the variable name.  In this case, the variable is evaluated at\n  the beginning of a run to determine the next timestep at which\n  thermodynamic info will be written out.  On that timestep, the\n  variable will be evaluated again to determine the next timestep, etc.\n  Thus the variable should return timestep values.  See the stagger()\n  and logfreq() and stride() math functions for equal-style variables, as examples of useful functions to use in\n  this context.  Other similar math functions could easily be added as\n  options for equal-style variables.\n  For example, the following commands will output thermodynamic info at\n  timesteps 0,10,20,30,100,200,300,1000,2000,etc:\n  variable        s equal logfreq(10,3,10)\n  thermo          v_s\n  \n  \n  ",
    "syntax": "thermo N\n  \n  \n  \n  N = output thermodynamics every N timesteps\n  N can be a variable (see below)\n  \n  ",
    "examples": "thermo 100\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "thermo_modify",
    "description": "Set options for how thermodynamic information is computed and printed\n  by LAMMPS.\n  \n  Note\n  These options apply to the currently defined thermo style.  When\n  you specify a thermo_style command, all\n  thermodynamic settings are restored to their default values, including\n  those previously reset by a thermo_modify command.  Thus if your input\n  script specifies a thermo_style command, you should use the\n  thermo_modify command after it.\n  \n  The lost keyword determines whether LAMMPS checks for lost atoms\n  each time it computes thermodynamics and what it does if atoms are\n  lost.  An atom can be “lost” if it moves across a non-periodic\n  simulation box boundary or if it moves more than a box\n  length outside the simulation domain (or more than a processor\n  sub-domain length) before reneighboring occurs.  The latter case is\n  typically due to bad dynamics, e.g. too large a timestep or huge\n  forces and velocities.  If the value is ignore, LAMMPS does not\n  check for lost atoms.  If the value is error or warn, LAMMPS\n  checks and either issues an error or warning.  The code will exit with\n  an error and continue with a warning.  A warning will only be issued\n  once, the first time an atom is lost.  This can be a useful debugging\n  option.\n  The lost/bond keyword determines whether LAMMPS throws an error or\n  not if an atom in a bonded interaction (bond, angle, etc) cannot be\n  found when it creates bonded neighbor lists.  By default this is a\n  fatal error.  However in some scenarios it may be desirable to only\n  issue a warning or ignore it and skip the computation of the missing\n  bond, angle, etc.  An example would be when gas molecules in a vapor\n  are drifting out of the box through a fixed boundary condition (see\n  the boundary command).  In this case one atom may be\n  deleted before the rest of the molecule is, on a later timestep.\n  The norm keyword determines whether various thermodynamic output\n  values are normalized by the number of atoms or not, depending on\n  whether it is set to yes or no.  Different unit styles have\n  different defaults for this setting (see below).  Even if norm is\n  set to yes, a value is only normalized if it is an “extensive”\n  quantity, meaning that it scales with the number of atoms in the\n  system.  For the thermo keywords described by the doc page for the\n  thermo_style command, all energy-related keywords\n  are extensive, such as pe or ebond or enthalpy.  Other keywords\n  such as temp or press are “intensive” meaning their value is\n  independent (in a statistical sense) of the number of atoms in the\n  system and thus are never normalized.  For thermodynamic output values\n  extracted from fixes and computes in a thermo_style custom command, the doc page for the individual\n  fix or compute lists whether the value is\n  “extensive” or “intensive” and thus whether it is normalized.\n  Thermodynamic output values calculated by a variable formula are\n  assumed to be “intensive” and thus are never normalized.  You can\n  always include a divide by the number of atoms in the variable formula\n  if this is not the case.\n  The flush keyword invokes a flush operation after thermodynamic info\n  is written to the log file.  This insures the output in that file is\n  current (no buffering by the OS), even if LAMMPS halts before the\n  simulation completes.\n  The line keyword determines whether thermodynamics will be output as\n  a series of numeric values on one line or in a multi-line format with\n  3 quantities with text strings per line and a dashed-line header\n  containing the timestep and CPU time.  This modify option overrides\n  the one and multi thermo_style settings.\n  The format keyword can be used to change the default numeric format\n  of any of quantities the thermo_style command\n  outputs.  All the specified format strings are C-style formats,\n  e.g. as used by the C/C++ printf() command.  The line keyword takes\n  a single argument which is the format string for the entire line of\n  thermo output, with N fields, which you must enclose in quotes if it\n  is more than one field.  The int and float keywords take a single\n  format argument and are applied to all integer or floating-point\n  quantities output.  The setting for M string also takes a single\n  format argument which is used for the Mth value output in each line,\n  e.g. the 5th column is output in high precision for “format 5\n  %20.15g”.\n  The format keyword can be used multiple times.  The precedence is\n  that for each value in a line of output, the M format (if specified)\n  is used, else the int or float setting (if specified) is used,\n  else the line setting (if specified) for that value is used, else\n  the default setting is used.  A setting of none clears all previous\n  settings, reverting all values to their default format.\n  \n  Note\n  The thermo output values step and atoms are stored\n  internally as 8-byte signed integers, rather than the usual 4-byte\n  signed integers.  When specifying the format int option you can use\n  a “%d”-style format identifier in the format string and LAMMPS will\n  convert this to the corresponding 8-byte form when it is applied to\n  those keywords.  However, when specifying the line option or format\n  M string option for step and natoms, you should specify a format\n  string appropriate for an 8-byte signed integer, e.g. one with “%ld”.\n  \n  The temp keyword is used to determine how thermodynamic temperature\n  is calculated, which is used by all thermo quantities that require a\n  temperature (“temp”, “press”, “ke”, “etotal”, “enthalpy”, “pxx”, etc).\n  The specified compute ID must have been previously defined by the user\n  via the compute command and it must be a style of\n  compute that calculates a temperature.  As described in the\n  thermo_style command, thermo output uses a default\n  compute for temperature with ID = thermo_temp.  This option allows\n  the user to override the default.\n  The press keyword is used to determine how thermodynamic pressure is\n  calculated, which is used by all thermo quantities that require a\n  pressure (“press”, “enthalpy”, “pxx”, etc).  The specified compute ID\n  must have been previously defined by the user via the\n  compute command and it must be a style of compute that\n  calculates a pressure.  As described in the\n  thermo_style command, thermo output uses a default\n  compute for pressure with ID = thermo_press.  This option allows the\n  user to override the default.\n  \n  Note\n  If both the temp and press keywords are used in a single\n  thermo_modify command (or in two separate commands), then the order in\n  which the keywords are specified is important.  Note that a pressure compute defines its own temperature compute as\n  an argument when it is specified.  The temp keyword will override\n  this (for the pressure compute being used by thermodynamics), but only\n  if the temp keyword comes after the press keyword.  If the temp\n  keyword comes before the press keyword, then the new pressure\n  compute specified by the press keyword will be unaffected by the\n  temp setting.\n  \n  ",
    "syntax": "thermo_modify keyword value ...\n  \n  \n  \n  one or more keyword/value pairs may be listed\n  keyword = lost or lost/bond or norm or flush or line or format or temp or press:l\n    lost value = error or warn or ignore\n    lost/bond value = error or warn or ignore\n    norm value = yes or no\n    flush value = yes or no\n    line value = one or multi\n    format values = line string, int string, float string, M string, or none\n      string = C-style format string\n      M = integer from 1 to N, where N = # of quantities being output\n    temp value = compute ID that calculates a temperature\n    press value = compute ID that calculates a pressure\n  \n  \n  ",
    "examples": "thermo_modify lost ignore flush yes\n  thermo_modify temp myTemp format 3 %15.8g\n  thermo_modify temp myTemp format line \"%ld %g %g %15.8g\"\n  thermo_modify line multi format float %g\n  \n  \n  ",
    "restrictions": "none\n  "
},
{
    "command": "thermo_style",
    "description": "Set the style and content for printing thermodynamic data to the\n  screen and log file.\n  Style one prints a one-line summary of thermodynamic info that is\n  the equivalent of “thermo_style custom step temp epair emol etotal\n  press”.  The line contains only numeric values.\n  Style multi prints a multiple-line listing of thermodynamic info\n  that is the equivalent of “thermo_style custom etotal ke temp pe ebond\n  eangle edihed eimp evdwl ecoul elong press”.  The listing contains\n  numeric values and a string ID for each quantity.\n  Style custom is the most general setting and allows you to specify\n  which of the keywords listed above you want printed on each\n  thermodynamic timestep.  Note that the keywords c_ID, f_ID, v_name are\n  references to computes, fixes, and\n  equal-style variables that have been defined elsewhere\n  in the input script or can even be new styles which users have added\n  to LAMMPS.  See the Modify doc page for details on the\n  latter.  Thus the custom style provides a flexible means of\n  outputting essentially any desired quantity as a simulation proceeds.\n  All styles except custom have vol appended to their list of\n  outputs if the simulation box volume changes during the simulation.\n  The values printed by the various keywords are instantaneous values,\n  calculated on the current timestep.  Time-averaged quantities, which\n  include values from previous timesteps, can be output by using the\n  f_ID keyword and accessing a fix that does time-averaging such as the\n  fix ave/time command.\n  Options invoked by the thermo_modify command can\n  be used to set the one- or multi-line format of the print-out, the\n  normalization of thermodynamic output (total values versus per-atom\n  values for extensive quantities (ones which scale with the number of\n  atoms in the system), and the numeric precision of each printed value.\n  \n  Note\n  When you use a “thermo_style” command, all thermodynamic\n  settings are restored to their default values, including those\n  previously set by a thermo_modify command.  Thus\n  if your input script specifies a thermo_style command, you should use\n  the thermo_modify command after it.\n  \n  \n  Several of the thermodynamic quantities require a temperature to be\n  computed: “temp”, “press”, “ke”, “etotal”, “enthalpy”, “pxx”, etc.  By\n  default this is done by using a temperature compute which is created\n  when LAMMPS starts up, as if this command had been issued:\n  compute thermo_temp all temp\n  \n  \n  See the compute temp command for details.  Note\n  that the ID of this compute is thermo_temp and the group is all.\n  You can change the attributes of this temperature (e.g. its\n  degrees-of-freedom) via the compute_modify\n  command.  Alternatively, you can directly assign a new compute (that\n  calculates temperature) which you have defined, to be used for\n  calculating any thermodynamic quantity that requires a temperature.\n  This is done via the thermo_modify command.\n  Several of the thermodynamic quantities require a pressure to be\n  computed: “press”, “enthalpy”, “pxx”, etc.  By default this is done by\n  using a pressure compute which is created when LAMMPS starts up, as\n  if this command had been issued:\n  compute thermo_press all pressure thermo_temp\n  \n  \n  See the compute pressure command for details.\n  Note that the ID of this compute is thermo_press and the group is\n  all.  You can change the attributes of this pressure via the\n  compute_modify command.  Alternatively, you can\n  directly assign a new compute (that calculates pressure) which you\n  have defined, to be used for calculating any thermodynamic quantity\n  that requires a pressure.  This is done via the\n  thermo_modify command.\n  Several of the thermodynamic quantities require a potential energy to\n  be computed: “pe”, “etotal”, “ebond”, etc.  This is done by using a\n  pe compute which is created when LAMMPS starts up, as if this\n  command had been issued:\n  compute thermo_pe all pe\n  \n  \n  See the compute pe command for details.  Note that\n  the ID of this compute is thermo_pe and the group is all.  You can\n  change the attributes of this potential energy via the\n  compute_modify command.\n  \n  The kinetic energy of the system ke is inferred from the temperature\n  of the system with \\(\\frac{1}{2} k_B T\\) of energy for each degree\n  of freedom.  Thus, using different compute commands for\n  calculating temperature, via the thermo_modify temp command, may yield different kinetic energies, since\n  different computes that calculate temperature can subtract out different\n  non-thermal components of velocity and/or include different degrees of\n  freedom (translational, rotational, etc).\n  The potential energy of the system pe will include contributions\n  from fixes if the fix_modify thermo option is set\n  for a fix that calculates such a contribution.  For example, the fix wall/lj93 fix calculates the energy of atoms\n  interacting with the wall.  See the doc pages for “individual fixes”\n  to see which ones contribute.\n  A long-range tail correction etail for the van der Waals pairwise\n  energy will be non-zero only if the pair_modify tail option is turned on.  The etail contribution\n  is included in evdwl, epair, pe, and etotal, and the\n  corresponding tail correction to the pressure is included in press\n  and pxx, pyy, etc.\n  \n  The step, elapsed, and elaplong keywords refer to timestep\n  count.  Step is the current timestep, or iteration count when a\n  minimization is being performed.  Elapsed is the\n  number of timesteps elapsed since the beginning of this run.\n  Elaplong is the number of timesteps elapsed since the beginning of\n  an initial run in a series of runs.  See the start and stop\n  keywords for the run for info on how to invoke a series of\n  runs that keep track of an initial starting time.  If these keywords\n  are not used, then elapsed and elaplong are the same value.\n  The dt keyword is the current timestep size in time\n  units.  The time keyword is the current elapsed\n  simulation time, also in time units, which is simply\n  (step*dt) if the timestep size has not changed and the timestep has\n  not been reset.  If the timestep has changed (e.g. via fix dt/reset) or the timestep has been reset (e.g. via\n  the “reset_timestep” command), then the simulation time is effectively\n  a cumulative value up to the current point.\n  The cpu keyword is elapsed CPU seconds since the beginning of this\n  run.  The tpcpu and spcpu keywords are measures of how fast your\n  simulation is currently running.  The tpcpu keyword is simulation\n  time per CPU second, where simulation time is in time\n  units.  E.g. for metal units, the tpcpu value would be\n  picoseconds per CPU second.  The spcpu keyword is the number of\n  timesteps per CPU second.  Both quantities are on-the-fly metrics,\n  measured relative to the last time they were invoked.  Thus if you are\n  printing out thermodynamic output every 100 timesteps, the two keywords\n  will continually output the time and timestep rate for the last 100\n  steps.  The tpcpu keyword does not attempt to track any changes in\n  timestep size, e.g. due to using the fix dt/reset\n  command.\n  The cpuremain keyword estimates the CPU time remaining in the\n  current run, based on the time elapsed thus far.  It will only be a\n  good estimate if the CPU time/timestep for the rest of the run is\n  similar to the preceding timesteps.  On the initial timestep the value\n  will be 0.0 since there is no history to estimate from.  For a\n  minimization run performed by the “minimize” command, the estimate is\n  based on the maxiter parameter, assuming the minimization will\n  proceed for the maximum number of allowed iterations.\n  The part keyword is useful for multi-replica or multi-partition\n  simulations to indicate which partition this output and this file\n  corresponds to, or for use in a variable to append to\n  a filename for output specific to this partition.  See discussion of\n  the -partition command-line switch for details on\n  running in multi-partition mode.\n  The timeremain keyword returns the remaining seconds when a\n  timeout has been configured via the timer timeout command.\n  If the timeout timer is inactive, the value of this keyword is 0.0 and\n  if the timer is expired, it is negative. This allows for example to exit\n  loops cleanly, if the timeout is expired with:\n  if \"$(timeremain) < 0.0\" then \"quit 0\"\n  \n  \n  The fmax and fnorm keywords are useful for monitoring the progress\n  of an energy minimization.  The fmax keyword\n  calculates the maximum force in any dimension on any atom in the\n  system, or the infinity-norm of the force vector for the system.  The\n  fnorm keyword calculates the 2-norm or length of the force vector.\n  The nbuild and ndanger keywords are useful for monitoring neighbor\n  list builds during a run.  Note that both these values are also\n  printed with the end-of-run statistics.  The nbuild keyword is the\n  number of re-builds during the current run.  The ndanger keyword is\n  the number of re-builds that LAMMPS considered potentially\n  “dangerous”.  If atom movement triggered neighbor list rebuilding (see\n  the neigh_modify command), then dangerous\n  reneighborings are those that were triggered on the first timestep\n  atom movement was checked for.  If this count is non-zero you may wish\n  to reduce the delay factor to insure no force interactions are missed\n  by atoms moving beyond the neighbor skin distance before a rebuild\n  takes place.\n  The keywords cella, cellb, cellc, cellalpha, cellbeta,\n  cellgamma, correspond to the usual crystallographic quantities that\n  define the periodic unit cell of a crystal.  See the Howto triclinic doc page for a geometric description\n  of triclinic periodic cells, including a precise definition of these\n  quantities in terms of the internal LAMMPS cell dimensions lx, ly,\n  lz, yz, xz, xy.\n  \n  For output values from a compute or fix, the bracketed index I used to\n  index a vector, as in c_ID[I] or f_ID[I], can be specified\n  using a wildcard asterisk with the index to effectively specify\n  multiple values.  This takes the form “*” or “*n” or “n*” or “m*n”.\n  If N = the size of the vector (for mode = scalar) or the number of\n  columns in the array (for mode = vector), then an asterisk with no\n  numeric values means all indices from 1 to N.  A leading asterisk\n  means all indices from 1 to n (inclusive).  A trailing asterisk means\n  all indices from n to N (inclusive).  A middle asterisk means all\n  indices from m to n (inclusive).\n  Using a wildcard is the same as if the individual elements of the\n  vector had been listed one by one.  E.g. these 2 thermo_style commands\n  are equivalent, since the compute temp command\n  creates a global vector with 6 values.\n  compute myTemp all temp\n  thermo_style custom step temp etotal c_myTemp[*]\n  thermo_style custom step temp etotal &\n               c_myTemp[1] c_myTemp[2] c_myTemp[3] &\n               c_myTemp[4] c_myTemp[5] c_myTemp[6]\n  \n  \n  \n  The c_ID and c_ID[I] and c_ID[I][J] keywords allow global\n  values calculated by a compute to be output.  As discussed on the\n  compute doc page, computes can calculate global,\n  per-atom, or local values.  Only global values can be referenced by\n  this command.  However, per-atom compute values for an individual atom\n  can be referenced in a variable and the variable\n  referenced by thermo_style custom, as discussed below.  See the\n  discussion above for how the I in c_ID[I] can be specified with a\n  wildcard asterisk to effectively specify multiple values from a global\n  compute vector.\n  The ID in the keyword should be replaced by the actual ID of a compute\n  that has been defined elsewhere in the input script.  See the\n  compute command for details.  If the compute calculates\n  a global scalar, vector, or array, then the keyword formats with 0, 1,\n  or 2 brackets will reference a scalar value from the compute.\n  Note that some computes calculate “intensive” global quantities like\n  temperature; others calculate “extensive” global quantities like\n  kinetic energy that are summed over all atoms in the compute group.\n  Intensive quantities are printed directly without normalization by\n  thermo_style custom.  Extensive quantities may be normalized by the\n  total number of atoms in the simulation (NOT the number of atoms in\n  the compute group) when output, depending on the thermo_modify norm option being used.\n  The f_ID and f_ID[I] and f_ID[I][J] keywords allow global\n  values calculated by a fix to be output.  As discussed on the\n  fix doc page, fixes can calculate global, per-atom, or\n  local values.  Only global values can be referenced by this command.\n  However, per-atom fix values can be referenced for an individual atom\n  in a variable and the variable referenced by\n  thermo_style custom, as discussed below.  See the discussion above for\n  how the I in f_ID[I] can be specified with a wildcard asterisk to\n  effectively specify multiple values from a global fix vector.\n  The ID in the keyword should be replaced by the actual ID of a fix\n  that has been defined elsewhere in the input script.  See the\n  fix command for details.  If the fix calculates a global\n  scalar, vector, or array, then the keyword formats with 0, 1, or 2\n  brackets will reference a scalar value from the fix.\n  Note that some fixes calculate “intensive” global quantities like\n  timestep size; others calculate “extensive” global quantities like\n  energy that are summed over all atoms in the fix group.  Intensive\n  quantities are printed directly without normalization by thermo_style\n  custom.  Extensive quantities may be normalized by the total number of\n  atoms in the simulation (NOT the number of atoms in the fix group)\n  when output, depending on the thermo_modify norm\n  option being used.\n  The v_name keyword allow the current value of a variable to be\n  output.  The name in the keyword should be replaced by the variable\n  name that has been defined elsewhere in the input script.  Only\n  equal-style and vector-style variables can be referenced; the latter\n  requires a bracketed term to specify the Ith element of the vector\n  calculated by the variable.  However, an atom-style variable can be\n  referenced for an individual atom by an equal-style variable and that\n  variable referenced.  See the variable command for\n  details.  Variables of style equal and vector and atom define a\n  formula which can reference per-atom properties or thermodynamic\n  keywords, or they can invoke other computes, fixes, or variables when\n  evaluated, so this is a very general means of creating thermodynamic\n  output.\n  Note that equal-style and vector-style variables are assumed to\n  produce “intensive” global quantities, which are thus printed as-is,\n  without normalization by thermo_style custom.  You can include a\n  division by “natoms” in the variable formula if this is not the case.\n  ",
    "syntax": "thermo_style style args\n  \n  \n  \n  style = one or multi or custom\n  args = list of arguments for a particular style\n  one args = none\n  multi args = none\n  custom args = list of keywords\n    possible keywords = step, elapsed, elaplong, dt, time,\n                        cpu, tpcpu, spcpu, cpuremain, part, timeremain,\n                        atoms, temp, press, pe, ke, etotal, enthalpy,\n                        evdwl, ecoul, epair, ebond, eangle, edihed, eimp,\n                        emol, elong, etail,\n                        vol, density, lx, ly, lz, xlo, xhi, ylo, yhi, zlo, zhi,\n                        xy, xz, yz, xlat, ylat, zlat,\n                        bonds, angles, dihedrals, impropers,\n                        pxx, pyy, pzz, pxy, pxz, pyz,\n                        fmax, fnorm, nbuild, ndanger,\n                        cella, cellb, cellc, cellalpha, cellbeta, cellgamma,\n                        c_ID, c_ID[I], c_ID[I][J],\n                        f_ID, f_ID[I], f_ID[I][J],\n                        v_name, v_name[I]\n      step = timestep\n      elapsed = timesteps since start of this run\n      elaplong = timesteps since start of initial run in a series of runs\n      dt = timestep size\n      time = simulation time\n      cpu = elapsed CPU time in seconds since start of this run\n      tpcpu = time per CPU second\n      spcpu = timesteps per CPU second\n      cpuremain = estimated CPU time remaining in run\n      part = which partition (0 to Npartition-1) this is\n      timeremain = remaining time in seconds on timer timeout.\n      atoms = # of atoms\n      temp = temperature\n      press = pressure\n      pe = total potential energy\n      ke = kinetic energy\n      etotal = total energy (pe + ke)\n      enthalpy = enthalpy (etotal + press*vol)\n      evdwl = van der Waals pairwise energy (includes etail)\n      ecoul = Coulombic pairwise energy\n      epair = pairwise energy (evdwl + ecoul + elong)\n      ebond = bond energy\n      eangle = angle energy\n      edihed = dihedral energy\n      eimp = improper energy\n      emol = molecular energy (ebond + eangle + edihed + eimp)\n      elong = long-range kspace energy\n      etail = van der Waals energy long-range tail correction\n      vol = volume\n      density = mass density of system\n      lx,ly,lz = box lengths in x,y,z\n      xlo,xhi,ylo,yhi,zlo,zhi = box boundaries\n      xy,xz,yz = box tilt for triclinic (non-orthogonal) simulation boxes\n      xlat,ylat,zlat = lattice spacings as calculated by lattice command\n      bonds,angles,dihedrals,impropers = # of these interactions defined\n      pxx,pyy,pzz,pxy,pxz,pyz = 6 components of pressure tensor\n      fmax = max component of force on any atom in any dimension\n      fnorm = length of force vector for all atoms\n      nbuild = # of neighbor list builds\n      ndanger = # of dangerous neighbor list builds\n      cella,cellb,cellc = periodic cell lattice constants a,b,c\n      cellalpha, cellbeta, cellgamma = periodic cell angles alpha,beta,gamma\n      c_ID = global scalar value calculated by a compute with ID\n      c_ID[I] = Ith component of global vector calculated by a compute with ID, I can include wildcard (see below)\n      c_ID[I][J] = I,J component of global array calculated by a compute with ID\n      f_ID = global scalar value calculated by a fix with ID\n      f_ID[I] = Ith component of global vector calculated by a fix with ID, I can include wildcard (see below)\n      f_ID[I][J] = I,J component of global array calculated by a fix with ID\n      v_name = value calculated by an equal-style variable with name\n      v_name[I] = value calculated by a vector-style variable with name\n  \n  \n  ",
    "examples": "thermo_style multi\n  thermo_style custom step temp pe etotal press vol\n  thermo_style custom step temp etotal c_myTemp v_abc\n  thermo_style custom step temp etotal c_myTemp[*] v_abc\n  \n  \n  ",
    "restrictions": "This command must come after the simulation box is defined by a\n  read_data, read_restart, or\n  create_box command.\n  "
},
{
    "command": "third_order",
    "description": "Calculate the third order force constant tensor by finite difference of the selected group,\n  \n  where Phi is the third order force constant tensor.\n  The output of the command is the tensor, three elements at a time. The\n  three elements correspond to the three gamma elements for a specific i/alpha/j/beta/k.\n  The initial five numbers are i, alpha, j, beta, and k respectively.\n  If the style eskm is selected, the tensor will be using energy units of 10 J/mol.\n  These units conform to eskm style from the dynamical_matrix command, which\n  will simplify operations using dynamical matrices with third order tensors.\n  ",
    "syntax": "third_order group-ID style delta args keyword value ...\n  \n  \n  \n  group-ID = ID of group of atoms to displace\n  style = regular or eskm\n  delta = finite different displacement length (distance units)\n  one or more keyword/arg pairs may be appended\n  keyword = file or binary\n    file name = name of output file for the third order tensor\n    binary arg = yes or no or gzip\n  \n  \n  ",
    "examples": "third_order 1 regular 0.000001\n  third_order 1 eskm 0.000001\n  third_order 3 regular 0.00004 file third_order.dat\n  third_order 5 eskm 0.00000001 file third_order.dat binary yes\n  \n  \n  ",
    "restrictions": "The command collects a 9 times the number of atoms in the group on every single MPI rank,\n  so the memory requirements can be very significant for large systems.\n  This command is part of the USER-PHONON package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "timer",
    "description": "Select the level of detail at which LAMMPS performs its CPU timings.\n  Multiple keywords can be specified with the timer command.  For\n  keywords that are mutually exclusive, the last one specified takes\n  precedence.\n  During a simulation run LAMMPS collects information about how much\n  time is spent in different sections of the code and thus can provide\n  information for determining performance and load imbalance problems.\n  This can be done at different levels of detail and accuracy.  For more\n  information about the timing output, see the Run output doc page.\n  The off setting will turn all time measurements off. The loop\n  setting will only measure the total time for a run and not collect any\n  detailed per section information.  With the normal setting, timing\n  information for portions of the timestep (pairwise calculations,\n  neighbor list construction, output, etc) are collected as well as\n  information about load imbalances for those sections across\n  processors.  The full setting adds information about CPU\n  utilization and thread utilization, when multi-threading is enabled.\n  With the sync setting, all MPI tasks are synchronized at each timer\n  call which measures load imbalance for each section more accurately,\n  though it can also slow down the simulation by prohibiting overlapping\n  independent computations on different MPI ranks  Using the nosync\n  setting (which is the default) turns this synchronization off.\n  With the timeout keyword a wall time limit can be imposed, that\n  affects the run and minimize commands.\n  This can be convenient when calculations have to comply with execution\n  time limits, e.g. when running under a batch system when you want to\n  maximize the utilization of the batch time slot, especially for runs\n  where the time per timestep varies much and thus it becomes difficult\n  to predict how many steps a simulation can perform for a given wall time\n  limit. This also applies for difficult to converge minimizations.\n  The timeout elapse value should be somewhat smaller than the maximum\n  wall time requested from the batch system, as there is usually\n  some overhead to launch jobs, and it is advisable to write\n  out a restart after terminating a run due to a timeout.\n  The timeout timer starts when the command is issued. When the time\n  limit is reached, the run or energy minimization will exit on the\n  next step or iteration that is a multiple of the Ncheck value\n  which can be set with the every keyword. Default is checking\n  every 10 steps. After the timer timeout has expired all subsequent\n  run or minimize commands in the input script will be skipped.\n  The remaining time or timer status can be accessed with the\n  thermo variable timeremain, which will be\n  zero, if the timeout is inactive (default setting), it will be\n  negative, if the timeout time is expired and positive if there\n  is time remaining and in this case the value of the variable are\n  the number of seconds remaining.\n  When the timeout key word is used a second time, the timer is\n  restarted with a new time limit. The timeout elapse value can\n  be specified as off or unlimited to impose a no timeout condition\n  (which is the default).  The elapse setting can be specified as\n  a single number for seconds, two numbers separated by a colon (MM:SS)\n  for minutes and seconds, or as three numbers separated by colons for\n  hours, minutes, and seconds (H:MM:SS).\n  The every keyword sets how frequently during a run or energy\n  minimization the wall clock will be checked.  This check count applies\n  to the outer iterations or time steps during minimizations or r-RESPA runs, respectively.  Checking for timeout too often,\n  can slow a calculation down.  Checking too infrequently can make the\n  timeout measurement less accurate, with the run being stopped later\n  than desired.\n  \n  Note\n  Using the full and sync options provides the most detailed\n  and accurate timing information, but can also have a negative\n  performance impact due to the overhead of the many required system\n  calls. It is thus recommended to use these settings only when testing\n  tests to identify performance bottlenecks. For calculations with few\n  atoms or a very large number of processors, even the normal setting\n  can have a measurable negative performance impact. In those cases you\n  can just use the loop or off setting.\n  \n  ",
    "syntax": "timer args\n  \n  \n  \n  args = one or more of off or loop or normal or full or sync or nosync or timeout or every\n  \n  off = do not collect or print any timing information\n  loop = collect only the total time for the simulation loop\n  normal = collect timer information broken down by sections (default)\n  full = like normal but also include CPU and thread utilization\n  sync = explicitly synchronize MPI tasks between sections\n  nosync = do not synchronize MPI tasks between sections (default)\n  timeout elapse = set wall time limit to elapse\n  every Ncheck = perform timeout check every Ncheck steps\n  ",
    "examples": "timer full sync\n  timer timeout 2:00:00 every 100\n  timer loop\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "timestep",
    "description": "Set the timestep size for subsequent molecular dynamics simulations.\n  See the units command for the time units associated with\n  each choice of units that LAMMPS supports.\n  The default value for the timestep size also depends on the choice of\n  units for the simulation; see the default values below.\n  When the run style is respa, dt is the timestep for\n  the outer loop (largest) timestep.\n  ",
    "syntax": "timestep dt\n  \n  \n  \n  dt = timestep size (time units)\n  \n  ",
    "examples": "timestep 2.0\n  timestep 0.003\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "uncompute",
    "description": "Delete a compute that was previously defined with a compute\n  command.  This also wipes out any additional changes made to the compute\n  via the compute_modify command.\n  ",
    "syntax": "uncompute compute-ID\n  \n  \n  \n  compute-ID = ID of a previously defined compute\n  \n  ",
    "examples": "uncompute 2\n  uncompute lower-boundary\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "undump",
    "description": "Turn off a previously defined dump so that it is no longer active.\n  This closes the file associated with the dump.\n  ",
    "syntax": "undump dump-ID\n  \n  \n  \n  dump-ID = ID of previously defined dump\n  \n  ",
    "examples": "undump mine\n  undump 2\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "unfix",
    "description": "Delete a fix that was previously defined with a fix\n  command.  This also wipes out any additional changes made to the fix\n  via the fix_modify command.\n  ",
    "syntax": "unfix fix-ID\n  \n  \n  \n  fix-ID = ID of a previously defined fix\n  \n  ",
    "examples": "unfix 2\n  unfix lower-boundary\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "units",
    "description": "This command sets the style of units used for a simulation.  It\n  determines the units of all quantities specified in the input script\n  and data file, as well as quantities output to the screen, log file,\n  and dump files.  Typically, this command is used at the very beginning\n  of an input script.\n  For all units except lj, LAMMPS uses physical constants from\n  www.physics.nist.gov.  For the definition of Kcal in real units,\n  LAMMPS uses the thermochemical calorie = 4.184 J.\n  The choice you make for units simply sets some internal conversion\n  factors within LAMMPS.  This means that any simulation you perform for\n  one choice of units can be duplicated with any other unit setting\n  LAMMPS supports.  In this context “duplicate” means the particles will\n  have identical trajectories and all output generated by the simulation\n  will be identical.  This will be the case for some number of timesteps\n  until round-off effects accumulate, since the conversion factors for\n  two different unit systems are not identical to infinite precision.\n  To perform the same simulation in a different set of units you must\n  change all the unit-based input parameters in your input script and\n  other input files (data file, potential files, etc) correctly to the\n  new units.  And you must correctly convert all output from the new\n  units to the old units when comparing to the original results.  That\n  is often not simple to do.\n  \n  For style lj, all quantities are unitless.  Without loss of\n  generality, LAMMPS sets the fundamental quantities mass, \\(\\sigma\\),\n  \\(\\epsilon\\), and the Boltzmann constant \\(k_B = 1\\).  The\n  masses, distances, energies you specify are multiples of these\n  fundamental values.  The formulas relating the reduced or unitless\n  quantity (with an asterisk) to the same quantity with units is also\n  given.  Thus you can use the mass & \\(\\sigma\\) & \\(\\epsilon\\)\n  values for a specific material and convert the results from a unitless\n  LJ simulation into physical quantities.\n  \n  mass = mass or m\n  distance = \\(\\sigma\\), where \\(x^* = \\frac{x}{\\sigma}\\)\n  time = \\(\\tau\\), where \\(\\tau^* = \\tau \\sqrt{\\frac{\\epsilon}{m \\sigma^2}}\\)\n  energy = \\(\\epsilon\\), where \\(E^* = \\frac{E}{\\epsilon}\\)\n  velocity = \\(\\frac{\\sigma}{\\tau}\\), where \\(v^* = v \\frac{\\tau}{\\sigma}\\)\n  force = \\(\\frac{\\epsilon}{\\sigma}\\), where \\(f^* = f \\frac{\\sigma}{\\epsilon}\\)\n  torque = \\(\\epsilon\\), where \\(t^* = \\frac{t}{\\epsilon}\\)\n  temperature = reduced LJ temperature, where \\(T^* = \\frac{T k_B}{\\epsilon}\\)\n  pressure = reduced LJ pressure, where \\(p^* = p \\frac{\\sigma^3}{\\epsilon}\\)\n  dynamic viscosity = reduced LJ viscosity, where \\(\\eta^* = \\eta \\frac{\\sigma^3}{\\epsilon\\tau}\\)\n  charge = reduced LJ charge, where \\(q^* = q \\frac{1}{\\sqrt{4 \\pi \\varepsilon_0 \\sigma \\epsilon}}\\)\n  dipole = reduced LJ dipole, moment where \\(\\mu^* = \\mu \\frac{1}{\\sqrt{4 \\pi \\varepsilon_0 \\sigma^3 \\epsilon}}\\)\n  electric field = force/charge, where \\(E^* = E \\frac{\\sqrt{4 \\pi \\varepsilon_0 \\sigma \\epsilon} \\sigma}{\\epsilon}\\)\n  density = mass/volume, where \\(\\rho^* = \\rho \\sigma^{dim}\\)\n  \n  Note that for LJ units, the default mode of thermodynamic output via\n  the thermo_style command is to normalize all\n  extensive quantities by the number of atoms.  E.g. potential energy is\n  extensive because it is summed over atoms, so it is output as\n  energy/atom.  Temperature is intensive since it is already normalized\n  by the number of atoms, so it is output as-is.  This behavior can be\n  changed via the thermo_modify norm command.\n  For style real, these are the units:\n  \n  mass = grams/mole\n  distance = Angstroms\n  time = femtoseconds\n  energy = Kcal/mole\n  velocity = Angstroms/femtosecond\n  force = Kcal/mole-Angstrom\n  torque = Kcal/mole\n  temperature = Kelvin\n  pressure = atmospheres\n  dynamic viscosity = Poise\n  charge = multiple of electron charge (1.0 is a proton)\n  dipole = charge*Angstroms\n  electric field = volts/Angstrom\n  density = gram/cm^dim\n  \n  For style metal, these are the units:\n  \n  mass = grams/mole\n  distance = Angstroms\n  time = picoseconds\n  energy = eV\n  velocity = Angstroms/picosecond\n  force = eV/Angstrom\n  torque = eV\n  temperature = Kelvin\n  pressure = bars\n  dynamic viscosity = Poise\n  charge = multiple of electron charge (1.0 is a proton)\n  dipole = charge*Angstroms\n  electric field = volts/Angstrom\n  density = gram/cm^dim\n  \n  For style si, these are the units:\n  \n  mass = kilograms\n  distance = meters\n  time = seconds\n  energy = Joules\n  velocity = meters/second\n  force = Newtons\n  torque = Newton-meters\n  temperature = Kelvin\n  pressure = Pascals\n  dynamic viscosity = Pascal*second\n  charge = Coulombs (1.6021765e-19 is a proton)\n  dipole = Coulombs*meters\n  electric field = volts/meter\n  density = kilograms/meter^dim\n  \n  For style cgs, these are the units:\n  \n  mass = grams\n  distance = centimeters\n  time = seconds\n  energy = ergs\n  velocity = centimeters/second\n  force = dynes\n  torque = dyne-centimeters\n  temperature = Kelvin\n  pressure = dyne/cm^2 or barye = 1.0e-6 bars\n  dynamic viscosity = Poise\n  charge = statcoulombs or esu (4.8032044e-10 is a proton)\n  dipole = statcoul-cm = 10^18 debye\n  electric field = statvolt/cm or dyne/esu\n  density = grams/cm^dim\n  \n  For style electron, these are the units:\n  \n  mass = atomic mass units\n  distance = Bohr\n  time = femtoseconds\n  energy = Hartrees\n  velocity = Bohr/atomic time units [1.03275e-15 seconds]\n  force = Hartrees/Bohr\n  temperature = Kelvin\n  pressure = Pascals\n  charge = multiple of electron charge (1.0 is a proton)\n  dipole moment = Debye\n  electric field = volts/cm\n  \n  For style micro, these are the units:\n  \n  mass = picograms\n  distance = micrometers\n  time = microseconds\n  energy = picogram-micrometer^2/microsecond^2\n  velocity = micrometers/microsecond\n  force = picogram-micrometer/microsecond^2\n  torque = picogram-micrometer^2/microsecond^2\n  temperature = Kelvin\n  pressure = picogram/(micrometer-microsecond^2)\n  dynamic viscosity = picogram/(micrometer-microsecond)\n  charge = picocoulombs (1.6021765e-7 is a proton)\n  dipole = picocoulomb-micrometer\n  electric field = volt/micrometer\n  density = picograms/micrometer^dim\n  \n  For style nano, these are the units:\n  \n  mass = attograms\n  distance = nanometers\n  time = nanoseconds\n  energy = attogram-nanometer^2/nanosecond^2\n  velocity = nanometers/nanosecond\n  force = attogram-nanometer/nanosecond^2\n  torque = attogram-nanometer^2/nanosecond^2\n  temperature = Kelvin\n  pressure = attogram/(nanometer-nanosecond^2)\n  dynamic viscosity = attogram/(nanometer-nanosecond)\n  charge = multiple of electron charge (1.0 is a proton)\n  dipole = charge-nanometer\n  electric field = volt/nanometer\n  density = attograms/nanometer^dim\n  \n  The units command also sets the timestep size and neighbor skin\n  distance to default values for each style:\n  \n  For style lj these are dt = 0.005 tau and skin = 0.3 sigma.\n  For style real these are dt = 1.0 femtoseconds and skin = 2.0 Angstroms.\n  For style metal these are dt = 0.001 picoseconds and skin = 2.0 Angstroms.\n  For style si these are dt = 1.0e-8 seconds and skin = 0.001 meters.\n  For style cgs these are dt = 1.0e-8 seconds and skin = 0.1 centimeters.\n  For style electron these are dt = 0.001 femtoseconds and skin = 2.0 Bohr.\n  For style micro these are dt = 2.0 microseconds and skin = 0.1 micrometers.\n  For style nano these are dt = 0.00045 nanoseconds and skin = 0.1 nanometers.\n  \n  ",
    "syntax": "units style\n  \n  \n  \n  style = lj or real or metal or si or cgs or electron or micro or nano\n  \n  ",
    "examples": "units metal\n  units lj\n  \n  \n  ",
    "restrictions": "This command cannot be used after the simulation box is defined by a\n  read_data or create_box command.\n  Related commands: none\n  "
},
{
    "command": "variable",
    "description": "This command assigns one or more strings to a variable name for\n  evaluation later in the input script or during a simulation.\n  Variables can thus be useful in several contexts.  A variable can be\n  defined and then referenced elsewhere in an input script to become\n  part of a new input command.  For variable styles that store multiple\n  strings, the next command can be used to increment which\n  string is assigned to the variable.  Variables of style equal store\n  a formula which when evaluated produces a single numeric value which\n  can be output either directly (see the print, fix print, and run every commands) or as part\n  of thermodynamic output (see the thermo_style\n  command), or used as input to an averaging fix (see the fix ave/time command).  Variables of style vector\n  store a formula which produces a vector of such values which can be\n  used as input to various averaging fixes, or elements of which can be\n  part of thermodynamic output.  Variables of style atom store a\n  formula which when evaluated produces one numeric value per atom which\n  can be output to a dump file (see the dump custom command)\n  or used as input to an averaging fix (see the fix ave/chunk and fix ave/atom\n  commands).  Variables of style atomfile can be used anywhere in an\n  input script that atom-style variables are used; they get their\n  per-atom values from a file rather than from a formula.  Variables of\n  style python can be hooked to Python functions using code you\n  provide, so that the variable gets its value from the evaluation of\n  the Python code.  Variables of style internal are used by a few\n  commands which set their value directly.\n  \n  Note\n  As discussed on the Commands parse doc\n  page, an input script can use “immediate” variables, specified as\n  $(formula) with parenthesis, where the formula has the same syntax as\n  equal-style variables described on this page.  This is a convenient\n  way to evaluate a formula immediately without using the variable\n  command to define a named variable and then evaluate that\n  variable. See below for a more detailed discussion of this feature.\n  \n  In the discussion that follows, the “name” of the variable is the\n  arbitrary string that is the 1st argument in the variable command.\n  This name can only contain alphanumeric characters and underscores.\n  The “string” is one or more of the subsequent arguments.  The “string”\n  can be simple text as in the 1st example above, it can contain other\n  variables as in the 2nd example, or it can be a formula as in the 3rd\n  example.  The “value” is the numeric quantity resulting from\n  evaluation of the string.  Note that the same string can generate\n  different values when it is evaluated at different times during a\n  simulation.\n  \n  Note\n  When an input script line is encountered that defines a variable\n  of style equal or vector or atom or python that contains a\n  formula or Python code, the formula is NOT immediately evaluated.  It\n  will be evaluated every time when the variable is used instead.  If\n  you simply want to evaluate a formula in place you can use as\n  so-called. See the section below about “Immediate Evaluation of\n  Variables” for more details on the topic.  This is also true of a\n  format style variable since it evaluates another variable when it is\n  invoked.\n  \n  Variables of style equal and vector and atom can be used as\n  inputs to various other commands which evaluate their formulas as\n  needed, e.g. at different timesteps during a run.\n  Variables of style internal can be used in place of an equal-style\n  variable, except by commands that set the value stored by the\n  internal-style variable.  Thus any command that states it can use an\n  equal-style variable as an argument, can also use an internal-style\n  variable.  This means that when the command evaluates the variable, it\n  will use the value set (internally) by another command.\n  Variables of style python can be used in place of an equal-style\n  variable so long as the associated Python function, as defined by the\n  python command, returns a numeric value.  Thus any\n  command that states it can use an equal-style variable as an argument,\n  can also use such a python-style variable.  This means that when the\n  LAMMPS command evaluates the variable, the Python function will be\n  executed.\n  \n  Note\n  When a variable command is encountered in the input script and\n  the variable name has already been specified, the command is ignored.\n  This means variables can NOT be re-defined in an input script (with\n  two exceptions, read further).  This is to allow an input script to be\n  processed multiple times without resetting the variables; see the\n  jump or include commands.  It also means\n  that using the command-line switch -var will\n  override a corresponding index variable setting in the input script.\n  \n  There are two exceptions to this rule.  First, variables of style\n  string, getenv, internal, equal, vector, atom, and\n  python ARE redefined each time the command is encountered.  This\n  allows these style of variables to be redefined multiple times in an\n  input script.  In a loop, this means the formula associated with an\n  equal or atom style variable can change if it contains a\n  substitution for another variable, e.g. $x or v_x.\n  Second, as described below, if a variable is iterated on to the end of\n  its list of strings via the next command, it is removed\n  from the list of active variables, and is thus available to be\n  re-defined in a subsequent variable command.  The delete style does\n  the same thing.\n  \n  The Commands parse doc page explains how\n  occurrences of a variable name in an input script line are replaced by\n  the variable’s string.  The variable name can be referenced as $x if\n  the name “x” is a single character, or as ${LoopVar} if the name\n  “LoopVar” is one or more characters.\n  As described below, for variable styles index, loop, file,\n  universe, and uloop, which string is assigned to a variable can be\n  incremented via the next command.  When there are no more\n  strings to assign, the variable is exhausted and a flag is set that\n  causes the next jump command encountered in the input\n  script to be skipped.  This enables the construction of simple loops\n  in the input script that are iterated over and then exited from.\n  As explained above, an exhausted variable can be re-used in an input\n  script.  The delete style also removes the variable, the same as if\n  it were exhausted, allowing it to be redefined later in the input\n  script or when the input script is looped over.  This can be useful\n  when breaking out of a loop via the if and jump\n  commands before the variable would become exhausted.  For example,\n  label       loop\n  variable    a loop 5\n  print       \"A = $a\"\n  if          \"$a > 2\" then \"jump in.script break\"\n  next        a\n  jump        in.script loop\n  label       break\n  variable    a delete\n  \n  \n  \n  This section describes how all the various variable styles are defined\n  and what they store.  Except for the equal and vector and atom\n  styles, which are explained in the next section.\n  Many of the styles store one or more strings.  Note that a single\n  string can contain spaces (multiple words), if it is enclosed in\n  quotes in the variable command.  When the variable is substituted for\n  in another input script command, its returned string will then be\n  interpreted as multiple arguments in the expanded command.\n  For the index style, one or more strings are specified.  Initially,\n  the 1st string is assigned to the variable.  Each time a\n  next command is used with the variable name, the next\n  string is assigned.  All processors assign the same string to the\n  variable.\n  Index style variables with a single string value can also be set by\n  using the command-line switch -var.\n  The loop style is identical to the index style except that the\n  strings are the integers from 1 to N inclusive, if only one argument N\n  is specified.  This allows generation of a long list of runs\n  (e.g. 1000) without having to list N strings in the input script.\n  Initially, the string “1” is assigned to the variable.  Each time a\n  next command is used with the variable name, the next\n  string (“2”, “3”, etc) is assigned.  All processors assign the same\n  string to the variable.  The loop style can also be specified with\n  two arguments N1 and N2.  In this case the loop runs from N1 to N2\n  inclusive, and the string N1 is initially assigned to the variable.\n  N1 <= N2 and N2 >= 0 is required.\n  For the world style, one or more strings are specified.  There must\n  be one string for each processor partition or “world”.  LAMMPS can be\n  run with multiple partitions via the -partition command-line switch.  This variable command assigns one string to\n  each world.  All processors in the world are assigned the same string.\n  The next command cannot be used with equal style variables, since\n  there is only one value per world.  This style of variable is useful\n  when you wish to run different simulations on different partitions, or\n  when performing a parallel tempering simulation (see the\n  temper command), to assign different temperatures to\n  different partitions.\n  For the universe style, one or more strings are specified.  There\n  must be at least as many strings as there are processor partitions or\n  “worlds”.  LAMMPS can be run with multiple partitions via the\n  -partition command-line switch.  This variable\n  command initially assigns one string to each world.  When a\n  next command is encountered using this variable, the first\n  processor partition to encounter it, is assigned the next available\n  string.  This continues until all the variable strings are consumed.\n  Thus, this command can be used to run 50 simulations on 8 processor\n  partitions.  The simulations will be run one after the other on\n  whatever partition becomes available, until they are all finished.\n  Universe style variables are incremented using the files\n  “tmp.lammps.variable” and “tmp.lammps.variable.lock” which you will\n  see in your directory during such a LAMMPS run.\n  The uloop style is identical to the universe style except that the\n  strings are the integers from 1 to N.  This allows generation of long\n  list of runs (e.g. 1000) without having to list N strings in the input\n  script.\n  For the string style, a single string is assigned to the variable.\n  Two differences between this style and using the index style exist:\n  a variable with string style can be redefined, e.g. by another command later\n  in the input script, or if the script is read again in a loop. The other\n  difference is that string performs variable substitution even if the\n  string parameter is quoted.\n  For the format style, an equal-style variable is specified along\n  with a C-style format string, e.g. “%f” or “%.10g”, which must be\n  appropriate for formatting a double-precision floating-point value.\n  The default format is “%.15g”.  This variable style allows an\n  equal-style variable to be formatted precisely when it is evaluated.\n  If you simply wish to print a variable value with desired precision to\n  the screen or logfile via the print or fix print commands, you can also do this by specifying an\n  “immediate” variable with a trailing colon and format string, as part\n  of the string argument of those commands.  This is explained on the\n  Commands parse doc page.\n  For the getenv style, a single string is assigned to the variable\n  which should be the name of an environment variable.  When the\n  variable is evaluated, it returns the value of the environment\n  variable, or an empty string if it not defined.  This style of\n  variable can be used to adapt the behavior of LAMMPS input scripts via\n  environment variable settings, or to retrieve information that has\n  been previously stored with the shell putenv command.\n  Note that because environment variable settings are stored by the\n  operating systems, they persist beyond a clear command.\n  For the file style, a filename is provided which contains a list of\n  strings to assign to the variable, one per line.  The strings can be\n  numeric values if desired.  See the discussion of the next() function\n  below for equal-style variables, which will convert the string of a\n  file-style variable into a numeric value in a formula.\n  When a file-style variable is defined, the file is opened and the\n  string on the first line is read and stored with the variable.  This\n  means the variable can then be evaluated as many times as desired and\n  will return that string.  There are two ways to cause the next string\n  from the file to be read: use the next command or the\n  next() function in an equal- or atom-style variable, as discussed\n  below.\n  The rules for formatting the file are as follows.  A comment character\n  “#” can be used anywhere on a line; text starting with the comment\n  character is stripped.  Blank lines are skipped.  The first “word” of\n  a non-blank line, delimited by white-space, is the “string” assigned\n  to the variable.\n  For the atomfile style, a filename is provided which contains one or\n  more sets of values, to assign on a per-atom basis to the variable.\n  The format of the file is described below.\n  When an atomfile-style variable is defined, the file is opened and the\n  first set of per-atom values are read and stored with the variable.\n  This means the variable can then be evaluated as many times as desired\n  and will return those values.  There are two ways to cause the next\n  set of per-atom values from the file to be read: use the\n  next command or the next() function in an atom-style\n  variable, as discussed below.\n  The rules for formatting the file are as follows.  Each time a set of\n  per-atom values is read, a non-blank line is searched for in the file.\n  A comment character “#” can be used anywhere on a line; text starting\n  with the comment character is stripped.  Blank lines are skipped.  The\n  first “word” of a non-blank line, delimited by white-space, is read as\n  the count N of per-atom lines to immediately follow.  N can be the\n  total number of atoms in the system, or only a subset.  The next N\n  lines have the following format\n  ID value\n  \n  \n  where ID is an atom ID and value is the per-atom numeric value that\n  will be assigned to that atom.  IDs can be listed in any order.\n  \n  Note\n  Every time a set of per-atom lines is read, the value for all\n  atoms is first set to 0.0.  Thus values for atoms whose ID does not\n  appear in the set, will remain 0.0.\n  \n  For the python style a Python function name is provided.  This needs\n  to match a function name specified in a python command\n  which returns a value to this variable as defined by its return\n  keyword.  For example these two commands would be self-consistent:\n  variable foo python myMultiply\n  python myMultiply return v_foo format f file funcs.py\n  \n  \n  The two commands can appear in either order so long as both are\n  specified before the Python function is invoked for the first time.\n  Each time the variable is evaluated, the associated Python function is\n  invoked, and the value it returns is also returned by the variable.\n  Since the Python function can use other LAMMPS variables as input, or\n  query interal LAMMPS quantities to perform its computation, this means\n  the variable can return a different value each time it is evaluated.\n  The type of value stored in the variable is determined by the format\n  keyword of the python command.  It can be an integer\n  (i), floating point (f), or string (s) value.  As mentioned above, if\n  it is a numeric value (integer or floating point), then the\n  python-style variable can be used in place of an equal-style variable\n  anywhere in an input script, e.g. as an argument to another command\n  that allows for equal-style variables.\n  For the internal style a numeric value is provided.  This value will\n  be assigned to the variable until a LAMMPS command sets it to a new\n  value.  There are currently only two LAMMPS commands that require\n  internal variables as inputs, because they reset them:\n  create_atoms and fix controller.  As mentioned above, an\n  internal-style variable can be used in place of an equal-style\n  variable anywhere else in an input script, e.g. as an argument to\n  another command that allows for equal-style variables.\n  \n  For the equal and vector and atom styles, a single string is\n  specified which represents a formula that will be evaluated afresh\n  each time the variable is used.  If you want spaces in the string,\n  enclose it in double quotes so the parser will treat it as a single\n  argument.  For equal-style variables the formula computes a scalar\n  quantity, which becomes the value of the variable whenever it is\n  evaluated.  For vector-style variables the formula must compute a\n  vector of quantities, which becomes the value of the variable whenever\n  it is evaluated.  The calculated vector can be on length one, but it\n  cannot be a simple scalar value like that produced by an equal-style\n  compute.  I.e. the formula for a vector-style variable must have at\n  least one quantity in it that refers to a global vector produced by a\n  compute, fix, or other vector-style variable.  For atom-style\n  variables the formula computes one quantity for each atom whenever it\n  is evaluated.\n  Note that equal, vector, and atom variables can produce\n  different values at different stages of the input script or at\n  different times during a run.  For example, if an equal variable is\n  used in a fix print command, different values could\n  be printed each timestep it was invoked.  If you want a variable to be\n  evaluated immediately, so that the result is stored by the variable\n  instead of the string, see the section below on “Immediate Evaluation\n  of Variables”.\n  The next command cannot be used with equal or vector or atom\n  style variables, since there is only one string.\n  The formula for an equal, vector, or atom variable can contain a\n  variety of quantities.  The syntax for each kind of quantity is\n  simple, but multiple quantities can be nested and combined in various\n  ways to build up formulas of arbitrary complexity.  For example, this\n  is a valid (though strange) variable formula:\n  variable x equal \"pe + c_MyTemp / vol^(1/3)\"\n  \n  \n  Specifically, a formula can contain numbers, constants, thermo\n  keywords, math operators, math functions, group functions, region\n  functions, atom values, atom vectors, compute references, fix\n  references, and references to other variables.\n  \n  \n  \n  \n  \n  \n  Number\n  0.2, 100, 1.0e20, -15.4, etc\n  \n  Constant\n  PI, version, on, off, true, false, yes, no\n  \n  Thermo keywords\n  vol, pe, ebond, etc\n  \n  Math operators\n  (), -x, x+y, x-y, x*y, x/y, x^y, x%y,      x == y, x != y, x < y, x <= y, x > y, x >= y, x && y, x || y, x |^ y, !x\n  \n  Math functions\n  sqrt(x), exp(x), ln(x), log(x), abs(x),      sin(x), cos(x), tan(x), asin(x), acos(x), atan(x), atan2(y,x),      random(x,y,z), normal(x,y,z), ceil(x), floor(x), round(x),      ramp(x,y), stagger(x,y), logfreq(x,y,z), logfreq2(x,y,z),      logfreq3(x,y,z), stride(x,y,z), stride2(x,y,z,a,b,c),      vdisplace(x,y), swiggle(x,y,z), cwiggle(x,y,z)\n  \n  Group functions\n  count(ID), mass(ID), charge(ID), xcm(ID,dim),      vcm(ID,dim), fcm(ID,dim), bound(ID,dir),      gyration(ID), ke(ID), angmom(ID,dim), torque(ID,dim),      inertia(ID,dimdim), omega(ID,dim)\n  \n  Region functions\n  count(ID,IDR), mass(ID,IDR), charge(ID,IDR),      xcm(ID,dim,IDR), vcm(ID,dim,IDR), fcm(ID,dim,IDR),      bound(ID,dir,IDR), gyration(ID,IDR), ke(ID,IDR),      angmom(ID,dim,IDR), torque(ID,dim,IDR),      inertia(ID,dimdim,IDR), omega(ID,dim,IDR)\n  \n  Special functions\n  sum(x), min(x), max(x), ave(x), trap(x),      slope(x), gmask(x), rmask(x), grmask(x,y), next(x)\n  \n  Atom values\n  id[i], mass[i], type[i], mol[i], x[i], y[i], z[i],              vx[i], vy[i], vz[i], fx[i], fy[i], fz[i], q[i]\n  \n  Atom vectors\n  id, mass, type, mol, x, y, z, vx, vy, vz, fx, fy, fz, q\n  \n  Compute references\n  c_ID, c_ID[i], c_ID[i][j], C_ID, C_ID[i]\n  \n  Fix references\n  f_ID, f_ID[i], f_ID[i][j], F_ID, F_ID[i]\n  \n  Other variables\n  v_name, v_name[i]\n  \n  \n  \n  Most of the formula elements produce a scalar value.  Some produce a\n  global or per-atom vector of values.  Global vectors can be produced\n  by computes or fixes or by other vector-style variables.  Per-atom\n  vectors are produced by atom vectors, compute references that\n  represent a per-atom vector, fix references that represent a per-atom\n  vector, and variables that are atom-style variables.  Math functions\n  that operate on scalar values produce a scalar value; math function\n  that operate on global or per-atom vectors do so element-by-element\n  and produce a global or per-atom vector.\n  A formula for equal-style variables cannot use any formula element\n  that produces a global or per-atom vector.  A formula for a\n  vector-style variable can use formula elements that produce either a\n  scalar value or a global vector value, but cannot use a formula\n  element that produces a per-atom vector.  A formula for an atom-style\n  variable can use formula elements that produce either a scalar value\n  or a per-atom vector, but not one that produces a global vector.\n  Atom-style variables are evaluated by other commands that define a\n  group on which they operate, e.g. a dump or\n  compute or fix command.  When they invoke\n  the atom-style variable, only atoms in the group are included in the\n  formula evaluation.  The variable evaluates to 0.0 for atoms not in\n  the group.\n  \n  \n  Numbers, constants, and thermo keywords\n  Numbers can contain digits, scientific notation\n  (3.0e20,3.0e-20,3.0E20,3.0E-20), and leading minus signs.\n  Constants are set at compile time and cannot be changed. PI will\n  return the number 3.14159265358979323846; on, true or yes will\n  return 1.0; off, false or no will return 0.0; version will\n  return a numeric version code of the current LAMMPS version (e.g.\n  version 2 Sep 2015 will return the number 20150902). The corresponding\n  value for newer versions of LAMMPS will be larger, for older versions\n  of LAMMPS will be smaller. This can be used to have input scripts\n  adapt automatically to LAMMPS versions, when non-backwards compatible\n  syntax changes are introduced. Here is an illustrative example (which\n  will not work, since the version has been introduced more recently):\n  if $(version<20140513) then \"communicate vel yes\" else \"comm_modify vel yes\"\n  \n  \n  The thermo keywords allowed in a formula are those defined by the\n  thermo_style custom command.  Thermo keywords that\n  require a compute to calculate their values such as\n  “temp” or “press”, use computes stored and invoked by the\n  thermo_style command.  This means that you can\n  only use those keywords in a variable if the style you are using with\n  the thermo_style command (and the thermo keywords associated with that\n  style) also define and use the needed compute.  Note that some thermo\n  keywords use a compute indirectly to calculate their value (e.g. the\n  enthalpy keyword uses temp, pe, and pressure).  If a variable is\n  evaluated directly in an input script (not during a run), then the\n  values accessed by the thermo keyword must be current.  See the\n  discussion below about “Variable Accuracy”.\n  \n  \n  \n  Math Operators\n  Math operators are written in the usual way, where the “x” and “y” in\n  the examples can themselves be arbitrarily complex formulas, as in the\n  examples above.  In this syntax, “x” and “y” can be scalar values or\n  per-atom vectors.  For example, “ke/natoms” is the division of two\n  scalars, where “vy+vz” is the element-by-element sum of two per-atom\n  vectors of y and z velocities.\n  Operators are evaluated left to right and have the usual C-style\n  precedence: unary minus and unary logical NOT operator “!” have the\n  highest precedence, exponentiation “^” is next; multiplication and\n  division and the modulo operator “%” are next; addition and\n  subtraction are next; the 4 relational operators “<”, “<=”, “>”, and\n  “>=” are next; the two remaining relational operators “==” and “!=”\n  are next; then the logical AND operator “&&”; and finally the logical\n  OR operator “||” and logical XOR (exclusive or) operator “|^” have the\n  lowest precedence.  Parenthesis can be used to group one or more\n  portions of a formula and/or enforce a different order of evaluation\n  than what would occur with the default precedence.\n  \n  Note\n  Because a unary minus is higher precedence than exponentiation,\n  the formula “-2^2” will evaluate to 4, not -4.  This convention is\n  compatible with some programming languages, but not others.  As\n  mentioned, this behavior can be easily overridden with parenthesis;\n  the formula “-(2^2)” will evaluate to -4.\n  \n  The 6 relational operators return either a 1.0 or 0.0 depending on\n  whether the relationship between x and y is TRUE or FALSE.  For\n  example the expression x<10.0 in an atom-style variable formula will\n  return 1.0 for all atoms whose x-coordinate is less than 10.0, and 0.0\n  for the others.  The logical AND operator will return 1.0 if both its\n  arguments are non-zero, else it returns 0.0.  The logical OR operator\n  will return 1.0 if either of its arguments is non-zero, else it\n  returns 0.0.  The logical XOR operator will return 1.0 if one of its\n  arguments is zero and the other non-zero, else it returns 0.0.  The\n  logical NOT operator returns 1.0 if its argument is 0.0, else it\n  returns 0.0.\n  These relational and logical operators can be used as a masking or\n  selection operation in a formula.  For example, the number of atoms\n  whose properties satisfy one or more criteria could be calculated by\n  taking the returned per-atom vector of ones and zeroes and passing it\n  to the compute reduce command.\n  \n  \n  \n  Math Functions\n  Math functions are specified as keywords followed by one or more\n  parenthesized arguments “x”, “y”, “z”, each of which can themselves be\n  arbitrarily complex formulas.  In this syntax, the arguments can\n  represent scalar values or global vectors or per-atom vectors.  In the\n  latter case, the math operation is performed on each element of the\n  vector.  For example, “sqrt(natoms)” is the sqrt() of a scalar, where\n  “sqrt(y*z)” yields a per-atom vector with each element being the\n  sqrt() of the product of one atom’s y and z coordinates.\n  Most of the math functions perform obvious operations.  The ln() is\n  the natural log; log() is the base 10 log.\n  The random(x,y,z) function takes 3 arguments: x = lo, y = hi, and z =\n  seed.  It generates a uniform random number between lo and hi.  The\n  normal(x,y,z) function also takes 3 arguments: x = mu, y = sigma, and\n  z = seed.  It generates a Gaussian variate centered on mu with\n  variance sigma^2.  In both cases the seed is used the first time the\n  internal random number generator is invoked, to initialize it.  For\n  equal-style and vector-style variables, every processor uses the same\n  seed so that they each generate the same sequence of random numbers.\n  For atom-style variables, a unique seed is created for each processor,\n  based on the specified seed.  This effectively generates a different\n  random number for each atom being looped over in the atom-style\n  variable.\n  \n  Note\n  Internally, there is just one random number generator for all\n  equal-style and vector-style variables and another one for all\n  atom-style variables.  If you define multiple variables (of each\n  style) which use the random() or normal() math functions, then the\n  internal random number generators will only be initialized once, which\n  means only one of the specified seeds will determine the sequence of\n  generated random numbers.\n  \n  The ceil(), floor(), and round() functions are those in the C math\n  library.  Ceil() is the smallest integer not less than its argument.\n  Floor() if the largest integer not greater than its argument.  Round()\n  is the nearest integer to its argument.\n  The ramp(x,y) function uses the current timestep to generate a value\n  linearly interpolated between the specified x,y values over the course\n  of a run, according to this formula:\n  value = x + (y-x) * (timestep-startstep) / (stopstep-startstep)\n  The run begins on startstep and ends on stopstep.  Startstep and\n  stopstep can span multiple runs, using the start and stop keywords\n  of the run command.  See the run command for\n  details of how to do this.\n  The stagger(x,y) function uses the current timestep to generate a new\n  timestep.  X,y > 0 and x > y are required.  The generated timesteps\n  increase in a staggered fashion, as the sequence\n  x,x+y,2x,2x+y,3x,3x+y,etc.  For any current timestep, the next\n  timestep in the sequence is returned.  Thus if stagger(1000,100) is\n  used in a variable by the dump_modify every\n  command, it will generate the sequence of output timesteps:\n  100,1000,1100,2000,2100,3000,etc\n  \n  \n  The logfreq(x,y,z) function uses the current timestep to generate a\n  new timestep.  X,y,z > 0 and y < z are required.  The generated\n  timesteps are on a base-z logarithmic scale, starting with x, and the\n  y value is how many of the z-1 possible timesteps within one\n  logarithmic interval are generated.  I.e. the timesteps follow the\n  sequence x,2x,3x,…y*x,x*z,2x*z,3x*z,…y*x*z,x*z^2,2x*z^2,etc.  For\n  any current timestep, the next timestep in the sequence is returned.\n  Thus if logfreq(100,4,10) is used in a variable by the dump_modify every command, it will generate this sequence of\n  output timesteps:\n  100,200,300,400,1000,2000,3000,4000,10000,20000,etc\n  \n  \n  The logfreq2(x,y,z) function is similar to logfreq, except a single\n  logarithmic interval is divided into y equally-spaced timesteps and\n  all of them are output.  Y < z is not required.  Thus, if\n  logfreq2(100,18,10) is used in a variable by the dump_modify every command, then the interval between 100 and\n  1000 is divided as 900/18 = 50 steps, and it will generate the\n  sequence of output timesteps:\n  100,150,200,...950,1000,1500,2000,...9500,10000,15000,etc\n  \n  \n  The logfreq3(x,y,z) function generates y points between x and z (inclusive),\n  that are separated by a multiplicative ratio: (z/x)^(1/(y-1)). Constraints\n  are: x,z > 0, y > 1, z-x >= y-1. For eg., if logfreq3(10,25,1000) is used in\n  a variable by the fix print command, then the interval\n  between 10 and 1000 is divided into 24 parts with a multiplicative\n  separation of ~1.21, and it will generate the following sequence of output\n  timesteps:\n  10, 13, 15, 18, 22, 27, 32,...384, 465, 563, 682, 826, 1000\n  \n  \n  The stride(x,y,z) function uses the current timestep to generate a new\n  timestep.  X,y >= 0 and z > 0 and x <= y are required.  The generated\n  timesteps increase in increments of z, from x to y, i.e. it generates\n  the sequence x,x+z,x+2z,…,y.  If y-x is not a multiple of z, then\n  similar to the way a for loop operates, the last value will be one\n  that does not exceed y.  For any current timestep, the next timestep\n  in the sequence is returned.  Thus if stride(1000,2000,100) is used\n  in a variable by the dump_modify every command, it\n  will generate the sequence of output timesteps:\n  1000,1100,1200, ... ,1900,2000\n  \n  \n  The stride2(x,y,z,a,b,c) function is similar to the stride() function\n  except it generates two sets of strided timesteps, one at a coarser\n  level and one at a finer level.  Thus it is useful for debugging,\n  e.g. to produce output every timestep at the point in simulation when\n  a problem occurs.  X,y >= 0 and z > 0 and x <= y are required, as are\n  a,b >= 0 and c > 0 and a < b.  Also, a >= x and b <= y are required so\n  that the second stride is inside the first.  The generated timesteps\n  increase in increments of z, starting at x, until a is reached.  At\n  that point the timestep increases in increments of c, from a to b,\n  then after b, increments by z are resumed until y is reached.  For any\n  current timestep, the next timestep in the sequence is returned.  Thus\n  if stride2(1000,2000,100,1350,1360,1) is used in a variable by the\n  dump_modify every command, it will generate the\n  sequence of output timesteps:\n  1000,1100,1200,1300,1350,1351,1352, ... 1359,1360,1400,1500, ... ,2000\n  \n  \n  The vdisplace(x,y) function takes 2 arguments: x = value0 and y =\n  velocity, and uses the elapsed time to change the value by a linear\n  displacement due to the applied velocity over the course of a run,\n  according to this formula:\n  value = value0 + velocity*(timestep-startstep)*dt\n  where dt = the timestep size.\n  The run begins on startstep.  Startstep can span multiple runs, using\n  the start keyword of the run command.  See the\n  run command for details of how to do this.  Note that the\n  thermo_style keyword elaplong =\n  timestep-startstep.\n  The swiggle(x,y,z) and cwiggle(x,y,z) functions each take 3 arguments:\n  x = value0, y = amplitude, z = period.  They use the elapsed time to\n  oscillate the value by a sin() or cos() function over the course of a\n  run, according to one of these formulas, where omega = 2 PI / period:\n  value = value0 + Amplitude * sin(omega*(timestep-startstep)*dt)\n  value = value0 + Amplitude * (1 - cos(omega*(timestep-startstep)*dt))\n  where dt = the timestep size.\n  The run begins on startstep.  Startstep can span multiple runs, using\n  the start keyword of the run command.  See the\n  run command for details of how to do this.  Note that the\n  thermo_style keyword elaplong =\n  timestep-startstep.\n  \n  \n  \n  Group and Region Functions\n  Group functions are specified as keywords followed by one or two\n  parenthesized arguments.  The first argument ID is the group-ID.\n  The dim argument, if it exists, is x or y or z.  The dir\n  argument, if it exists, is xmin, xmax, ymin, ymax, zmin, or\n  zmax.  The dimdim argument, if it exists, is xx or yy or zz\n  or xy or yz or xz.\n  The group function count() is the number of atoms in the group.  The\n  group functions mass() and charge() are the total mass and charge of\n  the group.  Xcm() and vcm() return components of the position and\n  velocity of the center of mass of the group.  Fcm() returns a\n  component of the total force on the group of atoms.  Bound() returns\n  the min/max of a particular coordinate for all atoms in the group.\n  Gyration() computes the radius-of-gyration of the group of atoms.  See\n  the compute gyration command for a definition\n  of the formula.  Angmom() returns components of the angular momentum\n  of the group of atoms around its center of mass.  Torque() returns\n  components of the torque on the group of atoms around its center of\n  mass, based on current forces on the atoms.  Inertia() returns one of\n  6 components of the symmetric inertia tensor of the group of atoms\n  around its center of mass, ordered as Ixx,Iyy,Izz,Ixy,Iyz,Ixz.\n  Omega() returns components of the angular velocity of the group of\n  atoms around its center of mass.\n  Region functions are specified exactly the same way as group functions\n  except they take an extra final argument IDR which is the region ID.\n  The function is computed for all atoms that are in both the group and\n  the region.  If the group is “all”, then the only criteria for atom\n  inclusion is that it be in the region.\n  \n  \n  \n  Special Functions\n  Special functions take specific kinds of arguments, meaning their\n  arguments cannot be formulas themselves.\n  The sum(x), min(x), max(x), ave(x), trap(x), and slope(x) functions\n  each take 1 argument which is of the form “c_ID” or “c_ID[N]” or\n  “f_ID” or “f_ID[N]” or “v_name”.  The first two are computes and the\n  second two are fixes; the ID in the reference should be replaced by\n  the ID of a compute or fix defined elsewhere in the input script.  The\n  compute or fix must produce either a global vector or array.  If it\n  produces a global vector, then the notation without “[N]” should be\n  used.  If it produces a global array, then the notation with “[N]”\n  should be used, when N is an integer, to specify which column of the\n  global array is being referenced.  The last form of argument “v_name”\n  is for a vector-style variable where “name” is replaced by the name of\n  the variable.\n  These functions operate on a global vector of inputs and reduce it to\n  a single scalar value.  This is analogous to the operation of the\n  compute reduce command, which performs similar\n  operations on per-atom and local vectors.\n  The sum() function calculates the sum of all the vector elements.  The\n  min() and max() functions find the minimum and maximum element\n  respectively.  The ave() function is the same as sum() except that it\n  divides the result by the length of the vector.\n  The trap() function is the same as sum() except the first and last\n  elements are multiplied by a weighting factor of 1/2 when performing\n  the sum.  This effectively implements an integration via the\n  trapezoidal rule on the global vector of data.  I.e. consider a set of\n  points, equally spaced by 1 in their x coordinate: (1,V1), (2,V2),\n  …, (N,VN), where the Vi are the values in the global vector of\n  length N.  The integral from 1 to N of these points is trap().  When\n  appropriately normalized by the timestep size, this function is useful\n  for calculating integrals of time-series data, like that generated by\n  the fix ave/correlate command.\n  The slope() function uses linear regression to fit a line to the set\n  of points, equally spaced by 1 in their x coordinate: (1,V1), (2,V2),\n  …, (N,VN), where the Vi are the values in the global vector of\n  length N.  The returned value is the slope of the line.  If the line\n  has a single point or is vertical, it returns 1.0e20.\n  The gmask(x) function takes 1 argument which is a group ID.  It\n  can only be used in atom-style variables.  It returns a 1 for\n  atoms that are in the group, and a 0 for atoms that are not.\n  The rmask(x) function takes 1 argument which is a region ID.  It can\n  only be used in atom-style variables.  It returns a 1 for atoms that\n  are in the geometric region, and a 0 for atoms that are not.\n  The grmask(x,y) function takes 2 arguments.  The first is a group ID,\n  and the second is a region ID.  It can only be used in atom-style\n  variables.  It returns a 1 for atoms that are in both the group and\n  region, and a 0 for atoms that are not in both.\n  The next(x) function takes 1 argument which is a variable ID (not\n  “v_foo”, just “foo”).  It must be for a file-style or atomfile-style\n  variable.  Each time the next() function is invoked (i.e. each time\n  the equal-style or atom-style variable is evaluated), the following\n  steps occur.\n  For file-style variables, the current string value stored by the\n  file-style variable is converted to a numeric value and returned by\n  the function.  And the next string value in the file is read and\n  stored.  Note that if the line previously read from the file was not a\n  numeric string, then it will typically evaluate to 0.0, which is\n  likely not what you want.\n  For atomfile-style variables, the current per-atom values stored by\n  the atomfile-style variable are returned by the function.  And the\n  next set of per-atom values in the file is read and stored.\n  Since file-style and atomfile-style variables read and store the first\n  line of the file or first set of per-atoms values when they are\n  defined in the input script, these are the value(s) that will be\n  returned the first time the next() function is invoked.  If next() is\n  invoked more times than there are lines or sets of lines in the file,\n  the variable is deleted, similar to how the next command\n  operates.\n  \n  \n  \n  Feature Functions\n  Feature functions allow to probe the running LAMMPS executable for\n  whether specific features are either active, defined, or available.\n  The functions take two arguments, a category and a corresponding\n  argument. The arguments are strings thus cannot be formulas\n  themselves (only $-style immediate variable expansion is possible).\n  Return value is either 1.0 or 0.0 depending on whether the function\n  evaluates to true or false, respectively.\n  The is_active() function allows to query for active settings which\n  are grouped by categories. Currently supported categories and\n  arguments are:\n  \n  package (argument = gpu or intel or kokkos or omp)\n  newton (argument = pair or bond or any)\n  pair (argument = single or respa or manybody or tail or shift)\n  comm_style (argument = brick or tiled)\n  min_style (argument = any of the compiled in minimizer styles)\n  run_style (argument = any of the compiled in run styles)\n  atom_style (argument = any of the compiled in atom styles)\n  pair_style (argument = any of the compiled in pair styles)\n  bond_style (argument = any of the compiled in bond styles)\n  angle_style (argument = any of the compiled in angle styles)\n  dihedral_style (argument = any of the compiled in dihedral styles)\n  improper_style (argument = any of the compiled in improper styles)\n  kspace_style (argument = any of the compiled in kspace styles)\n  \n  Most of the settings are self-explanatory, the single argument in the\n  pair category allows to check whether a pair style supports a\n  Pair::single() function as needed by compute group/group and others\n  features or LAMMPS, respa allows to check whether the inner/middle/outer\n  mode of r-RESPA is supported. In the various style categories,\n  the checking is also done using suffix flags, if available and enabled.\n  Example 1: disable use of suffix for pppm when using GPU package (i.e. run it on the CPU concurrently to running the pair style on the GPU), but do use the suffix otherwise (e.g. with USER-OMP).\n  pair_style lj/cut/coul/long 14.0\n  if $(is_active(package,gpu)) then \"suffix off\"\n  kspace_style pppm\n  \n  \n  Example 2: use r-RESPA with inner/outer cutoff, if supported by pair style, otherwise fall back to using pair and reducing the outer time step\n  timestep $(2.0*(1.0+2.0*is_active(pair,respa))\n  if $(is_active(pair,respa)) then \"run_style respa 4 3 2 2  improper 1 inner 2 5.5 7.0 outer 3 kspace 4\" else \"run_style respa 3 3 2  improper 1 pair 2 kspace 3\"\n  \n  \n  The is_defined() function allows to query categories like compute,\n  dump, fix, group, region, and variable whether an entry\n  with the provided name or id is defined.\n  The is_available(category,name) function allows to query whether\n  a specific optional feature is available, i.e. compiled in.\n  This currently works for the following categories: command,\n  compute, fix, pair_style and feature. For all categories\n  except command and feature also appending active suffixes is\n  tried before reporting failure.\n  The feature category is used to check the availability of compiled in\n  features such as GZIP support, PNG support, JPEG support, FFMPEG support,\n  and C++ exceptions for error handling. Corresponding values for name are\n  gzip, png, jpeg, ffmpeg and exceptions.\n  This enables writing input scripts which only dump using a given format if\n  the compiled binary supports it.\n  if \"$(is_available(feature,png))\" then \"print 'PNG supported'\" else \"print 'PNG not supported'\"\n  \n  if \"$(is_available(feature,ffmpeg)\" then \"dump 3 all movie 25 movie.mp4 type type zoom 1.6 adiam 1.0\"\n  \n  \n  \n  \n  \n  Atom Values and Vectors\n  Atom values take an integer argument I from 1 to N, where I is the\n  atom-ID, e.g. x[243], which means use the x coordinate of the atom\n  with ID = 243.  Or they can take a variable name, specified as v_name,\n  where name is the name of the variable, like x[v_myIndex].  The\n  variable can be of any style except vector or atom or atomfile\n  variables.  The variable is evaluated and the result is expected to be\n  numeric and is cast to an integer (i.e. 3.4 becomes 3), to use an\n  index, which must be a value from 1 to N.  Note that a “formula”\n  cannot be used as the argument between the brackets, e.g. x[243+10]\n  or x[v_myIndex+1] are not allowed.  To do this a single variable can\n  be defined that contains the needed formula.\n  Note that the 0 < atom-ID <= N, where N is the largest atom ID\n  in the system.  If an ID is specified for an atom that does not\n  currently exist, then the generated value is 0.0.\n  Atom vectors generate one value per atom, so that a reference like\n  “vx” means the x-component of each atom’s velocity will be used when\n  evaluating the variable.\n  The meaning of the different atom values and vectors is mostly\n  self-explanatory.  Mol refers to the molecule ID of an atom, and is\n  only defined if an atom_style is being used that\n  defines molecule IDs.\n  Note that many other atom attributes can be used as inputs to a\n  variable by using the compute property/atom command and then specifying\n  a quantity from that compute.\n  \n  \n  \n  Compute References\n  Compute references access quantities calculated by a\n  compute.  The ID in the reference should be replaced by\n  the ID of a compute defined elsewhere in the input script.  As\n  discussed in the doc page for the compute command,\n  computes can produce global, per-atom, or local values.  Only global\n  and per-atom values can be used in a variable.  Computes can also\n  produce a scalar, vector, or array.\n  An equal-style variable can only use scalar values, which means a\n  global scalar, or an element of a global or per-atom vector or array.\n  A vector-style variable can use scalar values or a global vector of\n  values, or a column of a global array of values.  Atom-style variables\n  can use global scalar values.  They can also use per-atom vector\n  values, or a column of a per-atom array.  See the doc pages for\n  individual computes to see what kind of values they produce.\n  Examples of different kinds of compute references are as follows.\n  There is typically no ambiguity (see exception below) as to what a\n  reference means, since computes only produce either global or per-atom\n  quantities, never both.\n  \n  \n  \n  \n  \n  \n  c_ID       | global scalar, or per-atom vector\n  \n  c_ID[I]    | Ith element of global vector, or atom I’s value in per-atom vector, or Ith column from per-atom array\n  \n  c_ID[I][J] | I,J element of global array, or atom I’s Jth value in per-atom array\n  \n  \n  \n  For I and J indices, integers can be specified or a variable name,\n  specified as v_name, where name is the name of the variable.  The\n  rules for this syntax are the same as for the “Atom Values and\n  Vectors” discussion above.\n  One source of ambiguity for compute references is when a vector-style\n  variable refers to a compute that produces both a global scalar and a\n  global vector.  Consider a compute with ID “foo” that does this,\n  referenced as follows by variable “a”, where “myVec” is another\n  vector-style variable:\n  variable a vector c_foo*v_myVec\n  \n  \n  The reference “c_foo” could refer to either the global scalar or\n  global vector produced by compute “foo”.  In this case, “c_foo” will\n  always refer to the global scalar, and “C_foo” can be used to\n  reference the global vector.  Similarly if the compute produces both a\n  global vector and global array, then “c_foo[I]” will always refer to\n  an element of the global vector, and “C_foo[I]” can be used to\n  reference the Ith column of the global array.\n  Note that if a variable containing a compute is evaluated directly in\n  an input script (not during a run), then the values accessed by the\n  compute must be current.  See the discussion below about “Variable\n  Accuracy”.\n  \n  \n  \n  Fix References\n  Fix references access quantities calculated by a fix.\n  The ID in the reference should be replaced by the ID of a fix defined\n  elsewhere in the input script.  As discussed in the doc page for the\n  fix command, fixes can produce global, per-atom, or local\n  values.  Only global and per-atom values can be used in a variable.\n  Fixes can also produce a scalar, vector, or array.  An equal-style\n  variable can only use scalar values, which means a global scalar, or\n  an element of a global or per-atom vector or array.  Atom-style\n  variables can use the same scalar values.  They can also use per-atom\n  vector values.  A vector value can be a per-atom vector itself, or a\n  column of an per-atom array.  See the doc pages for individual fixes\n  to see what kind of values they produce.\n  The different kinds of fix references are exactly the same as the\n  compute references listed in the above table, where “c_” is replaced\n  by “f_”.  Again, there is typically no ambiguity (see exception below)\n  as to what a reference means, since fixes only produce either global\n  or per-atom quantities, never both.\n  \n  \n  \n  \n  \n  \n  f_ID       | global scalar, or per-atom vector\n  \n  f_ID[I]    | Ith element of global vector, or atom I’s value in per-atom vector, or Ith column from per-atom array\n  \n  f_ID[I][J] | I,J element of global array, or atom I’s Jth value in per-atom array\n  \n  \n  \n  For I and J indices, integers can be specified or a variable name,\n  specified as v_name, where name is the name of the variable.  The\n  rules for this syntax are the same as for the “Atom Values and\n  Vectors” discussion above.\n  One source of ambiguity for fix references is the same ambiguity\n  discussed for compute references above.  Namely when a vector-style\n  variable refers to a fix that produces both a global scalar and a\n  global vector.  The solution is the same as for compute references.\n  For a fix with ID “foo”, “f_foo” will always refer to the global\n  scalar, and “F_foo” can be used to reference the global vector.  And\n  similarly for distinguishing between a fix’s global vector versus\n  global array with “f_foo[I]” versus “F_foo[I]”.\n  Note that if a variable containing a fix is evaluated directly in an\n  input script (not during a run), then the values accessed by the fix\n  should be current.  See the discussion below about “Variable\n  Accuracy”.\n  Note that some fixes only generate quantities on certain timesteps.\n  If a variable attempts to access the fix on non-allowed timesteps, an\n  error is generated.  For example, the fix ave/time\n  command may only generate averaged quantities every 100 steps.  See\n  the doc pages for individual fix commands for details.\n  \n  \n  \n  Variable References\n  Variable references access quantities stored or calculated by other\n  variables, which will cause those variables to be evaluated.  The name\n  in the reference should be replaced by the name of a variable defined\n  elsewhere in the input script.\n  As discussed on this doc page, equal-style variables generate a single\n  global numeric value, vector-style variables generate a vector of\n  global numeric values, and atom-style and atomfile-style variables\n  generate a per-atom vector of numeric values.  All other variables\n  store one or more strings.\n  The formula for an equal-style variable can use any style of variable\n  including a vector_style or atom-style or atomfile-style.  For these\n  3 styles, a subscript must be used to access a single value from\n  the vector-, atom-, or atomfile-style variable.  If a string-storing\n  variable is used, the string is converted to a numeric value.  Note\n  that this will typically produce a 0.0 if the string is not a numeric\n  string, which is likely not what you want.\n  The formula for a vector-style variable can use any style of variable,\n  including atom-style or atomfile-style variables.  For these 2 styles,\n  a subscript must be used to access a single value from the atom-, or\n  atomfile-style variable.\n  The formula for an atom-style variable can use any style of variable,\n  including other atom-style or atomfile-style variables.  If it uses a\n  vector-style variable, a subscript must be used to access a single\n  value from the vector-style variable.\n  Examples of different kinds of variable references are as follows.\n  There is no ambiguity as to what a reference means, since variables\n  produce only a global scalar or global vector or per-atom vector.\n  \n  \n  \n  \n  \n  \n  v_name    | global scalar from equal-style variable\n  \n  v_name    | global vector from vector-style variable\n  \n  v_name    | per-atom vector from atom-style or atomfile-style variable\n  \n  v_name[I] | Ith element of a global vector from vector-style variable\n  \n  v_name[I] | value of atom with ID = I from atom-style or atomfile-style variable\n  \n  \n  \n  For the I index, an integer can be specified or a variable name,\n  specified as v_name, where name is the name of the variable.  The\n  rules for this syntax are the same as for the “Atom Values and\n  Vectors” discussion above.\n  \n  Immediate Evaluation of Variables:\n  If you want an equal-style variable to be evaluated immediately, it\n  may be the case that you do not need to define a variable at all.  See\n  the Commands parse doc page for info on how to\n  use “immediate” variables in an input script, specified as $(formula)\n  with parenthesis, where the formula has the same syntax as equal-style\n  variables described on this page.  This effectively evaluates a\n  formula immediately without using the variable command to define a\n  named variable.\n  More generally, there is a difference between referencing a variable\n  with a leading $ sign (e.g. $x or ${abc}) versus with a leading “v_”\n  (e.g. v_x or v_abc).  The former can be used in any input script\n  command, including a variable command.  The input script parser\n  evaluates the reference variable immediately and substitutes its value\n  into the command.  As explained on the Commands parse doc page, you can also use un-named\n  “immediate” variables for this purpose.  For example, a string like\n  this $((xlo+xhi)/2+sqrt(v_area)) in an input script command evaluates\n  the string between the parenthesis as an equal-style variable formula.\n  Referencing a variable with a leading “v_” is an optional or required\n  kind of argument for some commands (e.g. the fix ave/chunk or dump custom or\n  thermo_style commands) if you wish it to evaluate\n  a variable periodically during a run.  It can also be used in a\n  variable formula if you wish to reference a second variable.  The\n  second variable will be evaluated whenever the first variable is\n  evaluated.\n  As an example, suppose you use this command in your input script to\n  define the variable “v” as\n  variable v equal vol\n  \n  \n  before a run where the simulation box size changes.  You might think\n  this will assign the initial volume to the variable “v”.  That is not\n  the case.  Rather it assigns a formula which evaluates the volume\n  (using the thermo_style keyword “vol”) to the variable “v”.  If you\n  use the variable “v” in some other command like fix ave/time then the current volume of the box will be\n  evaluated continuously during the run.\n  If you want to store the initial volume of the system, you can do it\n  this way:\n  variable v equal vol\n  variable v0 equal $v\n  \n  \n  The second command will force “v” to be evaluated (yielding the\n  initial volume) and assign that value to the variable “v0”.  Thus the\n  command\n  thermo_style custom step v_v v_v0\n  \n  \n  would print out both the current and initial volume periodically\n  during the run.\n  Note that it is a mistake to enclose a variable formula in double\n  quotes if it contains variables preceded by $ signs.  For example,\n  variable vratio equal \"${vfinal}/${v0}\"\n  \n  \n  This is because the quotes prevent variable substitution (explained on\n  the Commands parse doc page), and thus an error\n  will occur when the formula for “vratio” is evaluated later.\n  \n  Variable Accuracy:\n  Obviously, LAMMPS attempts to evaluate variables containing formulas\n  (equal and atom style variables) accurately whenever the\n  evaluation is performed.  Depending on what is included in the\n  formula, this may require invoking a compute, either\n  directly or indirectly via a thermo keyword, or accessing a value\n  previously calculated by a compute, or accessing a value calculated\n  and stored by a fix.  If the compute is one that calculates\n  the pressure or energy of the system, then these quantities need to be\n  tallied during the evaluation of the interatomic potentials (pair,\n  bond, etc) on timesteps that the variable will need the values.\n  LAMMPS keeps track of all of this during a run or energy minimization.  An error will be generated if you\n  attempt to evaluate a variable on timesteps when it cannot produce\n  accurate values.  For example, if a thermo_style custom command prints a variable which accesses\n  values stored by a fix ave/time command and the\n  timesteps on which thermo output is generated are not multiples of the\n  averaging frequency used in the fix command, then an error will occur.\n  An input script can also request variables be evaluated before or\n  after or in between runs, e.g. by including them in a\n  print command.  In this case, if a compute is needed to\n  evaluate a variable (either directly or indirectly), LAMMPS will not\n  invoke the compute, but it will use a value previously calculated by\n  the compute, and can do this only if it was invoked on the current\n  timestep.  Fixes will always provide a quantity needed by a variable,\n  but the quantity may or may not be current.  This leads to one of\n  three kinds of behavior:\n  (1) The variable may be evaluated accurately.  If it contains\n  references to a compute or fix, and these values were calculated on\n  the last timestep of a preceding run, then they will be accessed and\n  used by the variable and the result will be accurate.\n  (2) LAMMPS may not be able to evaluate the variable and will generate\n  an error message stating so.  For example, if the variable requires a\n  quantity from a compute that has not been invoked on\n  the current timestep, LAMMPS will generate an error.  This means, for\n  example, that such a variable cannot be evaluated before the first run\n  has occurred.  Likewise, in between runs, a variable containing a\n  compute cannot be evaluated unless the compute was invoked on the last\n  timestep of the preceding run, e.g. by thermodynamic output.\n  One way to get around this problem is to perform a 0-timestep run\n  before using the variable.  For example, these commands\n  variable t equal temp\n  print \"Initial temperature = $t\"\n  run 1000\n  \n  \n  will generate an error if the run is the first run specified in the\n  input script, because generating a value for the “t” variable requires\n  a compute for calculating the temperature to be invoked.\n  However, this sequence of commands would be fine:\n  run 0\n  variable t equal temp\n  print \"Initial temperature = $t\"\n  run 1000\n  \n  \n  The 0-timestep run initializes and invokes various computes, including\n  the one for temperature, so that the value it stores is current and\n  can be accessed by the variable “t” after the run has completed.  Note\n  that a 0-timestep run does not alter the state of the system, so it\n  does not change the input state for the 1000-timestep run that\n  follows.  Also note that the 0-timestep run must actually use and\n  invoke the compute in question (e.g. via thermo or\n  dump output) in order for it to enable the compute to be\n  used in a variable after the run.  Thus if you are trying to print a\n  variable that uses a compute you have defined, you can insure it is\n  invoked on the last timestep of the preceding run by including it in\n  thermodynamic output.\n  Unlike computes, fixes will never generate an error if\n  their values are accessed by a variable in between runs.  They always\n  return some value to the variable.  However, the value may not be what\n  you expect if the fix has not yet calculated the quantity of interest\n  or it is not current.  For example, the fix indent\n  command stores the force on the indenter.  But this is not computed\n  until a run is performed.  Thus if a variable attempts to print this\n  value before the first run, zeroes will be output.  Again, performing\n  a 0-timestep run before printing the variable has the desired effect.\n  (3) The variable may be evaluated incorrectly and LAMMPS may have no\n  way to detect this has occurred.  Consider the following sequence of\n  commands:\n  pair_coeff 1 1 1.0 1.0\n  run 1000\n  pair_coeff 1 1 1.5 1.0\n  variable e equal pe\n  print \"Final potential energy = $e\"\n  \n  \n  The first run is performed using one setting for the pairwise\n  potential defined by the pair_style and\n  pair_coeff commands.  The potential energy is\n  evaluated on the final timestep and stored by the compute pe compute (this is done by the\n  thermo_style command).  Then a pair coefficient is\n  changed, altering the potential energy of the system.  When the\n  potential energy is printed via the “e” variable, LAMMPS will use the\n  potential energy value stored by the compute pe\n  compute, thinking it is current.  There are many other commands which\n  could alter the state of the system between runs, causing a variable\n  to evaluate incorrectly.\n  The solution to this issue is the same as for case (2) above, namely\n  perform a 0-timestep run before the variable is evaluated to insure\n  the system is up-to-date.  For example, this sequence of commands\n  would print a potential energy that reflected the changed pairwise\n  coefficient:\n  pair_coeff 1 1 1.0 1.0\n  run 1000\n  pair_coeff 1 1 1.5 1.0\n  run 0\n  variable e equal pe\n  print \"Final potential energy = $e\"\n  \n  \n  \n  ",
    "syntax": "variable name style args ...\n  \n  \n  \n  name = name of variable to define\n  style = delete or index or loop or world or universe or uloop or string or format or getenv or file or atomfile or python or internal or equal or vector or atom\n  delete = no args\n  index args = one or more strings\n  loop args = N\n    N = integer size of loop, loop from 1 to N inclusive\n  loop args = N pad\n    N = integer size of loop, loop from 1 to N inclusive\n    pad = all values will be same length, e.g. 001, 002, ..., 100\n  loop args = N1 N2\n    N1,N2 = loop from N1 to N2 inclusive\n  loop args = N1 N2 pad\n    N1,N2 = loop from N1 to N2 inclusive\n    pad = all values will be same length, e.g. 050, 051, ..., 100\n  world args = one string for each partition of processors\n  universe args = one or more strings\n  uloop args = N\n    N = integer size of loop\n  uloop args = N pad\n    N = integer size of loop\n    pad = all values will be same length, e.g. 001, 002, ..., 100\n  string arg = one string\n  format args = vname fstr\n    vname = name of equal-style variable to evaluate\n    fstr = C-style format string\n  getenv arg = one string\n  file arg = filename\n  atomfile arg = filename\n  python arg = function\n  internal arg = numeric value\n  equal or vector or atom args = one formula containing numbers, thermo keywords, math operations, group functions, atom values and vectors, compute/fix/variable references\n    numbers = 0.0, 100, -5.4, 2.8e-4, etc\n    constants = PI, version, on, off, true, false, yes, no\n    thermo keywords = vol, ke, press, etc from thermo_style\n    math operators = (), -x, x+y, x-y, x*y, x/y, x^y, x%y,\n                     x == y, x != y, x < y, x <= y, x > y, x >= y, x && y, x || y, x |^ y, !x\n    math functions = sqrt(x), exp(x), ln(x), log(x), abs(x),\n                     sin(x), cos(x), tan(x), asin(x), acos(x), atan(x), atan2(y,x),\n                     random(x,y,z), normal(x,y,z), ceil(x), floor(x), round(x)\n                     ramp(x,y), stagger(x,y), logfreq(x,y,z), logfreq2(x,y,z),\n                     logfreq3(x,y,z), stride(x,y,z), stride2(x,y,z,a,b,c),\n                     vdisplace(x,y), swiggle(x,y,z), cwiggle(x,y,z)\n    group functions = count(group), mass(group), charge(group),\n                      xcm(group,dim), vcm(group,dim), fcm(group,dim),\n                      bound(group,dir), gyration(group), ke(group),\n                      angmom(group,dim), torque(group,dim),\n                      inertia(group,dimdim), omega(group,dim)\n    region functions = count(group,region), mass(group,region), charge(group,region),\n                      xcm(group,dim,region), vcm(group,dim,region), fcm(group,dim,region),\n                      bound(group,dir,region), gyration(group,region), ke(group,reigon),\n                      angmom(group,dim,region), torque(group,dim,region),\n                      inertia(group,dimdim,region), omega(group,dim,region)\n    special functions = sum(x), min(x), max(x), ave(x), trap(x), slope(x), gmask(x), rmask(x), grmask(x,y), next(x)\n    feature functions = is_active(category,feature,exact), is_defined(category,id,exact)\n    atom value = id[i], mass[i], type[i], mol[i], x[i], y[i], z[i], vx[i], vy[i], vz[i], fx[i], fy[i], fz[i], q[i]\n    atom vector = id, mass, type, mol, x, y, z, vx, vy, vz, fx, fy, fz, q\n    compute references = c_ID, c_ID[i], c_ID[i][j], C_ID, C_ID[i]\n    fix references = f_ID, f_ID[i], f_ID[i][j], F_ID, F_ID[i]\n    variable references = v_name, v_name[i]\n  \n  \n  ",
    "examples": "variable x index run1 run2 run3 run4 run5 run6 run7 run8\n  variable LoopVar loop $n\n  variable beta equal temp/3.0\n  variable b1 equal x[234]+0.5*vol\n  variable b1 equal \"x[234] + 0.5*vol\"\n  variable b equal xcm(mol1,x)/2.0\n  variable b equal c_myTemp\n  variable b atom x*y/vol\n  variable foo string myfile\n  variable foo internal 3.5\n  variable myPy python increase\n  variable f file values.txt\n  variable temp world 300.0 310.0 320.0 ${Tfinal}\n  variable x universe 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n  variable x uloop 15 pad\n  variable str format x %.6g\n  variable x delete\n  \n  \n  ",
    "restrictions": "Indexing any formula element by global atom ID, such as an atom value,\n  requires the atom style to use a global mapping in\n  order to look up the vector indices.  By default, only atom styles\n  with molecular information create global maps.  The atom_modify map command can override the default, e.g. for\n  atomic-style atom styles.\n  All universe- and uloop-style variables defined in an input script\n  must have the same number of values.\n  "
},
{
    "command": "velocity",
    "description": "Set or change the velocities of a group of atoms in one of several\n  styles.  For each style, there are required arguments and optional\n  keyword/value parameters.  Not all options are used by each style.\n  Each option has a default as listed below.\n  The create style generates an ensemble of velocities using a random\n  number generator with the specified seed at the specified temperature.\n  The set style sets the velocities of all atoms in the group to the\n  specified values.  If any component is specified as NULL, then it is\n  not set.  Any of the vx,vy,vz velocity components can be specified as\n  an equal-style or atom-style variable.  If the value\n  is a variable, it should be specified as v_name, where name is the\n  variable name.  In this case, the variable will be evaluated, and its\n  value used to determine the velocity component.  Note that if a\n  variable is used, the velocity it calculates must be in box units, not\n  lattice units; see the discussion of the units keyword below.\n  Equal-style variables can specify formulas with various mathematical\n  functions, and include thermo_style command\n  keywords for the simulation box parameters or other parameters.\n  Atom-style variables can specify the same formulas as equal-style\n  variables but can also include per-atom values, such as atom\n  coordinates.  Thus it is easy to specify a spatially-dependent\n  velocity field.\n  The scale style computes the current temperature of the group of\n  atoms and then rescales the velocities to the specified temperature.\n  The ramp style is similar to that used by the compute temp/ramp command.  Velocities ramped\n  uniformly from vlo to vhi are applied to dimension vx, or vy, or vz.\n  The value assigned to a particular atom depends on its relative\n  coordinate value (in dim) from clo to chi.  For the example above, an\n  atom with y-coordinate of 10 (1/4 of the way from 5 to 25), would be\n  assigned a x-velocity of 1.25 (1/4 of the way from 0.0 to 5.0).  Atoms\n  outside the coordinate bounds (less than 5 or greater than 25 in this\n  case), are assigned velocities equal to vlo or vhi (0.0 or 5.0 in this\n  case).\n  The zero style adjusts the velocities of the group of atoms so that\n  the aggregate linear or angular momentum is zero.  No other changes\n  are made to the velocities of the atoms.  If the rigid option is\n  specified (see below), then the zeroing is performed on individual\n  rigid bodies, as defined by the fix rigid or fix rigid/small commands.  In other words, zero linear\n  will set the linear momentum of each rigid body to zero, and zero\n  angular will set the angular momentum of each rigid body to zero.\n  This is done by adjusting the velocities of the atoms in each rigid\n  body.\n  All temperatures specified in the velocity command are in temperature\n  units; see the units command.  The units of velocities and\n  coordinates depend on whether the units keyword is set to box or\n  lattice, as discussed below.\n  For all styles, no atoms are assigned z-component velocities if the\n  simulation is 2d; see the dimension command.\n  \n  The keyword/value options are used in the following ways by the\n  various styles.\n  The dist keyword is used by create.  The ensemble of generated\n  velocities can be a uniform distribution from some minimum to\n  maximum value, scaled to produce the requested temperature.  Or it can\n  be a gaussian distribution with a mean of 0.0 and a sigma scaled to\n  produce the requested temperature.\n  The sum keyword is used by all styles, except zero.  The new\n  velocities will be added to the existing ones if sum = yes, or will\n  replace them if sum = no.\n  The mom and rot keywords are used by create.  If mom = yes, the\n  linear momentum of the newly created ensemble of velocities is zeroed;\n  if rot = yes, the angular momentum is zeroed.\n  \n  If specified, the temp keyword is used by create and scale to\n  specify a compute that calculates temperature in a\n  desired way, e.g. by first subtracting out a velocity bias, as\n  discussed on the Howto thermostat doc page.\n  If this keyword is not specified, create and scale calculate\n  temperature using a compute that is defined internally as follows:\n  compute velocity_temp group-ID temp\n  \n  \n  where group-ID is the same ID used in the velocity command. i.e. the\n  group of atoms whose velocity is being altered.  This compute is\n  deleted when the velocity command is finished.  See the compute temp command for details.  If the calculated\n  temperature should have degrees-of-freedom removed due to fix\n  constraints (e.g. SHAKE or rigid-body constraints), then the\n  appropriate fix command must be specified before the velocity command\n  is issued.\n  The bias keyword with a yes setting is used by create and\n  scale, but only if the temp keyword is also used to specify a\n  compute that calculates temperature in a desired way.\n  If the temperature compute also calculates a velocity bias, the\n  bias is subtracted from atom velocities before the create and\n  scale operations are performed.  After the operations, the bias is\n  added back to the atom velocities.  See the Howto thermostat doc page for more discussion of\n  temperature computes with biases.  Note that the velocity bias is only\n  applied to atoms in the temperature compute specified with the temp\n  keyword.\n  As an example, assume atoms are currently streaming in a flow\n  direction (which could be separately initialized with the ramp\n  style), and you wish to initialize their thermal velocity to a desired\n  temperature.  In this context thermal velocity means the per-particle\n  velocity that remains when the streaming velocity is subtracted.  This\n  can be done using the create style with the temp keyword\n  specifying the ID of a compute temp/ramp or\n  compute temp/profile command, and the\n  bias keyword set to a yes value.\n  \n  The loop keyword is used by create in the following ways.\n  If loop = all, then each processor loops over all atoms in the\n  simulation to create velocities, but only stores velocities for atoms\n  it owns.  This can be a slow loop for a large simulation.  If atoms\n  were read from a data file, the velocity assigned to a particular atom\n  will be the same, independent of how many processors are being used.\n  This will not be the case if atoms were created using the\n  create_atoms command, since atom IDs will likely\n  be assigned to atoms differently.\n  If loop = local, then each processor loops over only its atoms to\n  produce velocities.  The random number seed is adjusted to give a\n  different set of velocities on each processor.  This is a fast loop,\n  but the velocity assigned to a particular atom will depend on which\n  processor owns it.  Thus the results will always be different when a\n  simulation is run on a different number of processors.\n  If loop = geom, then each processor loops over only its atoms.  For\n  each atom a unique random number seed is created, based on the atom’s\n  xyz coordinates.  A velocity is generated using that seed.  This is a\n  fast loop and the velocity assigned to a particular atom will be the\n  same, independent of how many processors are used.  However, the set\n  of generated velocities may be more correlated than if the all or\n  local keywords are used.\n  Note that the loop geom keyword will not necessarily assign\n  identical velocities for two simulations run on different machines.\n  This is because the computations based on xyz coordinates are\n  sensitive to tiny differences in the double-precision value for a\n  coordinate as stored on a particular machine.\n  \n  The rigid keyword only has meaning when used with the zero style.\n  It allows specification of a fix-ID for one of the rigid-body fix variants which defines a set of rigid bodies.  The\n  zeroing of linear or angular momentum is then performed for each rigid\n  body defined by the fix, as described above.\n  The units keyword is used by set and ramp.  If units = box,\n  the velocities and coordinates specified in the velocity command are\n  in the standard units described by the units command\n  (e.g. Angstroms/fmsec for real units).  If units = lattice, velocities\n  are in units of lattice spacings per time (e.g. spacings/fmsec) and\n  coordinates are in lattice spacings.  The lattice\n  command must have been previously used to define the lattice spacing.\n  ",
    "syntax": "velocity group-ID style args keyword value ...\n  \n  \n  \n  group-ID = ID of group of atoms whose velocity will be changed\n  style = create or set or scale or ramp or zero\n  create args = temp seed\n    temp = temperature value (temperature units)\n    seed = random # seed (positive integer)\n  set args = vx vy vz\n    vx,vy,vz = velocity value or NULL (velocity units)\n    any of vx,vy,vz van be a variable (see below)\n  scale arg = temp\n    temp = temperature value (temperature units)\n  ramp args = vdim vlo vhi dim clo chi\n    vdim = vx or vy or vz\n    vlo,vhi = lower and upper velocity value (velocity units)\n    dim = x or y or z\n    clo,chi = lower and upper coordinate bound (distance units)\n  zero arg = linear or angular\n    linear = zero the linear momentum\n    angular = zero the angular momentum\n  \n  zero or more keyword/value pairs may be appended\n  keyword = dist or sum or mom or rot or temp or bias or loop or units\n  dist value = uniform or gaussian\n  sum value = no or yes\n  mom value = no or yes\n  rot value = no or yes\n  temp value = temperature compute ID\n  bias value = no or yes\n  loop value = all or local or geom\n  rigid value = fix-ID\n    fix-ID = ID of rigid body fix\n  units value = box or lattice\n  \n  \n  ",
    "examples": "velocity all create 300.0 4928459 rot yes dist gaussian\n  velocity border set NULL 4.0 v_vz sum yes units box\n  velocity flow scale 300.0\n  velocity flow ramp vx 0.0 5.0 y 5 25 temp mytemp\n  velocity all zero linear\n  \n  \n  ",
    "restrictions": "Assigning a temperature via the create style to a system with rigid bodies or SHAKE constraints may not\n  have the desired outcome for two reasons.  First, the velocity command\n  can be invoked before all of the relevant fixes are created and\n  initialized and the number of adjusted degrees of freedom (DOFs) is\n  known.  Thus it is not possible to compute the target temperature\n  correctly.  Second, the assigned velocities may be partially canceled\n  when constraints are first enforced, leading to a different\n  temperature than desired.  A workaround for this is to perform a run 0 command, which insures all DOFs are accounted for\n  properly, and then rescale the temperature to the desired value before\n  performing a simulation.  For example:\n  velocity all create 300.0 12345\n  run 0                             # temperature may not be 300K\n  velocity all scale 300.0          # now it should be\n  \n  \n  "
},
{
    "command": "write_coeff",
    "description": "Write a text format file with the currently defined force field\n  coefficients in a way, that it can be read by LAMMPS with the\n  include command. In combination with the nocoeff\n  option of write_data this can be used to move\n  the Coeffs sections from a data file into a separate file.\n  \n  Note\n  The write_coeff command is not yet fully implemented as\n  some pair styles do not output their coefficient information.\n  This means you will need to add/copy this information manually.\n  \n  ",
    "syntax": "write_coeff file\n  \n  \n  \n  file = name of data file to write out\n  \n  ",
    "examples": "write_coeff polymer.coeff\n  \n  \n  ",
    "restrictions": "none\n  "
},
{
    "command": "write_data",
    "description": "Write a data file in text format of the current state of the\n  simulation.  Data files can be read by the read data\n  command to begin a simulation.  The read_data command\n  also describes their format.\n  Similar to dump files, the data filename can contain a “*”\n  wild-card character.  The “*” is replaced with the current timestep\n  value.\n  \n  Note\n  The write-data command is not yet fully implemented in two\n  respects.  First, most pair styles do not yet write their coefficient\n  information into the data file.  This means you will need to specify\n  that information in your input script that reads the data file, via\n  the pair_coeff command.  Second, a few of the atom styles (body, ellipsoid, line, tri) that store\n  auxiliary “bonus” information about aspherical particles, do not yet\n  write the bonus info into the data file.  Both these functionalities\n  will be added to the write_data command later.\n  \n  Because a data file is in text format, if you use a data file written\n  out by this command to restart a simulation, the initial state of the\n  new run will be slightly different than the final state of the old run\n  (when the file was written) which was represented internally by LAMMPS\n  in binary format.  A new simulation which reads the data file will\n  thus typically diverge from a simulation that continued in the\n  original input script.\n  If you want to do more exact restarts, using binary files, see the\n  restart, write_restart, and\n  read_restart commands.  You can also convert\n  binary restart files to text data files, after a simulation has run,\n  using the -r command-line switch.\n  \n  Note\n  Only limited information about a simulation is stored in a data\n  file.  For example, no information about atom groups and\n  fixes are stored.  Binary restart files\n  store more information.\n  \n  Bond interactions (angle, etc) that have been turned off by the fix shake or delete_bonds command will\n  be written to a data file as if they are turned on.  This means they\n  will need to be turned off again in a new run after the data file is\n  read.\n  Bonds that are broken (e.g. by a bond-breaking potential) are not\n  written to the data file.  Thus these bonds will not exist when the\n  data file is read.\n  \n  The nocoeff keyword requests that no force field parameters should\n  be written to the data file. This can be very helpful, if one wants\n  to make significant changes to the force field or if the parameters\n  are read in separately anyway, e.g. from an include file.\n  The nofix keyword requests that no extra sections read by fixes\n  should be written to the data file (see the fix option of the\n  read_data command for details). For example, this\n  option excludes sections for user-created per-atom properties\n  from fix property/atom.\n  The pair keyword lets you specify in what format the pair\n  coefficient information is written into the data file.  If the value\n  is specified as ii, then one line per atom type is written, to\n  specify the coefficients for each of the I=J interactions.  This means\n  that no cross-interactions for I != J will be specified in the data\n  file and the pair style will apply its mixing rule, as documented on\n  individual pair_style doc pages.  Of course this\n  behavior can be overridden in the input script after reading the data\n  file, by specifying additional pair_coeff commands\n  for any desired I,J pairs.\n  If the value is specified as ij, then one line of coefficients is\n  written for all I,J pairs where I <= J.  These coefficients will\n  include any specific settings made in the input script up to that\n  point.  The presence of these I != J coefficients in the data file\n  will effectively turn off the default mixing rule for the pair style.\n  Again, the coefficient values in the data file can be overridden\n  in the input script after reading the data file, by specifying\n  additional pair_coeff commands for any desired I,J\n  pairs.\n  ",
    "syntax": "write_data file keyword value ...\n  \n  \n  \n  file = name of data file to write out\n  zero or more keyword/value pairs may be appended\n  keyword = pair or nocoeff\n  nocoeff = do not write out force field info\n  nofix = do not write out extra sections read by fixes\n  pair value = ii or ij\n    ii = write one line of pair coefficient info per atom type\n    ij = write one line of pair coefficient info per IJ atom type pair\n  \n  \n  ",
    "examples": "write_data data.polymer\n  write_data data.*\n  \n  \n  ",
    "restrictions": "This command requires inter-processor communication to migrate atoms\n  before the data file is written.  This means that your system must be\n  ready to perform a simulation before using this command (force fields\n  setup, atom masses initialized, etc).\n  "
},
{
    "command": "write_dump",
    "description": "Dump a single snapshot of atom quantities to one or more files for the\n  current state of the system.  This is a one-time immediate operation,\n  in contrast to the dump command which will will set up a\n  dump style to write out snapshots periodically during a running\n  simulation.\n  The syntax for this command is mostly identical to that of the\n  dump and dump_modify commands as if\n  they were concatenated together, with the following exceptions: There\n  is no need for a dump ID or dump frequency and the keyword modify is\n  added.  The latter is so that the full range of\n  dump_modify options can be specified for the single\n  snapshot, just as they can be for multiple snapshots.  The modify\n  keyword separates the arguments that would normally be passed to the\n  dump command from those that would be given the dump_modify.  Both\n  support optional arguments and thus LAMMPS needs to be able to cleanly\n  separate the two sets of args.\n  Note that if the specified filename uses wildcard characters “*” or\n  “%”, as supported by the dump command, they will operate\n  in the same fashion to create the new filename(s).  Normally, dump image files require a filename with a “*” character\n  for the timestep.  That is not the case for the write_dump command; no\n  wildcard “*” character is necessary.\n  ",
    "syntax": "write_dump group-ID style file dump-args modify dump_modify-args\n  \n  \n  \n  group-ID = ID of the group of atoms to be dumped\n  style = any of the supported dump styles\n  file = name of file to write dump info to\n  dump-args = any additional args needed for a particular dump style\n  modify = all args after this keyword are passed to dump_modify (optional)\n  dump-modify-args = args for dump_modify (optional)\n  \n  ",
    "examples": "write_dump all atom dump.atom\n  write_dump subgroup atom dump.run.bin\n  write_dump all custom dump.myforce.* id type x y vx fx\n  write_dump flow custom dump.%.myforce id type c_myF[3] v_ke modify sort id\n  write_dump all xyz system.xyz modify sort id element O H\n  write_dump all image snap*.jpg type type size 960 960 modify backcolor white\n  write_dump all image snap*.jpg element element &\n     bond atom 0.3 shiny 0.1 ssao yes 6345 0.2 size 1600 1600  &\n     modify backcolor white element C C O H N C C C O H H S O H\n  \n  \n  ",
    "restrictions": "All restrictions for the dump and\n  dump_modify commands apply to this command as well,\n  with the exception of the dump image filename not\n  requiring a wildcard “*” character, as noted above.\n  Since dumps are normally written during a run or energy minimization, the simulation has to be ready to run\n  before this command can be used.  Similarly, if the dump requires\n  information from a compute, fix, or variable, the information needs to\n  have been calculated for the current timestep (e.g. by a prior run),\n  else LAMMPS will generate an error message.\n  For example, it is not possible to dump per-atom energy with this\n  command before a run has been performed, since no energies and forces\n  have yet been calculated.  See the variable doc page\n  section on Variable Accuracy for more information on this topic.\n  "
},
{
    "command": "write_restart",
    "description": "Write a binary restart file of the current state of the simulation.\n  During a long simulation, the restart command is\n  typically used to output restart files periodically.  The\n  write_restart command is useful after a minimization or whenever you\n  wish to write out a single current restart file.\n  Similar to dump files, the restart filename can contain\n  two wild-card characters.  If a “*” appears in the filename, it is\n  replaced with the current timestep value.  If a “%” character appears\n  in the filename, then one file is written by each processor and the\n  “%” character is replaced with the processor ID from 0 to P-1.  An\n  additional file with the “%” replaced by “base” is also written, which\n  contains global information.  For example, the files written for\n  filename restart.% would be restart.base, restart.0, restart.1, …\n  restart.P-1.  This creates smaller files and can be a fast mode of\n  output and subsequent input on parallel machines that support parallel\n  I/O.  The optional fileper and nfile keywords discussed below can\n  alter the number of files written.\n  The restart file can also be written in parallel as one large binary\n  file via the MPI-IO library, which is part of the MPI standard for\n  versions 2.0 and above.  Using MPI-IO requires two steps.  First,\n  build LAMMPS with its MPIIO package installed, e.g.\n  make yes-mpiio    # installs the MPIIO package\n  make mpi          # build LAMMPS for your platform\n  \n  \n  Second, use a restart filename which contains “.mpiio”.  Note that it\n  does not have to end in “.mpiio”, just contain those characters.\n  Unlike MPI-IO dump files, a particular restart file must be both\n  written and read using MPI-IO.\n  Restart files can be read by a read_restart\n  command to restart a simulation from a particular state.  Because the\n  file is binary (to enable exact restarts), it may not be readable on\n  another machine.  In this case, you can use the -r command-line switch to convert a restart file to a data file.\n  \n  Note\n  Although the purpose of restart files is to enable restarting a\n  simulation from where it left off, not all information about a\n  simulation is stored in the file.  For example, the list of fixes that\n  were specified during the initial run is not stored, which means the\n  new input script must specify any fixes you want to use.  Even when\n  restart information is stored in the file, as it is for some fixes,\n  commands may need to be re-specified in the new input script, in order\n  to re-use that information. Details are usually given in the\n  documentation of the respective command. Also, see the\n  read_restart command for general information about\n  what is stored in a restart file.\n  \n  \n  The optional nfile or fileper keywords can be used in conjunction\n  with the “%” wildcard character in the specified restart file name.\n  As explained above, the “%” character causes the restart file to be\n  written in pieces, one piece for each of P processors.  By default P =\n  the number of processors the simulation is running on.  The nfile or\n  fileper keyword can be used to set P to a smaller value, which can\n  be more efficient when running on a large number of processors.\n  The nfile keyword sets P to the specified Nf value.  For example, if\n  Nf = 4, and the simulation is running on 100 processors, 4 files will\n  be written, by processors 0,25,50,75.  Each will collect information\n  from itself and the next 24 processors and write it to a restart file.\n  For the fileper keyword, the specified value of Np means write one\n  file for every Np processors.  For example, if Np = 4, every 4th\n  processor (0,4,8,12,etc) will collect information from itself and the\n  next 3 processors and write it to a restart file.\n  ",
    "syntax": "write_restart file keyword value ...\n  \n  \n  \n  file = name of file to write restart information to\n  zero or more keyword/value pairs may be appended\n  keyword = fileper or nfile\n  fileper arg = Np\n    Np = write one file for every this many processors\n  nfile arg = Nf\n    Nf = write this many files, one from each of Nf processors\n  \n  \n  ",
    "examples": "write_restart restart.equil\n  write_restart restart.equil.mpiio\n  write_restart poly.%.* nfile 10\n  \n  \n  ",
    "restrictions": "This command requires inter-processor communication to migrate atoms\n  before the restart file is written.  This means that your system must\n  be ready to perform a simulation before using this command (force\n  fields setup, atom masses initialized, etc).\n  To write and read restart files in parallel with MPI-IO, the MPIIO\n  package must be installed.\n  "
},
{
    "command": "fix adapt",
    "description": "Change or adapt one or more specific simulation attributes or settings\n  over time as a simulation runs.  Pair potential and K-space and atom\n  attributes which can be varied by this fix are discussed below.  Many\n  other fixes can also be used to time-vary simulation parameters,\n  e.g. the “fix deform” command will change the simulation box\n  size/shape and the “fix move” command will change atom positions and\n  velocities in a prescribed manner.  Also note that many commands allow\n  variables as arguments for specific parameters, if described in that\n  manner on their doc pages.  An equal-style variable can calculate a\n  time-dependent quantity, so this is another way to vary a simulation\n  parameter over time.\n  If N is specified as 0, the specified attributes are only changed\n  once, before the simulation begins.  This is all that is needed if the\n  associated variables are not time-dependent.  If N > 0, then changes\n  are made every N steps during the simulation, presumably with a\n  variable that is time-dependent.\n  Depending on the value of the reset keyword, attributes changed by\n  this fix will or will not be reset back to their original values at\n  the end of a simulation.  Even if reset is specified as yes, a\n  restart file written during a simulation will contain the modified\n  settings.\n  If the scale keyword is set to no, then the value the parameter is\n  set to will be whatever the variable generates.  If the scale\n  keyword is set to yes, then the value of the altered parameter will\n  be the initial value of that parameter multiplied by whatever the\n  variable generates.  I.e. the variable is now a “scale factor” applied\n  in (presumably) a time-varying fashion to the parameter.\n  Note that whether scale is no or yes, internally, the parameters\n  themselves are actually altered by this fix.  Make sure you use the\n  reset yes option if you want the parameters to be restored to their\n  initial values after the run.\n  \n  The pair keyword enables various parameters of potentials defined by\n  the pair_style command to be changed, if the pair\n  style supports it.  Note that the pair_style and\n  pair_coeff commands must be used in the usual manner\n  to specify these parameters initially; the fix adapt command simply\n  overrides the parameters.\n  The pstyle argument is the name of the pair style.  If pair_style hybrid or hybrid/overlay is used, pstyle should be\n  a sub-style name.  If there are multiple sub-styles using the same\n  pair style, then pstyle should be specified as “style:N” where N is\n  which instance of the pair style you wish to adapt, e.g. the first,\n  second, etc.  For example, pstyle could be specified as “soft” or\n  “lubricate” or “lj/cut:1” or “lj/cut:2”.  The pparam argument is the\n  name of the parameter to change.  This is the current list of pair\n  styles and parameters that can be varied by this fix.  See the doc\n  pages for individual pair styles and their energy formulas for the\n  meaning of these parameters:\n  \n  \n  \n  \n  \n  \n  \n  born\n  a,b,c\n  type pairs\n  \n  born/coul/long, born/coul/msm\n  coulombic_cutoff\n  type global\n  \n  buck\n  a,c\n  type pairs\n  \n  buck/coul/long, buck/coul/msm\n  coulombic_cutoff\n  type global\n  \n  buck/mdf\n  a,c\n  type pairs\n  \n  coul/cut\n  scale\n  type pairs\n  \n  coul/cut/soft\n  lambda\n  type pairs\n  \n  coul/debye\n  scale\n  type pairs\n  \n  coul/dsf\n  coulombic_cutoff\n  type global\n  \n  coul/long, coul/msm\n  coulombic_cutoff, scale\n  type pairs\n  \n  coul/long/soft\n  scale, lambda, coulombic_cutoff\n  type pairs\n  \n  eam, eam/alloy, eam/fs\n  scale\n  type pairs\n  \n  gauss\n  a\n  type pairs\n  \n  lennard/mdf\n  A,B\n  type pairs\n  \n  lj/class2\n  epsilon,sigma\n  type pairs\n  \n  lj/class2/coul/cut, lj/class2/coul/long\n  epsilon,sigma,coulombic_cutoff\n  type pairs\n  \n  lj/cut\n  epsilon,sigma\n  type pairs\n  \n  lj/cut/coul/cut, lj/cut/coul/long, lj/cut/coul/msm\n  epsilon,sigma,coulombic_cutoff\n  type pairs\n  \n  lj/cut/coul/cut/soft, lj/cut/coul/long/soft\n  epsilon,sigma,lambda,coulombic_cutoff\n  type pairs\n  \n  lj/cut/coul/dsf\n  cutoff\n  type global\n  \n  lj/cut/tip4p/cut\n  epsilon,sigma,coulombic_cutoff\n  type pairs\n  \n  lj/cut/soft\n  epsilon,sigma,lambda\n  type pairs\n  \n  lj/expand\n  epsilon,sigma,delta\n  type pairs\n  \n  lj/mdf\n  epsilon,sigma\n  type pairs\n  \n  lj/sf/dipole/sf\n  epsilon,sigma,scale\n  type pairs\n  \n  lubricate\n  mu\n  global\n  \n  mie/cut\n  epsilon,sigma,gamma_repulsive,gamma_attractive\n  type pairs\n  \n  morse, morse/smooth/linear\n  D0,R0,alpha\n  type pairs\n  \n  morse/soft\n  D0,R0,alpha,lambda\n  type pairs\n  \n  nm/cut\n  E0,R0,m,n\n  type pairs\n  \n  nm/cut/coul/cut, nm/cut/coul/long\n  E0,R0,m,n,coulombic_cutoff\n  type pairs\n  \n  reax/c\n  chi, eta, gamma\n  type global\n  \n  spin/dmi\n  coulombic_cutoff\n  type global\n  \n  spin/exchange\n  coulombic_cutoff\n  type global\n  \n  spin/magelec\n  coulombic_cutoff\n  type global\n  \n  spin/neel\n  coulombic_cutoff\n  type global\n  \n  table\n  table_cutoff\n  type pairs\n  \n  ufm\n  epsilon,sigma\n  type pairs\n  \n  soft\n  a\n  type pairs\n  \n  \n  \n  \n  \n  \n  \n  \n  Note\n  It is easy to add new pairwise potentials and their parameters\n  to this list.  All it typically takes is adding an extract() method to\n  the pair_*.cpp file associated with the potential.\n  \n  Some parameters are global settings for the pair style, e.g. the\n  viscosity setting “mu” for pair_style lubricate.\n  Other parameters apply to atom type pairs within the pair style,\n  e.g. the prefactor “a” for pair_style soft.\n  Note that for many of the potentials, the parameter that can be varied\n  is effectively a prefactor on the entire energy expression for the\n  potential, e.g. the lj/cut epsilon.  The parameters listed as “scale”\n  are exactly that, since the energy expression for the\n  coul/cut potential (for example) has no labeled\n  prefactor in its formula.  To apply an effective prefactor to some\n  potentials, multiple parameters need to be altered.  For example, the\n  Buckingham potential needs both the A and C terms\n  altered together.  To scale the Buckingham potential, you should thus\n  list the pair style twice, once for A and once for C.\n  If a type pair parameter is specified, the I and J settings should\n  be specified to indicate which type pairs to apply it to.  If a global\n  parameter is specified, the I and J settings still need to be\n  specified, but are ignored.\n  Similar to the pair_coeff command, I and J can be\n  specified in one of two ways.  Explicit numeric values can be used for\n  each, as in the 1st example above.  I <= J is required.  LAMMPS sets\n  the coefficients for the symmetric J,I interaction to the same values.\n  A wild-card asterisk can be used in place of or in conjunction with\n  the I,J arguments to set the coefficients for multiple pairs of atom\n  types.  This takes the form “*” or “*n” or “n*” or “m*n”.  If N = the\n  number of atom types, then an asterisk with no numeric values means\n  all types from 1 to N.  A leading asterisk means all types from 1 to n\n  (inclusive).  A trailing asterisk means all types from n to N\n  (inclusive).  A middle asterisk means all types from m to n\n  (inclusive).  Note that only type pairs with I <= J are considered; if\n  asterisks imply type pairs where J < I, they are ignored.\n  IMPROTANT NOTE: If pair_style hybrid or hybrid/overlay is being used, then the pstyle will\n  be a sub-style name.  You must specify I,J arguments that correspond\n  to type pair values defined (via the pair_coeff\n  command) for that sub-style.\n  The v_name argument for keyword pair is the name of an\n  equal-style variable which will be evaluated each time\n  this fix is invoked to set the parameter to a new value.  It should be\n  specified as v_name, where name is the variable name.  Equal-style\n  variables can specify formulas with various mathematical functions,\n  and include thermo_style command keywords for the\n  simulation box parameters and timestep and elapsed time.  Thus it is\n  easy to specify parameters that change as a function of time or span\n  consecutive runs in a continuous fashion.  For the latter, see the\n  start and stop keywords of the run command and the\n  elaplong keyword of thermo_style custom for\n  details.\n  For example, these commands would change the prefactor coefficient of\n  the pair_style soft potential from 10.0 to 30.0 in a\n  linear fashion over the course of a simulation:\n  variable prefactor equal ramp(10,30)\n  fix 1 all adapt 1 pair soft a * * v_prefactor\n  \n  \n  \n  The bond keyword uses the specified variable to change the value of\n  a bond coefficient over time, very similar to how the pair keyword\n  operates. The only difference is that now a bond coefficient for a\n  given bond type is adapted.\n  A wild-card asterisk can be used in place of or in conjunction with\n  the bond type argument to set the coefficients for multiple bond types.\n  This takes the form “*” or “*n” or “n*” or “m*n”.  If N = the number of\n  atom types, then an asterisk with no numeric values means all types\n  from 1 to N.  A leading asterisk means all types from 1 to n (inclusive).\n  A trailing asterisk means all types from n to N (inclusive).  A middle\n  asterisk means all types from m to n (inclusive).\n  Currently bond does not support bond_style hybrid nor bond_style\n  hybrid/overlay as bond styles. The only bonds that currently are\n  working with fix_adapt are\n  \n  \n  \n  \n  \n  \n  \n  gromos\n  k, r0\n  type bonds\n  \n  harmonic\n  k,r0\n  type bonds\n  \n  \n  \n  \n  The kspace keyword used the specified variable as a scale factor on\n  the energy, forces, virial calculated by whatever K-Space solver is\n  defined by the kspace_style command.  If the\n  variable has a value of 1.0, then the solver is unaltered.\n  The kspace keyword works this way whether the scale keyword\n  is set to no or yes.\n  \n  The atom keyword enables various atom properties to be changed.  The\n  aparam argument is the name of the parameter to change.  This is the\n  current list of atom parameters that can be varied by this fix:\n  \n  charge = charge on particle\n  diameter = diameter of particle\n  \n  The v_name argument of the atom keyword is the name of an\n  equal-style variable which will be evaluated each time\n  this fix is invoked to set the parameter to a new value.  It should be\n  specified as v_name, where name is the variable name.  See the\n  discussion above describing the formulas associated with equal-style\n  variables.  The new value is assigned to the corresponding attribute\n  for all atoms in the fix group.\n  \n  Note\n  The atom keyword works this way whether the scale keyword is\n  set to no or yes.  I.e. the use of scale yes is not yet supported\n  by the atom keyword.\n  \n  If the atom parameter is diameter and per-atom density and per-atom\n  mass are defined for particles (e.g. atom_style granular), then the mass of each particle is also\n  changed when the diameter changes (density is assumed to stay\n  constant).\n  For example, these commands would shrink the diameter of all granular\n  particles in the “center” group from 1.0 to 0.1 in a linear fashion\n  over the course of a 1000-step simulation:\n  variable size equal ramp(1.0,0.1)\n  fix 1 center adapt 10 atom diameter v_size\n  \n  \n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  For rRESPA time integration, this fix changes\n  parameters on the outermost rRESPA level.\n  ",
    "syntax": "fix ID group-ID adapt N attribute args ... keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  adapt = style name of this fix command\n  N = adapt simulation settings every this many timesteps\n  one or more attribute/arg pairs may be appended\n  attribute = pair or kspace or atom\n  pair args = pstyle pparam I J v_name\n    pstyle = pair style name, e.g. lj/cut\n    pparam = parameter to adapt over time\n    I,J = type pair(s) to set parameter for\n    v_name = variable with name that calculates value of pparam\n  bond args = bstyle bparam I v_name\n    bstyle = bond style name, e.g. harmonic\n    bparam = parameter to adapt over time\n    I = type bond to set parameter for\n    v_name = variable with name that calculates value of bparam\n  kspace arg = v_name\n    v_name = variable with name that calculates scale factor on K-space terms\n  atom args = aparam v_name\n    aparam = parameter to adapt over time\n    v_name = variable with name that calculates value of aparam\n  \n  zero or more keyword/value pairs may be appended\n  keyword = scale or reset\n  scale value = no or yes\n    no = the variable value is the new setting\n    yes = the variable value multiplies the original setting\n  reset value = no or yes\n    no = values will remain altered at the end of a run\n    yes = reset altered values to their original values at the end of a run\n  \n  \n  ",
    "examples": "fix 1 all adapt 1 pair soft a 1 1 v_prefactor\n  fix 1 all adapt 1 pair soft a 2* 3 v_prefactor\n  fix 1 all adapt 1 pair lj/cut epsilon * * v_scale1 coul/cut scale 3 3 v_scale2 scale yes reset yes\n  fix 1 all adapt 10 atom diameter v_size\n  \n  variable ramp_up equal \"ramp(0.01,0.5)\"\n  fix stretch all adapt 1 bond harmonic r0 1 v_ramp_up\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix adapt/fep",
    "description": "Change or adapt one or more specific simulation attributes or settings\n  over time as a simulation runs.\n  This is an enhanced version of the fix adapt command\n  with two differences,\n  \n  It is possible to modify the charges of chosen atom types only,\n  instead of scaling all the charges in the system.\n  There is a new option after for better compatibility with “fix\n  ave/time”.\n  \n  This version is suited for free energy calculations using\n  compute ti or compute fep.\n  If N is specified as 0, the specified attributes are only changed\n  once, before the simulation begins.  This is all that is needed if the\n  associated variables are not time-dependent.  If N > 0, then changes\n  are made every N steps during the simulation, presumably with a\n  variable that is time-dependent.\n  Depending on the value of the reset keyword, attributes changed by\n  this fix will or will not be reset back to their original values at\n  the end of a simulation.  Even if reset is specified as yes, a\n  restart file written during a simulation will contain the modified\n  settings.\n  If the scale keyword is set to no, then the value the parameter is\n  set to will be whatever the variable generates.  If the scale\n  keyword is set to yes, then the value of the altered parameter will\n  be the initial value of that parameter multiplied by whatever the\n  variable generates.  I.e. the variable is now a “scale factor” applied\n  in (presumably) a time-varying fashion to the parameter.  Internally,\n  the parameters themselves are actually altered; make sure you use the\n  reset yes option if you want the parameters to be restored to their\n  initial values after the run.\n  If the after keyword is set to yes, then the parameters are\n  changed one timestep after the multiple of N. In this manner, if a fix\n  such as “fix ave/time” is used to calculate averages at every N\n  timesteps, all the contributions to the average will be obtained with\n  the same values of the parameters.\n  \n  The pair keyword enables various parameters of potentials defined by\n  the pair_style command to be changed, if the pair\n  style supports it.  Note that the pair_style and\n  pair_coeff commands must be used in the usual manner\n  to specify these parameters initially; the fix adapt command simply\n  overrides the parameters.\n  The pstyle argument is the name of the pair style.  If pair_style hybrid or hybrid/overlay is used, pstyle should be\n  a sub-style name.  For example, pstyle could be specified as “soft”\n  or “lubricate”.  The pparam argument is the name of the parameter to\n  change.  This is the current list of pair styles and parameters that\n  can be varied by this fix.  See the doc pages for individual pair\n  styles and their energy formulas for the meaning of these parameters:\n  \n  \n  \n  \n  \n  \n  \n  born\n  a,b,c\n  type pairs\n  \n  buck\n  a,c\n  type pairs\n  \n  buck/mdf\n  a,c\n  type pairs\n  \n  coul/cut\n  scale\n  type pairs\n  \n  coul/cut/soft\n  lambda\n  type pairs\n  \n  coul/long, coul/msm\n  scale\n  type pairs\n  \n  coul/long/soft\n  scale, lambda\n  type pairs\n  \n  eam\n  scale\n  type pairs\n  \n  gauss\n  a\n  type pairs\n  \n  lennard/mdf\n  a,b\n  type pairs\n  \n  lj/class2\n  epsilon,sigma\n  type pairs\n  \n  lj/class2/coul/cut, lj/class2/coul/long\n  epsilon,sigma\n  type pairs\n  \n  lj/cut\n  epsilon,sigma\n  type pairs\n  \n  lj/cut/soft\n  epsilon,sigma,lambda\n  type pairs\n  \n  lj/cut/coul/cut, lj/cut/coul/long, lj/cut/coul/msm\n  epsilon,sigma\n  type pairs\n  \n  lj/cut/coul/cut/soft, lj/cut/coul/long/soft\n  epsilon,sigma,lambda\n  type pairs\n  \n  lj/cut/tip4p/cut, lj/cut/tip4p/long\n  epsilon,sigma\n  type pairs\n  \n  lj/cut/tip4p/long/soft\n  epsilon,sigma,lambda\n  type pairs\n  \n  lj/expand\n  epsilon,sigma,delta\n  type pairs\n  \n  lj/mdf\n  epsilon,sigma\n  type pairs\n  \n  lj/sf/dipole/sf\n  epsilon,sigma,scale\n  type pairs\n  \n  mie/cut\n  epsilon,sigma,gamR,gamA\n  type pairs\n  \n  morse, morse/smooth/linear\n  d0,r0,alpha\n  type pairs\n  \n  morse/soft\n  d0,r0,alpha,lambda\n  type pairs\n  \n  nm/cut\n  e0,r0,nn,mm\n  type pairs\n  \n  nm/cut/coul/cut, nm/cut/coul/long\n  e0,r0,nn,mm\n  type pairs\n  \n  ufm\n  epsilon,sigma,scale\n  type pairs\n  \n  soft\n  a\n  type pairs\n  \n  \n  \n  \n  Note\n  It is easy to add new potentials and their parameters to this\n  list.  All it typically takes is adding an extract() method to the\n  pair_*.cpp file associated with the potential.\n  \n  Note that for many of the potentials, the parameter that can be varied\n  is effectively a prefactor on the entire energy expression for the\n  potential, e.g. the lj/cut epsilon.  The parameters listed as “scale”\n  are exactly that, since the energy expression for the\n  coul/cut potential (for example) has no labeled\n  prefactor in its formula.  To apply an effective prefactor to some\n  potentials, multiple parameters need to be altered.  For example, the\n  Buckingham potential needs both the A and C terms\n  altered together.  To scale the Buckingham potential, you should thus\n  list the pair style twice, once for A and once for C.\n  If a type pair parameter is specified, the I and J settings should\n  be specified to indicate which type pairs to apply it to.  If a global\n  parameter is specified, the I and J settings still need to be\n  specified, but are ignored.\n  Similar to the pair_coeff command, I and J can be\n  specified in one of two ways.  Explicit numeric values can be used for\n  each, as in the 1st example above.  I <= J is required.  LAMMPS sets\n  the coefficients for the symmetric J,I interaction to the same values.\n  A wild-card asterisk can be used in place of or in conjunction with\n  the I,J arguments to set the coefficients for multiple pairs of atom\n  types.  This takes the form “*” or “*n” or “n*” or “m*n”.  If N = the\n  number of atom types, then an asterisk with no numeric values means\n  all types from 1 to N.  A leading asterisk means all types from 1 to n\n  (inclusive).  A trailing asterisk means all types from n to N\n  (inclusive).  A middle asterisk means all types from m to n\n  (inclusive).  Note that only type pairs with I <= J are considered; if\n  asterisks imply type pairs where J < I, they are ignored.\n  IMPROTANT NOTE: If pair_style hybrid or hybrid/overlay is being used, then the pstyle will\n  be a sub-style name.  You must specify I,J arguments that correspond\n  to type pair values defined (via the pair_coeff\n  command) for that sub-style.\n  The v_name argument for keyword pair is the name of an\n  equal-style variable which will be evaluated each time\n  this fix is invoked to set the parameter to a new value.  It should be\n  specified as v_name, where name is the variable name.  Equal-style\n  variables can specify formulas with various mathematical functions,\n  and include thermo_style command keywords for the\n  simulation box parameters and timestep and elapsed time.  Thus it is\n  easy to specify parameters that change as a function of time or span\n  consecutive runs in a continuous fashion.  For the latter, see the\n  start and stop keywords of the run command and the\n  elaplong keyword of thermo_style custom for\n  details.\n  For example, these commands would change the prefactor coefficient of\n  the pair_style soft potential from 10.0 to 30.0 in a\n  linear fashion over the course of a simulation:\n  variable prefactor equal ramp(10,30)\n  fix 1 all adapt 1 pair soft a * * v_prefactor\n  \n  \n  \n  The kspace keyword used the specified variable as a scale factor on\n  the energy, forces, virial calculated by whatever K-Space solver is\n  defined by the kspace_style command.  If the\n  variable has a value of 1.0, then the solver is unaltered.\n  The kspace keyword works this way whether the scale keyword\n  is set to no or yes.\n  \n  The atom keyword enables various atom properties to be changed.  The\n  aparam argument is the name of the parameter to change.  This is the\n  current list of atom parameters that can be varied by this fix:\n  \n  charge = charge on particle\n  diameter = diameter of particle\n  \n  The I argument indicates which atom types are affected. A wild-card\n  asterisk can be used in place of or in conjunction with the I argument\n  to set the coefficients for multiple atom types.\n  The v_name argument of the atom keyword is the name of an\n  equal-style variable which will be evaluated each time\n  this fix is invoked to set the parameter to a new value.  It should be\n  specified as v_name, where name is the variable name.  See the\n  discussion above describing the formulas associated with equal-style\n  variables.  The new value is assigned to the corresponding attribute\n  for all atoms in the fix group.\n  If the atom parameter is diameter and per-atom density and per-atom\n  mass are defined for particles (e.g. atom_style granular), then the mass of each particle is also\n  changed when the diameter changes (density is assumed to stay\n  constant).\n  For example, these commands would shrink the diameter of all granular\n  particles in the “center” group from 1.0 to 0.1 in a linear fashion\n  over the course of a 1000-step simulation:\n  variable size equal ramp(1.0,0.1)\n  fix 1 center adapt 10 atom diameter * v_size\n  \n  \n  For rRESPA time integration, this fix changes\n  parameters on the outermost rRESPA level.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID adapt/fep N attribute args ... keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  adapt/fep = style name of this fix command\n  N = adapt simulation settings every this many timesteps\n  one or more attribute/arg pairs may be appended\n  attribute = pair or kspace or atom\n  pair args = pstyle pparam I J v_name\n    pstyle = pair style name, e.g. lj/cut\n    pparam = parameter to adapt over time\n    I,J = type pair(s) to set parameter for\n    v_name = variable with name that calculates value of pparam\n  kspace arg = v_name\n    v_name = variable with name that calculates scale factor on K-space terms\n  atom args = aparam v_name\n    aparam = parameter to adapt over time\n    I = type(s) to set parameter for\n    v_name = variable with name that calculates value of aparam\n  \n  zero or more keyword/value pairs may be appended\n  keyword = scale or reset or after\n  scale value = no or yes\n    no = the variable value is the new setting\n    yes = the variable value multiplies the original setting\n  reset value = no or yes\n    no = values will remain altered at the end of a run\n    yes = reset altered values to their original values at the end\n    of a run\n  after value = no or yes\n    no = parameters are adapted at timestep N\n    yes = parameters are adapted one timestep after N\n  \n  \n  ",
    "examples": "fix 1 all adapt/fep 1 pair soft a 1 1 v_prefactor\n  fix 1 all adapt/fep 1 pair soft a 2* 3 v_prefactor\n  fix 1 all adapt/fep 1 pair lj/cut epsilon * * v_scale1 coul/cut scale 3 3 v_scale2 scale yes reset yes\n  fix 1 all adapt/fep 10 atom diameter 1 v_size\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix addforce",
    "description": "Add fx,fy,fz to the corresponding component of force for each atom in\n  the group.  This command can be used to give an additional push to\n  atoms in a simulation, such as for a simulation of Poiseuille flow in\n  a channel.\n  Any of the 3 quantities defining the force components can be specified\n  as an equal-style or atom-style variable, namely fx,\n  fy, fz.  If the value is a variable, it should be specified as\n  v_name, where name is the variable name.  In this case, the variable\n  will be evaluated each timestep, and its value(s) used to determine\n  the force component.\n  Equal-style variables can specify formulas with various mathematical\n  functions, and include thermo_style command\n  keywords for the simulation box parameters and timestep and elapsed\n  time.  Thus it is easy to specify a time-dependent force field.\n  Atom-style variables can specify the same formulas as equal-style\n  variables but can also include per-atom values, such as atom\n  coordinates.  Thus it is easy to specify a spatially-dependent force\n  field with optional time-dependence as well.\n  If the every keyword is used, the Nevery setting determines how\n  often the forces are applied.  The default value is 1, for every\n  timestep.\n  If the region keyword is used, the atom must also be in the\n  specified geometric region in order to have force added\n  to it.\n  \n  Adding a force to atoms implies a change in their potential energy as\n  they move due to the applied force field.  For dynamics via the “run”\n  command, this energy can be optionally added to the system’s potential\n  energy for thermodynamic output (see below).  For energy minimization\n  via the “minimize” command, this energy must be added to the system’s\n  potential energy to formulate a self-consistent minimization problem\n  (see below).\n  The energy keyword is not allowed if the added force is a constant\n  vector F = (fx,fy,fz), with all components defined as numeric\n  constants and not as variables.  This is because LAMMPS can compute\n  the energy for each atom directly as E = -x dot F = -(x*fx + y*fy +\n  z*fz), so that -Grad(E) = F.\n  The energy keyword is optional if the added force is defined with\n  one or more variables, and if you are performing dynamics via the\n  run command.  If the keyword is not used, LAMMPS will set\n  the energy to 0.0, which is typically fine for dynamics.\n  The energy keyword is required if the added force is defined with\n  one or more variables, and you are performing energy minimization via\n  the “minimize” command.  The keyword specifies the name of an\n  atom-style variable which is used to compute the\n  energy of each atom as function of its position.  Like variables used\n  for fx, fy, fz, the energy variable is specified as v_name,\n  where name is the variable name.\n  Note that when the energy keyword is used during an energy\n  minimization, you must insure that the formula defined for the\n  atom-style variable is consistent with the force\n  variable formulas, i.e. that -Grad(E) = F.  For example, if the force\n  were a spring-like F = kx, then the energy formula should be E =\n  -0.5kx^2.  If you don’t do this correctly, the minimization will not\n  converge properly.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The fix_modify energy option is supported by this\n  fix to add the potential “energy” inferred by the added force to the\n  system’s potential energy as part of thermodynamic output.  This is a fictitious quantity but is\n  needed so that the minimize command can include the\n  forces added by this fix in a consistent manner.  I.e. there is a\n  decrease in potential energy when atoms move in the direction of the\n  added force.\n  The fix_modify virial option is supported by this\n  fix to add the contribution due to the added forces on atoms to the\n  system’s virial as part of thermodynamic output.\n  The default is virial no\n  The fix_modify respa option is supported by this\n  fix. This allows to set at which level of the r-RESPA\n  integrator the fix is adding its forces. Default is the outermost\n  level.\n  This fix computes a global scalar and a global 3-vector of forces,\n  which can be accessed by various output commands.\n  The scalar is the potential energy discussed above.  The vector is the\n  total force on the group of atoms before the forces on individual\n  atoms are changed by the fix.  The scalar and vector values calculated\n  by this fix are “extensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  The forces due to this fix are imposed during an energy minimization,\n  invoked by the minimize command.  You should not\n  specify force components with a variable that has time-dependence for\n  use with a minimizer, since the minimizer increments the timestep as\n  the iteration count during the minimization.\n  \n  Note\n  If you want the fictitious potential energy associated with the\n  added forces to be included in the total potential energy of the\n  system (the quantity being minimized), you MUST enable the\n  fix_modify energy option for this fix.\n  \n  ",
    "syntax": "fix ID group-ID addforce fx fy fz keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  addforce = style name of this fix command\n  fx,fy,fz = force component values (force units)\n  any of fx,fy,fz can be a variable (see below)\n  \n  \n  \n  zero or more keyword/value pairs may be appended to args\n  keyword = every or region or energy\n  every value = Nevery\n    Nevery = add force every this many timesteps\n  region value = region-ID\n    region-ID = ID of region atoms must be in to have added force\n  energy value = v_name\n    v_name = variable with name that calculates the potential energy of each atom in the added force field\n  \n  \n  ",
    "examples": "fix kick flow addforce 1.0 0.0 0.0\n  fix kick flow addforce 1.0 0.0 v_oscillate\n  fix ff boundary addforce 0.0 0.0 v_push energy v_espace\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix addtorque",
    "description": "Add a set of forces to each atom in\n  the group such that:\n  \n  the components of the total torque applied on the group (around its\n  center of mass) are Tx,Ty,Tz\n  the group would move as a rigid body in the absence of other\n  forces.\n  \n  This command can be used to drive a group of atoms into rotation.\n  Any of the 3 quantities defining the torque components can be specified\n  as an equal-style variable, namely Tx,\n  Ty, Tz.  If the value is a variable, it should be specified as\n  v_name, where name is the variable name.  In this case, the variable\n  will be evaluated each timestep, and its value used to determine the\n  torque component.\n  Equal-style variables can specify formulas with various mathematical\n  functions, and include thermo_style command\n  keywords for the simulation box parameters and timestep and elapsed\n  time.  Thus it is easy to specify a time-dependent torque.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The fix_modify energy option is supported by this\n  fix to add the potential “energy” inferred by the added forces to the\n  system’s potential energy as part of thermodynamic output.  This is a fictitious quantity but is\n  needed so that the minimize command can include the\n  forces added by this fix in a consistent manner.  I.e. there is a\n  decrease in potential energy when atoms move in the direction of the\n  added forces.\n  The fix_modify respa option is supported by\n  this fix. This allows to set at which level of the r-RESPA\n  integrator the fix is adding its torque. Default is the outermost level.\n  This fix computes a global scalar and a global 3-vector, which can be\n  accessed by various output commands.  The scalar\n  is the potential energy discussed above.  The vector is the total\n  torque on the group of atoms before the forces on individual atoms are\n  changed by the fix.  The scalar and vector values calculated by this\n  fix are “extensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  The forces due to this fix are imposed during an energy minimization,\n  invoked by the minimize command.  You should not\n  specify force components with a variable that has time-dependence for\n  use with a minimizer, since the minimizer increments the timestep as\n  the iteration count during the minimization.\n  ",
    "syntax": "fix ID group-ID addtorque Tx Ty Tz\n  \n  \n  \n  ID, group-ID are documented in fix command\n  addtorque = style name of this fix command\n  Tx,Ty,Tz = torque component values (torque units)\n  any of Tx,Ty,Tz can be a variable (see below)\n  \n  ",
    "examples": "fix kick bead addtorque 2.0 3.0 5.0\n  fix kick bead addtorque 0.0 0.0 v_oscillate\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "fix append/atoms",
    "description": "This fix creates atoms on a lattice, appended on the zhi edge of the\n  system box.  This can be useful when a shock or wave is propagating\n  from zlo.  This allows the system to grow with time to accommodate an\n  expanding wave.  A simulation box must already exist, which is\n  typically created via the create_box command.\n  Before using this command, a lattice must also be defined using the\n  lattice command.\n  This fix will automatically freeze atoms on the zhi edge of the\n  system, so that overlaps are avoided when new atoms are appended.\n  The basis keyword specifies an atom type that will be assigned to\n  specific basis atoms as they are created.  See the\n  lattice command for specifics on how basis atoms are\n  defined for the unit cell of the lattice.  By default, all created\n  atoms are assigned type = 1 unless this keyword specifies differently.\n  The size keyword defines the size in z of the chunk of material to\n  be added.\n  The random keyword will give the atoms random displacements around\n  their lattice points to simulate some initial temperature.\n  The temp keyword will cause a region to be thermostatted with a\n  Langevin thermostat on the zhi boundary.  The size of the region is\n  measured from zhi and is set with the extent argument.\n  The units keyword determines the meaning of the distance units used\n  to define a wall position, but only when a numeric constant is used.\n  A box value selects standard distance units as defined by the\n  units command, e.g. Angstroms for units = real or metal.\n  A lattice value means the distance units are in lattice spacings.\n  The lattice command must have been previously used to\n  define the lattice spacings.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID append/atoms face ... keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  append/atoms = style name of this fix command\n  face = zhi\n  zero or more keyword/value pairs may be appended\n  keyword = basis or size or freq or temp or random or units\n  basis values = M itype\n    M = which basis atom\n    itype = atom type (1-N) to assign to this basis atom\n  size args = Lz\n    Lz = z size of lattice region appended in a single event(distance units)\n  freq args = freq\n    freq = the number of timesteps between append events\n  temp args = target damp seed extent\n    target = target temperature for the region between zhi-extent and zhi (temperature units)\n    damp = damping parameter (time units)\n    seed = random number seed for langevin kicks\n    extent = extent of thermostatted region (distance units)\n  random args = xmax ymax zmax seed\n    xmax, ymax, zmax = maximum displacement in particular direction (distance units)\n    seed = random number seed for random displacement\n  units value = lattice or box\n    lattice = the wall position is defined in lattice units\n    box = the wall position is defined in simulation box units\n  \n  \n  ",
    "examples": "fix 1 all append/atoms zhi size 5.0 freq 295 units lattice\n  fix 4 all append/atoms zhi size 15.0 freq 5 units box\n  fix A all append/atoms zhi size 1.0 freq 1000 units lattice\n  \n  \n  ",
    "restrictions": "This fix style is part of the SHOCK package.  It is only enabled if\n  LAMMPS was built with that package. See the Build package doc page for more info.\n  The boundary on which atoms are added with append/atoms must be\n  shrink/minimum.  The opposite boundary may be any boundary type other\n  than periodic.\n  "
},
{
    "command": "fix atc",
    "description": "This fix is the beginning to creating a coupled FE/MD simulation and/or\n  an on-the-fly estimation of continuum fields. The coupled versions of\n  this fix do Verlet integration and the post-processing does not. After\n  instantiating this fix, several other fix_modify commands will be\n  needed to set up the problem, e.g. define the finite element mesh and\n  prescribe initial and boundary conditions.\n  \n  The following coupling example is typical, but non-exhaustive:\n  # ... commands to create and initialize the MD system\n  \n  # initial fix to designate coupling type and group to apply it to\n  # tag group physics material_file\n  fix AtC internal atc thermal Ar_thermal.mat\n  \n  # create a uniform 12 x 2 x 2 mesh that covers region contain the group\n  # nx ny nz region periodicity\n  fix_modify AtC mesh create 12 2 2 mdRegion f p p\n  \n  # specify the control method for the type of coupling\n  # physics control_type\n  fix_modify AtC thermal control flux\n  \n  # specify the initial values for the empirical field \"temperature\"\n  # field node_group value\n  fix_modify AtC initial temperature all 30\n  \n  # create an output stream for nodal fields\n  # filename output_frequency\n  fix_modify AtC output atc_fe_output 100\n  \n  run 1000\n  \n  \n  likewise for this post-processing example:\n  # ... commands to create and initialize the MD system\n  \n  # initial fix to designate post-processing and the group to apply it to\n  # no material file is allowed nor required\n  fix AtC internal atc hardy\n  \n  # for hardy fix, specific kernel function (function type and range) to # be used as a localization function\n  fix AtC kernel quartic_sphere 10.0\n  \n  # create a uniform 1 x 1 x 1 mesh that covers region contain the group\n  # with periodicity this effectively creates a system average\n  fix_modify AtC mesh create 1 1 1 box p p p\n  \n  # change from default lagrangian map to eulerian\n  # refreshed every 100 steps\n  fix_modify AtC atom_element_map eulerian 100\n  \n  # start with no field defined\n  # add mass density, potential energy density, stress and temperature\n  fix_modify AtC fields add density energy stress temperature\n  \n  # create an output stream for nodal fields\n  # filename output_frequency\n  fix_modify AtC output nvtFE 100 text\n  \n  run 1000\n  \n  \n  the mesh’s linear interpolation functions can be used as the localization function\n  by using the field option:\n  fix AtC internal atc field\n  fix_modify AtC mesh create 1 1 1 box p p p\n  ...\n  \n  \n  Note coupling and post-processing can be combined in the same simulations using separate fixes.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  The fix_modify options relevant to this\n  fix are listed below.  No global scalar or vector or per-atom quantities\n  are stored by this fix for access by various output commands.  No parameter of this fix can be used with the\n  start/stop keywords of the run command.  This fix is not\n  invoked during energy minimization.\n  ",
    "syntax": "fix <fixID> <group> atc <type> <parameter_file>\n  \n  \n  \n  fixID = name of fix\n  group = name of group fix is to be applied\n  type = thermal or two_temperature or hardy or field\n  \n  thermal = thermal coupling with fields: temperature\n  two_temperature = electron-phonon coupling with field: temperature and electron_temperature\n  hardy = on-the-fly post-processing using kernel localization functions\n  field = on-the-fly post-processing using mesh-based localization functions\n  \n  parameter_file = name of the file with material parameters. Note: Neither hardy nor field requires a parameter file\n  \n  ",
    "examples": "fix AtC internal atc thermal Ar_thermal.dat\n  fix AtC internal atc two_temperature Ar_ttm.mat\n  fix AtC internal atc hardy\n  fix AtC internal atc field\n  \n  \n  ",
    "restrictions": "Thermal and two_temperature (coupling) types use a Verlet\n  time-integration algorithm. The hardy type does not contain its own\n  time-integrator and must be used with a separate fix that does contain\n  one, e.g. nve, nvt, etc. In addition, currently:\n  \n  the coupling is restricted to thermal physics\n  the FE computations are done in serial on each processor.\n  \n  "
},
{
    "command": "fix atom/swap",
    "description": "This fix performs Monte Carlo swaps of atoms of one given atom type\n  with atoms of the other given atom types. The specified T is used in\n  the Metropolis criterion dictating swap probabilities.\n  Perform X swaps of atoms of one type with atoms of another type\n  according to a Monte Carlo probability. Swap candidates must be in the\n  fix group, must be in the region (if specified), and must be of one of\n  the listed types. Swaps are attempted between candidates that are\n  chosen randomly with equal probability among the candidate\n  atoms. Swaps are not attempted between atoms of the same type since\n  nothing would happen.\n  All atoms in the simulation domain can be moved using regular time\n  integration displacements, e.g. via fix nvt, resulting\n  in a hybrid MC+MD simulation. A smaller-than-usual timestep size may\n  be needed when running such a hybrid simulation, especially if the\n  swapped atoms are not well equilibrated.\n  The types keyword is required. At least two atom types must be\n  specified.\n  The ke keyword can be set to no to turn off kinetic energy\n  conservation for swaps. The default is yes, which means that swapped\n  atoms have their velocities scaled by the ratio of the masses of the\n  swapped atom types. This ensures that the kinetic energy of each atom\n  is the same after the swap as it was before the swap, even though the\n  atom masses have changed.\n  The semi-grand keyword can be set to yes to switch to the\n  semi-grand canonical ensemble as discussed in (Sadigh). This\n  means that the total number of each particle type does not need to be\n  conserved. The default is no, which means that the only kind of swap\n  allowed exchanges an atom of one type with an atom of a different\n  given type. In other words, the relative mole fractions of the swapped\n  atoms remains constant. Whereas in the semi-grand canonical ensemble,\n  the composition of the system can change. Note that when using\n  semi-grand, atoms in the fix group whose type is not listed\n  in the types keyword are ineligible for attempted\n  conversion. An attempt is made to switch\n  the selected atom (if eligible) to one of the other listed types\n  with equal probability. Acceptance of each attempt depends upon the Metropolis criterion.\n  The mu keyword allows users to specify chemical\n  potentials. This is required and allowed only when using semi-grand.\n  All chemical potentials are absolute, so there is one for\n  each swap type listed following the types keyword.\n  In semi-grand canonical ensemble simulations the chemical composition\n  of the system is controlled by the difference in these values. So\n  shifting all values by a constant amount will have no effect\n  on the simulation.\n  This command may optionally use the region keyword to define swap\n  volume.  The specified region must have been previously defined with a\n  region command.  It must be defined with side = in.\n  Swap attempts occur only between atoms that are both within the\n  specified region. Swaps are not otherwise attempted.\n  You should ensure you do not swap atoms belonging to a molecule, or\n  LAMMPS will soon generate an error when it tries to find those atoms.\n  LAMMPS will warn you if any of the atoms eligible for swapping have a\n  non-zero molecule ID, but does not check for this at the time of\n  swapping.\n  If not using semi-grand this fix checks to ensure all atoms of the\n  given types have the same atomic charge. LAMMPS does not enforce this\n  in general, but it is needed for this fix to simplify the\n  swapping procedure. Successful swaps will swap the atom type and charge\n  of the swapped atoms. Conversely, when using semi-grand, it is assumed that all the atom\n  types involved in switches have the same charge. Otherwise, charge\n  would not be conserved. As a consequence, no checks on atomic charges are\n  performed, and successful switches update the atom type but not the\n  atom charge. While it is possible to use semi-grand with groups of\n  atoms that have different charges, these charges will not be changed when the\n  atom types change.\n  Since this fix computes total potential energies before and after\n  proposed swaps, so even complicated potential energy calculations are\n  OK, including the following:\n  \n  long-range electrostatics (kspace)\n  many body pair styles\n  hybrid pair styles\n  eam pair styles\n  triclinic systems\n  need to include potential energy contributions from other fixes\n  \n  Some fixes have an associated potential energy. Examples of such fixes\n  include: efield, gravity,\n  addforce, langevin,\n  restrain, temp/berendsen,\n  temp/rescale, and wall fixes.\n  For that energy to be included in the total potential energy of the\n  system (the quantity used when performing GCMC moves),\n  you MUST enable the fix_modify energy option for\n  that fix.  The doc pages for individual fix commands\n  specify if this should be done.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  This fix writes the state of the fix to binary restart files.  This includes information about the random\n  number generator seed, the next timestep for MC exchanges, the number\n  of exchange attempts and successes etc.  See\n  the read_restart command for info on how to\n  re-specify a fix in an input script that reads a restart file, so that\n  the operation of the fix continues in an uninterrupted fashion.\n  \n  Note\n  For this to work correctly, the timestep must not be changed\n  after reading the restart with reset_timestep.\n  The fix will try to detect it and stop with an error.\n  \n  None of the fix_modify options are relevant to this\n  fix.\n  This fix computes a global vector of length 2, which can be accessed\n  by various output commands.  The vector values are\n  the following global cumulative quantities:\n  \n  1 = swap attempts\n  2 = swap successes\n  \n  The vector values calculated by this fix are “extensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID atom/swap N X seed T keyword values ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  atom/swap = style name of this fix command\n  N = invoke this fix every N steps\n  X = number of swaps to attempt every N steps\n  seed = random # seed (positive integer)\n  T = scaling temperature of the MC swaps (temperature units)\n  one or more keyword/value pairs may be appended to args\n  keyword = types or mu or ke or semi-grand or region\n  types values = two or more atom types\n  mu values = chemical potential of swap types (energy units)\n  ke value = no or yes\n    no = no conservation of kinetic energy after atom swaps\n    yes = kinetic energy is conserved after atom swaps\n  semi-grand value = no or yes\n    no = particle type counts and fractions conserved\n    yes = semi-grand canonical ensemble, particle fractions not conserved\n  region value = region-ID\n    region-ID = ID of region to use as an exchange/move volume\n  \n  \n  ",
    "examples": "fix 2 all atom/swap 1 1 29494 300.0 ke no types 1 2\n  fix myFix all atom/swap 100 1 12345 298.0 region my_swap_region types 5 6\n  fix SGMC all atom/swap 1 100 345 1.0 semi-grand yes types 1 2 3 mu 0.0 4.3 -5.0\n  \n  \n  ",
    "restrictions": "This fix is part of the MC package.  It is only enabled if LAMMPS was\n  built with that package.  See the Build package\n  doc page for more info.\n  "
},
{
    "command": "fix ave/atom",
    "description": "Use one or more per-atom vectors as inputs every few timesteps, and\n  average them atom by atom over longer timescales.  The resulting\n  per-atom averages can be used by other output commands such as the fix ave/chunk or dump custom commands.\n  The group specified with the command means only atoms within the group\n  have their averages computed.  Results are set to 0.0 for atoms not in\n  the group.\n  Each input value can be an atom attribute (position, velocity, force\n  component) or can be the result of a compute or\n  fix or the evaluation of an atom-style\n  variable.  In the latter cases, the compute, fix, or\n  variable must produce a per-atom vector, not a global quantity or\n  local quantity.  If you wish to time-average global quantities from a\n  compute, fix, or variable, then see the fix ave/time command.\n  Each per-atom value of each input vector is averaged independently.\n  Computes that produce per-atom vectors or arrays are\n  those which have the word atom in their style name.  See the doc\n  pages for individual fixes to determine which ones produce\n  per-atom vectors or arrays.  Variables of style atom\n  are the only ones that can be used with this fix since they produce\n  per-atom vectors.\n  Note that for values from a compute or fix, the bracketed index I can\n  be specified using a wildcard asterisk with the index to effectively\n  specify multiple values.  This takes the form “*” or “*n” or “n*” or\n  “m*n”.  If N = the size of the vector (for mode = scalar) or the\n  number of columns in the array (for mode = vector), then an asterisk\n  with no numeric values means all indices from 1 to N.  A leading\n  asterisk means all indices from 1 to n (inclusive).  A trailing\n  asterisk means all indices from n to N (inclusive).  A middle asterisk\n  means all indices from m to n (inclusive).\n  Using a wildcard is the same as if the individual columns of the array\n  had been listed one by one.  E.g. these 2 fix ave/atom commands are\n  equivalent, since the compute stress/atom\n  command creates a per-atom array with 6 columns:\n  compute my_stress all stress/atom NULL\n  fix 1 all ave/atom 10 20 1000 c_my_stress[*]\n  fix 1 all ave/atom 10 20 1000 c_my_stress[1] c_my_stress[2] &\n                                c_my_stress[3] c_my_stress[4] &\n                                c_my_stress[5] c_my_stress[6]\n  \n  \n  \n  The Nevery, Nrepeat, and Nfreq arguments specify on what\n  timesteps the input values will be used in order to contribute to the\n  average.  The final averaged quantities are generated on timesteps\n  that are a multiple of Nfreq.  The average is over Nrepeat\n  quantities, computed in the preceding portion of the simulation every\n  Nevery timesteps.  Nfreq must be a multiple of Nevery and\n  Nevery must be non-zero even if Nrepeat is 1.  Also, the timesteps\n  contributing to the average value cannot overlap,\n  i.e. Nrepeat*Nevery can not exceed Nfreq.\n  For example, if Nevery=2, Nrepeat=6, and Nfreq=100, then values on\n  timesteps 90,92,94,96,98,100 will be used to compute the final average\n  on timestep 100.  Similarly for timesteps 190,192,194,196,198,200 on\n  timestep 200, etc.\n  \n  The atom attribute values (x,y,z,vx,vy,vz,fx,fy,fz) are\n  self-explanatory.  Note that other atom attributes can be used as\n  inputs to this fix by using the compute property/atom command and then specifying\n  an input value from that compute.\n  \n  Note\n  The x,y,z attributes are values that are re-wrapped inside the\n  periodic box whenever an atom crosses a periodic boundary.  Thus if\n  you time average an atom that spends half its time on either side of\n  the periodic box, you will get a value in the middle of the box.  If\n  this is not what you want, consider averaging unwrapped coordinates,\n  which can be provided by the compute property/atom command via its xu,yu,zu\n  attributes.\n  \n  If a value begins with “c_”, a compute ID must follow which has been\n  previously defined in the input script.  If no bracketed term is\n  appended, the per-atom vector calculated by the compute is used.  If a\n  bracketed term containing an index I is appended, the Ith column of\n  the per-atom array calculated by the compute is used.  Users can also\n  write code for their own compute styles and add them to LAMMPS.  See the discussion above for how I can\n  be specified with a wildcard asterisk to effectively specify multiple\n  values.\n  If a value begins with “f_”, a fix ID must follow which has been\n  previously defined in the input script.  If no bracketed term is\n  appended, the per-atom vector calculated by the fix is used.  If a\n  bracketed term containing an index I is appended, the Ith column of\n  the per-atom array calculated by the fix is used.  Note that some\n  fixes only produce their values on certain timesteps, which must be\n  compatible with Nevery, else an error will result.  Users can also\n  write code for their own fix styles and add them to LAMMPS.  See the discussion above for how I can be\n  specified with a wildcard asterisk to effectively specify multiple\n  values.\n  If a value begins with “v_”, a variable name must follow which has\n  been previously defined in the input script as an atom-style variable Variables of style atom can reference\n  thermodynamic keywords, or invoke other computes, fixes, or variables\n  when they are evaluated, so this is a very general means of generating\n  per-atom quantities to time average.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global scalar or vector quantities are\n  stored by this fix for access by various output commands.\n  This fix produces a per-atom vector or array which can be accessed by\n  various output commands.  A vector is produced if\n  only a single quantity is averaged by this fix.  If two or more\n  quantities are averaged, then an array of values is produced.  The\n  per-atom values can only be accessed on timesteps that are multiples\n  of Nfreq since that is when averaging is performed.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID ave/atom Nevery Nrepeat Nfreq value1 value2 ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  ave/atom = style name of this fix command\n  Nevery = use input values every this many timesteps\n  Nrepeat = # of times to use input values for calculating averages\n  Nfreq = calculate averages every this many timesteps\n  one or more input values can be listed\n  value = x, y, z, vx, vy, vz, fx, fy, fz, c_ID, c_ID[i], f_ID, f_ID[i], v_name\n  x,y,z,vx,vy,vz,fx,fy,fz = atom attribute (position, velocity, force component)\n  c_ID = per-atom vector calculated by a compute with ID\n  c_ID[I] = Ith column of per-atom array calculated by a compute with ID, I can include wildcard (see below)\n  f_ID = per-atom vector calculated by a fix with ID\n  f_ID[I] = Ith column of per-atom array calculated by a fix with ID, I can include wildcard (see below)\n  v_name = per-atom vector calculated by an atom-style variable with name\n  \n  \n  \n  \n  ",
    "examples": "fix 1 all ave/atom 1 100 100 vx vy vz\n  fix 1 all ave/atom 10 20 1000 c_my_stress[1]\n  fix 1 all ave/atom 10 20 1000 c_my_stress[*]\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix ave/chunk",
    "description": "Use one or more per-atom vectors as inputs every few timesteps, sum\n  the values over the atoms in each chunk at each timestep, then average\n  the per-chunk values over longer timescales.  The resulting chunk\n  averages can be used by other output commands such\n  as thermo_style custom, and can also be written to\n  a file.\n  In LAMMPS, chunks are collections of atoms defined by a compute chunk/atom command, which assigns each atom\n  to a single chunk (or no chunk).  The ID for this command is specified\n  as chunkID.  For example, a single chunk could be the atoms in a\n  molecule or atoms in a spatial bin.  See the compute chunk/atom doc page and the Howto chunk doc page for details of how chunks can be\n  defined and examples of how they can be used to measure properties of\n  a system.\n  Note that only atoms in the specified group contribute to the summing\n  and averaging calculations.  The compute chunk/atom command defines its own group as\n  well as an optional region.  Atoms will have a chunk ID = 0, meaning\n  they belong to no chunk, if they are not in that group or region.\n  Thus you can specify the “all” group for this command if you simply\n  want to use the chunk definitions provided by chunkID.\n  Each specified per-atom value can be an atom attribute (position,\n  velocity, force component), a mass or number density, or the result of\n  a compute or fix or the evaluation of an\n  atom-style variable.  In the latter cases, the\n  compute, fix, or variable must produce a per-atom quantity, not a\n  global quantity.  Note that the compute property/atom command provides access to\n  any attribute defined and stored by atoms.  If you wish to\n  time-average global quantities from a compute, fix, or variable, then\n  see the fix ave/time command.\n  The per-atom values of each input vector are summed and averaged\n  independently of the per-atom values in other input vectors.\n  Computes that produce per-atom quantities are those\n  which have the word atom in their style name.  See the doc pages for\n  individual fixes to determine which ones produce per-atom\n  quantities.  Variables of style atom are the only\n  ones that can be used with this fix since all other styles of variable\n  produce global quantities.\n  Note that for values from a compute or fix, the bracketed index I can\n  be specified using a wildcard asterisk with the index to effectively\n  specify multiple values.  This takes the form “*” or “*n” or “n*” or\n  “m*n”.  If N = the size of the vector (for mode = scalar) or the\n  number of columns in the array (for mode = vector), then an asterisk\n  with no numeric values means all indices from 1 to N.  A leading\n  asterisk means all indices from 1 to n (inclusive).  A trailing\n  asterisk means all indices from n to N (inclusive).  A middle asterisk\n  means all indices from m to n (inclusive).\n  Using a wildcard is the same as if the individual columns of the array\n  had been listed one by one.  E.g. these 2 fix ave/chunk commands are\n  equivalent, since the compute property/atom command creates, in this\n  case, a per-atom array with 3 columns:\n  compute myAng all property/atom angmomx angmomy angmomz\n  fix 1 all ave/chunk 100 1 100 cc1 c_myAng[*] file tmp.angmom\n  fix 2 all ave/chunk 100 1 100 cc1 c_myAng[1] c_myAng[2] c_myAng[3] file tmp.angmom\n  \n  \n  \n  Note\n  This fix works by creating an array of size Nchunk by Nvalues\n  on each processor.  Nchunk is the number of chunks which is defined\n  by the compute chunk/atom command.\n  Nvalues is the number of input values specified.  Each processor loops\n  over its atoms, tallying its values to the appropriate chunk.  Then\n  the entire array is summed across all processors.  This means that\n  using a large number of chunks will incur an overhead in memory and\n  computational cost (summing across processors), so be careful to\n  define a reasonable number of chunks.\n  \n  \n  The Nevery, Nrepeat, and Nfreq arguments specify on what\n  timesteps the input values will be accessed and contribute to the\n  average.  The final averaged quantities are generated on timesteps\n  that are a multiples of Nfreq.  The average is over Nrepeat\n  quantities, computed in the preceding portion of the simulation every\n  Nevery timesteps.  Nfreq must be a multiple of Nevery and\n  Nevery must be non-zero even if Nrepeat is 1.  Also, the timesteps\n  contributing to the average value cannot overlap, i.e. Nrepeat*Nevery\n  can not exceed Nfreq.\n  For example, if Nevery=2, Nrepeat=6, and Nfreq=100, then values on\n  timesteps 90,92,94,96,98,100 will be used to compute the final average\n  on timestep 100.  Similarly for timesteps 190,192,194,196,198,200 on\n  timestep 200, etc.  If Nrepeat=1 and Nfreq = 100, then no time\n  averaging is done; values are simply generated on timesteps\n  100,200,etc.\n  Each input value can also be averaged over the atoms in each chunk.\n  The way the averaging is done across the Nrepeat timesteps to\n  produce output on the Nfreq timesteps, and across multiple Nfreq\n  outputs, is determined by the norm and ave keyword settings, as\n  discussed below.\n  \n  Note\n  To perform per-chunk averaging within a Nfreq time window, the\n  number of chunks Nchunk defined by the compute chunk/atom command must remain constant.  If\n  the ave keyword is set to running or window then Nchunk must\n  remain constant for the duration of the simulation.  This fix forces\n  the chunk/atom compute specified by chunkID to hold Nchunk constant\n  for the appropriate time windows, by not allowing it to re-calculate\n  Nchunk, which can also affect how it assigns chunk IDs to atoms.\n  This is particularly important to understand if the chunks defined by\n  the compute chunk/atom command are spatial\n  bins.  If its units keyword is set to box or lattice, then the\n  number of bins Nchunk and size of each bin will be fixed over the\n  Nfreq time window, which can affect which atoms are discarded if the\n  simulation box size changes.  If its units keyword is set to\n  reduced, then the number of bins Nchunk will still be fixed, but\n  the size of each bin can vary at each timestep if the simulation box\n  size changes, e.g. for an NPT simulation.\n  \n  \n  The atom attribute values (vx,vy,vz,fx,fy,fz) are self-explanatory.\n  As noted above, any other atom attributes can be used as input values\n  to this fix by using the compute property/atom command and then specifying\n  an input value from that compute.\n  The density/number value means the number density is computed for\n  each chunk, i.e. number/volume.  The density/mass value means the\n  mass density is computed for each chunk, i.e. total-mass/volume.  The\n  output values are in units of 1/volume or density (mass/volume).  See\n  the units command doc page for the definition of density\n  for each choice of units, e.g. gram/cm^3.  If the chunks defined by\n  the compute chunk/atom command are spatial\n  bins, the volume is the bin volume.  Otherwise it is the volume of the\n  entire simulation box.\n  The temp value means the temperature is computed for each chunk, by\n  the formula KE = DOF/2 k T, where KE = total kinetic energy of the\n  chunk of atoms (sum of 1/2 m v^2), DOF = the total number of degrees\n  of freedom for all atoms in the chunk, k = Boltzmann constant, and T =\n  temperature.\n  The DOF is calculated as N*adof + cdof, where N = number of atoms in\n  the chunk, adof = degrees of freedom per atom, and cdof = degrees of\n  freedom per chunk.  By default adof = 2 or 3 = dimensionality of\n  system, as set via the dimension command, and cdof =\n  0.0.  This gives the usual formula for temperature.\n  Note that currently this temperature only includes translational\n  degrees of freedom for each atom.  No rotational degrees of freedom\n  are included for finite-size particles.  Also no degrees of freedom\n  are subtracted for any velocity bias or constraints that are applied,\n  such as compute temp/partial, or fix shake or fix rigid.  This is because\n  those degrees of freedom (e.g. a constrained bond) could apply to sets\n  of atoms that are both included and excluded from a specific chunk,\n  and hence the concept is somewhat ill-defined.  In some cases, you can\n  use the adof and cdof keywords to adjust the calculated degrees of\n  freedom appropriately, as explained below.\n  Also note that a bias can be subtracted from atom velocities before\n  they are used in the above formula for KE, by using the bias\n  keyword.  This allows, for example, a thermal temperature to be\n  computed after removal of a flow velocity profile.\n  Note that the per-chunk temperature calculated by this fix and the\n  compute temp/chunk command can be different.\n  The compute calculates the temperature for each chunk for a single\n  snapshot.  This fix can do that but can also time average those values\n  over many snapshots, or it can compute a temperature as if the atoms\n  in the chunk on different timesteps were collected together as one set\n  of atoms to calculate their temperature.  The compute allows the\n  center-of-mass velocity of each chunk to be subtracted before\n  calculating the temperature; this fix does not.\n  If a value begins with “c_”, a compute ID must follow which has been\n  previously defined in the input script.  If no bracketed integer is\n  appended, the per-atom vector calculated by the compute is used.  If a\n  bracketed integer is appended, the Ith column of the per-atom array\n  calculated by the compute is used.  Users can also write code for\n  their own compute styles and add them to LAMMPS.\n  See the discussion above for how I can be specified with a wildcard\n  asterisk to effectively specify multiple values.\n  If a value begins with “f_”, a fix ID must follow which has been\n  previously defined in the input script.  If no bracketed integer is\n  appended, the per-atom vector calculated by the fix is used.  If a\n  bracketed integer is appended, the Ith column of the per-atom array\n  calculated by the fix is used.  Note that some fixes only produce\n  their values on certain timesteps, which must be compatible with\n  Nevery, else an error results.  Users can also write code for their\n  own fix styles and add them to LAMMPS.  See the\n  discussion above for how I can be specified with a wildcard asterisk\n  to effectively specify multiple values.\n  If a value begins with “v_”, a variable name must follow which has\n  been previously defined in the input script.  Variables of style\n  atom can reference thermodynamic keywords and various per-atom\n  attributes, or invoke other computes, fixes, or variables when they\n  are evaluated, so this is a very general means of generating per-atom\n  quantities to average within chunks.\n  \n  Additional optional keywords also affect the operation of this fix\n  and its outputs.\n  The norm keyword affects how averaging is done for the per-chunk\n  values that are output every Nfreq timesteps.\n  It the norm setting is all, which is the default, a chunk value is\n  summed over all atoms in all Nrepeat samples, as is the count of\n  atoms in the chunk.  The averaged output value for the chunk on the\n  Nfreq timesteps is Total-sum / Total-count.  In other words it is an\n  average over atoms across the entire Nfreq timescale.  For the\n  density/number and density/mass values, the volume (bin volume or\n  system volume) used in the final normalization will be the volume at\n  the final Nfreq timestep.\n  If the norm setting is sample, the chunk value is summed over\n  atoms for each sample, as is the count, and an “average sample value”\n  is computed for each sample, i.e. Sample-sum / Sample-count.  The\n  output value for the chunk on the Nfreq timesteps is the average of\n  the Nrepeat “average sample values”, i.e. the sum of Nrepeat\n  “average sample values” divided by Nrepeat.  In other words it is an\n  average of an average.  For the density/number and density/mass\n  values, the volume (bin volume or system volume) used in the\n  per-sample normalization will be the current volume at each sampling\n  step.\n  If the norm setting is none, a similar computation as for the\n  sample setting is done, except the individual “average sample\n  values” are “summed sample values”.  A summed sample value is simply\n  the chunk value summed over atoms in the sample, without dividing by\n  the number of atoms in the sample.  The output value for the chunk on\n  the Nfreq timesteps is the average of the Nrepeat “summed sample\n  values”, i.e. the sum of Nrepeat “summed sample values” divided by\n  Nrepeat.  For the density/number and density/mass values, the\n  volume (bin volume or system volume) used in the per-sample sum\n  normalization will be the current volume at each sampling step.\n  The ave keyword determines how the per-chunk values produced every\n  Nfreq steps are averaged with values produced on previous steps that\n  were multiples of Nfreq, before they are accessed by another output\n  command or written to a file.\n  If the ave setting is one, which is the default, then the chunk\n  values produced on timesteps that are multiples of Nfreq are\n  independent of each other; they are output as-is without further\n  averaging.\n  If the ave setting is running, then the chunk values produced on\n  timesteps that are multiples of Nfreq are summed and averaged in a\n  cumulative sense before being output.  Each output chunk value is thus\n  the average of the chunk value produced on that timestep with all\n  preceding values for the same chunk.  This running average begins when\n  the fix is defined; it can only be restarted by deleting the fix via\n  the unfix command, or re-defining the fix by\n  re-specifying it.\n  If the ave setting is window, then the chunk values produced on\n  timesteps that are multiples of Nfreq are summed and averaged within\n  a moving “window” of time, so that the last M values for the same\n  chunk are used to produce the output.  E.g. if M = 3 and Nfreq = 1000,\n  then the output on step 10000 will be the average of the individual\n  chunk values on steps 8000,9000,10000.  Outputs on early steps will\n  average over less than M values if they are not available.\n  The bias keyword specifies the ID of a temperature compute that\n  removes a “bias” velocity from each atom, specified as bias-ID.  It\n  is only used when the temp value is calculated, to compute the\n  thermal temperature of each chunk after the translational kinetic\n  energy components have been altered in a prescribed way, e.g.  to\n  remove a flow velocity profile.  See the doc pages for individual\n  computes that calculate a temperature to see which ones implement a\n  bias.\n  The adof and cdof keywords define the values used in the degree of\n  freedom (DOF) formula described above for temperature calculation\n  for each chunk.  They are only used when the temp value is\n  calculated.  They can be used to calculate a more appropriate\n  temperature for some kinds of chunks.  Here are 3 examples:\n  If spatially binned chunks contain some number of water molecules and\n  fix shake is used to make each molecule rigid, then\n  you could calculate a temperature with 6 degrees of freedom (DOF) (3\n  translational, 3 rotational) per molecule by setting adof to 2.0.\n  If compute temp/partial is used with the\n  bias keyword to only allow the x component of velocity to contribute\n  to the temperature, then adof = 1.0 would be appropriate.\n  If each chunk consists of a large molecule, with some number of its\n  bonds constrained by fix shake or the entire molecule\n  by fix rigid/small, adof = 0.0 and cdof could be\n  set to the remaining degrees of freedom for the entire molecule\n  (entire chunk in this case), e.g. 6 for 3d, or 3 for 2d, for a rigid\n  molecule.\n  The file keyword allows a filename to be specified.  Every Nfreq\n  timesteps, a section of chunk info will be written to a text file in\n  the following format.  A line with the timestep and number of chunks\n  is written.  Then one line per chunk is written, containing the chunk\n  ID (1-Nchunk), an optional original ID value, optional coordinate\n  values for chunks that represent spatial bins, the number of atoms in\n  the chunk, and one or more calculated values.  More explanation of the\n  optional values is given below.  The number of values in each line\n  corresponds to the number of values specified in the fix ave/chunk\n  command.  The number of atoms and the value(s) are summed or average\n  quantities, as explained above.\n  The overwrite keyword will continuously overwrite the output file\n  with the latest output, so that it only contains one timestep worth of\n  output.  This option can only be used with the ave running setting.\n  The format keyword sets the numeric format of each value when it is\n  printed to a file via the file keyword.  Note that all values are\n  floating point quantities.  The default format is %g.  You can specify\n  a higher precision if desired, e.g. %20.16g.\n  The title1 and title2 and title3 keywords allow specification of\n  the strings that will be printed as the first 3 lines of the output\n  file, assuming the file keyword was used.  LAMMPS uses default\n  values for each of these, so they do not need to be specified.\n  By default, these header lines are as follows:\n  # Chunk-averaged data for fix ID and group name\n  # Timestep Number-of-chunks\n  # Chunk (OrigID) (Coord1) (Coord2) (Coord3) Ncount value1 value2 ...\n  \n  \n  In the first line, ID and name are replaced with the fix-ID and group\n  name.  The second line describes the two values that are printed at\n  the first of each section of output.  In the third line the values are\n  replaced with the appropriate value names, e.g. fx or c_myCompute[2].\n  The words in parenthesis only appear with corresponding columns if the\n  chunk style specified for the compute chunk/atom command supports them.  The OrigID\n  column is only used if the compress keyword was set to yes for the\n  compute chunk/atom command.  This means that\n  the original chunk IDs (e.g. molecule IDs) will have been compressed\n  to remove chunk IDs with no atoms assigned to them.  Thus a compressed\n  chunk ID of 3 may correspond to an original chunk ID or molecule ID of\n  415.  The OrigID column will list 415 for the 3rd chunk.\n  The CoordN columns only appear if a binning style was used in the\n  compute chunk/atom command.  For bin/1d,\n  bin/2d, and bin/3d styles the column values are the center point\n  of the bin in the corresponding dimension.  Just Coord1 is used for\n  bin/1d, Coord2 is added for bin/2d, Coord3 is added for bin/3d.\n  For bin/sphere, just Coord1 is used, and it is the radial\n  coordinate.  For bin/cylinder, Coord1 and Coord2 are used.  Coord1\n  is the radial coordinate (away from the cylinder axis), and coord2 is\n  the coordinate along the cylinder axis.\n  Note that if the value of the units keyword used in the compute chunk/atom command is box or lattice, the\n  coordinate values will be in distance units.  If the\n  value of the units keyword is reduced, the coordinate values will\n  be in unitless reduced units (0-1).  This is not true for the Coord1 value\n  of style bin/sphere or bin/cylinder which both represent radial\n  dimensions.  Those values are always in distance units.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.\n  This fix computes a global array of values which can be accessed by\n  various output commands.  The values can only be\n  accessed on timesteps that are multiples of Nfreq since that is when\n  averaging is performed.  The global array has # of rows = the number\n  of chunks Nchunk as calculated by the specified compute chunk/atom command.  The # of columns =\n  M+1+Nvalues, where M = 1 to 4, depending on whether the optional\n  columns for OrigID and CoordN are used, as explained above.  Following\n  the optional columns, the next column contains the count of atoms in\n  the chunk, and the remaining columns are the Nvalue quantities.  When\n  the array is accessed with a row I that exceeds the current number of\n  chunks, than a 0.0 is returned by the fix instead of an error, since\n  the number of chunks can vary as a simulation runs depending on how\n  that value is computed by the compute chunk/atom command.\n  The array values calculated by this fix are treated as “intensive”,\n  since they are typically already normalized by the count of atoms in\n  each chunk.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID ave/chunk Nevery Nrepeat Nfreq chunkID value1 value2 ... keyword args ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  ave/chunk = style name of this fix command\n  Nevery = use input values every this many timesteps\n  Nrepeat = # of times to use input values for calculating averages\n  Nfreq = calculate averages every this many timesteps\n  chunkID = ID of compute chunk/atom command\n  one or more input values can be listed\n  value = vx, vy, vz, fx, fy, fz, density/mass, density/number, temp, c_ID, c_ID[I], f_ID, f_ID[I], v_name\n  vx,vy,vz,fx,fy,fz = atom attribute (velocity, force component)\n  density/number, density/mass = number or mass density\n  temp = temperature\n  c_ID = per-atom vector calculated by a compute with ID\n  c_ID[I] = Ith column of per-atom array calculated by a compute with ID, I can include wildcard (see below)\n  f_ID = per-atom vector calculated by a fix with ID\n  f_ID[I] = Ith column of per-atom array calculated by a fix with ID, I can include wildcard (see below)\n  v_name = per-atom vector calculated by an atom-style variable with name\n  \n  \n  \n  zero or more keyword/arg pairs may be appended\n  keyword = norm or ave or bias or adof or cdof or file or overwrite or title1 or title2 or title3\n  norm arg = all or sample or none = how output on Nfreq steps is normalized\n    all = output is sum of atoms across all Nrepeat samples, divided by atom count\n    sample = output is sum of Nrepeat sample averages, divided by Nrepeat\n    none = output is sum of Nrepeat sample sums, divided by Nrepeat\n  ave args = one or running or window M\n    one = output new average value every Nfreq steps\n    running = output cumulative average of all previous Nfreq steps\n    window M = output average of M most recent Nfreq steps\n  bias arg = bias-ID\n    bias-ID = ID of a temperature compute that removes a velocity bias for temperature calculation\n  adof value = dof_per_atom\n    dof_per_atom = define this many degrees-of-freedom per atom for temperature calculation\n  cdof value = dof_per_chunk\n    dof_per_chunk = define this many degrees-of-freedom per chunk for temperature calculation\n  file arg = filename\n    filename = file to write results to\n  overwrite arg = none = overwrite output file with only latest output\n  format arg = string\n    string = C-style format string\n  title1 arg = string\n    string = text to print as 1st line of output file\n  title2 arg = string\n    string = text to print as 2nd line of output file\n  title3 arg = string\n    string = text to print as 3rd line of output file\n  \n  \n  ",
    "examples": "fix 1 all ave/chunk 10000 1 10000 binchunk c_myCentro title1 \"My output values\"\n  fix 1 flow ave/chunk 100 10 1000 molchunk vx vz norm sample file vel.profile\n  fix 1 flow ave/chunk 100 5 1000 binchunk density/mass ave running\n  fix 1 flow ave/chunk 100 5 1000 binchunk density/mass ave running\n  \n  \n  NOTE:\n  If you are trying to replace a deprecated fix ave/spatial command\n  with the newer, more flexible fix ave/chunk and compute chunk/atom commands, you simply need to split\n  the fix ave/spatial arguments across the two new commands.  For\n  example, this command:\n  fix 1 flow ave/spatial 100 10 1000 y 0.0 1.0 vx vz norm sample file vel.profile\n  \n  \n  could be replaced by:\n  compute cc1 flow chunk/atom bin/1d y 0.0 1.0\n  fix 1 flow ave/chunk 100 10 1000 cc1 vx vz norm sample file vel.profile\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix ave/correlate",
    "description": "Use one or more global scalar values as inputs every few timesteps,\n  calculate time correlations between them at varying time intervals,\n  and average the correlation data over longer timescales.  The\n  resulting correlation values can be time integrated by\n  variables or used by other output commands such as thermo_style custom, and can also be written to a file.  See the\n  fix ave/correlate/long command for an\n  alternate method for computing correlation functions efficiently over\n  very long time windows.\n  The group specified with this command is ignored.  However, note that\n  specified values may represent calculations performed by computes and\n  fixes which store their own “group” definitions.\n  Each listed value can be the result of a compute or\n  fix or the evaluation of an equal-style or vector-style\n  variable.  In each case, the compute, fix, or variable\n  must produce a global quantity, not a per-atom or local quantity.  If\n  you wish to spatial- or time-average or histogram per-atom quantities\n  from a compute, fix, or variable, then see the fix ave/chunk, fix ave/atom, or\n  fix ave/histo commands.  If you wish to convert a\n  per-atom quantity into a single global value, see the compute reduce command.\n  The input values must either be all scalars.  What kinds of\n  correlations between input values are calculated is determined by the\n  type keyword as discussed below.\n  Computes that produce global quantities are those which\n  do not have the word atom in their style name.  Only a few\n  fixes produce global quantities.  See the doc pages for\n  individual fixes for info on which ones produce such values.\n  Variables of style equal and vector are the only\n  ones that can be used with this fix.  Variables of style atom cannot\n  be used, since they produce per-atom values.\n  Note that for values from a compute or fix, the bracketed index I can\n  be specified using a wildcard asterisk with the index to effectively\n  specify multiple values.  This takes the form “*” or “*n” or “n*” or\n  “m*n”.  If N = the size of the vector (for mode = scalar) or the\n  number of columns in the array (for mode = vector), then an asterisk\n  with no numeric values means all indices from 1 to N.  A leading\n  asterisk means all indices from 1 to n (inclusive).  A trailing\n  asterisk means all indices from n to N (inclusive).  A middle asterisk\n  means all indices from m to n (inclusive).\n  Using a wildcard is the same as if the individual elements of the\n  vector had been listed one by one.  E.g. these 2 fix ave/correlate\n  commands are equivalent, since the compute pressure command creates a global vector with 6\n  values.\n  compute myPress all pressure NULL\n  fix 1 all ave/correlate 1 50 10000 c_myPress[*]\n  fix 1 all ave/correlate 1 50 10000 &\n            c_myPress[1] c_myPress[2] c_myPress[3] &\n            c_myPress[4] c_myPress[5] c_myPress[6]\n  \n  \n  \n  The Nevery, Nrepeat, and Nfreq arguments specify on what\n  timesteps the input values will be used to calculate correlation data.\n  The input values are sampled every Nevery timesteps.  The\n  correlation data for the preceding samples is computed on timesteps\n  that are a multiple of Nfreq.  Consider a set of samples from some\n  initial time up to an output timestep.  The initial time could be the\n  beginning of the simulation or the last output time; see the ave\n  keyword for options.  For the set of samples, the correlation value\n  Cij is calculated as:\n  Cij(delta) = ave(Vi(t)*Vj(t+delta))\n  which is the correlation value between input values Vi and Vj,\n  separated by time delta.  Note that the second value Vj in the pair is\n  always the one sampled at the later time.  The ave() represents an\n  average over every pair of samples in the set that are separated by\n  time delta.  The maximum delta used is of size (Nrepeat-1)*Nevery.\n  Thus the correlation between a pair of input values yields Nrepeat\n  correlation datums:\n  Cij(0), Cij(Nevery), Cij(2*Nevery), ..., Cij((Nrepeat-1)*Nevery)\n  For example, if Nevery=5, Nrepeat=6, and Nfreq=100, then values on\n  timesteps 0,5,10,15,…,100 will be used to compute the final averages\n  on timestep 100.  Six averages will be computed: Cij(0), Cij(5),\n  Cij(10), Cij(15), Cij(20), and Cij(25).  Cij(10) on timestep 100 will\n  be the average of 19 samples, namely Vi(0)*Vj(10), Vi(5)*Vj(15),\n  Vi(10)*V j20), Vi(15)*Vj(25), …, Vi(85)*Vj(95), Vi(90)*Vj(100).\n  Nfreq must be a multiple of Nevery; Nevery and Nrepeat must be\n  non-zero.  Also, if the ave keyword is set to one which is the\n  default, then Nfreq >= (Nrepeat-1)*Nevery is required.\n  \n  If a value begins with “c_”, a compute ID must follow which has been\n  previously defined in the input script.  If no bracketed term is\n  appended, the global scalar calculated by the compute is used.  If a\n  bracketed term is appended, the Ith element of the global vector\n  calculated by the compute is used.  See the discussion above for how I\n  can be specified with a wildcard asterisk to effectively specify\n  multiple values.\n  Note that there is a compute reduce command\n  which can sum per-atom quantities into a global scalar or vector which\n  can thus be accessed by fix ave/correlate.  Or it can be a compute\n  defined not in your input script, but by thermodynamic output or other fixes such as fix nvt\n  or fix temp/rescale.  See the doc pages for\n  these commands which give the IDs of these computes.  Users can also\n  write code for their own compute styles and add them to LAMMPS.\n  If a value begins with “f_”, a fix ID must follow which has been\n  previously defined in the input script.  If no bracketed term is\n  appended, the global scalar calculated by the fix is used.  If a\n  bracketed term is appended, the Ith element of the global vector\n  calculated by the fix is used.  See the discussion above for how I can\n  be specified with a wildcard asterisk to effectively specify multiple\n  values.\n  Note that some fixes only produce their values on certain timesteps,\n  which must be compatible with Nevery, else an error will result.\n  Users can also write code for their own fix styles and add them to LAMMPS.\n  If a value begins with “v_”, a variable name must follow which has\n  been previously defined in the input script.  Only equal-style or\n  vector-style variables can be referenced; the latter requires a\n  bracketed term to specify the Ith element of the vector calculated by\n  the variable.  See the variable command for details.\n  Note that variables of style equal or vector define a formula\n  which can reference individual atom properties or thermodynamic\n  keywords, or they can invoke other computes, fixes, or variables when\n  they are evaluated, so this is a very general means of specifying\n  quantities to time correlate.\n  \n  Additional optional keywords also affect the operation of this fix.\n  The type keyword determines which pairs of input values are\n  correlated with each other.  For N input values Vi, for i = 1 to N,\n  let the number of pairs = Npair.  Note that the second value in the\n  pair Vi(t)*Vj(t+delta) is always the one sampled at the later time.\n  \n  If type is set to auto then each input value is correlated with\n  itself.  I.e. Cii = Vi*Vi, for i = 1 to N, so Npair = N.\n  If type is set\n  to upper then each input value is correlated with every succeeding\n  value.  I.e. Cij = Vi*Vj, for i < j, so Npair = N*(N-1)/2.\n  If type is set\n  to lower then each input value is correlated with every preceding\n  value.  I.e. Cij = Vi*Vj, for i > j, so Npair = N*(N-1)/2.\n  If type is set to auto/upper then each input value is correlated\n  with itself and every succeeding value.  I.e. Cij = Vi*Vj, for i >= j,\n  so Npair = N*(N+1)/2.\n  If type is set to auto/lower then each input value is correlated\n  with itself and every preceding value.  I.e. Cij = Vi*Vj, for i <= j,\n  so Npair = N*(N+1)/2.\n  If type is set to full then each input value is correlated with\n  itself and every other value.  I.e. Cij = Vi*Vj, for i,j = 1,N so\n  Npair = N^2.\n  \n  The ave keyword determines what happens to the accumulation of\n  correlation samples every Nfreq timesteps.  If the ave setting is\n  one, then the accumulation is restarted or zeroed every Nfreq\n  timesteps.  Thus the outputs on successive Nfreq timesteps are\n  essentially independent of each other.  The exception is that the\n  Cij(0) = Vi(T)*Vj(T) value at a timestep T, where T is a multiple of\n  Nfreq, contributes to the correlation output both at time T and at\n  time T+Nfreq.\n  If the ave setting is running, then the accumulation is never\n  zeroed.  Thus the output of correlation data at any timestep is the\n  average over samples accumulated every Nevery steps since the fix\n  was defined.  it can only be restarted by deleting the fix via the\n  unfix command, or by re-defining the fix by re-specifying\n  it.\n  The start keyword specifies what timestep the accumulation of\n  correlation samples will begin on.  The default is step 0.  Setting it\n  to a larger value can avoid adding non-equilibrated data to the\n  correlation averages.\n  The prefactor keyword specifies a constant which will be used as a\n  multiplier on the correlation data after it is averaged.  It is\n  effectively a scale factor on Vi*Vj, which can be used to account for\n  the size of the time window or other unit conversions.\n  The file keyword allows a filename to be specified.  Every Nfreq\n  steps, an array of correlation data is written to the file.  The\n  number of rows is Nrepeat, as described above.  The number of\n  columns is the Npair+2, also as described above.  Thus the file ends\n  up to be a series of these array sections.\n  The overwrite keyword will continuously overwrite the output file\n  with the latest output, so that it only contains one timestep worth of\n  output.  This option can only be used with the ave running setting.\n  The title1 and title2 and title3 keywords allow specification of\n  the strings that will be printed as the first 3 lines of the output\n  file, assuming the file keyword was used.  LAMMPS uses default\n  values for each of these, so they do not need to be specified.\n  By default, these header lines are as follows:\n  # Time-correlated data for fix ID\n  # TimeStep Number-of-time-windows\n  # Index TimeDelta Ncount valueI*valueJ valueI*valueJ ...\n  In the first line, ID is replaced with the fix-ID.  The second line\n  describes the two values that are printed at the first of each section\n  of output.  In the third line the value pairs are replaced with the\n  appropriate fields from the fix ave/correlate command.\n  \n  Let Sij = a set of time correlation data for input values I and J,\n  namely the Nrepeat values:\n  Sij = Cij(0), Cij(Nevery), Cij(2*Nevery), ..., Cij(*Nrepeat-1)*Nevery)\n  As explained below, these datums are output as one column of a global\n  array, which is effectively the correlation matrix.\n  The trap function defined for equal-style variables\n  can be used to perform a time integration of this vector of datums,\n  using a trapezoidal rule.  This is useful for calculating various\n  quantities which can be derived from time correlation data.  If a\n  normalization factor is needed for the time integration, it can be\n  included in the variable formula or via the prefactor keyword.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.\n  This fix computes a global array of values which can be accessed by\n  various output commands.  The values can only be\n  accessed on timesteps that are multiples of Nfreq since that is when\n  averaging is performed.  The global array has # of rows = Nrepeat\n  and # of columns = Npair+2.  The first column has the time delta (in\n  timesteps) between the pairs of input values used to calculate the\n  correlation, as described above.  The 2nd column has the number of\n  samples contributing to the correlation average, as described above.\n  The remaining Npair columns are for I,J pairs of the N input values,\n  as determined by the type keyword, as described above.\n  \n  For type = auto, the Npair = N columns are ordered: C11, C22, …,\n  CNN.\n  For type = upper, the Npair = N*(N-1)/2 columns are ordered: C12,\n  C13, …, C1N, C23, …, C2N, C34, …, CN-1N.\n  For type = lower, the Npair = N*(N-1)/2 columns are ordered: C21,\n  C31, C32, C41, C42, C43, …, CN1, CN2, …, CNN-1.\n  For type = auto/upper, the Npair = N*(N+1)/2 columns are ordered:\n  C11, C12, C13, …, C1N, C22, C23, …, C2N, C33, C34, …, CN-1N,\n  CNN.\n  For type = auto/lower, the Npair = N*(N+1)/2 columns are ordered:\n  C11, C21, C22, C31, C32, C33, C41, …, C44, CN1, CN2, …, CNN-1,\n  CNN.\n  For type = full, the Npair = N^2 columns are ordered: C11, C12,\n  …, C1N, C21, C22, …, C2N, C31, …, C3N, …, CN1, …, CNN-1,\n  CNN.\n  \n  The array values calculated by this fix are treated as intensive.  If\n  you need to divide them by the number of atoms, you must do this in a\n  later processing step, e.g. when using them in a\n  variable.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID ave/correlate Nevery Nrepeat Nfreq value1 value2 ... keyword args ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  ave/correlate = style name of this fix command\n  Nevery = use input values every this many timesteps\n  Nrepeat = # of correlation time windows to accumulate\n  Nfreq = calculate time window averages every this many timesteps\n  one or more input values can be listed\n  value = c_ID, c_ID[N], f_ID, f_ID[N], v_name\n  c_ID = global scalar calculated by a compute with ID\n  c_ID[I] = Ith component of global vector calculated by a compute with ID, I can include wildcard (see below)\n  f_ID = global scalar calculated by a fix with ID\n  f_ID[I] = Ith component of global vector calculated by a fix with ID, I can include wildcard (see below)\n  v_name = global value calculated by an equal-style variable with name\n  v_name[I] = Ith component of a vector-style variable with name\n  \n  \n  \n  zero or more keyword/arg pairs may be appended\n  keyword = type or ave or start or prefactor or file or overwrite or title1 or title2 or title3\n  type arg = auto or upper or lower or auto/upper or auto/lower or full\n    auto = correlate each value with itself\n    upper = correlate each value with each succeeding value\n    lower = correlate each value with each preceding value\n    auto/upper = auto + upper\n    auto/lower = auto + lower\n    full = correlate each value with every other value, including itself = auto + upper + lower\n  ave args = one or running\n    one = zero the correlation accumulation every Nfreq steps\n    running = accumulate correlations continuously\n  start args = Nstart\n    Nstart = start accumulating correlations on this timestep\n  prefactor args = value\n    value = prefactor to scale all the correlation data by\n  file arg = filename\n    filename = name of file to output correlation data to\n  overwrite arg = none = overwrite output file with only latest output\n  title1 arg = string\n    string = text to print as 1st line of output file\n  title2 arg = string\n    string = text to print as 2nd line of output file\n  title3 arg = string\n    string = text to print as 3rd line of output file\n  \n  \n  ",
    "examples": "fix 1 all ave/correlate 5 100 1000 c_myTemp file temp.correlate\n  fix 1 all ave/correlate 1 50 10000 &\n            c_thermo_press[1] c_thermo_press[2] c_thermo_press[3] &\n            type upper ave running title1 \"My correlation data\"\n  \n  fix 1 all ave/correlate 1 50 10000 c_thermo_press[*]\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix ave/correlate/long",
    "description": "This fix is similar in spirit and syntax to the fix ave/correlate.\n  However, this fix allows the efficient calculation of time correlation\n  functions on-the-fly over extremely long time windows with little\n  additional CPU overhead, using a multiple-tau method\n  (Ramirez) that decreases the resolution of the stored\n  correlation function with time.  It is not a full drop-in replacement.\n  The group specified with this command is ignored.  However, note that\n  specified values may represent calculations performed by computes and\n  fixes which store their own “group” definitions.\n  Each listed value can be the result of a compute or fix or the\n  evaluation of an equal-style variable. See the fix ave/correlate doc page for details.\n  The Nevery and Nfreq arguments specify on what timesteps the input\n  values will be used to calculate correlation data, and the frequency\n  with which the time correlation functions will be output to a file.\n  Note that there is no Nrepeat argument, unlike the fix ave/correlate command.\n  The optional keywords ncorr, nlen, and ncount are unique to this\n  command and determine the number of correlation points calculated and\n  the memory and CPU overhead used by this calculation. Nlen and\n  ncount determine the amount of averaging done at longer correlation\n  times.  The default values nlen=16, ncount=2 ensure that the\n  systematic error of the multiple-tau correlator is always below the\n  level of the statistical error of a typical simulation (which depends\n  on the ensemble size and the simulation length).\n  The maximum correlation time (in time steps) that can be reached is\n  given by the formula (nlen-1) * ncount^(ncorr-1).  Longer correlation\n  times are discarded and not calculated.  With the default values of\n  the parameters (ncorr=20, nlen=16 and ncount=2), this corresponds to\n  7864320 time steps.  If longer correlation times are needed, the value\n  of ncorr should be increased. Using nlen=16 and ncount=2, with\n  ncorr=30, the maximum number of steps that can be correlated is\n  80530636808.  If ncorr=40, correlation times in excess of 8e12 time\n  steps can be calculated.\n  The total memory needed for each correlation pair is roughly\n  4*ncorr*nlen*8 bytes. With the default values of the parameters, this\n  corresponds to about 10 KB.\n  For the meaning of the additional optional keywords, see the fix ave/correlate doc page.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  Contrary to fix ave/correlate this fix\n  does not provide access to its internal data to various output\n  options. Since this fix in intended for the calculation of time\n  correlation functions over very long MD simulations, the information\n  about this fix is written automatically to binary restart files, so\n  that the time correlation calculation can continue in subsequent\n  simulations. None of the fix_modify options are relevant to this fix.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command. This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID ave/correlate/long Nevery Nfreq value1 value2 ... keyword args ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  ave/correlate/long = style name of this fix command\n  Nevery = use input values every this many timesteps\n  Nfreq = save state of the time correlation functions every this many timesteps\n  one or more input values can be listed\n  value = c_ID, c_ID[N], f_ID, f_ID[N], v_name\n  c_ID = global scalar calculated by a compute with ID\n  c_ID[I] = Ith component of global vector calculated by a compute with ID\n  f_ID = global scalar calculated by a fix with ID\n  f_ID[I] = Ith component of global vector calculated by a fix with ID\n  v_name = global value calculated by an equal-style variable with name\n  \n  \n  \n  zero or more keyword/arg pairs may be appended\n  keyword = type or start or file or overwrite or title1 or title2 or ncorr or p or m\n  type arg = auto or upper or lower or auto/upper or auto/lower or full\n    auto = correlate each value with itself\n    upper = correlate each value with each succeeding value\n    lower = correlate each value with each preceding value\n    auto/upper = auto + upper\n    auto/lower = auto + lower\n    full = correlate each value with every other value, including itself = auto + upper + lower\n  start args = Nstart\n    Nstart = start accumulating correlations on this timestep\n  file arg = filename\n    filename = name of file to output correlation data to\n  overwrite arg = none = overwrite output file with only latest output\n  title1 arg = string\n    string = text to print as 1st line of output file\n  title2 arg = string\n    string = text to print as 2nd line of output file\n  ncorr arg = Ncorrelators\n    Ncorrelators = number of correlators to store\n  nlen args = Nlen\n    Nlen = length of each correlator\n  ncount args = Ncount\n    Ncount = number of values over which successive correlators are averaged\n  \n  \n  ",
    "examples": "fix 1 all ave/correlate/long 5 1000 c_myTemp file temp.correlate\n  fix 1 all ave/correlate/long 1 10000 &\n            c_thermo_press[1] c_thermo_press[2] c_thermo_press[3] &\n            type upper title1 \"My correlation data\" nlen 15 ncount 3\n  \n  \n  ",
    "restrictions": "This compute is part of the USER-MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "fix ave/histo",
    "description": "Use one or more values as inputs every few timesteps to create a\n  single histogram.  The histogram can then be averaged over longer\n  timescales.  The resulting histogram can be used by other output commands, and can also be written to a file.  The\n  fix ave/histo/weight command has identical syntax to fix ave/histo,\n  except that exactly two values must be specified.  See details below.\n  The group specified with this command is ignored for global and local\n  input values.  For per-atom input values, only atoms in the group\n  contribute to the histogram.  Note that regardless of the specified\n  group, specified values may represent calculations performed by\n  computes and fixes which store their own “group” definition.\n  A histogram is simply a count of the number of values that fall within\n  a histogram bin.  Nbins are defined, with even spacing between lo\n  and hi.  Values that fall outside the lo/hi bounds can be treated in\n  different ways; see the discussion of the beyond keyword below.\n  Each input value can be an atom attribute (position, velocity, force\n  component) or can be the result of a compute or\n  fix or the evaluation of an equal-style or vector-style or\n  atom-style variable.  The set of input values can be\n  either all global, all per-atom, or all local quantities.  Inputs of\n  different kinds (e.g. global and per-atom) cannot be mixed.  Atom\n  attributes are per-atom vector values.  See the doc page for\n  individual “compute” and “fix” commands to see what kinds of\n  quantities they generate.  See the optional kind keyword below for\n  how to force the fix ave/histo command to disambiguate if necessary.\n  Note that the output of this command is a single histogram for all\n  input values combined together, not one histogram per input value.\n  See below for details on the format of the output of this fix.\n  The input values must either be all scalars or all vectors (or\n  arrays), depending on the setting of the mode keyword.\n  If mode = scalar, then the input values must be scalars, or vectors\n  with a bracketed term appended, indicating the Ith value of the vector\n  is used.\n  If mode = vector, then the input values must be vectors, or arrays\n  with a bracketed term appended, indicating the Ith column of the array\n  is used.\n  Note that for values from a compute or fix, the bracketed index I can\n  be specified using a wildcard asterisk with the index to effectively\n  specify multiple values.  This takes the form “*” or “*n” or “n*” or\n  “m*n”.  If N = the size of the vector (for mode = scalar) or the\n  number of columns in the array (for mode = vector), then an asterisk\n  with no numeric values means all indices from 1 to N.  A leading\n  asterisk means all indices from 1 to n (inclusive).  A trailing\n  asterisk means all indices from n to N (inclusive).  A middle asterisk\n  means all indices from m to n (inclusive).\n  Using a wildcard is the same as if the individual elements of the\n  vector or columns of the array had been listed one by one.  E.g. these\n  2 fix ave/histo commands are equivalent, since the compute com/chunk command creates a global array with\n  3 columns:\n  compute myCOM all com/chunk\n  fix 1 all ave/histo 100 1 100 c_myCOM[*] file tmp1.com mode vector\n  fix 2 all ave/histo 100 1 100 c_myCOM[1] c_myCOM[2] c_myCOM[3] file tmp2.com mode vector\n  \n  \n  If the fix ave/histo/weight command is used, exactly two values must\n  be specified.  If the values are vectors, they must be the same\n  length.  The first value (a scalar or vector) is what is histogrammed\n  into bins, in the same manner the fix ave/histo command operates.  The\n  second value (a scalar or vector) is used as a “weight”.  This means\n  that instead of each value tallying a “1” to its bin, the\n  corresponding weight is tallied.  E.g. The Nth entry (weight) in the\n  second vector is tallied to the bin corresponding to the Nth entry in\n  the first vector.\n  \n  The Nevery, Nrepeat, and Nfreq arguments specify on what\n  timesteps the input values will be used in order to contribute to the\n  histogram.  The final histogram is generated on timesteps that are\n  multiple of Nfreq.  It is averaged over Nrepeat histograms,\n  computed in the preceding portion of the simulation every Nevery\n  timesteps.  Nfreq must be a multiple of Nevery and Nevery must\n  be non-zero even if Nrepeat is 1.  Also, the timesteps\n  contributing to the histogram value cannot overlap,\n  i.e. Nrepeat*Nevery can not exceed Nfreq.\n  For example, if Nevery=2, Nrepeat=6, and Nfreq=100, then input values\n  on timesteps 90,92,94,96,98,100 will be used to compute the final\n  histogram on timestep 100.  Similarly for timesteps\n  190,192,194,196,198,200 on timestep 200, etc.  If Nrepeat=1 and Nfreq\n  = 100, then no time averaging of the histogram is done; a histogram is\n  simply generated on timesteps 100,200,etc.\n  \n  The atom attribute values (x,y,z,vx,vy,vz,fx,fy,fz) are\n  self-explanatory.  Note that other atom attributes can be used as\n  inputs to this fix by using the compute property/atom command and then specifying\n  an input value from that compute.\n  If a value begins with “c_”, a compute ID must follow which has been\n  previously defined in the input script.  If mode = scalar, then if\n  no bracketed term is appended, the global scalar calculated by the\n  compute is used.  If a bracketed term is appended, the Ith element of\n  the global vector calculated by the compute is used.  If mode =\n  vector, then if no bracketed term is appended, the global or per-atom\n  or local vector calculated by the compute is used.  If a bracketed\n  term is appended, the Ith column of the global or per-atom or local\n  array calculated by the compute is used.  See the discussion above for\n  how I can be specified with a wildcard asterisk to effectively specify\n  multiple values.\n  Note that there is a compute reduce command\n  which can sum per-atom quantities into a global scalar or vector which\n  can thus be accessed by fix ave/histo.  Or it can be a compute defined\n  not in your input script, but by thermodynamic output or other fixes such as fix nvt\n  or fix temp/rescale.  See the doc pages for\n  these commands which give the IDs of these computes.  Users can also\n  write code for their own compute styles and add them to LAMMPS.\n  If a value begins with “f_”, a fix ID must follow which has been\n  previously defined in the input script.  If mode = scalar, then if\n  no bracketed term is appended, the global scalar calculated by the fix\n  is used.  If a bracketed term is appended, the Ith element of the\n  global vector calculated by the fix is used.  If mode = vector, then\n  if no bracketed term is appended, the global or per-atom or local\n  vector calculated by the fix is used.  If a bracketed term is\n  appended, the Ith column of the global or per-atom or local array\n  calculated by the fix is used.  See the discussion above for how I can\n  be specified with a wildcard asterisk to effectively specify multiple\n  values.\n  Note that some fixes only produce their values on certain timesteps,\n  which must be compatible with Nevery, else an error will result.\n  Users can also write code for their own fix styles and add them to LAMMPS.\n  If a value begins with “v_”, a variable name must follow which has\n  been previously defined in the input script.  If mode = scalar, then\n  only equal-style or vector-style variables can be used, which both\n  produce global values.  In this mode, a vector-style variable requires\n  a bracketed term to specify the Ith element of the vector calculated\n  by the variable.  If mode = vector, then only vector-style or\n  atom-style variables can be used, which produce a global or per-atom\n  vector respectively.  The vector-style variable must be used without a\n  bracketed term.  See the variable command for details.\n  Note that variables of style equal, vector, and atom define a\n  formula which can reference individual atom properties or\n  thermodynamic keywords, or they can invoke other computes, fixes, or\n  variables when they are evaluated, so this is a very general means of\n  specifying quantities to histogram.\n  \n  Additional optional keywords also affect the operation of this fix.\n  If the mode keyword is set to scalar, then all input values must\n  be global scalars, or elements of global vectors.  If the mode\n  keyword is set to vector, then all input values must be global or\n  per-atom or local vectors, or columns of global or per-atom or local\n  arrays.\n  The kind keyword only needs to be set if a compute or fix produces\n  more than one kind of output (global, per-atom, local).  If this is\n  not the case, then LAMMPS will determine what kind of input is\n  provided and whether all the input arguments are consistent.  If a\n  compute or fix produces more than one kind of output, the kind\n  keyword should be used to specify which output will be used.  The\n  remaining input arguments must still be consistent.\n  The beyond keyword determines how input values that fall outside the\n  lo to hi bounds are treated.  Values such that lo <= value <=\n  hi are assigned to one bin.  Values on a bin boundary are assigned\n  to the lower of the 2 bins.  If beyond is set to ignore then\n  values < lo and values > hi are ignored, i.e. they are not binned.\n  If beyond is set to end then values < lo are counted in the\n  first bin and values > hi are counted in the last bin.  If beyond\n  is set to extend then two extra bins are created, so that there are\n  Nbins+2 total bins.  Values < lo are counted in the first bin and\n  values > hi are counted in the last bin (Nbins+2).  Values between\n  lo and hi (inclusive) are counted in bins 2 through Nbins+1.  The\n  “coordinate” stored and printed for these two extra bins is lo and\n  hi.\n  The ave keyword determines how the histogram produced every Nfreq\n  steps are averaged with histograms produced on previous steps that\n  were multiples of Nfreq, before they are accessed by another output\n  command or written to a file.\n  If the ave setting is one, then the histograms produced on\n  timesteps that are multiples of Nfreq are independent of each other;\n  they are output as-is without further averaging.\n  If the ave setting is running, then the histograms produced on\n  timesteps that are multiples of Nfreq are summed and averaged in a\n  cumulative sense before being output.  Each bin value in the histogram\n  is thus the average of the bin value produced on that timestep with\n  all preceding values for the same bin.  This running average begins\n  when the fix is defined; it can only be restarted by deleting the fix\n  via the unfix command, or by re-defining the fix by\n  re-specifying it.\n  If the ave setting is window, then the histograms produced on\n  timesteps that are multiples of Nfreq are summed within a moving\n  “window” of time, so that the last M histograms are used to produce\n  the output.  E.g. if M = 3 and Nfreq = 1000, then the output on step\n  10000 will be the combined histogram of the individual histograms on\n  steps 8000,9000,10000.  Outputs on early steps will be sums over less\n  than M histograms if they are not available.\n  The start keyword specifies what timestep histogramming will begin\n  on.  The default is step 0.  Often input values can be 0.0 at time 0,\n  so setting start to a larger value can avoid including a 0.0 in\n  a running or windowed histogram.\n  The file keyword allows a filename to be specified.  Every Nfreq\n  steps, one histogram is written to the file.  This includes a leading\n  line that contains the timestep, number of bins, the total count of\n  values contributing to the histogram, the count of values that were\n  not histogrammed (see the beyond keyword), the minimum value\n  encountered, and the maximum value encountered.  The min/max values\n  include values that were not histogrammed.  Following the leading\n  line, one line per bin is written into the file.  Each line contains\n  the bin #, the coordinate for the center of the bin (between lo and\n  hi), the count of values in the bin, and the normalized count.  The\n  normalized count is the bin count divided by the total count (not\n  including values not histogrammed), so that the normalized values sum\n  to 1.0 across all bins.\n  The overwrite keyword will continuously overwrite the output file\n  with the latest output, so that it only contains one timestep worth of\n  output.  This option can only be used with the ave running setting.\n  The title1 and title2 and title3 keywords allow specification of\n  the strings that will be printed as the first 3 lines of the output\n  file, assuming the file keyword was used.  LAMMPS uses default\n  values for each of these, so they do not need to be specified.\n  By default, these header lines are as follows:\n  # Histogram for fix ID\n  # TimeStep Number-of-bins Total-counts Missing-counts Min-value Max-value\n  # Bin Coord Count Count/Total\n  \n  \n  In the first line, ID is replaced with the fix-ID.  The second line\n  describes the six values that are printed at the first of each section\n  of output.  The third describes the 4 values printed for each bin in\n  the histogram.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.\n  This fix produces a global vector and global array which can be\n  accessed by various output commands.  The values\n  can only be accessed on timesteps that are multiples of Nfreq since\n  that is when a histogram is generated.  The global vector has 4\n  values:\n  \n  1 = total counts in the histogram\n  2 = values that were not histogrammed (see beyond keyword)\n  3 = min value of all input values, including ones not histogrammed\n  4 = max value of all input values, including ones not histogrammed\n  \n  The global array has # of rows = Nbins and # of columns = 3.  The\n  first column has the bin coordinate, the 2nd column has the count of\n  values in that histogram bin, and the 3rd column has the bin count\n  divided by the total count (not including missing counts), so that the\n  values in the 3rd column sum to 1.0.\n  The vector and array values calculated by this fix are all treated as\n  intensive.  If this is not the case, e.g. due to histogramming\n  per-atom input values, then you will need to account for that when\n  interpreting the values produced by this fix.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID style Nevery Nrepeat Nfreq lo hi Nbin value1 value2 ... keyword args ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  style = ave/histo or ave/histo/weight = style name of this fix command\n  Nevery = use input values every this many timesteps\n  Nrepeat = # of times to use input values for calculating histogram\n  Nfreq = calculate histogram every this many timesteps\n  lo,hi = lo/hi bounds within which to histogram\n  Nbin = # of histogram bins\n  one or more input values can be listed\n  value = x, y, z, vx, vy, vz, fx, fy, fz, c_ID, c_ID[N], f_ID, f_ID[N], v_name\n  x,y,z,vx,vy,vz,fx,fy,fz = atom attribute (position, velocity, force component)\n  c_ID = scalar or vector calculated by a compute with ID\n  c_ID[I] = Ith component of vector or Ith column of array calculated by a compute with ID, I can include wildcard (see below)\n  f_ID = scalar or vector calculated by a fix with ID\n  f_ID[I] = Ith component of vector or Ith column of array calculated by a fix with ID, I can include wildcard (see below)\n  v_name = value(s) calculated by an equal-style or vector-style or atom-style variable with name\n  v_name[I] = value calculated by a vector-style variable with name\n  \n  \n  \n  zero or more keyword/arg pairs may be appended\n  keyword = mode or file or ave or start or beyond or overwrite or title1 or title2 or title3\n  mode arg = scalar or vector\n    scalar = all input values are scalars\n    vector = all input values are vectors\n  kind arg = global or peratom or local\n  file arg = filename\n    filename = name of file to output histogram(s) to\n  ave args = one or running or window\n    one = output a new average value every Nfreq steps\n    running = output cumulative average of all previous Nfreq steps\n    window M = output average of M most recent Nfreq steps\n  start args = Nstart\n    Nstart = start averaging on this timestep\n  beyond arg = ignore or end or extra\n    ignore = ignore values outside histogram lo/hi bounds\n    end = count values outside histogram lo/hi bounds in end bins\n    extra = create 2 extra bins for value outside histogram lo/hi bounds\n  overwrite arg = none = overwrite output file with only latest output\n  title1 arg = string\n    string = text to print as 1st line of output file\n  title2 arg = string\n    string = text to print as 2nd line of output file\n  title3 arg = string\n    string = text to print as 3rd line of output file, only for vector mode\n  \n  \n  ",
    "examples": "fix 1 all ave/histo 100 5 1000 0.5 1.5 50 c_myTemp file temp.histo ave running\n  fix 1 all ave/histo 100 5 1000 -5 5 100 c_thermo_press[2] c_thermo_press[3] title1 \"My output values\"\n  fix 1 all ave/histo 100 5 1000 -5 5 100 c_thermo_press[*]\n  fix 1 all ave/histo 1 100 1000 -2.0 2.0 18 vx vy vz mode vector ave running beyond extra\n  fix 1 all ave/histo/weight 1 1 1 10 100 2000 c_XRD[1] c_XRD[2]\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix ave/time",
    "description": "Use one or more global values as inputs every few timesteps, and\n  average them over longer timescales.  The resulting averages can be\n  used by other output commands such as\n  thermo_style custom, and can also be written to a\n  file.  Note that if no time averaging is done, this command can be\n  used as a convenient way to simply output one or more global values to\n  a file.\n  The group specified with this command is ignored.  However, note that\n  specified values may represent calculations performed by computes and\n  fixes which store their own “group” definitions.\n  Each listed value can be the result of a compute or\n  fix or the evaluation of an equal-style or vector-style\n  variable.  In each case, the compute, fix, or variable\n  must produce a global quantity, not a per-atom or local quantity.  If\n  you wish to spatial- or time-average or histogram per-atom quantities\n  from a compute, fix, or variable, then see the fix ave/chunk, fix ave/atom,\n  or fix ave/histo commands.  If you wish to sum a\n  per-atom quantity into a single global quantity, see the compute reduce command.\n  Computes that produce global quantities are those which\n  do not have the word atom in their style name.  Only a few\n  fixes produce global quantities.  See the doc pages for\n  individual fixes for info on which ones produce such values.\n  Variables of style equal and vector are the only\n  ones that can be used with this fix.  Variables of style atom cannot\n  be used, since they produce per-atom values.\n  The input values must either be all scalars or all vectors depending\n  on the setting of the mode keyword.  In both cases, the averaging is\n  performed independently on each input value.  I.e. each input scalar\n  is averaged independently or each element of each input vector is\n  averaged independently.\n  If mode = scalar, then the input values must be scalars, or vectors\n  with a bracketed term appended, indicating the Ith value of the vector\n  is used.\n  If mode = vector, then the input values must be vectors, or arrays\n  with a bracketed term appended, indicating the Ith column of the array\n  is used.  All vectors must be the same length, which is the length of\n  the vector or number of rows in the array.\n  Note that for values from a compute or fix, the bracketed index I can\n  be specified using a wildcard asterisk with the index to effectively\n  specify multiple values.  This takes the form “*” or “*n” or “n*” or\n  “m*n”.  If N = the size of the vector (for mode = scalar) or the\n  number of columns in the array (for mode = vector), then an asterisk\n  with no numeric values means all indices from 1 to N.  A leading\n  asterisk means all indices from 1 to n (inclusive).  A trailing\n  asterisk means all indices from n to N (inclusive).  A middle asterisk\n  means all indices from m to n (inclusive).\n  Using a wildcard is the same as if the individual elements of the\n  vector or columns of the array had been listed one by one.  E.g. these\n  2 fix ave/time commands are equivalent, since the compute rdf command creates, in this case, a global array\n  with 3 columns, each of length 50:\n  compute myRDF all rdf 50 1 2\n  fix 1 all ave/time 100 1 100 c_myRDF[*] file tmp1.rdf mode vector\n  fix 2 all ave/time 100 1 100 c_myRDF[1] c_myRDF[2] c_myRDF[3] file tmp2.rdf mode vector\n  \n  \n  \n  The Nevery, Nrepeat, and Nfreq arguments specify on what\n  timesteps the input values will be used in order to contribute to the\n  average.  The final averaged quantities are generated on timesteps\n  that are a multiple of Nfreq.  The average is over Nrepeat\n  quantities, computed in the preceding portion of the simulation every\n  Nevery timesteps.  Nfreq must be a multiple of Nevery and\n  Nevery must be non-zero even if Nrepeat is 1.  Also, the timesteps\n  contributing to the average value cannot overlap,\n  i.e. Nrepeat*Nevery can not exceed Nfreq.\n  For example, if Nevery=2, Nrepeat=6, and Nfreq=100, then values on\n  timesteps 90,92,94,96,98,100 will be used to compute the final average\n  on timestep 100.  Similarly for timesteps 190,192,194,196,198,200 on\n  timestep 200, etc.  If Nrepeat=1 and Nfreq = 100, then no time\n  averaging is done; values are simply generated on timesteps\n  100,200,etc.\n  \n  If a value begins with “c_”, a compute ID must follow which has been\n  previously defined in the input script.  If mode = scalar, then if\n  no bracketed term is appended, the global scalar calculated by the\n  compute is used.  If a bracketed term is appended, the Ith element of\n  the global vector calculated by the compute is used.  If mode =\n  vector, then if no bracketed term is appended, the global vector\n  calculated by the compute is used.  If a bracketed term is appended,\n  the Ith column of the global array calculated by the compute is used.\n  See the discussion above for how I can be specified with a wildcard\n  asterisk to effectively specify multiple values.\n  Note that there is a compute reduce command\n  which can sum per-atom quantities into a global scalar or vector which\n  can thus be accessed by fix ave/time.  Or it can be a compute defined\n  not in your input script, but by thermodynamic output or other fixes such as fix nvt or fix temp/rescale.  See\n  the doc pages for these commands which give the IDs of these computes.\n  Users can also write code for their own compute styles and add them to LAMMPS.\n  If a value begins with “f_”, a fix ID must follow which has been\n  previously defined in the input script.  If mode = scalar, then if\n  no bracketed term is appended, the global scalar calculated by the fix\n  is used.  If a bracketed term is appended, the Ith element of the\n  global vector calculated by the fix is used.  If mode = vector, then\n  if no bracketed term is appended, the global vector calculated by the\n  fix is used.  If a bracketed term is appended, the Ith column of the\n  global array calculated by the fix is used.  See the discussion above\n  for how I can be specified with a wildcard asterisk to effectively\n  specify multiple values.\n  Note that some fixes only produce their values on certain timesteps,\n  which must be compatible with Nevery, else an error will result.\n  Users can also write code for their own fix styles and add them to LAMMPS.\n  If a value begins with “v_”, a variable name must follow which has\n  been previously defined in the input script.  If mode = scalar, then\n  only equal-style or vector-style variables can be used, which both\n  produce global values.  In this mode, a vector-style variable requires\n  a bracketed term to specify the Ith element of the vector calculated\n  by the variable.  If mode = vector, then only a vector-style\n  variable can be used, without a bracketed term.  See the\n  variable command for details.\n  Note that variables of style equal and vector define a formula\n  which can reference individual atom properties or thermodynamic\n  keywords, or they can invoke other computes, fixes, or variables when\n  they are evaluated, so this is a very general means of specifying\n  quantities to time average.\n  \n  Additional optional keywords also affect the operation of this fix.\n  If the mode keyword is set to scalar, then all input values must\n  be global scalars, or elements of global vectors.  If the mode\n  keyword is set to vector, then all input values must be global\n  vectors, or columns of global arrays.  They can also be global arrays,\n  which are converted into a series of global vectors (one per column),\n  as explained above.\n  The ave keyword determines how the values produced every Nfreq\n  steps are averaged with values produced on previous steps that were\n  multiples of Nfreq, before they are accessed by another output\n  command or written to a file.\n  If the ave setting is one, then the values produced on timesteps\n  that are multiples of Nfreq are independent of each other; they are\n  output as-is without further averaging.\n  If the ave setting is running, then the values produced on\n  timesteps that are multiples of Nfreq are summed and averaged in a\n  cumulative sense before being output.  Each output value is thus the\n  average of the value produced on that timestep with all preceding\n  values.  This running average begins when the fix is defined; it can\n  only be restarted by deleting the fix via the unfix\n  command, or by re-defining the fix by re-specifying it.\n  If the ave setting is window, then the values produced on\n  timesteps that are multiples of Nfreq are summed and averaged within\n  a moving “window” of time, so that the last M values are used to\n  produce the output.  E.g. if M = 3 and Nfreq = 1000, then the output\n  on step 10000 will be the average of the individual values on steps\n  8000,9000,10000.  Outputs on early steps will average over less than M\n  values if they are not available.\n  The start keyword specifies what timestep averaging will begin on.\n  The default is step 0.  Often input values can be 0.0 at time 0, so\n  setting start to a larger value can avoid including a 0.0 in a\n  running or windowed average.\n  The off keyword can be used to flag any of the input values.  If a\n  value is flagged, it will not be time averaged.  Instead the most\n  recent input value will always be stored and output.  This is useful\n  if one of more of the inputs produced by a compute or fix or variable\n  are effectively constant or are simply current values.  E.g. they are\n  being written to a file with other time-averaged values for purposes\n  of creating well-formatted output.\n  The file keyword allows a filename to be specified.  Every Nfreq\n  steps, one quantity or vector of quantities is written to the file for\n  each input value specified in the fix ave/time command.  For mode =\n  scalar, this means a single line is written each time output is\n  performed.  Thus the file ends up to be a series of lines, i.e. one\n  column of numbers for each input value.  For mode = vector, an array\n  of numbers is written each time output is performed.  The number of\n  rows is the length of the input vectors, and the number of columns is\n  the number of values.  Thus the file ends up to be a series of these\n  array sections.\n  The overwrite keyword will continuously overwrite the output file\n  with the latest output, so that it only contains one timestep worth of\n  output.  This option can only be used with the ave running setting.\n  The format keyword sets the numeric format of each value when it is\n  printed to a file via the file keyword.  Note that all values are\n  floating point quantities.  The default format is %g.  You can specify\n  a higher precision if desired, e.g. %20.16g.\n  The title1 and title2 and title3 keywords allow specification of\n  the strings that will be printed as the first 2 or 3 lines of the\n  output file, assuming the file keyword was used.  LAMMPS uses\n  default values for each of these, so they do not need to be specified.\n  By default, these header lines are as follows for mode = scalar:\n  # Time-averaged data for fix ID\n  # TimeStep value1 value2 ...\n  \n  \n  In the first line, ID is replaced with the fix-ID.  In the second line\n  the values are replaced with the appropriate fields from the fix\n  ave/time command.  There is no third line in the header of the file,\n  so the title3 setting is ignored when mode = scalar.\n  By default, these header lines are as follows for mode = vector:\n  # Time-averaged data for fix ID\n  # TimeStep Number-of-rows\n  # Row value1 value2 ...\n  \n  \n  In the first line, ID is replaced with the fix-ID.  The second line\n  describes the two values that are printed at the first of each section\n  of output.  In the third line the values are replaced with the\n  appropriate fields from the fix ave/time command.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.\n  This fix produces a global scalar or global vector or global array\n  which can be accessed by various output commands.\n  The values can only be accessed on timesteps that are multiples of\n  Nfreq since that is when averaging is performed.\n  A scalar is produced if only a single input value is averaged and\n  mode = scalar.  A vector is produced if multiple input values are\n  averaged for mode = scalar, or a single input value for mode =\n  vector.  In the first case, the length of the vector is the number of\n  inputs.  In the second case, the length of the vector is the same as\n  the length of the input vector.  An array is produced if multiple\n  input values are averaged and mode = vector.  The global array has #\n  of rows = length of the input vectors and # of columns = number of\n  inputs.\n  If the fix produces a scalar or vector, then the scalar and each\n  element of the vector can be either “intensive” or “extensive”,\n  depending on whether the values contributing to the scalar or vector\n  element are “intensive” or “extensive”.  If the fix produces an array,\n  then all elements in the array must be the same, either “intensive” or\n  “extensive”.  If a compute or fix provides the value being time\n  averaged, then the compute or fix determines whether the value is\n  intensive or extensive; see the doc page for that compute or fix for\n  further info.  Values produced by a variable are treated as intensive.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID ave/time Nevery Nrepeat Nfreq value1 value2 ... keyword args ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  ave/time = style name of this fix command\n  Nevery = use input values every this many timesteps\n  Nrepeat = # of times to use input values for calculating averages\n  Nfreq = calculate averages every this many timesteps\n  one or more input values can be listed\n  value = c_ID, c_ID[N], f_ID, f_ID[N], v_name\n  c_ID = global scalar or vector calculated by a compute with ID\n  c_ID[I] = Ith component of global vector or Ith column of global array calculated by a compute with ID, I can include wildcard (see below)\n  f_ID = global scalar or vector calculated by a fix with ID\n  f_ID[I] = Ith component of global vector or Ith column of global array calculated by a fix with ID, I can include wildcard (see below)\n  v_name = value(s) calculated by an equal-style or vector-style variable with name\n  v_name[I] = value calculated by a vector-style variable with name\n  \n  \n  \n  zero or more keyword/arg pairs may be appended\n  keyword = mode or file or ave or start or off or overwrite or title1 or title2 or title3\n  mode arg = scalar or vector\n    scalar = all input values are global scalars\n    vector = all input values are global vectors or global arrays\n  ave args = one or running or window M\n    one = output a new average value every Nfreq steps\n    running = output cumulative average of all previous Nfreq steps\n    window M = output average of M most recent Nfreq steps\n  start args = Nstart\n    Nstart = start averaging on this timestep\n  off arg = M = do not average this value\n    M = value # from 1 to Nvalues\n  file arg = filename\n    filename = name of file to output time averages to\n  overwrite arg = none = overwrite output file with only latest output\n  format arg = string\n    string = C-style format string\n  title1 arg = string\n    string = text to print as 1st line of output file\n  title2 arg = string\n    string = text to print as 2nd line of output file\n  title3 arg = string\n    string = text to print as 3rd line of output file, only for vector mode\n  \n  \n  ",
    "examples": "fix 1 all ave/time 100 5 1000 c_myTemp c_thermo_temp file temp.profile\n  fix 1 all ave/time 100 5 1000 c_thermo_press[2] ave window 20 &\n                                title1 \"My output values\"\n  fix 1 all ave/time 100 5 1000 c_thermo_press[*]\n  fix 1 all ave/time 1 100 1000 f_indent f_indent[1] file temp.indent off 1\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix aveforce",
    "description": "Apply an additional external force to a group of atoms in such a way\n  that every atom experiences the same force.  This is useful for\n  pushing on wall or boundary atoms so that the structure of the wall\n  does not change over time.\n  The existing force is averaged for the group of atoms, component by\n  component.  The actual force on each atom is then set to the average\n  value plus the component specified in this command.  This means each\n  atom in the group receives the same force.\n  Any of the fx,fy,fz values can be specified as NULL which means the\n  force in that dimension is not changed.  Note that this is not the\n  same as specifying a 0.0 value, since that sets all forces to the same\n  average value without adding in any additional force.\n  Any of the 3 quantities defining the force components can be specified\n  as an equal-style variable, namely fx, fy, fz.\n  If the value is a variable, it should be specified as v_name, where\n  name is the variable name.  In this case, the variable will be\n  evaluated each timestep, and its value used to determine the average\n  force.\n  Equal-style variables can specify formulas with various mathematical\n  functions, and include thermo_style command\n  keywords for the simulation box parameters and timestep and elapsed\n  time.  Thus it is easy to specify a time-dependent average force.\n  If the region keyword is used, the atom must also be in the\n  specified geometric region in order to have force added\n  to it.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The fix_modify respa option is supported by this\n  fix. This allows to set at which level of the r-RESPA\n  integrator the fix is adding its forces. Default is the outermost level.\n  This fix computes a global 3-vector of forces, which can be accessed\n  by various output commands.  This is the total\n  force on the group of atoms before the forces on individual atoms are\n  changed by the fix.  The vector values calculated by this fix are\n  “extensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  The forces due to this fix are imposed during an energy minimization,\n  invoked by the minimize command.  You should not\n  specify force components with a variable that has time-dependence for\n  use with a minimizer, since the minimizer increments the timestep as\n  the iteration count during the minimization.\n  ",
    "syntax": "fix ID group-ID aveforce fx fy fz keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  aveforce = style name of this fix command\n  fx,fy,fz = force component values (force units)\n  any of fx,fy,fz can be a variable (see below)\n  \n  \n  \n  zero or more keyword/value pairs may be appended to args\n  keyword = region\n  region value = region-ID\n    region-ID = ID of region atoms must be in to have added force\n  \n  \n  ",
    "examples": "fix pressdown topwall aveforce 0.0 -1.0 0.0\n  fix 2 bottomwall aveforce NULL -1.0 0.0 region top\n  fix 2 bottomwall aveforce NULL -1.0 v_oscillate region top\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix balance",
    "description": "This command adjusts the size and shape of processor sub-domains\n  within the simulation box, to attempt to balance the number of\n  particles and thus the computational cost (load) evenly across\n  processors.  The load balancing is “dynamic” in the sense that\n  re-balancing is performed periodically during the simulation.  To\n  perform “static” balancing, before or between runs, see the\n  balance command.\n  Load-balancing is typically most useful if the particles in the\n  simulation box have a spatially-varying density distribution or\n  where the computational cost varies significantly between different\n  atoms. E.g. a model of a vapor/liquid interface, or a solid with\n  an irregular-shaped geometry containing void regions, or\n  hybrid pair style simulations which combine\n  pair styles with different computational cost.  In these cases, the\n  LAMMPS default of dividing the simulation box volume into a\n  regular-spaced grid of 3d bricks, with one equal-volume sub-domain\n  per processor, may assign numbers of particles per processor in a\n  way that the computational effort varies significantly.  This can\n  lead to poor performance when the simulation is run in parallel.\n  The balancing can be performed with or without per-particle weighting.\n  With no weighting, the balancing attempts to assign an equal number of\n  particles to each processor.  With weighting, the balancing attempts\n  to assign an equal aggregate computational weight to each processor,\n  which typically induces a different number of atoms assigned to each\n  processor.\n  \n  Note\n  The weighting options listed above are documented with the\n  balance command in this section of the balance command doc page.  That section\n  describes the various weighting options and gives a few examples of\n  how they can be used.  The weighting options are the same for both the\n  fix balance and balance commands.\n  \n  Note that the processors command allows some control\n  over how the box volume is split across processors.  Specifically, for\n  a Px by Py by Pz grid of processors, it allows choice of Px, Py, and\n  Pz, subject to the constraint that Px * Py * Pz = P, the total number\n  of processors.  This is sufficient to achieve good load-balance for\n  some problems on some processor counts.  However, all the processor\n  sub-domains will still have the same shape and same volume.\n  On a particular timestep, a load-balancing operation is only performed\n  if the current “imbalance factor” in particles owned by each processor\n  exceeds the specified thresh parameter.  The imbalance factor is\n  defined as the maximum number of particles (or weight) owned by any\n  processor, divided by the average number of particles (or weight) per\n  processor.  Thus an imbalance factor of 1.0 is perfect balance.\n  As an example, for 10000 particles running on 10 processors, if the\n  most heavily loaded processor has 1200 particles, then the factor is\n  1.2, meaning there is a 20% imbalance.  Note that re-balances can be\n  forced even if the current balance is perfect (1.0) be specifying a\n  thresh < 1.0.\n  \n  Note\n  This command attempts to minimize the imbalance factor, as\n  defined above.  But depending on the method a perfect balance (1.0)\n  may not be achieved.  For example, “grid” methods (defined below) that\n  create a logical 3d grid cannot achieve perfect balance for many\n  irregular distributions of particles.  Likewise, if a portion of the\n  system is a perfect lattice, e.g. the initial system is generated by\n  the create_atoms command, then “grid” methods may\n  be unable to achieve exact balance.  This is because entire lattice\n  planes will be owned or not owned by a single processor.\n  \n  \n  Note\n  The imbalance factor is also an estimate of the maximum speed-up\n  you can hope to achieve by running a perfectly balanced simulation\n  versus an imbalanced one.  In the example above, the 10000 particle\n  simulation could run up to 20% faster if it were perfectly balanced,\n  versus when imbalanced.  However, computational cost is not strictly\n  proportional to particle count, and changing the relative size and\n  shape of processor sub-domains may lead to additional computational\n  and communication overheads, e.g. in the PPPM solver used via the\n  kspace_style command.  Thus you should benchmark\n  the run times of a simulation before and after balancing.\n  \n  \n  The method used to perform a load balance is specified by one of the\n  listed styles, which are described in detail below.  There are 2 kinds\n  of styles.\n  The shift style is a “grid” method which produces a logical 3d grid\n  of processors.  It operates by changing the cutting planes (or lines)\n  between processors in 3d (or 2d), to adjust the volume (area in 2d)\n  assigned to each processor, as in the following 2d diagram where\n  processor sub-domains are shown and atoms are colored by the processor\n  that owns them.  The leftmost diagram is the default partitioning of\n  the simulation box across processors (one sub-box for each of 16\n  processors); the middle diagram is after a “grid” method has been\n  applied.\n    \n  The rcb style is a “tiling” method which does not produce a logical\n  3d grid of processors.  Rather it tiles the simulation domain with\n  rectangular sub-boxes of varying size and shape in an irregular\n  fashion so as to have equal numbers of particles (or weight) in each\n  sub-box, as in the rightmost diagram above.\n  The “grid” methods can be used with either of the\n  comm_style command options, brick or tiled.  The\n  “tiling” methods can only be used with comm_style tiled.\n  When a “grid” method is specified, the current domain partitioning can\n  be either a logical 3d grid or a tiled partitioning.  In the former\n  case, the current logical 3d grid is used as a starting point and\n  changes are made to improve the imbalance factor.  In the latter case,\n  the tiled partitioning is discarded and a logical 3d grid is created\n  with uniform spacing in all dimensions.  This is the starting point\n  for the balancing operation.\n  When a “tiling” method is specified, the current domain partitioning\n  (“grid” or “tiled”) is ignored, and a new partitioning is computed\n  from scratch.\n  \n  The group-ID is ignored.  However the impact of balancing on\n  different groups of atoms can be affected by using the group weight\n  style as described below.\n  The Nfreq setting determines how often a re-balance is performed.  If\n  Nfreq > 0, then re-balancing will occur every Nfreq steps.  Each\n  time a re-balance occurs, a reneighboring is triggered, so Nfreq\n  should not be too small.  If Nfreq = 0, then re-balancing will be\n  done every time reneighboring normally occurs, as determined by the\n  the neighbor and neigh_modify\n  command settings.\n  On re-balance steps, re-balancing will only be attempted if the current\n  imbalance factor, as defined above, exceeds the thresh setting.\n  \n  The shift style invokes a “grid” method for balancing, as described\n  above.  It changes the positions of cutting planes between processors\n  in an iterative fashion, seeking to reduce the imbalance factor.\n  The dimstr argument is a string of characters, each of which must be\n  an “x” or “y” or “z”.  Eacn character can appear zero or one time,\n  since there is no advantage to balancing on a dimension more than\n  once.  You should normally only list dimensions where you expect there\n  to be a density variation in the particles.\n  Balancing proceeds by adjusting the cutting planes in each of the\n  dimensions listed in dimstr, one dimension at a time.  For a single\n  dimension, the balancing operation (described below) is iterated on up\n  to Niter times.  After each dimension finishes, the imbalance factor\n  is re-computed, and the balancing operation halts if the stopthresh\n  criterion is met.\n  A re-balance operation in a single dimension is performed using a\n  density-dependent recursive multisectioning algorithm, where the\n  position of each cutting plane (line in 2d) in the dimension is\n  adjusted independently.  This is similar to a recursive bisectioning\n  for a single value, except that the bounds used for each bisectioning\n  take advantage of information from neighboring cuts if possible, as\n  well as counts of particles at the bounds on either side of each cuts,\n  which themselves were cuts in previous iterations.  The latter is used\n  to infer a density of particles near each of the current cuts.  At\n  each iteration, the count of particles on either side of each plane is\n  tallied.  If the counts do not match the target value for the plane,\n  the position of the cut is adjusted based on the local density.  The\n  low and high bounds are adjusted on each iteration, using new count\n  information, so that they become closer together over time.  Thus as\n  the recursion progresses, the count of particles on either side of the\n  plane gets closer to the target value.\n  The density-dependent part of this algorithm is often an advantage\n  when you re-balance a system that is already nearly balanced.  It\n  typically converges more quickly than the geometric bisectioning\n  algorithm used by the balance command.  However, if can\n  be a disadvantage if you attempt to re-balance a system that is far\n  from balanced, and converge more slowly.  In this case you probably\n  want to use the balance command before starting a run,\n  so that you begin the run with a balanced system.\n  Once the re-balancing is complete and final processor sub-domains\n  assigned, particles migrate to their new owning processor as part of\n  the normal reneighboring procedure.\n  \n  Note\n  At each re-balance operation, the bisectioning for each cutting\n  plane (line in 2d) typically starts with low and high bounds separated\n  by the extent of a processor’s sub-domain in one dimension.  The size\n  of this bracketing region shrinks based on the local density, as\n  described above, which should typically be 1/2 or more every\n  iteration.  Thus if Niter is specified as 10, the cutting plane will\n  typically be positioned to better than 1 part in 1000 accuracy\n  (relative to the perfect target position).  For Niter = 20, it will\n  be accurate to better than 1 part in a million.  Thus there is no need\n  to set Niter to a large value.  This is especially true if you are\n  re-balancing often enough that each time you expect only an incremental\n  adjustment in the cutting planes is necessary.  LAMMPS will check if\n  the threshold accuracy is reached (in a dimension) is less iterations\n  than Niter and exit early.\n  \n  \n  The rcb style invokes a “tiled” method for balancing, as described\n  above.  It performs a recursive coordinate bisectioning (RCB) of the\n  simulation domain. The basic idea is as follows.\n  The simulation domain is cut into 2 boxes by an axis-aligned cut in\n  the longest dimension, leaving one new box on either side of the cut.\n  All the processors are also partitioned into 2 groups, half assigned\n  to the box on the lower side of the cut, and half to the box on the\n  upper side.  (If the processor count is odd, one side gets an extra\n  processor.)  The cut is positioned so that the number of atoms in the\n  lower box is exactly the number that the processors assigned to that\n  box should own for load balance to be perfect.  This also makes load\n  balance for the upper box perfect.  The positioning is done\n  iteratively, by a bisectioning method.  Note that counting atoms on\n  either side of the cut requires communication between all processors\n  at each iteration.\n  That is the procedure for the first cut.  Subsequent cuts are made\n  recursively, in exactly the same manner.  The subset of processors\n  assigned to each box make a new cut in the longest dimension of that\n  box, splitting the box, the subset of processors, and the atoms in\n  the box in two.  The recursion continues until every processor is\n  assigned a sub-box of the entire simulation domain, and owns the atoms\n  in that sub-box.\n  \n  The out keyword writes text to the specified filename with the\n  results of each re-balancing operation.  The file contains the bounds\n  of the sub-domain for each processor after the balancing operation\n  completes.  The format of the file is compatible with the\n  Pizza.py mdump tool which has support for manipulating and\n  visualizing mesh files.  An example is shown here for a balancing by 4\n  processors for a 2d problem:\n  ITEM: TIMESTEP\n  0\n  ITEM: NUMBER OF NODES\n  16\n  ITEM: BOX BOUNDS\n  0 10\n  0 10\n  0 10\n  ITEM: NODES\n  1 1 0 0 0\n  2 1 5 0 0\n  3 1 5 5 0\n  4 1 0 5 0\n  5 1 5 0 0\n  6 1 10 0 0\n  7 1 10 5 0\n  8 1 5 5 0\n  9 1 0 5 0\n  10 1 5 5 0\n  11 1 5 10 0\n  12 1 10 5 0\n  13 1 5 5 0\n  14 1 10 5 0\n  15 1 10 10 0\n  16 1 5 10 0\n  ITEM: TIMESTEP\n  0\n  ITEM: NUMBER OF SQUARES\n  4\n  ITEM: SQUARES\n  1 1 1 2 3 4\n  2 1 5 6 7 8\n  3 1 9 10 11 12\n  4 1 13 14 15 16\n  \n  \n  The coordinates of all the vertices are listed in the NODES section, 5\n  per processor.  Note that the 4 sub-domains share vertices, so there\n  will be duplicate nodes in the list.\n  The “SQUARES” section lists the node IDs of the 4 vertices in a\n  rectangle for each processor (1 to 4).\n  For a 3d problem, the syntax is similar with 8 vertices listed for\n  each processor, instead of 4, and “SQUARES” replaced by “CUBES”.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.\n  This fix computes a global scalar which is the imbalance factor\n  after the most recent re-balance and a global vector of length 3 with\n  additional information about the most recent re-balancing.  The 3\n  values in the vector are as follows:\n  \n  1 = max # of particles per processor\n  2 = total # iterations performed in last re-balance\n  3 = imbalance factor right before the last re-balance was performed\n  \n  As explained above, the imbalance factor is the ratio of the maximum\n  number of particles (or total weight) on any processor to the average\n  number of particles (or total weight) per processor.\n  These quantities can be accessed by various output commands.  The scalar and vector values calculated\n  by this fix are “intensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID balance Nfreq thresh style args keyword args ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  balance = style name of this fix command\n  Nfreq = perform dynamic load balancing every this many steps\n  thresh = imbalance threshold that must be exceeded to perform a re-balance\n  style = shift or rcb\n  shift args = dimstr Niter stopthresh\n    dimstr = sequence of letters containing \"x\" or \"y\" or \"z\", each not more than once\n    Niter = # of times to iterate within each dimension of dimstr sequence\n    stopthresh = stop balancing when this imbalance threshold is reached\n  rcb args = none\n  \n  zero or more keyword/arg pairs may be appended\n  keyword = weight or out\n  weight style args = use weighted particle counts for the balancing\n    style = group or neigh or time or var or store\n      group args = Ngroup group1 weight1 group2 weight2 ...\n        Ngroup = number of groups with assigned weights\n        group1, group2, ... = group IDs\n        weight1, weight2, ...   = corresponding weight factors\n      neigh factor = compute weight based on number of neighbors\n        factor = scaling factor (> 0)\n      time factor = compute weight based on time spend computing\n        factor = scaling factor (> 0)\n      var name = take weight from atom-style variable\n        name = name of the atom-style variable\n      store name = store weight in custom atom property defined by fix property/atom command\n        name = atom property name (without d_ prefix)\n  out arg = filename\n    filename = write each processor's sub-domain to a file, at each re-balancing\n  \n  \n  ",
    "examples": "fix 2 all balance 1000 1.05 shift x 10 1.05\n  fix 2 all balance 100 0.9 shift xy 20 1.1 out tmp.balance\n  fix 2 all balance 100 0.9 shift xy 20 1.1 weight group 3 substrate 3.0 solvent 1.0 solute 0.8 out tmp.balance\n  fix 2 all balance 100 1.0 shift x 10 1.1 weight time 0.8\n  fix 2 all balance 100 1.0 shift xy 5 1.1 weight var myweight weight neigh 0.6 weight store allweight\n  fix 2 all balance 1000 1.1 rcb\n  \n  \n  ",
    "restrictions": "For 2d simulations, the z style cannot be used.  Nor can a “z”\n  appear in dimstr for the shift style.\n  Balancing through recursive bisectioning (rcb style) requires\n  comm_style tiled\n  "
},
{
    "command": "fix bocs",
    "description": "These commands incorporate a pressure correction as described by\n  Dunn and Noid in (Dunn1) to the standard MTTK\n  barostat by Martyna et. al. in (Martyna) .\n  The first half of the command mimics a standard fix npt command:\n  fix 1 all bocs temp Tstart Tstop Tcoupl cgiso Pstart Pstop Pdamp\n  \n  \n  The two differences are replacing npt with bocs, and replacing\n  iso/aniso/etc with cgiso.\n  The rest of the command details what form you would like to use for\n  the pressure correction equation. The choices are: analytic, linear_spline,\n  or cubic_spline.\n  With either spline method, the only argument that needs to follow it\n  is the name of a file that contains the desired pressure correction\n  as a function of volume. The file must be formatted so each line has:\n  Volume_i, PressureCorrection_i\n  \n  \n  Note both the COMMA and the SPACE separating the volume’s\n  value and its corresponding pressure correction. The volumes in the file\n  must be uniformly spaced. Both the volumes and the pressure corrections\n  should be provided in the proper units, e.g. if you are using units real,\n  the volumes should all be in cubic angstroms, and the pressure corrections\n  should all be in atmospheres. Furthermore, the table should start/end at a\n  volume considerably smaller/larger than you expect your system to sample\n  during the simulation. If the system ever reaches a volume outside of the\n  range provided, the simulation will stop.\n  With the analytic option, the arguments are as follows:\n  ... analytic V_avg N_particles N_coeff Coeff_1 Coeff_2 ... Coeff_N\n  \n  \n  Note that V_avg and Coeff_i should all be in the proper units, e.g. if you\n  are using units real, V_avg should be in cubic angstroms, and the\n  coefficients should all be in atmospheres * cubic angstroms.\n  ",
    "syntax": "fix  ID group-ID bocs keyword values ...\n  \n  keyword = temp or cgiso or analytic or linear_spline or cubic_spline\n    temp values = Tstart Tstop Tdamp\n    cgiso values = Pstart Pstop Pdamp\n    basis set\n      analytic values = V_avg N_particles N_coeff Coeff_1 Coeff_2 ... Coeff_N\n      linear_spline values = input_filename\n      cubic_spline values = input_filename\n  ",
    "examples": "fix 1 all bocs temp 300.0 300.0 100.0 cgiso 0.986 0.986 1000.0 analytic 66476.015 968 2 245030.10 8962.20\n  \n  fix 1 all bocs temp 300.0 300.0 100.0 cgiso 0.986 0.986 1000.0 cubic_spline input_Fv.dat\n  \n  thermo_modify press 1_press\n  \n  \n  ",
    "restrictions": "As this is computing a (modified) pressure, group-ID should be all.\n  The pressure correction has only been tested for use with an isotropic\n  pressure coupling in 3 dimensions.\n  By default, LAMMPS will still report the normal value for the pressure\n  if the pressure is printed via a thermo command, or if the pressures\n  are written to a file every so often. In order to have LAMMPS report the\n  modified pressure, you must include the thermo_modify command given in\n  the examples. For the last argument in the command, you should put\n  XXXX_press, where XXXX is the ID given to the fix bocs command (in the\n  example, the ID of the fix bocs command is 1 ).\n  This fix is part of the USER-BOCS package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  Related:\n  For more details about the pressure correction and the entire BOCS software\n  package, visit the BOCS package on GitHub and read the release\n  paper by Dunn et. al. (Dunn2) .\n  \n  (Dunn1) Dunn and Noid, J Chem Phys, 143, 243148 (2015).\n  (Martyna) Martyna, Tobias, and Klein, J Chem Phys, 101, 4177 (1994).\n  (Dunn2) Dunn, Lebold, DeLyser, Rudzinski, and Noid, J. Phys. Chem. B, 122, 3363 (2018).\n  "
},
{
    "command": "fix bond/break",
    "description": "Break bonds between pairs of atoms as a simulation runs according to\n  specified criteria.  This can be used to model the dissolution of a\n  polymer network due to stretching of the simulation box or other\n  deformations.  In this context, a bond means an interaction between a\n  pair of atoms computed by the bond_style command.\n  Once the bond is broken it will be permanently deleted, as will all\n  angle, dihedral, and improper interactions that bond is part of.\n  This is different than a pairwise bond-order\n  potential such as Tersoff or AIREBO which infers bonds and many-body\n  interactions based on the current geometry of a small cluster of atoms\n  and effectively creates and destroys bonds and higher-order many-body\n  interactions from timestep to timestep as atoms move.\n  A check for possible bond breakage is performed every Nevery\n  timesteps.  If two bonded atoms I,J are further than a distance Rmax\n  of each other, if the bond is of type bondtype, and if both I and J\n  are in the specified fix group, then I,J is labeled as a “possible”\n  bond to break.\n  If several bonds involving an atom are stretched, it may have multiple\n  possible bonds to break.  Every atom checks its list of possible bonds\n  to break and labels the longest such bond as its “sole” bond to break.\n  After this is done, if atom I is bonded to atom J in its sole bond,\n  and atom J is bonded to atom I in its sole bond, then the I,J bond is\n  “eligible” to be broken.\n  Note that these rules mean an atom will only be part of at most one\n  broken bond on a given timestep.  It also means that if atom I chooses\n  atom J as its sole partner, but atom J chooses atom K is its sole\n  partner (due to Rjk > Rij), then this means atom I will not be part of\n  a broken bond on this timestep, even if it has other possible bond\n  partners.\n  The prob keyword can effect whether an eligible bond is actually\n  broken.  The fraction setting must be a value between 0.0 and 1.0.\n  A uniform random number between 0.0 and 1.0 is generated and the\n  eligible bond is only broken if the random number < fraction.\n  When a bond is broken, data structures within LAMMPS that store bond\n  topology are updated to reflect the breakage.  Likewise, if the bond\n  is part of a 3-body (angle) or 4-body (dihedral, improper)\n  interaction, that interaction is removed as well.  These changes\n  typically affect pairwise interactions between atoms that used to be\n  part of bonds, angles, etc.\n  \n  Note\n  One data structure that is not updated when a bond breaks are\n  the molecule IDs stored by each atom.  Even though one molecule\n  becomes two molecules due to the broken bond, all atoms in both new\n  molecules retain their original molecule IDs.\n  \n  Computationally, each timestep this fix operates, it loops over all\n  the bonds in the system and computes distances between pairs of bonded\n  atoms.  It also communicates between neighboring processors to\n  coordinate which bonds are broken.  Moreover, if any bonds are broken,\n  neighbor lists must be immediately updated on the same timestep.  This\n  is to insure that any pairwise interactions that should be turned “on”\n  due to a bond breaking, because they are no longer excluded by the\n  presence of the bond and the settings of the\n  special_bonds command, will be immediately\n  recognized.  All of these operations increase the cost of a timestep.\n  Thus you should be cautious about invoking this fix too frequently.\n  You can dump out snapshots of the current bond topology via the dump local command.\n  \n  Note\n  Breaking a bond typically alters the energy of a system.  You\n  should be careful not to choose bond breaking criteria that induce a\n  dramatic change in energy.  For example, if you define a very stiff\n  harmonic bond and break it when 2 atoms are separated by a distance\n  far from the equilibrium bond length, then the 2 atoms will be\n  dramatically released when the bond is broken.  More generally, you\n  may need to thermostat your system to compensate for energy changes\n  resulting from broken bonds (and angles, dihedrals, impropers).\n  \n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.\n  This fix computes two statistics which it stores in a global vector of\n  length 2, which can be accessed by various output commands.  The vector values calculated by this fix\n  are “intensive”.\n  These are the 2 quantities:\n  \n  \n  # of bonds broken on the most recent breakage timestep\n  \n  \n  \n  cumulative # of bonds broken\n  \n  \n  \n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID bond/break Nevery bondtype Rmax keyword values ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  bond/break = style name of this fix command\n  Nevery = attempt bond breaking every this many steps\n  bondtype = type of bonds to break\n  Rmax = bond longer than Rmax can break (distance units)\n  zero or more keyword/value pairs may be appended to args\n  keyword = prob\n  prob values = fraction seed\n    fraction = break a bond with this probability if otherwise eligible\n    seed = random number seed (positive integer)\n  \n  \n  ",
    "examples": "fix 5 all bond/break 10 2 1.2\n  fix 5 polymer bond/break 1 1 2.0 prob 0.5 49829\n  \n  \n  ",
    "restrictions": "This fix is part of the MC package.  It is only enabled if LAMMPS was\n  built with that package.  See the Build package\n  doc page for more info.\n  "
},
{
    "command": "fix bond/create",
    "description": "Create bonds between pairs of atoms as a simulation runs according to\n  specified criteria.  This can be used to model cross-linking of\n  polymers, the formation of a percolation network, etc.  In this\n  context, a bond means an interaction between a pair of atoms computed\n  by the bond_style command.  Once the bond is created\n  it will be permanently in place.  Optionally, the creation of a bond\n  can also create angle, dihedral, and improper interactions that bond\n  is part of.  See the discussion of the atype, dtype, and itype\n  keywords below.\n  This is different than a pairwise bond-order\n  potential such as Tersoff or AIREBO which infers bonds and many-body\n  interactions based on the current geometry of a small cluster of atoms\n  and effectively creates and destroys bonds and higher-order many-body\n  interactions from timestep to timestep as atoms move.\n  A check for possible new bonds is performed every Nevery timesteps.\n  If two atoms I,J are within a distance Rmin of each other, if I is\n  of atom type itype, if J is of atom type jtype, if both I and J\n  are in the specified fix group, if a bond does not already exist\n  between I and J, and if both I and J meet their respective maxbond\n  requirement (explained below), then I,J is labeled as a “possible”\n  bond pair.\n  If several atoms are close to an atom, it may have multiple possible\n  bond partners.  Every atom checks its list of possible bond partners\n  and labels the closest such partner as its “sole” bond partner.  After\n  this is done, if atom I has atom J as its sole partner, and atom J has\n  atom I as its sole partner, then the I,J bond is “eligible” to be\n  formed.\n  Note that these rules mean an atom will only be part of at most one\n  created bond on a given timestep.  It also means that if atom I\n  chooses atom J as its sole partner, but atom J chooses atom K is its\n  sole partner (due to Rjk < Rij), then this means atom I will not form\n  a bond on this timestep, even if it has other possible bond partners.\n  It is permissible to have itype = jtype.  Rmin must be <= the\n  pairwise cutoff distance between itype and jtype atoms, as defined\n  by the pair_style command.\n  The iparam and jparam keywords can be used to limit the bonding\n  functionality of the participating atoms.  Each atom keeps track of\n  how many bonds of bondtype it already has.  If atom I of\n  itype already has maxbond bonds (as set by the iparam\n  keyword), then it will not form any more.  Likewise for atom J.  If\n  maxbond is set to 0, then there is no limit on the number of bonds\n  that can be formed with that atom.\n  The newtype value for iparam and jparam can be used to change\n  the atom type of atom I or J when it reaches maxbond number of bonds\n  of type bondtype.  This means it can now interact in a pairwise\n  fashion with other atoms in a different way by specifying different\n  pair_coeff coefficients.  If you do not wish the\n  atom type to change, simply specify newtype as itype or jtype.\n  The prob keyword can also effect whether an eligible bond is\n  actually created.  The fraction setting must be a value between 0.0\n  and 1.0.  A uniform random number between 0.0 and 1.0 is generated and\n  the eligible bond is only created if the random number < fraction.\n  Any bond that is created is assigned a bond type of bondtype\n  When a bond is created, data structures within LAMMPS that store bond\n  topology are updated to reflect the creation.  If the bond is part of\n  new 3-body (angle) or 4-body (dihedral, improper) interactions, you\n  can choose to create new angles, dihedrals, impropers as well, using\n  the atype, dtype, and itype keywords.  All of these changes\n  typically affect pairwise interactions between atoms that are now part\n  of new bonds, angles, etc.\n  \n  Note\n  One data structure that is not updated when a bond breaks are\n  the molecule IDs stored by each atom.  Even though two molecules\n  become one molecule due to the created bond, all atoms in the new\n  molecule retain their original molecule IDs.\n  \n  If the atype keyword is used and if an angle potential is defined\n  via the angle_style command, then any new 3-body\n  interactions inferred by the creation of a bond will create new angles\n  of type angletype, with parameters assigned by the corresponding\n  angle_coeff command.  Likewise, the dtype and\n  itype keywords will create new dihedrals and impropers of type\n  dihedraltype and impropertype.\n  \n  Note\n  To create a new bond, the internal LAMMPS data structures that\n  store this information must have space for it.  When LAMMPS is\n  initialized from a data file, the list of bonds is scanned and the\n  maximum number of bonds per atom is tallied.  If some atom will\n  acquire more bonds than this limit as this fix operates, then the\n  “extra bond per atom” parameter must be set to allow for it.  Ditto\n  for “extra angle per atom”, “extra dihedral per atom”, and “extra\n  improper per atom” if angles, dihedrals, or impropers are being added\n  when bonds are created.  See the read_data or\n  create_box command for more details.  Note that a\n  data file with no atoms can be used if you wish to add non-bonded\n  atoms via the create atoms command, e.g. for a\n  percolation simulation.\n  \n  \n  Note\n  LAMMPS stores and maintains a data structure with a list of the\n  1st, 2nd, and 3rd neighbors of each atom (within the bond topology of\n  the system) for use in weighting pairwise interactions for bonded\n  atoms.  Note that adding a single bond always adds a new 1st neighbor\n  but may also induce *many* new 2nd and 3rd neighbors, depending on the\n  molecular topology of your system.  The “extra special per atom”\n  parameter must typically be set to allow for the new maximum total\n  size (1st + 2nd + 3rd neighbors) of this per-atom list.  There are 2\n  ways to do this.  See the read_data or\n  create_box commands for details.\n  \n  \n  Note\n  Even if you do not use the atype, dtype, or itype\n  keywords, the list of topological neighbors is updated for atoms\n  affected by the new bond.  This in turn affects which neighbors are\n  considered for pairwise interactions, using the weighting rules set by\n  the special_bonds command.  Consider a new bond\n  created between atoms I,J.  If J has a bonded neighbor K, then K\n  becomes a 2nd neighbor of I.  Even if the atype keyword is not used\n  to create angle I-J-K, the pairwise interaction between I and K will\n  be potentially turned off or weighted by the 1-3 weighting specified\n  by the special_bonds command.  This is the case\n  even if the “angle yes” option was used with that command.  The same\n  is true for 3rd neighbors (1-4 interactions), the dtype keyword, and\n  the “dihedral yes” option used with the\n  special_bonds command.\n  \n  Note that even if your simulation starts with no bonds, you must\n  define a bond_style and use the\n  bond_coeff command to specify coefficients for the\n  bondtype.  Similarly, if new atom types are specified by the\n  iparam or jparam keywords, they must be within the range of atom\n  types allowed by the simulation and pairwise coefficients must be\n  specified for the new types.\n  Computationally, each timestep this fix operates, it loops over\n  neighbor lists and computes distances between pairs of atoms in the\n  list.  It also communicates between neighboring processors to\n  coordinate which bonds are created.  Moreover, if any bonds are\n  created, neighbor lists must be immediately updated on the same\n  timestep.  This is to insure that any pairwise interactions that\n  should be turned “off” due to a bond creation, because they are now\n  excluded by the presence of the bond and the settings of the\n  special_bonds command, will be immediately\n  recognized.  All of these operations increase the cost of a timestep.\n  Thus you should be cautious about invoking this fix too frequently.\n  You can dump out snapshots of the current bond topology via the dump local command.\n  \n  Note\n  Creating a bond typically alters the energy of a system.  You\n  should be careful not to choose bond creation criteria that induce a\n  dramatic change in energy.  For example, if you define a very stiff\n  harmonic bond and create it when 2 atoms are separated by a distance\n  far from the equilibrium bond length, then the 2 atoms will oscillate\n  dramatically when the bond is formed.  More generally, you may need to\n  thermostat your system to compensate for energy changes resulting from\n  created bonds (and angles, dihedrals, impropers).\n  \n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.\n  This fix computes two statistics which it stores in a global vector of\n  length 2, which can be accessed by various output commands.  The vector values calculated by this fix\n  are “intensive”.\n  These are the 2 quantities:\n  \n  \n  # of bonds created on the most recent creation timestep\n  \n  \n  \n  cumulative # of bonds created\n  \n  \n  \n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID bond/create Nevery itype jtype Rmin bondtype keyword values ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  bond/create = style name of this fix command\n  Nevery = attempt bond creation every this many steps\n  itype,jtype = atoms of itype can bond to atoms of jtype\n  Rmin = 2 atoms separated by less than Rmin can bond (distance units)\n  bondtype = type of created bonds\n  zero or more keyword/value pairs may be appended to args\n  keyword = iparam or jparam or prob or atype or dtype or itype\n  iparam values = maxbond, newtype\n    maxbond = max # of bonds of bondtype the itype atom can have\n    newtype = change the itype atom to this type when maxbonds exist\n  jparam values = maxbond, newtype\n    maxbond = max # of bonds of bondtype the jtype atom can have\n    newtype = change the jtype atom to this type when maxbonds exist\n  prob values = fraction seed\n    fraction = create a bond with this probability if otherwise eligible\n    seed = random number seed (positive integer)\n  atype value = angletype\n    angletype = type of created angles\n  dtype value = dihedraltype\n    dihedraltype = type of created dihedrals\n  itype value = impropertype\n    impropertype = type of created impropers\n  \n  \n  ",
    "examples": "fix 5 all bond/create 10 1 2 0.8 1\n  fix 5 all bond/create 1 3 3 0.8 1 prob 0.5 85784 iparam 2 3\n  fix 5 all bond/create 1 3 3 0.8 1 prob 0.5 85784 iparam 2 3 atype 1 dtype 2\n  \n  \n  ",
    "restrictions": "This fix is part of the MC package.  It is only enabled if LAMMPS was\n  built with that package.  See the Build package\n  doc page for more info.\n  "
},
{
    "command": "fix bond/react",
    "description": "Initiate complex covalent bonding (topology) changes. These topology\n  changes will be referred to as ‘reactions’ throughout this\n  documentation. Topology changes are defined in pre- and post-reaction\n  molecule templates and can include creation and deletion of bonds,\n  angles, dihedrals, impropers, bond types, angle types, dihedral types,\n  atom types, or atomic charges. In addition, reaction by-products or\n  other molecules can be identified and deleted.\n  Fix bond/react does not use quantum mechanical (eg. fix qmmm) or\n  pairwise bond-order potential (eg. Tersoff or AIREBO) methods to\n  determine bonding changes a priori. Rather, it uses a distance-based\n  probabilistic criteria to effect predetermined topology changes in\n  simulations using standard force fields.\n  This fix was created to facilitate the dynamic creation of polymeric,\n  amorphous or highly cross-linked systems. A suggested workflow for\n  using this fix is: 1) identify a reaction to be simulated 2) build a\n  molecule template of the reaction site before the reaction has\n  occurred 3) build a molecule template of the reaction site after the\n  reaction has occurred 4) create a map that relates the\n  template-atom-IDs of each atom between pre- and post-reaction molecule\n  templates 5) fill a simulation box with molecules and run a simulation\n  with fix bond/react.\n  Only one ‘fix bond/react’ command can be used at a time. Multiple\n  reactions can be simultaneously applied by specifying multiple react\n  arguments to a single ‘fix bond/react’ command. This syntax is\n  necessary because the ‘common keywords’ are applied to all reactions.\n  The stabilization keyword enables reaction site stabilization.\n  Reaction site stabilization is performed by including reacting atoms\n  in an internally-created fix nve/limit time\n  integrator for a set number of timesteps given by the\n  stabilize_steps keyword. While reacting atoms are being time\n  integrated by the internal nve/limit, they are prevented from being\n  involved in any new reactions. The xmax value keyword should\n  typically be set to the maximum distance that non-reacting atoms move\n  during the simulation.\n  Fix bond/react creates and maintains two important dynamic groups of\n  atoms when using the stabilization keyword. The first group contains\n  all atoms currently involved in a reaction; this group is\n  automatically thermostatted by an internally-created\n  nve/limit integrator. The second group contains\n  all atoms currently not involved in a reaction. This group should be\n  used by a thermostat in order to time integrate the system. The name\n  of this group of non-reacting atoms is created by appending ‘_REACT’\n  to the group-ID argument of the stabilization keyword, as shown in\n  the second example above.\n  \n  Note\n  When using reaction stabilization, you should generally not have\n  a separate thermostat which acts on the ‘all’ group.\n  \n  The group-ID set using the stabilization keyword can be an existing\n  static group or a previously-unused group-ID. It cannot be specified\n  as ‘all’. If the group-ID is previously unused, the fix bond/react\n  command creates a dynamic group that is initialized to\n  include all atoms. If the group-ID is that of an existing static\n  group, the group is used as the parent group of new,\n  internally-created dynamic group. In both cases, this new dynamic\n  group is named by appending ‘_REACT’ to the group-ID, e.g.\n  nvt_grp_REACT. By specifying an existing group, you may thermostat\n  constant-topology parts of your system separately. The dynamic group\n  contains only atoms not involved in a reaction at a given timestep,\n  and therefore should be used by a subsequent system-wide time\n  integrator such as nvt, npt, or nve, as shown in the second example\n  above (full examples can be found at examples/USER/reaction). The time\n  integration command should be placed after the fix bond/react command\n  due to the internal dynamic grouping performed by fix bond/react.\n  \n  Note\n  If the group-ID is an existing static group, react-group-IDs\n  should also be specified as this static group, or a subset.\n  \n  The following comments pertain to each react argument (in other\n  words, can be customized for each reaction, or reaction step):\n  A check for possible new reaction sites is performed every Nevery\n  timesteps.\n  Three physical conditions must be met for a reaction to occur. First,\n  a bonding atom pair must be identified within the reaction distance\n  cutoffs. Second, the topology surrounding the bonding atom pair must\n  match the topology of the pre-reaction template. Finally, any reaction\n  constraints listed in the map file (see below) must be satisfied. If\n  all of these conditions are met, the reaction site is eligible to be\n  modified to match the post-reaction template.\n  A bonding atom pair will be identified if several conditions are met.\n  First, a pair of atoms I,J within the specified react-group-ID of type\n  itype and jtype must be separated by a distance between Rmin and\n  Rmax. It is possible that multiple bonding atom pairs are\n  identified: if the bonding atoms in the pre-reacted template are  1-2\n  neighbors, i.e. directly bonded, the farthest bonding atom partner is\n  set as its bonding partner; otherwise, the closest potential partner\n  is chosen. Then, if both an atom I and atom J have each other as their\n  bonding partners, these two atoms are identified as the bonding atom\n  pair of the reaction site. Once this unique bonding atom pair is\n  identified for each reaction, there could two or more reactions that\n  involve a given atom on the same timestep. If this is the case, only\n  one such reaction is permitted to occur. This reaction is chosen\n  randomly from all potential reactions. This capability allows e.g. for\n  different reaction pathways to proceed from identical reaction sites\n  with user-specified probabilities.\n  The pre-reacted molecule template is specified by a molecule command.\n  This molecule template file contains a sample reaction site and its\n  surrounding topology. As described below, the bonding atom pairs of\n  the pre-reacted template are specified by atom ID in the map file. The\n  pre-reacted molecule template should contain as few atoms as possible\n  while still completely describing the topology of all atoms affected\n  by the reaction. For example, if the force field contains dihedrals,\n  the pre-reacted template should contain any atom within three bonds of\n  reacting atoms.\n  Some atoms in the pre-reacted template that are not reacting may have\n  missing topology with respect to the simulation. For example, the\n  pre-reacted template may contain an atom that, in the simulation, is\n  currently connected to the rest of a long polymer chain. These are\n  referred to as edge atoms, and are also specified in the map file. All\n  pre-reaction template atoms should be linked to a bonding atom, via at\n  least one path that does not involve edge atoms. When the pre-reaction\n  template contains edge atoms, not all atoms, bonds, charges, etc.\n  specified in the reaction templates will be updated. Specifically,\n  topology that involves only atoms that are ‘too near’ to template\n  edges will not be updated. The definition of ‘too near the edge’\n  depends on which interactions are defined in the simulation. If the\n  simulation has defined dihedrals, atoms within two bonds of edge atoms\n  are considered ‘too near the edge.’ If the simulation defines angles,\n  but not dihedrals, atoms within one bond of edge atoms are considered\n  ‘too near the edge.’ If just bonds are defined, only edge atoms are\n  considered ‘too near the edge.’\n  \n  Note\n  Small molecules, i.e. ones that have all their atoms contained\n  within the reaction templates, never have edge atoms.\n  \n  Note that some care must be taken when a building a molecule template\n  for a given simulation. All atom types in the pre-reacted template\n  must be the same as those of a potential reaction site in the\n  simulation. A detailed discussion of matching molecule template atom\n  types with the simulation is provided on the molecule\n  command page.\n  The post-reacted molecule template contains a sample of the reaction\n  site and its surrounding topology after the reaction has occurred. It\n  must contain the same number of atoms as the pre-reacted template. A\n  one-to-one correspondence between the atom IDs in the pre- and\n  post-reacted templates is specified in the map file as described\n  below. Note that during a reaction, an atom, bond, etc. type may\n  change to one that was previously not present in the simulation. These\n  new types must also be defined during the setup of a given simulation.\n  A discussion of correctly handling this is also provided on the\n  molecule command page.\n  \n  Note\n  When a reaction occurs, it is possible that the resulting\n  topology/atom (e.g. special bonds, dihedrals, etc.) exceeds that of\n  the existing system and reaction templates. As when inserting\n  molecules, enough space for this increased topology/atom must be\n  reserved by using the relevant “extra” keywords to the\n  read_data or create_box commands.\n  \n  The map file is a text document with the following format:\n  A map file has a header and a body. The header of map file the\n  contains one mandatory keyword and five optional keywords. The\n  mandatory keyword is ‘equivalences’:\n  N equivalences = # of atoms N in the reaction molecule templates\n  The optional keywords are ‘edgeIDs’, ‘deleteIDs’, ‘customIDs’ and\n  ‘constraints’:\n  N edgeIDs = # of edge atoms N in the pre-reacted molecule template\n  N deleteIDs = # of atoms N that are specified for deletion\n  N chiralIDs = # of specified chiral centers N\n  N customIDs = # of atoms N that are specified for a custom update\n  N constraints = # of specified reaction constraints N\n  The body of the map file contains two mandatory sections and five\n  optional sections. The first mandatory section begins with the keyword\n  ‘BondingIDs’ and lists the atom IDs of the bonding atom pair in the\n  pre-reacted molecule template. The second mandatory section begins\n  with the keyword ‘Equivalences’ and lists a one-to-one correspondence\n  between atom IDs of the pre- and post-reacted templates. The first\n  column is an atom ID of the pre-reacted molecule template, and the\n  second column is the corresponding atom ID of the post-reacted\n  molecule template. The first optional section begins with the keyword\n  ‘EdgeIDs’ and lists the atom IDs of edge atoms in the pre-reacted\n  molecule template. The second optional section begins with the keyword\n  ‘DeleteIDs’ and lists the atom IDs of pre-reaction template atoms to\n  delete. The third optional section begins with the keyword ‘ChiralIDs’\n  lists the atom IDs of chiral atoms whose handedness should be\n  enforced. The fourth optional section begins with the keyword ‘Custom\n  Edges’ and allows for forcing the update of a specific atom’s atomic\n  charge. The first column is the ID of an atom near the edge of the\n  pre-reacted molecule template, and the value of the second column is\n  either ‘none’ or ‘charges.’ Further details are provided in the\n  discussion of the ‘update_edges’ keyword. The fifth optional section\n  begins with the keyword ‘Constraints’ and lists additional criteria\n  that must be satisfied in order for the reaction to occur. Currently,\n  there are four types of constraints available, as discussed below.\n  A sample map file is given below:\n  \n  # this is a map file\n  \n  7 equivalences\n  2 edgeIDs\n  \n  BondingIDs\n  \n  3\n  5\n  \n  EdgeIDs\n  \n  1\n  7\n  \n  Equivalences\n  \n  1   1\n  2   2\n  3   3\n  4   4\n  5   5\n  6   6\n  7   7\n  \n  \n  \n  The handedness of atoms that are chiral centers can be enforced by\n  listing their IDs in the ChiralIDs section. A chiral atom must be\n  bonded to four atoms with mutually different atom types. This feature\n  uses the coordinates and types of the involved atoms in the\n  pre-reaction template to determine handedness. Three atoms bonded to\n  the chiral center are arbitrarily chosen, to define an oriented plane,\n  and the relative position of the fourth bonded atom determines the\n  chiral center’s handedness.\n  Any number of additional constraints may be specified in the\n  Constraints section of the map file. The constraint of type ‘distance’\n  has syntax as follows:\n  distance ID1 ID2 rmin rmax\n  where ‘distance’ is the required keyword, ID1 and ID2 are\n  pre-reaction atom IDs, and these two atoms must be separated by a\n  distance between rmin and rmax for the reaction to occur.\n  The constraint of type ‘angle’ has the following syntax:\n  angle ID1 ID2 ID3 amin amax\n  where ‘angle’ is the required keyword, ID1, ID2 and ID3 are\n  pre-reaction atom IDs, and these three atoms must form an angle\n  between amin and amax for the reaction to occur (where ID2 is\n  the central atom). Angles must be specified in degrees. This\n  constraint can be used to enforce a certain orientation between\n  reacting molecules.\n  The constraint of type ‘dihedral’ has the following syntax:\n  dihedral ID1 ID2 ID3 ID4 amin amax amin2 amax2\n  where ‘dihedral’ is the required keyword, and ID1, ID2, ID3\n  and ID4 are pre-reaction atom IDs. Dihedral angles are calculated in\n  the interval (-180,180]. Refer to the dihedral style\n  documentation for further details on convention. If amin is less\n  than amax, these four atoms must form a dihedral angle greater than\n  amin and less than amax for the reaction to occur. If amin\n  is greater than amax, these four atoms must form a dihedral angle\n  greater than amin or less than amax for the reaction to occur.\n  Angles must be specified in degrees. Optionally, a second range of\n  permissible angles amin2-amax2 can be specified.\n  The constraint of type ‘arrhenius’ imposes an additional reaction\n  probability according to the temperature-dependent Arrhenius equation:\n  \n  \\[k = AT^{n}e^{\\frac{-E_{a}}{k_{B}T}}\\]\n  The Arrhenius constraint has the following syntax:\n  arrhenius A n E_a seed\n  where ‘arrhenius’ is the required keyword, A is the pre-exponential\n  factor, n is the exponent of the temperature dependence, \\(E_a\\)\n  is the activation energy (units of energy), and seed is a\n  random number seed. The temperature is defined as the instantaneous\n  temperature averaged over all atoms in the reaction site, and is\n  calculated in the same manner as for example\n  compute temp/chunk. Currently, there are no\n  options for additional temperature averaging or velocity-biased\n  temperature calculations. A uniform random number between 0 and 1 is\n  generated using seed; if this number is less than the result of the\n  Arrhenius equation above, the reaction is permitted to occur.\n  Once a reaction site has been successfully identified, data structures\n  within LAMMPS that store bond topology are updated to reflect the\n  post-reacted molecule template. All force fields with fixed bonds,\n  angles, dihedrals or impropers are supported.\n  A few capabilities to note: 1) You may specify as many react\n  arguments as desired. For example, you could break down a complicated\n  reaction mechanism into several reaction steps, each defined by its\n  own react argument. 2) While typically a bond is formed or removed\n  between the bonding atom pairs specified in the pre-reacted molecule\n  template, this is not required. 3) By reversing the order of the pre-\n  and post- reacted molecule templates in another react argument, you\n  can allow for the possibility of one or more reverse reactions.\n  The optional keywords deal with the probability of a given reaction\n  occurring as well as the stable equilibration of each reaction site as\n  it occurs:\n  The prob keyword can affect whether or not an eligible reaction\n  actually occurs. The fraction setting must be a value between 0.0 and\n  1.0. A uniform random number between 0.0 and 1.0 is generated and the\n  eligible reaction only occurs if the random number is less than the\n  fraction. Up to N reactions are permitted to occur, as optionally\n  specified by the max_rxn keyword.\n  The stabilize_steps keyword allows for the specification of how many\n  timesteps a reaction site is stabilized before being returned to the\n  overall system thermostat. In order to produce the most physical\n  behavior, this ‘reaction site equilibration time’ should be tuned to\n  be as small as possible while retaining stability for a given system\n  or reaction step. After a limited number of case studies, this number\n  has been set to a default of 60 timesteps. Ideally, it should be\n  individually tuned for each fix reaction step. Note that in some\n  situations, decreasing rather than increasing this parameter will\n  result in an increase in stability.\n  The update_edges keyword can increase the number of atoms whose\n  atomic charges are updated, when the pre-reaction template contains\n  edge atoms. When the value is set to ‘charges,’ all atoms’ atomic\n  charges are updated to those specified by the post-reaction template,\n  including atoms near the edge of reaction templates. When the value is\n  set to ‘custom,’ an additional section must be included in the map\n  file that specifies whether or not to update charges, on a per-atom\n  basis. The format of this section is detailed above. Listing a\n  pre-reaction atom ID with a value of ‘charges’ will force the update\n  of the atom’s charge, even if it is near a template edge. Atoms not\n  near a template edge are unaffected by this setting.\n  A few other considerations:\n  Many reactions result in one or more atoms that are considered\n  unwanted by-products. Therefore, bond/react provides the option to\n  delete a user-specified set of atoms. These pre-reaction atoms are\n  identified in the map file. A deleted atom must still be included in\n  the post-reaction molecule template, in which it cannot be bonded to\n  an atom that is not deleted. In addition to deleting unwanted reaction\n  by-products, this feature can be used to remove specific topologies,\n  such as small rings, that may be otherwise indistinguishable.\n  Optionally, you can enforce additional behaviors on reacting atoms.\n  For example, it may be beneficial to force reacting atoms to remain at\n  a certain temperature. For this, you can use the internally-created\n  dynamic group named “bond_react_MASTER_group”, which consists of all\n  atoms currently involved in a reaction. For example, adding the\n  following command would add an additional thermostat to the group of\n  all currently-reacting atoms:\n  fix 1 bond_react_MASTER_group temp/rescale 1 300 300 10 1\n  \n  \n  \n  Note\n  This command must be added after the fix bond/react command, and\n  will apply to all reactions.\n  \n  Computationally, each timestep this fix operates, it loops over\n  neighbor lists (for bond-forming reactions) and computes distances\n  between pairs of atoms in the list. It also communicates between\n  neighboring processors to coordinate which bonds are created and/or\n  removed. All of these operations increase the cost of a timestep. Thus\n  you should be cautious about invoking this fix too frequently.\n  You can dump out snapshots of the current bond topology via the dump\n  local command.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  Cumulative reaction counts for each reaction are written to binary restart files. These values are associated with the\n  reaction name (react-ID). Additionally, internally-created per-atom\n  properties are stored to allow for smooth restarts. None of the\n  fix_modify options are relevant to this fix.\n  This fix computes one statistic for each react argument that it\n  stores in a global vector, of length ‘number of react arguments’, that\n  can be accessed by various output commands. The\n  vector values calculated by this fix are “intensive”.\n  These is 1 quantity for each react argument:\n  \n  \n  cumulative # of reactions occurred\n  \n  \n  \n  No parameter of this fix can be used with the start/stop keywords\n  of the run command.  This fix is not invoked during energy minimization.\n  When fix bond/react is ‘unfixed,’ all internally-created groups are\n  deleted. Therefore, fix bond/react can only be unfixed after unfixing\n  all other fixes that use any group created by fix bond/react.\n  ",
    "syntax": "fix ID group-ID bond/react common_keyword values ...\n    react react-ID react-group-ID Nevery Rmin Rmax template-ID(pre-reacted) template-ID(post-reacted) map_file individual_keyword values ...\n    react react-ID react-group-ID Nevery Rmin Rmax template-ID(pre-reacted) template-ID(post-reacted) map_file individual_keyword values ...\n    react react-ID react-group-ID Nevery Rmin Rmax template-ID(pre-reacted) template-ID(post-reacted) map_file individual_keyword values ...\n    ...\n  \n  \n  \n  ID, group-ID are documented in fix command. Group-ID is ignored.\n  bond/react = style name of this fix command\n  the common keyword/values may be appended directly after ‘bond/react’\n  this applies to all reaction specifications (below)\n  common_keyword = stabilization\n  stabilization values = no or yes group-ID xmax\n    no = no reaction site stabilization\n    yes = perform reaction site stabilization\n      group-ID = user-assigned prefix for the dynamic group of atoms not currently involved in a reaction\n      xmax = xmax value that is used by an internally-created nve/limit integrator\n  \n  react = mandatory argument indicating new reaction specification\n  react-ID = user-assigned name for the reaction\n  react-group-ID = only atoms in this group are considered for the reaction\n  Nevery = attempt reaction every this many steps\n  Rmin = bonding pair atoms must be separated by more than Rmin to initiate reaction (distance units)\n  Rmax = bonding pair atoms must be separated by less than Rmax to initiate reaction (distance units)\n  template-ID(pre-reacted) = ID of a molecule template containing pre-reaction topology\n  template-ID(post-reacted) = ID of a molecule template containing post-reaction topology\n  map_file = name of file specifying corresponding atom-IDs in the pre- and post-reacted templates\n  zero or more individual keyword/value pairs may be appended to each react argument\n  individual_keyword = prob or max_rxn or stabilize_steps or update_edges\n  prob values = fraction seed\n    fraction = initiate reaction with this probability if otherwise eligible\n    seed = random number seed (positive integer)\n  max_rxn value = N\n    N = maximum number of reactions allowed to occur\n  stabilize_steps value = timesteps\n    timesteps = number of timesteps to apply the internally-created nve/limit fix to reacting atoms\n  update_edges value = none or charges or custom\n    none = do not update topology near the edges of reaction templates\n    charges = update atomic charges of all atoms in reaction templates\n    custom = force the update of user-specified atomic charges\n  \n  \n  ",
    "examples": "For unabridged example scripts and files, see examples/USER/reaction.\n  molecule mol1 pre_reacted_topology.txt\n  molecule mol2 post_reacted_topology.txt\n  fix 5 all bond/react react myrxn1 all 1 0 3.25 mol1 mol2 map_file.txt\n  \n  molecule mol1 pre_reacted_rxn1.txt\n  molecule mol2 post_reacted_rxn1.txt\n  molecule mol3 pre_reacted_rxn2.txt\n  molecule mol4 post_reacted_rxn2.txt\n  fix 5 all bond/react stabilization yes nvt_grp .03 &\n    react myrxn1 all 1 0 3.25 mol1 mol2 map_file_rxn1.txt prob 0.50 12345 &\n    react myrxn2 all 1 0 2.75 mol3 mol4 map_file_rxn2.txt prob 0.25 12345\n  fix 6 nvt_grp_REACT nvt temp 300 300 100 # set thermostat after bond/react\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-REACTION package.  It is only enabled if\n  LAMMPS was built with that package.  See the\n  Build package doc page for more info.\n  "
},
{
    "command": "fix bond/swap",
    "description": "In a simulation of polymer chains, this command attempts to swap bonds\n  between two different chains, effectively grafting the end of one\n  chain onto another chain and vice versa.  This is done via Monte Carlo\n  rules using the Boltzmann acceptance criterion.  The purpose is to\n  equilibrate the polymer chain conformations more rapidly than dynamics\n  alone would do it, by enabling instantaneous large conformational\n  changes in a dense polymer melt.  The polymer chains should thus more\n  rapidly converge to the proper end-to-end distances and radii of\n  gyration.  It is designed for use with systems of\n  FENE or harmonic bead-spring\n  polymer chains where each polymer is a linear chain of monomers, but\n  LAMMPS does not enforce this requirement, i.e. any\n  bond_style can be used.\n  A schematic of the kinds of bond swaps that can occur is shown here:\n  \n  On the left, the red and blue chains have two monomers A1 and B1 close\n  to each other, which are currently bonded to monomers A2 and B2\n  respectively within their own chains.  The bond swap operation will\n  attempt to delete the A1-A2 and B1-B2 bonds and replace them with\n  A1-B2 and B1-A2 bonds.  If the swap is energetically favorable, the\n  two chains on the right are the result and each polymer chain has\n  undergone a dramatic conformational change.  This reference,\n  (Sides) provides more details on how the algorithm works and\n  its application:\n  The bond swapping operation is invoked every Nevery timesteps.  If\n  any bond is swapped, a re-build of the neighbor lists is triggered,\n  since a swap alters the list of which neighbors are considered for\n  pairwise interaction.  At each invocation, each processor considers a\n  random specified fraction of its atoms as potential swapping\n  monomers for this timestep.  Choosing a small fraction value can\n  reduce the likelihood of a reverse swap occurring soon after an\n  initial swap.\n  For each monomer A1, its neighbors are examined to find a possible B1\n  monomer.  Both A1 and B1 must be in the fix group, their separation\n  must be less than the specified cutoff, and the molecule IDs of A1\n  and B1 must be the same (see below).  If a suitable partner is found,\n  the energy change due to swapping the 2 bonds is computed.  This\n  includes changes in pairwise, bond, and angle energies due to the\n  altered connectivity of the 2 chains.  Dihedral and improper\n  interactions are not allowed to be defined when this fix is used.\n  If the energy decreases due to the swap operation, the bond swap is\n  accepted.  If the energy increases it is accepted with probability\n  exp(-delta/kT) where delta is the increase in energy, k is the\n  Boltzmann constant, and T is the current temperature of the system.\n  Whether the swap is accepted or rejected, no other swaps are attempted\n  by this processor on this timestep.\n  The criterion for matching molecule IDs is how bond swaps performed by\n  this fix conserve chain length.  To use this features you must setup\n  the molecule IDs for your polymer chains in a certain way, typically\n  in the data file, read by the read_data command.\n  Consider a system of 6-mer chains.  You have 2 choices.  If the\n  molecule IDs for monomers on each chain are set to 1,2,3,4,5,6 then\n  swaps will conserve chain length.  For a particular monomer there will\n  be only one other monomer on another chain which is a potential swap\n  partner.  If the molecule IDs for monomers on each chain are set to\n  1,2,3,3,2,1 then swaps will conserve chain length but swaps will be\n  able to occur at either end of a chain.  Thus for a particular monomer\n  there will be 2 possible swap partners on another chain.  In this\n  scenario, swaps can also occur within a single chain, i.e. the two\n  ends of a chain swap with each other.\n  \n  Note\n  If your simulation uses molecule IDs in the usual way, where all\n  monomers on a single chain are assigned the same ID (different for\n  each chain), then swaps will only occur within the same chain.  If you\n  assign the same molecule ID to all monomers in all chains then\n  inter-chain swaps will occur, but they will not conserve chain length.\n  Neither of these scenarios is probably what you want for this fix.\n  \n  \n  Note\n  When a bond swap occurs the image flags of monomers in the new\n  polymer chains can become inconsistent.  See the dump\n  command for a discussion of image flags.  This is not an issue for\n  running dynamics, but can affect calculation of some diagnostic\n  quantities or the printing of unwrapped coordinates to a dump file.\n  \n  \n  This fix computes a temperature each time it is invoked for use by the\n  Boltzmann criterion.  To do this, the fix creates its own compute of\n  style temp, as if this command had been issued:\n  compute fix-ID_temp all temp\n  \n  \n  See the compute temp command for details.  Note\n  that the ID of the new compute is the fix-ID with underscore + “temp”\n  appended and the group for the new compute is “all”, so that the\n  temperature of the entire system is used.\n  Note that this is NOT the compute used by thermodynamic output (see\n  the thermo_style command) with ID = thermo_temp.\n  This means you can change the attributes of this fix’s temperature\n  (e.g. its degrees-of-freedom) via the\n  compute_modify command or print this temperature\n  during thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\n  It also means that changing attributes of thermo_temp will have no\n  effect on this fix.\n  \n  Restart, fix_modify, thermo output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  Because the state of the random number generator\n  is not saved in restart files, this means you cannot do “exact”\n  restarts with this fix, where the simulation continues on the same as\n  if no restart had taken place.  However, in a statistical sense, a\n  restarted simulation should produce the same behavior.  Also note that\n  each processor generates possible swaps independently of other\n  processors.  Thus if you repeat the same simulation on a different number\n  of processors, the specific swaps performed will be different.\n  The fix_modify temp option is supported by this\n  fix.  You can use it to assign a compute you have\n  defined to this fix which will be used to compute the temperature for\n  the Boltzmann criterion.\n  This fix computes two statistical quantities as a global 2-vector of\n  output, which can be accessed by various output commands.  The first component of the vector is the\n  cumulative number of swaps performed by all processors.  The second\n  component of the vector is the cumulative number of swaps attempted\n  (whether accepted or rejected).  Note that a swap “attempt” only\n  occurs when swap partners meeting the criteria described above are\n  found on a particular timestep.  The vector values calculated by this\n  fix are “intensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID bond/swap Nevery fraction cutoff seed\n  \n  \n  \n  ID, group-ID are documented in fix command\n  bond/swap = style name of this fix command\n  Nevery = attempt bond swapping every this many steps\n  fraction = fraction of group atoms to consider for swapping\n  cutoff = distance at which swapping will be considered (distance units)\n  seed = random # seed (positive integer)\n  \n  ",
    "examples": "fix 1 all bond/swap 50 0.5 1.3 598934\n  \n  \n  ",
    "restrictions": "This fix is part of the MC package.  It is only enabled if LAMMPS was\n  built with that package.  See the Build package\n  doc page for more info.\n  The settings of the “special_bond” command must be 0,1,1 in order to\n  use this fix, which is typical of bead-spring chains with FENE or\n  harmonic bonds.  This means that pairwise interactions between bonded\n  atoms are turned off, but are turned on between atoms two or three\n  hops away along the chain backbone.\n  Currently, energy changes in dihedral and improper interactions due to\n  a bond swap are not considered.  Thus a simulation that uses this fix\n  cannot use a dihedral or improper potential.\n  "
},
{
    "command": "fix box/relax",
    "description": "Apply an external pressure or stress tensor to the simulation box\n  during an energy minimization.  This allows the box\n  size and shape to vary during the iterations of the minimizer so that\n  the final configuration will be both an energy minimum for the\n  potential energy of the atoms, and the system pressure tensor will be\n  close to the specified external tensor.  Conceptually, specifying a\n  positive pressure is like squeezing on the simulation box; a negative\n  pressure typically allows the box to expand.\n  \n  The external pressure tensor is specified using one or more of the\n  iso, aniso, tri, x, y, z, xy, xz, yz, and couple\n  keywords.  These keywords give you the ability to specify all 6\n  components of an external stress tensor, and to couple various of\n  these components together so that the dimensions they represent are\n  varied together during the minimization.\n  Orthogonal simulation boxes have 3 adjustable dimensions (x,y,z).\n  Triclinic (non-orthogonal) simulation boxes have 6 adjustable\n  dimensions (x,y,z,xy,xz,yz).  The create_box, read data, and read_restart commands\n  specify whether the simulation box is orthogonal or non-orthogonal\n  (triclinic) and explain the meaning of the xy,xz,yz tilt factors.\n  The target pressures Ptarget for each of the 6 components of the\n  stress tensor can be specified independently via the x, y, z,\n  xy, xz, yz keywords, which correspond to the 6 simulation box\n  dimensions.  For example, if the y keyword is used, the y-box length\n  will change during the minimization.  If the xy keyword is used, the\n  xy tilt factor will change.  A box dimension will not change if that\n  component is not specified.\n  Note that in order to use the xy, xz, or yz keywords, the\n  simulation box must be triclinic, even if its initial tilt factors are\n  0.0.\n  When the size of the simulation box changes, all atoms are re-scaled\n  to new positions, unless the keyword dilate is specified with a\n  value of partial, in which case only the atoms in the fix group are\n  re-scaled.  This can be useful for leaving the coordinates of atoms in\n  a solid substrate unchanged and controlling the pressure of a\n  surrounding fluid.\n  The scaleyz, scalexz, and scalexy keywords control whether or\n  not the corresponding tilt factors are scaled with the associated box\n  dimensions when relaxing triclinic periodic cells.  The default\n  values yes will turn on scaling, which corresponds to adjusting the\n  linear dimensions of the cell while preserving its shape.  Choosing\n  no ensures that the tilt factors are not scaled with the box\n  dimensions. See below for restrictions and default values in different\n  situations. In older versions of LAMMPS, scaling of tilt factors was\n  not performed. The old behavior can be recovered by setting all three\n  scale keywords to no.\n  The fixedpoint keyword specifies the fixed point for cell relaxation.\n  By default, it is the center of the box.  Whatever point is\n  chosen will not move during the simulation.  For example, if the lower\n  periodic boundaries pass through (0,0,0), and this point is provided\n  to fixedpoint, then the lower periodic boundaries will remain at\n  (0,0,0), while the upper periodic boundaries will move twice as\n  far. In all cases, the particle positions at each iteration are\n  unaffected by the chosen value, except that all particles are\n  displaced by the same amount, different on each iteration.\n  \n  Note\n  Applying an external pressure to tilt dimensions xy, xz, yz\n  can sometimes result in arbitrarily large values of the tilt factors,\n  i.e. a dramatically deformed simulation box.  This typically indicates\n  that there is something badly wrong with how the simulation was\n  constructed.  The two most common sources of this error are applying a\n  shear stress to a liquid system or specifying an external shear stress\n  tensor that exceeds the yield stress of the solid.  In either case the\n  minimization may converge to a bogus conformation or not converge at\n  all.  Also note that if the box shape tilts to an extreme shape,\n  LAMMPS will run less efficiently, due to the large volume of\n  communication needed to acquire ghost atoms around a processor’s\n  irregular-shaped sub-domain.  For extreme values of tilt, LAMMPS may\n  also lose atoms and generate an error.\n  \n  \n  Note\n  Performing a minimization with this fix is not a mathematically\n  well-defined minimization problem.  This is because the objective\n  function being minimized changes if the box size/shape changes.  In\n  practice this means the minimizer can get “stuck” before you have\n  reached the desired tolerance.  The solution to this is to restart the\n  minimizer from the new adjusted box size/shape, since that creates a\n  new objective function valid for the new box size/shape.  Repeat as\n  necessary until the box size/shape has reached its new equilibrium.\n  \n  \n  The couple keyword allows two or three of the diagonal components of\n  the pressure tensor to be “coupled” together.  The value specified\n  with the keyword determines which are coupled.  For example, xz\n  means the Pxx and Pzz components of the stress tensor are coupled.\n  Xyz means all 3 diagonal components are coupled.  Coupling means two\n  things: the instantaneous stress will be computed as an average of the\n  corresponding diagonal components, and the coupled box dimensions will\n  be changed together in lockstep, meaning coupled dimensions will be\n  dilated or contracted by the same percentage every timestep.  The\n  Ptarget values for any coupled dimensions must be identical.\n  Couple xyz can be used for a 2d simulation; the z dimension is\n  simply ignored.\n  \n  The iso, aniso, and tri keywords are simply shortcuts that are\n  equivalent to specifying several other keywords together.\n  The keyword iso means couple all 3 diagonal components together when\n  pressure is computed (hydrostatic pressure), and dilate/contract the\n  dimensions together.  Using “iso Ptarget” is the same as specifying\n  these 4 keywords:\n  x Ptarget\n  y Ptarget\n  z Ptarget\n  couple xyz\n  \n  \n  The keyword aniso means x, y, and z dimensions are controlled\n  independently using the Pxx, Pyy, and Pzz components of the\n  stress tensor as the driving forces, and the specified scalar external\n  pressure.  Using “aniso Ptarget” is the same as specifying these 4\n  keywords:\n  x Ptarget\n  y Ptarget\n  z Ptarget\n  couple none\n  \n  \n  The keyword tri means x, y, z, xy, xz, and yz dimensions\n  are controlled independently using their individual stress components\n  as the driving forces, and the specified scalar pressure as the\n  external normal stress.  Using “tri Ptarget” is the same as specifying\n  these 7 keywords:\n  x Ptarget\n  y Ptarget\n  z Ptarget\n  xy 0.0\n  yz 0.0\n  xz 0.0\n  couple none\n  \n  \n  \n  The vmax keyword can be used to limit the fractional change in the\n  volume of the simulation box that can occur in one iteration of the\n  minimizer.  If the pressure is not settling down during the\n  minimization this can be because the volume is fluctuating too much.\n  The specified fraction must be greater than 0.0 and should be << 1.0.\n  A value of 0.001 means the volume cannot change by more than 1/10 of a\n  percent in one iteration when couple xyz has been specified.  For\n  any other case it means no linear dimension of the simulation box can\n  change by more than 1/10 of a percent.\n  \n  With this fix, the potential energy used by the minimizer is augmented\n  by an additional energy provided by the fix. The overall objective\n  function then is:\n  \n  \\[E = U + P_t \\left(V-V_0 \\right) + E_{strain}\\]\n  where U is the system potential energy, \\(P_t\\) is the desired\n  hydrostatic pressure, \\(V\\) and \\(V_0\\) are the system and reference\n  volumes, respectively.  \\(E_{strain}\\) is the strain energy expression\n  proposed by Parrinello and Rahman (Parrinello1981).\n  Taking derivatives of E w.r.t. the box dimensions, and setting these\n  to zero, we find that at the minimum of the objective function, the\n  global system stress tensor P will satisfy the relation:\n  \n  \\[\\mathbf P = P_t \\mathbf I + {\\mathbf S_t} \\left( \\mathbf h_0^{-1} \\right)^t \\mathbf h_{0d}\\]\n  where I is the identity matrix, \\(\\mathbf{h_0}\\) is the box\n  dimension tensor of the reference cell, and :\\(\\mathbf{h_{0d}}\\)\n  is the diagonal part of \\(\\mathbf{h_0}\\). \\(\\mathbf{S_t}\\)\n  is a symmetric stress tensor that is chosen by LAMMPS\n  so that the upper-triangular components of P equal the stress tensor\n  specified by the user.\n  This equation only applies when the box dimensions are equal to those\n  of the reference dimensions. If this is not the case, then the\n  converged stress tensor will not equal that specified by the user.  We\n  can resolve this problem by periodically resetting the reference\n  dimensions. The keyword nreset controls how often this is done.  If\n  this keyword is not used, or is given a value of zero, then the\n  reference dimensions are set to those of the initial simulation domain\n  and are never changed. A value of nstep means that every nstep\n  minimization steps, the reference dimensions are set to those of the\n  current simulation domain. Note that resetting the reference\n  dimensions changes the objective function and gradients, which\n  sometimes causes the minimization to fail. This can be resolved by\n  changing the value of nreset, or simply continuing the minimization\n  from a restart file.\n  \n  Note\n  As normally computed, pressure includes a kinetic- energy or\n  temperature-dependent component; see the compute pressure command.  However, atom velocities are\n  ignored during a minimization, and the applied pressure(s) specified\n  with this command are assumed to only be the virial component of the\n  pressure (the non-kinetic portion).  Thus if atoms have a non-zero\n  temperature and you print the usual thermodynamic pressure, it may not\n  appear the system is converging to your specified pressure.  The\n  solution for this is to either (a) zero the velocities of all atoms\n  before performing the minimization, or (b) make sure you are\n  monitoring the pressure without its kinetic component.  The latter can\n  be done by outputting the pressure from the pressure compute this\n  command creates (see below) or a pressure compute you define yourself.\n  \n  \n  Note\n  Because pressure is often a very sensitive function of volume,\n  it can be difficult for the minimizer to equilibrate the system the\n  desired pressure with high precision, particularly for solids.  Some\n  techniques that seem to help are (a) use the “min_modify line\n  quadratic” option when minimizing with box relaxations, (b) minimize\n  several times in succession if need be, to drive the pressure closer\n  to the target pressure, (c) relax the atom positions before relaxing\n  the box, and (d) relax the box to the target hydrostatic pressure\n  before relaxing to a target shear stress state. Also note that some\n  systems (e.g. liquids) will not sustain a non-hydrostatic applied\n  pressure, which means the minimizer will not converge.\n  \n  \n  This fix computes a temperature and pressure each timestep.  The\n  temperature is used to compute the kinetic contribution to the\n  pressure, even though this is subsequently ignored by default.  To do\n  this, the fix creates its own computes of style “temp” and “pressure”,\n  as if these commands had been issued:\n  compute fix-ID_temp group-ID temp\n  compute fix-ID_press group-ID pressure fix-ID_temp virial\n  \n  \n  See the compute temp and compute pressure commands for details.  Note that the\n  IDs of the new computes are the fix-ID + underscore + “temp” or fix_ID\n  + underscore + “press”, and the group for the new computes is the same\n  as the fix group.  Also note that the pressure compute does not\n  include a kinetic component.\n  Note that these are NOT the computes used by thermodynamic output (see\n  the thermo_style command) with ID = thermo_temp\n  and thermo_press.  This means you can change the attributes of this\n  fix’s temperature or pressure via the\n  compute_modify command or print this temperature\n  or pressure during thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\n  It also means that changing attributes of thermo_temp or\n  thermo_press will have no effect on this fix.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The fix_modify temp and press options are\n  supported by this fix.  You can use them to assign a\n  compute you have defined to this fix which will be used\n  in its temperature and pressure calculation, as described above.  Note\n  that as described above, if you assign a pressure compute to this fix\n  that includes a kinetic energy component it will affect the\n  minimization, most likely in an undesirable way.\n  \n  Note\n  If both the temp and press keywords are used in a single\n  thermo_modify command (or in two separate commands), then the order in\n  which the keywords are specified is important.  Note that a pressure compute defines its own temperature compute as\n  an argument when it is specified.  The temp keyword will override\n  this (for the pressure compute being used by fix box/relax), but only if the\n  temp keyword comes after the press keyword.  If the temp keyword\n  comes before the press keyword, then the new pressure compute\n  specified by the press keyword will be unaffected by the temp\n  setting.\n  \n  This fix computes a global scalar which can be accessed by various\n  output commands. The scalar is the pressure-volume\n  energy, plus the strain energy, if it exists, as described above.  The\n  energy values reported at the end of a minimization run under\n  “Minimization stats” include this energy, and so differ from what\n  LAMMPS normally reports as potential energy. This fix does not support\n  the fix_modify energy option, because that would\n  result in double-counting of the fix energy in the minimization\n  energy. Instead, the fix energy can be explicitly added to the\n  potential energy using one of these two variants:\n  variable emin equal pe+f_1\n  \n  variable emin equal pe+f_1/atoms\n  \n  \n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  This fix is invoked during energy minimization, but\n  not for the purpose of adding a contribution to the energy or forces\n  being minimized.  Instead it alters the simulation box geometry as\n  described above.\n  ",
    "syntax": "fix ID group-ID box/relax keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  box/relax = style name of this fix command\n  one or more keyword value pairs may be appended\n  keyword = iso or aniso or tri or x or y or z or xy or yz or xz or couple or nreset or vmax or dilate or scaleyz or scalexz or scalexy or fixedpoint\n    iso or aniso or tri value = Ptarget = desired pressure (pressure units)\n    x or y or z or xy or yz or xz value = Ptarget = desired pressure (pressure units)\n    couple = none or xyz or xy or yz or xz\n    nreset value = reset reference cell every this many minimizer iterations\n    vmax value = fraction = max allowed volume change in one iteration\n    dilate value = all or partial\n    scaleyz value = yes or no = scale yz with lz\n    scalexz value = yes or no = scale xz with lz\n    scalexy value = yes or no = scale xy with ly\n    fixedpoint values = x y z\n      x,y,z = perform relaxation dilation/contraction around this point (distance units)\n  \n  \n  ",
    "examples": "fix 1 all box/relax iso 0.0 vmax 0.001\n  fix 2 water box/relax aniso 0.0 dilate partial\n  fix 2 ice box/relax tri 0.0 couple xy nreset 100\n  \n  \n  ",
    "restrictions": "Only dimensions that are available can be adjusted by this fix.\n  Non-periodic dimensions are not available.  z, xz, and yz, are\n  not available for 2D simulations. xy, xz, and yz are only\n  available if the simulation domain is non-orthogonal.  The\n  create_box, read data, and\n  read_restart commands specify whether the\n  simulation box is orthogonal or non-orthogonal (triclinic) and explain\n  the meaning of the xy,xz,yz tilt factors.\n  The scaleyz yes and scalexz yes keyword/value pairs can not be used\n  for 2D simulations. scaleyz yes, scalexz yes, and scalexy yes options\n  can only be used if the 2nd dimension in the keyword is periodic,\n  and if the tilt factor is not coupled to the barostat via keywords\n  tri, yz, xz, and xy.\n  "
},
{
    "command": "fix client/md",
    "description": "This fix style enables LAMMPS to run as a “client” code and\n  communicate each timestep with a separate “server” code to perform an\n  MD simulation together.\n  The Howto client/server doc page gives an\n  overview of client/server coupling of LAMMPS with another code where\n  one code is the “client” and sends request messages to a “server”\n  code.  The server responds to each request with a reply message.  This\n  enables the two codes to work in tandem to perform a simulation.\n  When using this fix, LAMMPS (as the client code) passes the current\n  coordinates of all particles to the server code each timestep, which\n  computes their interaction, and returns the energy, forces, and virial\n  for the interacting particles to LAMMPS, so it can complete the\n  timestep.\n  Note that the server code can be a quantum code, or another classical\n  MD code which encodes a force field (pair_style in LAMMPS lingo) which\n  LAMMPS does not have.  In the quantum case, this fix is a mechanism\n  for running ab initio MD with quantum forces.\n  The group associated with this fix is ignored.\n  The protocol and units for message format and content\n  that LAMMPS exchanges with the server code is defined on the server md doc page.\n  Note that when using LAMMPS as an MD client, your LAMMPS input script\n  should not normally contain force field commands, like a\n  pair_style, bond_style, or\n  kspace_style command.  However it is possible for\n  a server code to only compute a portion of the full force-field, while\n  LAMMPS computes the remaining part.  Your LAMMPS script can also\n  specify boundary conditions or force constraints in the usual way,\n  which will be added to the per-atom forces returned by the server\n  code.\n  See the examples/message directory for example scripts where LAMMPS is both\n  the “client” and/or “server” code for this kind of client/server MD\n  simulation.  The examples/message/README file explains how to launch\n  LAMMPS and another code in tandem to perform a coupled simulation.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The fix_modify energy option is supported by this\n  fix to add the potential energy computed by the server application to\n  the system’s potential energy as part of thermodynamic output.\n  The fix_modify virial option is supported by this\n  fix to add the server application’s contribution to the system’s\n  virial as part of thermodynamic output.  The\n  default is virial yes\n  This fix computes a global scalar which can be accessed by various\n  output commands.  The scalar is the potential\n  energy discussed above.  The scalar value calculated by this fix is\n  “extensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID client/md\n  \n  \n  \n  ID, group-ID are documented in fix command\n  client/md = style name of this fix command\n  \n  ",
    "examples": "fix 1 all client/md\n  \n  \n  ",
    "restrictions": "This fix is part of the MESSAGE package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  A script that uses this command must also use the\n  message command to setup and shut down the messaging\n  protocol with the server code.\n  "
},
{
    "command": "fix cmap",
    "description": "This command enables CMAP cross-terms to be added to simulations which\n  use the CHARMM force field.  These are relevant for any CHARMM model\n  of a peptide or protein sequences that is 3 or more amino-acid\n  residues long; see (Buck) and (Brooks) for details,\n  including the analytic energy expressions for CMAP interactions.  The\n  CMAP cross-terms add additional potential energy contributions to pairs\n  of overlapping phi-psi dihedrals of amino-acids, which are important\n  to properly represent their conformational behavior.\n  The examples/cmap directory has a sample input script and data file\n  for a small peptide, that illustrates use of the fix cmap command.\n  As in the example above, this fix should be used before reading a data\n  file that contains a listing of CMAP interactions.  The filename\n  specified should contain the CMAP parameters for a particular version\n  of the CHARMM force field.  Two such files are including in the\n  lammps/potentials directory: charmm22.cmap and charmm36.cmap.\n  The data file read by the “read_data” must contain the topology of all\n  the CMAP interactions, similar to the topology data for bonds, angles,\n  dihedrals, etc.  Specially it should have a line like this\n  in its header section:\n  N crossterms\n  \n  \n  where N is the number of CMAP cross-terms.  It should also have a section\n  in the body of the data file like this with N lines:\n  CMAP\n  \n         1       1       8      10      12      18      20\n         2       5      18      20      22      25      27\n         [...]\n         N       3     314     315     317      318    330\n  \n  \n  The first column is an index from 1 to N to enumerate the CMAP terms;\n  it is ignored by LAMMPS.  The 2nd column is the “type” of the\n  interaction; it is an index into the CMAP force field file.  The\n  remaining 5 columns are the atom IDs of the atoms in the two 4-atom\n  dihedrals that overlap to create the CMAP 5-body interaction.  Note\n  that the “crossterm” and “CMAP” keywords for the header and body\n  sections match those specified in the read_data command following the\n  data file name; see the read_data doc page for\n  more details.\n  A data file containing CMAP cross-terms can be generated from a PDB\n  file using the charmm2lammps.pl script in the tools/ch2lmp directory\n  of the LAMMPS distribution.  The script must be invoked with the\n  optional “-cmap” flag to do this; see the tools/ch2lmp/README file for\n  more information.\n  The potential energy associated with CMAP interactions can be output\n  as described below.  It can also be included in the total potential\n  energy of the system, as output by the\n  thermo_style command, if the fix_modify energy command is used, as in the example above.  See\n  the note below about how to include the CMAP energy when performing an\n  energy minimization.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  This fix writes the list of CMAP cross-terms to binary restart files.  See the read_restart command\n  for info on how to re-specify a fix in an input script that reads a\n  restart file, so that the operation of the fix continues in an\n  uninterrupted fashion.\n  The fix_modify energy option is supported by this\n  fix to add the potential “energy” of the CMAP interactions system’s\n  potential energy as part of thermodynamic output.\n  The fix_modify virial option is supported by this\n  fix to add the contribution due to the interaction between atoms to\n  the system’s virial as part of thermodynamic output.\n  The default is virial yes\n  This fix computes a global scalar which can be accessed by various\n  output commands.  The scalar is the potential\n  energy discussed above.  The scalar value calculated by this fix is\n  “extensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  The forces due to this fix are imposed during an energy minimization,\n  invoked by the minimize command.\n  \n  Note\n  If you want the potential energy associated with the CMAP terms\n  forces to be included in the total potential energy of the system (the\n  quantity being minimized), you MUST enable the\n  fix_modify energy option for this fix.\n  \n  ",
    "syntax": "fix ID group-ID cmap filename\n  \n  \n  \n  ID, group-ID are documented in fix command\n  cmap = style name of this fix command\n  filename = force-field file with CMAP coefficients\n  \n  ",
    "examples": "fix            myCMAP all cmap ../potentials/cmap36.data\n  read_data      proteinX.data fix myCMAP crossterm CMAP\n  fix_modify     myCMAP energy yes\n  \n  \n  ",
    "restrictions": "To function as expected this fix command must be issued before a\n  read_data command but after a\n  read_restart command.\n  This fix can only be used if LAMMPS was built with the MOLECULE\n  package.  See the Build package doc page for more\n  info.\n  "
},
{
    "command": "fix colvars",
    "description": "This fix interfaces LAMMPS to the collective variables “Colvars”\n  library, which allows to calculate potentials of mean force\n  (PMFs) for any set of colvars, using different sampling methods:\n  currently implemented are the Adaptive Biasing Force (ABF) method,\n  metadynamics, Steered Molecular Dynamics (SMD) and Umbrella Sampling\n  (US) via a flexible harmonic restraint bias.\n  This documentation describes only the fix colvars command itself and\n  LAMMPS specific parts of the code.  The full documentation of the\n  colvars library is available as this supplementary PDF document\n  The Colvars library is developed at https://github.com/colvars/colvars\n  A detailed discussion of its implementation is in (Fiorin).\n  There are some example scripts for using this package with LAMMPS in the\n  examples/USER/colvars directory.\n  \n  The only mandatory argument to the fix is the filename to the colvars\n  input file that contains the input that is independent from the MD\n  program in which the colvars library has been integrated.\n  The group-ID entry is ignored. The collective variable module will\n  always apply to the entire system and there can only be one instance\n  of the colvars fix at a time. The colvars fix will only communicate\n  the minimum information necessary and the colvars library supports\n  multiple, completely independent collective variables, so there is\n  no restriction to functionality by limiting the number of colvars fixes.\n  The input keyword allows to specify a state file that would contain\n  the restart information required in order to continue a calculation from\n  a prerecorded state. Fix colvars records it state in binary restart\n  files, so when using the read_restart command,\n  this is usually not needed.\n  The output keyword allows to specify the output prefix. All output\n  files generated will use this prefix followed by the “.colvars.” and\n  a word like “state” or “traj”.\n  The seed keyword contains the seed for the random number generator\n  that will be used in the colvars module.\n  The unwrap keyword controls whether wrapped or unwrapped coordinates\n  are passed to the colvars library for calculation of the collective\n  variables and the resulting forces. The default is yes, i.e. to use\n  the image flags to reconstruct the absolute atom positions.\n  Setting this to no will use the current local coordinates that are\n  wrapped back into the simulation cell at each re-neighboring instead.\n  The tstat keyword can be either NULL or the label of a thermostatting\n  fix that thermostats all atoms in the fix colvars group. This will be\n  used to provide the colvars module with the current thermostat target\n  temperature.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  This fix writes the current status of the colvars module into\n  binary restart files. This is in addition to the text\n  mode status file that is written by the colvars module itself and the\n  kind of information in both files is identical.\n  The fix_modify energy option is supported by this\n  fix to add the energy change from the biasing force added by the fix\n  to the system’s potential energy as part of thermodynamic output.\n  The fix_modify configfile <config file> option allows to add settings\n  from an additional config file to the colvars module. This option can\n  only be used, after the system has been initialized with a run\n  command.\n  The fix_modify config <quoted string> option allows to add settings\n  from inline strings. Those have to fit on a single line when enclosed\n  in a pair of double quotes (“), or can span multiple lines when bracketed\n  by a pair of triple double quotes (“””, like python embedded documentation).\n  This fix computes a global scalar which can be accessed by various\n  output commands.  The scalar is the cumulative\n  energy change due to this fix.  The scalar value calculated by this\n  fix is “extensive”.\n  ",
    "syntax": "fix ID group-ID colvars configfile keyword values ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  colvars = style name of this fix command\n  configfile = the configuration file for the colvars module\n  keyword = input or output or seed or tstat\n  input arg = colvars.state file name or prefix or NULL (default: NULL)\n  output arg = output filename prefix (default: out)\n  seed arg = seed for random number generator (default: 1966)\n  unwrap arg = yes or no\n    use unwrapped coordinates in collective variables (default: yes)\n  tstat arg = fix id of a thermostat or NULL (default: NULL)\n  \n  \n  ",
    "examples": "fix mtd all colvars peptide.colvars.inp seed 2122 input peptide.colvars.state output peptide\n  fix abf all colvars colvars.inp tstat 1\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-COLVARS package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  There can only be one colvars fix active at a time. Since the interface\n  communicates only the minimum amount of information and colvars module\n  itself can handle an arbitrary number of collective variables, this is\n  not a limitation of functionality.\n  "
},
{
    "command": "fix controller",
    "description": "This fix enables control of a LAMMPS simulation using a control loop\n  feedback mechanism known as a proportional-integral-derivative (PID)\n  controller.  The basic idea is to define a “process variable” which is\n  a quantity that can be monitored during a running simulation.  A\n  desired target value is chosen for the process variable.  A “control\n  variable” is also defined which is an adjustable attribute of the\n  running simulation, which the process variable will respond to.  The\n  PID controller continuously adjusts the control variable based on the\n  difference between the process variable and the target.\n  Here are examples of ways in which this fix can be used.  The\n  examples/pid directory contains a script that implements the simple\n  thermostat.\n  \n  \n  \n  \n  \n  \n  \n  Goal\n  process variable\n  control variable\n  \n  Simple thermostat\n  instantaneous T\n  thermostat target T\n  \n  Find melting temperature\n  average PE per atom\n  thermostat target T\n  \n  Control pressure in non-periodic system\n  force on wall\n  position of wall\n  \n  \n  \n  \n  \n  \n  \n  \n  Note\n  For this fix to work, the control variable must actually induce\n  a change in a running LAMMPS simulation.  Typically this will only\n  occur if there is some other command (e.g. a thermostat fix) which\n  uses the control variable as an input parameter.  This could be done\n  directly or indirectly, e.g. the other command uses a variable as\n  input whose formula uses the control variable.  The other command\n  should alter its behavior dynamically as the variable changes.\n  \n  \n  Note\n  If there is a command you think could be used in this fashion,\n  but does not currently allow a variable as an input parameter, please\n  notify the LAMMPS developers.  It is often not difficult to enable a\n  command to use a variable as an input parameter.\n  \n  The group specified with this command is ignored.  However, note that\n  the process variable may be defined by calculations performed by\n  computes and fixes which store their own “group” definitions.\n  The PID controller is invoked once each Nevery timesteps.\n  The PID controller is implemented as a discretized version of\n  the following dynamic equation:\n  \n  \\[\\frac{dc}{dt}  = \\hat{E} -\\alpha (K_p e + K_i \\int_0^t e \\, dt + K_d \\frac{de}{dt} )\\]\n  where c is the continuous time analog of the control variable,\n  e =pvar-setpoint is the error in the process variable, and\n  \\(\\alpha\\), \\(K_p\\), \\(K_i\\) , and \\(K_d\\) are constants\n  set by the corresponding\n  keywords described above. The discretized version of this equation is:\n  \n  \\[c_n  = \\hat{E} c_{n-1} -\\alpha \\left( K_p \\tau e_n + K_i \\tau^2 \\sum_{i=1}^n e_i + K_d (e_n - e_{n-1}) \\right)\\]\n  where \\(\\tau = \\mathtt{Nevery} \\cdot \\mathtt{timestep}\\) is the time\n  interval between updates,\n  and the subscripted variables indicate the values of c and e at\n  successive updates.\n  From the first equation, it is clear that if the three gain values\n  \\(K_p\\), \\(K_i\\), \\(K_d\\) are dimensionless constants,\n  then \\(\\alpha\\) must have\n  units of [unit cvar]/[unit pvar]/[unit time] e.g. [ eV/K/ps\n  ]. The advantage of this unit scheme is that the value of the\n  constants should be invariant under a change of either the MD timestep\n  size or the value of Nevery. Similarly, if the LAMMPS unit style is changed, it should only be necessary to change\n  the value of \\(\\alpha\\) to reflect this, while leaving \\(K_p\\),\n  \\(K_i\\), and \\(K_d\\) unaltered.\n  When choosing the values of the four constants, it is best to first\n  pick a value and sign for \\(\\alpha\\) that is consistent with the\n  magnitudes and signs of pvar and cvar.  The magnitude of \\(K_p\\)\n  should then be tested over a large positive range keeping \\(K_i = K_d =0\\).\n  A good value for \\(K_p\\) will produce a fast response in pvar,\n  without overshooting the setpoint.  For many applications, proportional\n  feedback is sufficient, and so \\(K_i\\) = K_d =0` can be used. In cases\n  where there is a substantial lag time in the response of pvar to a change\n  in cvar, this can be counteracted by increasing \\(K_d\\). In situations\n  where pvar plateaus without reaching setpoint, this can be\n  counteracted by increasing \\(K_i\\).  In the language of Charles Dickens,\n  \\(K_p\\) represents the error of the present, \\(K_i\\) the error of\n  the past, and \\(K_d\\) the error yet to come.\n  Because this fix updates cvar, but does not initialize its value,\n  the initial value is that assigned by the user in the input script via\n  the internal-style variable command.  This value is\n  used (by the other LAMMPS command that used the variable) until this\n  fix performs its first update of cvar after Nevery timesteps.  On\n  the first update, the value of the derivative term is set to zero,\n  because the value of \\(e_n-1\\) is not yet defined.\n  \n  The process variable pvar can be specified as the output of a\n  compute or fix or the evaluation of a\n  variable.  In each case, the compute, fix, or variable\n  must produce a global quantity, not a per-atom or local quantity.\n  If pvar begins with “c_”, a compute ID must follow which has been\n  previously defined in the input script and which generates a global\n  scalar or vector.  See the individual compute doc page\n  for details.  If no bracketed integer is appended, the scalar\n  calculated by the compute is used.  If a bracketed integer is\n  appended, the Ith value of the vector calculated by the compute is\n  used.  Users can also write code for their own compute styles and add them to LAMMPS.\n  If pvar begins with “f_”, a fix ID must follow which has been\n  previously defined in the input script and which generates a global\n  scalar or vector.  See the individual fix doc page for\n  details.  Note that some fixes only produce their values on certain\n  timesteps, which must be compatible with when fix controller\n  references the values, or else an error results.  If no bracketed integer\n  is appended, the scalar calculated by the fix is used.  If a bracketed\n  integer is appended, the Ith value of the vector calculated by the fix\n  is used.  Users can also write code for their own fix style and add them to LAMMPS.\n  If pvar begins with “v_”, a variable name must follow which has been\n  previously defined in the input script.  Only equal-style variables\n  can be referenced.  See the variable command for\n  details.  Note that variables of style equal define a formula which\n  can reference individual atom properties or thermodynamic keywords, or\n  they can invoke other computes, fixes, or variables when they are\n  evaluated, so this is a very general means of specifying the process\n  variable.\n  The target value setpoint for the process variable must be a numeric\n  value, in whatever units pvar is defined for.\n  The control variable cvar must be the name of an internal-style variable previously defined in the input script.  Note\n  that it is not specified with a “v_” prefix, just the name of the\n  variable.  It must be an internal-style variable, because this fix\n  updates its value directly.  Note that other commands can use an\n  equal-style versus internal-style variable interchangeably.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  Currently, no information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.\n  This fix produces a global vector with 3 values which can be accessed\n  by various output commands.  The values can be\n  accessed on any timestep, though they are only updated on timesteps\n  that are a multiple of Nevery.\n  The three values are the most recent updates made to the control\n  variable by each of the 3 terms in the PID equation above.  The first\n  value is the proportional term, the second is the integral term, the\n  third is the derivative term.\n  The units of the vector values will be whatever units the control\n  variable is in.  The vector values calculated by this fix are\n  “extensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID controller Nevery alpha Kp Ki Kd pvar setpoint cvar\n  \n  \n  \n  ID, group-ID are documented in fix command\n  controller = style name of this fix command\n  Nevery = invoke controller every this many timesteps\n  alpha = coupling constant for PID equation (see units discussion below)\n  Kp = proportional gain in PID equation (unitless)\n  Ki = integral gain in PID equation (unitless)\n  Kd = derivative gain in PID equation (unitless)\n  pvar = process variable of form c_ID, c_ID[I], f_ID, f_ID[I], or v_name\n  c_ID = global scalar calculated by a compute with ID\n  c_ID[I] = Ith component of global vector calculated by a compute with ID\n  f_ID = global scalar calculated by a fix with ID\n  f_ID[I] = Ith component of global vector calculated by a fix with ID\n  v_name = value calculated by an equal-style variable with name\n  \n  \n  \n  setpoint = desired value of process variable (same units as process variable)\n  cvar = name of control variable\n  \n  ",
    "examples": "fix 1 all controller 100 1.0 0.5 0.0 0.0 c_thermo_temp 1.5 tcontrol\n  fix 1 all controller 100 0.2 0.5 0 100.0 v_pxxwall 1.01325 xwall\n  fix 1 all controller 10000 0.2 0.5 0 2000 v_avpe -3.785 tcontrol\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix deform",
    "description": "Change the volume and/or shape of the simulation box during a dynamics\n  run.  Orthogonal simulation boxes have 3 adjustable parameters\n  (x,y,z).  Triclinic (non-orthogonal) simulation boxes have 6\n  adjustable parameters (x,y,z,xy,xz,yz).  Any or all of them can be\n  adjusted independently and simultaneously by this command.\n  This fix can be used to perform non-equilibrium MD (NEMD) simulations\n  of a continuously strained system.  See the fix nvt/sllod and compute temp/deform commands for more details.  Note\n  that simulation of a continuously extended system (extensional flow)\n  can be modeled using the USER-UEF package and its fix commands.\n  For the x, y, z parameters, the associated dimension cannot be\n  shrink-wrapped.  For the xy, yz, xz parameters, the associated\n  2nd dimension cannot be shrink-wrapped.  Dimensions not varied by this\n  command can be periodic or non-periodic.  Dimensions corresponding to\n  unspecified parameters can also be controlled by a fix npt or fix nph command.\n  The size and shape of the simulation box at the beginning of the\n  simulation run were either specified by the\n  create_box or read_data or\n  read_restart command used to setup the simulation\n  initially if it is the first run, or they are the values from the end\n  of the previous run.  The create_box, read data, and read_restart commands\n  specify whether the simulation box is orthogonal or non-orthogonal\n  (triclinic) and explain the meaning of the xy,xz,yz tilt factors.  If\n  fix deform changes the xy,xz,yz tilt factors, then the simulation box\n  must be triclinic, even if its initial tilt factors are 0.0.\n  As described below, the desired simulation box size and shape at the\n  end of the run are determined by the parameters of the fix deform\n  command.  Every Nth timestep during the run, the simulation box is\n  expanded, contracted, or tilted to ramped values between the initial\n  and final values.\n  \n  For the x, y, and z parameters, this is the meaning of their\n  styles and values.\n  The final, delta, scale, vel, and erate styles all change\n  the specified dimension of the box via “constant displacement” which\n  is effectively a “constant engineering strain rate”.  This means the\n  box dimension changes linearly with time from its initial to final\n  value.\n  For style final, the final lo and hi box boundaries of a dimension\n  are specified.  The values can be in lattice or box distance units.\n  See the discussion of the units keyword below.\n  For style delta, plus or minus changes in the lo/hi box boundaries\n  of a dimension are specified.  The values can be in lattice or box\n  distance units.  See the discussion of the units keyword below.\n  For style scale, a multiplicative factor to apply to the box length\n  of a dimension is specified.  For example, if the initial box length\n  is 10, and the factor is 1.1, then the final box length will be 11.  A\n  factor less than 1.0 means compression.\n  For style vel, a velocity at which the box length changes is\n  specified in units of distance/time.  This is effectively a “constant\n  engineering strain rate”, where rate = V/L0 and L0 is the initial box\n  length.  The distance can be in lattice or box distance units.  See\n  the discussion of the units keyword below.  For example, if the\n  initial box length is 100 Angstroms, and V is 10 Angstroms/psec, then\n  after 10 psec, the box length will have doubled.  After 20 psec, it\n  will have tripled.\n  The erate style changes a dimension of the box at a “constant\n  engineering strain rate”.  The units of the specified strain rate are\n  1/time.  See the units command for the time units\n  associated with different choices of simulation units,\n  e.g. picoseconds for “metal” units).  Tensile strain is unitless and\n  is defined as delta/L0, where L0 is the original box length and delta\n  is the change relative to the original length.  The box length L as a\n  function of time will change as\n  L(t) = L0 (1 + erate*dt)\n  where dt is the elapsed time (in time units).  Thus if erate R is\n  specified as 0.1 and time units are picoseconds, this means the box\n  length will increase by 10% of its original length every picosecond.\n  I.e. strain after 1 psec = 0.1, strain after 2 psec = 0.2, etc.  R =\n  -0.01 means the box length will shrink by 1% of its original length\n  every picosecond.  Note that for an “engineering” rate the change is\n  based on the original box length, so running with R = 1 for 10\n  picoseconds expands the box length by a factor of 11 (strain of 10),\n  which is different that what the trate style would induce.\n  The trate style changes a dimension of the box at a “constant true\n  strain rate”.  Note that this is not an “engineering strain rate”, as\n  the other styles are.  Rather, for a “true” rate, the rate of change\n  is constant, which means the box dimension changes non-linearly with\n  time from its initial to final value.  The units of the specified\n  strain rate are 1/time.  See the units command for the\n  time units associated with different choices of simulation units,\n  e.g. picoseconds for “metal” units).  Tensile strain is unitless and\n  is defined as delta/L0, where L0 is the original box length and delta\n  is the change relative to the original length.\n  The box length L as a function of time will change as\n  L(t) = L0 exp(trate*dt)\n  where dt is the elapsed time (in time units).  Thus if trate R is\n  specified as ln(1.1) and time units are picoseconds, this means the\n  box length will increase by 10% of its current (not original) length\n  every picosecond.  I.e. strain after 1 psec = 0.1, strain after 2 psec\n  = 0.21, etc.  R = ln(2) or ln(3) means the box length will double or\n  triple every picosecond.  R = ln(0.99) means the box length will\n  shrink by 1% of its current length every picosecond.  Note that for a\n  “true” rate the change is continuous and based on the current length,\n  so running with R = ln(2) for 10 picoseconds does not expand the box\n  length by a factor of 11 as it would with erate, but by a factor of\n  1024 since the box length will double every picosecond.\n  Note that to change the volume (or cross-sectional area) of the\n  simulation box at a constant rate, you can change multiple dimensions\n  via erate or trate.  E.g. to double the box volume in a picosecond\n  picosecond, you could set “x erate M”, “y erate M”, “z erate M”, with\n  M = pow(2,1/3) - 1 = 0.26, since if each box dimension grows by 26%,\n  the box volume doubles.  Or you could set “x trate M”, “y trate M”, “z\n  trate M”, with M = ln(1.26) = 0.231, and the box volume would double\n  every picosecond.\n  The volume style changes the specified dimension in such a way that\n  the box volume remains constant while other box dimensions are changed\n  explicitly via the styles discussed above.  For example, “x scale 1.1\n  y scale 1.1 z volume” will shrink the z box length as the x,y box\n  lengths increase, to keep the volume constant (product of x,y,z\n  lengths).  If “x scale 1.1 z volume” is specified and parameter y is\n  unspecified, then the z box length will shrink as x increases to keep\n  the product of x,z lengths constant.  If “x scale 1.1 y volume z\n  volume” is specified, then both the y,z box lengths will shrink as x\n  increases to keep the volume constant (product of x,y,z lengths).  In\n  this case, the y,z box lengths shrink so as to keep their relative\n  aspect ratio constant.\n  For solids or liquids, note that when one dimension of the box is\n  expanded via fix deform (i.e. tensile strain), it may be physically\n  undesirable to hold the other 2 box lengths constant (unspecified by\n  fix deform) since that implies a density change.  Using the volume\n  style for those 2 dimensions to keep the box volume constant may make\n  more physical sense, but may also not be correct for materials and\n  potentials whose Poisson ratio is not 0.5.  An alternative is to use\n  fix npt aniso with zero applied pressure on those 2\n  dimensions, so that they respond to the tensile strain dynamically.\n  The wiggle style oscillates the specified box length dimension\n  sinusoidally with the specified amplitude and period.  I.e. the box\n  length L as a function of time is given by\n  L(t) = L0 + A sin(2*pi t/Tp)\n  where L0 is its initial length.  If the amplitude A is a positive\n  number the box initially expands, then contracts, etc.  If A is\n  negative then the box initially contracts, then expands, etc.  The\n  amplitude can be in lattice or box distance units.  See the discussion\n  of the units keyword below.\n  The variable style changes the specified box length dimension by\n  evaluating a variable, which presumably is a function of time.  The\n  variable with name1 must be an equal-style variable\n  and should calculate a change in box length in units of distance.\n  Note that this distance is in box units, not lattice units; see the\n  discussion of the units keyword below.  The formula associated with\n  variable name1 can reference the current timestep.  Note that it\n  should return the “change” in box length, not the absolute box length.\n  This means it should evaluate to 0.0 when invoked on the initial\n  timestep of the run following the definition of fix deform.  It should\n  evaluate to a value > 0.0 to dilate the box at future times, or a\n  value < 0.0 to compress the box.\n  The variable name2 must also be an equal-style variable and should calculate the rate of box length\n  change, in units of distance/time, i.e. the time-derivative of the\n  name1 variable.  This quantity is used internally by LAMMPS to reset\n  atom velocities when they cross periodic boundaries.  It is computed\n  internally for the other styles, but you must provide it when using an\n  arbitrary variable.\n  Here is an example of using the variable style to perform the same\n  box deformation as the wiggle style formula listed above, where we\n  assume that the current timestep = 0.\n  variable A equal 5.0\n  variable Tp equal 10.0\n  variable displace equal \"v_A * sin(2*PI * step*dt/v_Tp)\"\n  variable rate equal \"2*PI*v_A/v_Tp * cos(2*PI * step*dt/v_Tp)\"\n  fix 2 all deform 1 x variable v_displace v_rate remap v\n  \n  \n  For the scale, vel, erate, trate, volume, wiggle, and\n  variable styles, the box length is expanded or compressed around its\n  mid point.\n  \n  For the xy, xz, and yz parameters, this is the meaning of their\n  styles and values.  Note that changing the tilt factors of a triclinic\n  box does not change its volume.\n  The final, delta, vel, and erate styles all change the shear\n  strain at a “constant engineering shear strain rate”.  This means the\n  tilt factor changes linearly with time from its initial to final\n  value.\n  For style final, the final tilt factor is specified.  The value\n  can be in lattice or box distance units.  See the discussion of the\n  units keyword below.\n  For style delta, a plus or minus change in the tilt factor is\n  specified.  The value can be in lattice or box distance units.  See\n  the discussion of the units keyword below.\n  For style vel, a velocity at which the tilt factor changes is\n  specified in units of distance/time.  This is effectively an\n  “engineering shear strain rate”, where rate = V/L0 and L0 is the\n  initial box length perpendicular to the direction of shear.  The\n  distance can be in lattice or box distance units.  See the discussion\n  of the units keyword below.  For example, if the initial tilt factor\n  is 5 Angstroms, and the V is 10 Angstroms/psec, then after 1 psec, the\n  tilt factor will be 15 Angstroms.  After 2 psec, it will be 25\n  Angstroms.\n  The erate style changes a tilt factor at a “constant engineering\n  shear strain rate”.  The units of the specified shear strain rate are\n  1/time.  See the units command for the time units\n  associated with different choices of simulation units,\n  e.g. picoseconds for “metal” units).  Shear strain is unitless and is\n  defined as offset/length, where length is the box length perpendicular\n  to the shear direction (e.g. y box length for xy deformation) and\n  offset is the displacement distance in the shear direction (e.g. x\n  direction for xy deformation) from the unstrained orientation.\n  The tilt factor T as a function of time will change as\n  T(t) = T0 + L0*erate*dt\n  where T0 is the initial tilt factor, L0 is the original length of the\n  box perpendicular to the shear direction (e.g. y box length for xy\n  deformation), and dt is the elapsed time (in time units).  Thus if\n  erate R is specified as 0.1 and time units are picoseconds, this\n  means the shear strain will increase by 0.1 every picosecond.  I.e. if\n  the xy shear strain was initially 0.0, then strain after 1 psec = 0.1,\n  strain after 2 psec = 0.2, etc.  Thus the tilt factor would be 0.0 at\n  time 0, 0.1*ybox at 1 psec, 0.2*ybox at 2 psec, etc, where ybox is the\n  original y box length.  R = 1 or 2 means the tilt factor will increase\n  by 1 or 2 every picosecond.  R = -0.01 means a decrease in shear\n  strain by 0.01 every picosecond.\n  The trate style changes a tilt factor at a “constant true shear\n  strain rate”.  Note that this is not an “engineering shear strain\n  rate”, as the other styles are.  Rather, for a “true” rate, the rate\n  of change is constant, which means the tilt factor changes\n  non-linearly with time from its initial to final value.  The units of\n  the specified shear strain rate are 1/time.  See the\n  units command for the time units associated with\n  different choices of simulation units, e.g. picoseconds for “metal”\n  units).  Shear strain is unitless and is defined as offset/length,\n  where length is the box length perpendicular to the shear direction\n  (e.g. y box length for xy deformation) and offset is the displacement\n  distance in the shear direction (e.g. x direction for xy deformation)\n  from the unstrained orientation.\n  The tilt factor T as a function of time will change as\n  T(t) = T0 exp(trate*dt)\n  where T0 is the initial tilt factor and dt is the elapsed time (in\n  time units).  Thus if trate R is specified as ln(1.1) and time units\n  are picoseconds, this means the shear strain or tilt factor will\n  increase by 10% every picosecond.  I.e. if the xy shear strain was\n  initially 0.1, then strain after 1 psec = 0.11, strain after 2 psec =\n  0.121, etc.  R = ln(2) or ln(3) means the tilt factor will double or\n  triple every picosecond.  R = ln(0.99) means the tilt factor will\n  shrink by 1% every picosecond.  Note that the change is continuous, so\n  running with R = ln(2) for 10 picoseconds does not change the tilt\n  factor by a factor of 10, but by a factor of 1024 since it doubles\n  every picosecond.  Note that the initial tilt factor must be non-zero\n  to use the trate option.\n  Note that shear strain is defined as the tilt factor divided by the\n  perpendicular box length.  The erate and trate styles control the\n  tilt factor, but assume the perpendicular box length remains constant.\n  If this is not the case (e.g. it changes due to another fix deform\n  parameter), then this effect on the shear strain is ignored.\n  The wiggle style oscillates the specified tilt factor sinusoidally\n  with the specified amplitude and period.  I.e. the tilt factor T as a\n  function of time is given by\n  T(t) = T0 + A sin(2*pi t/Tp)\n  where T0 is its initial value.  If the amplitude A is a positive\n  number the tilt factor initially becomes more positive, then more\n  negative, etc.  If A is negative then the tilt factor initially\n  becomes more negative, then more positive, etc.  The amplitude can be\n  in lattice or box distance units.  See the discussion of the units\n  keyword below.\n  The variable style changes the specified tilt factor by evaluating a\n  variable, which presumably is a function of time.  The variable with\n  name1 must be an equal-style variable and should\n  calculate a change in tilt in units of distance.  Note that this\n  distance is in box units, not lattice units; see the discussion of the\n  units keyword below.  The formula associated with variable name1\n  can reference the current timestep.  Note that it should return the\n  “change” in tilt factor, not the absolute tilt factor.  This means it\n  should evaluate to 0.0 when invoked on the initial timestep of the run\n  following the definition of fix deform.\n  The variable name2 must also be an equal-style variable and should calculate the rate of tilt change,\n  in units of distance/time, i.e. the time-derivative of the name1\n  variable.  This quantity is used internally by LAMMPS to reset atom\n  velocities when they cross periodic boundaries.  It is computed\n  internally for the other styles, but you must provide it when using an\n  arbitrary variable.\n  Here is an example of using the variable style to perform the same\n  box deformation as the wiggle style formula listed above, where we\n  assume that the current timestep = 0.\n  variable A equal 5.0\n  variable Tp equal 10.0\n  variable displace equal \"v_A * sin(2*PI * step*dt/v_Tp)\"\n  variable rate equal \"2*PI*v_A/v_Tp * cos(2*PI * step*dt/v_Tp)\"\n  fix 2 all deform 1 xy variable v_displace v_rate remap v\n  \n  \n  \n  All of the tilt styles change the xy, xz, yz tilt factors during a\n  simulation.  In LAMMPS, tilt factors (xy,xz,yz) for triclinic boxes\n  are normally bounded by half the distance of the parallel box length.\n  See the discussion of the flip keyword below, to allow this bound to\n  be exceeded, if desired.\n  For example, if xlo = 2 and xhi = 12, then the x box length is 10 and\n  the xy tilt factor must be between -5 and 5.  Similarly, both xz and\n  yz must be between -(xhi-xlo)/2 and +(yhi-ylo)/2.  Note that this is\n  not a limitation, since if the maximum tilt factor is 5 (as in this\n  example), then configurations with tilt = …, -15, -5, 5, 15, 25,\n  … are all equivalent.\n  To obey this constraint and allow for large shear deformations to be\n  applied via the xy, xz, or yz parameters, the following\n  algorithm is used.  If prd is the associated parallel box length (10\n  in the example above), then if the tilt factor exceeds the accepted\n  range of -5 to 5 during the simulation, then the box is flipped to the\n  other limit (an equivalent box) and the simulation continues.  Thus\n  for this example, if the initial xy tilt factor was 0.0 and “xy final\n  100.0” was specified, then during the simulation the xy tilt factor\n  would increase from 0.0 to 5.0, the box would be flipped so that the\n  tilt factor becomes -5.0, the tilt factor would increase from -5.0 to\n  5.0, the box would be flipped again, etc.  The flip occurs 10 times\n  and the final tilt factor at the end of the simulation would be 0.0.\n  During each flip event, atoms are remapped into the new box in the\n  appropriate manner.\n  The one exception to this rule is if the 1st dimension in the tilt\n  factor (x for xy) is non-periodic.  In that case, the limits on the\n  tilt factor are not enforced, since flipping the box in that dimension\n  does not change the atom positions due to non-periodicity.  In this\n  mode, if you tilt the system to extreme angles, the simulation will\n  simply become inefficient due to the highly skewed simulation box.\n  \n  Each time the box size or shape is changed, the remap keyword\n  determines whether atom positions are remapped to the new box.  If\n  remap is set to x (the default), atoms in the fix group are\n  remapped; otherwise they are not.  Note that their velocities are not\n  changed, just their positions are altered.  If remap is set to v,\n  then any atom in the fix group that crosses a periodic boundary will\n  have a delta added to its velocity equal to the difference in\n  velocities between the lo and hi boundaries.  Note that this velocity\n  difference can include tilt components, e.g. a delta in the x velocity\n  when an atom crosses the y periodic boundary.  If remap is set to\n  none, then neither of these remappings take place.\n  Conceptually, setting remap to x forces the atoms to deform via an\n  affine transformation that exactly matches the box deformation.  This\n  setting is typically appropriate for solids.  Note that though the\n  atoms are effectively “moving” with the box over time, it is not due\n  to their having a velocity that tracks the box change, but only due to\n  the remapping.  By contrast, setting remap to v is typically\n  appropriate for fluids, where you want the atoms to respond to the\n  change in box size/shape on their own and acquire a velocity that\n  matches the box change, so that their motion will naturally track the\n  box without explicit remapping of their coordinates.\n  \n  Note\n  When non-equilibrium MD (NEMD) simulations are performed using\n  this fix, the option “remap v” should normally be used.  This is\n  because fix nvt/sllod adjusts the atom positions\n  and velocities to induce a velocity profile that matches the changing\n  box size/shape.  Thus atom coordinates should NOT be remapped by fix\n  deform, but velocities SHOULD be when atoms cross periodic boundaries,\n  since that is consistent with maintaining the velocity profile already\n  created by fix nvt/sllod.  LAMMPS will warn you if the remap setting\n  is not consistent with fix nvt/sllod.\n  \n  \n  Note\n  For non-equilibrium MD (NEMD) simulations using “remap v” it is\n  usually desirable that the fluid (or flowing material, e.g. granular\n  particles) stream with a velocity profile consistent with the\n  deforming box.  As mentioned above, using a thermostat such as fix nvt/sllod or fix lavgevin\n  (with a bias provided by compute temp/deform), will typically accomplish\n  that.  If you do not use a thermostat, then there is no driving force\n  pushing the atoms to flow in a manner consistent with the deforming\n  box.  E.g. for a shearing system the box deformation velocity may vary\n  from 0 at the bottom to 10 at the top of the box.  But the stream\n  velocity profile of the atoms may vary from -5 at the bottom to +5 at\n  the top.  You can monitor these effects using the fix ave/chunk, compute temp/deform, and compute temp/profile commands.  One way to induce\n  atoms to stream consistent with the box deformation is to give them an\n  initial velocity profile, via the velocity ramp\n  command, that matches the box deformation rate.  This also typically\n  helps the system come to equilibrium more quickly, even if a\n  thermostat is used.\n  \n  \n  Note\n  If a fix rigid is defined for rigid bodies, and\n  remap is set to x, then the center-of-mass coordinates of rigid\n  bodies will be remapped to the changing simulation box.  This will be\n  done regardless of whether atoms in the rigid bodies are in the fix\n  deform group or not.  The velocity of the centers of mass are not\n  remapped even if remap is set to v, since fix nvt/sllod does not currently do anything special\n  for rigid particles.  If you wish to perform a NEMD simulation of\n  rigid particles, you can either thermostat them independently or\n  include a background fluid and thermostat the fluid via fix nvt/sllod.\n  \n  The flip keyword allows the tilt factors for a triclinic box to\n  exceed half the distance of the parallel box length, as discussed\n  above.  If the flip value is set to yes, the bound is enforced by\n  flipping the box when it is exceeded.  If the flip value is set to\n  no, the tilt will continue to change without flipping.  Note that if\n  you apply large deformations, this means the box shape can tilt\n  dramatically LAMMPS will run less efficiently, due to the large volume\n  of communication needed to acquire ghost atoms around a processor’s\n  irregular-shaped sub-domain.  For extreme values of tilt, LAMMPS may\n  also lose atoms and generate an error.\n  The units keyword determines the meaning of the distance units used\n  to define various arguments.  A box value selects standard distance\n  units as defined by the units command, e.g. Angstroms for\n  units = real or metal.  A lattice value means the distance units are\n  in lattice spacings.  The lattice command must have\n  been previously used to define the lattice spacing.  Note that the\n  units choice also affects the vel style parameters since it is\n  defined in terms of distance/time.  Also note that the units keyword\n  does not affect the variable style.  You should use the xlat,\n  ylat, zlat keywords of the thermo_style\n  command if you want to include lattice spacings in a variable formula.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  This fix will restore the initial box settings from binary restart files, which allows the fix to be properly continue\n  deformation, when using the start/stop options of the run\n  command.  None of the fix_modify options are\n  relevant to this fix.  No global or per-atom quantities are stored by\n  this fix for access by various output commands.\n  This fix can perform deformation over multiple runs, using the start\n  and stop keywords of the run command.  See the\n  run command for details of how to do this.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID deform N parameter args ... keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  deform = style name of this fix command\n  N = perform box deformation every this many timesteps\n  one or more parameter/arg pairs may be appended\n  parameter = x or y or z or xy or xz or yz\n    x, y, z args = style value(s)\n      style = final or delta or scale or vel or erate or trate or volume or wiggle or variable\n        final values = lo hi\n          lo hi = box boundaries at end of run (distance units)\n        delta values = dlo dhi\n          dlo dhi = change in box boundaries at end of run (distance units)\n        scale values = factor\n          factor = multiplicative factor for change in box length at end of run\n        vel value = V\n          V = change box length at this velocity (distance/time units),\n              effectively an engineering strain rate\n        erate value = R\n          R = engineering strain rate (1/time units)\n        trate value = R\n          R = true strain rate (1/time units)\n        volume value = none = adjust this dim to preserve volume of system\n        wiggle values = A Tp\n          A = amplitude of oscillation (distance units)\n          Tp = period of oscillation (time units)\n        variable values = v_name1 v_name2\n          v_name1 = variable with name1 for box length change as function of time\n          v_name2 = variable with name2 for change rate as function of time\n    xy, xz, yz args = style value\n      style = final or delta or vel or erate or trate or wiggle\n        final value = tilt\n          tilt = tilt factor at end of run (distance units)\n        delta value = dtilt\n          dtilt = change in tilt factor at end of run (distance units)\n        vel value = V\n          V = change tilt factor at this velocity (distance/time units),\n              effectively an engineering shear strain rate\n        erate value = R\n          R = engineering shear strain rate (1/time units)\n        trate value = R\n          R = true shear strain rate (1/time units)\n        wiggle values = A Tp\n          A = amplitude of oscillation (distance units)\n          Tp = period of oscillation (time units)\n        variable values = v_name1 v_name2\n          v_name1 = variable with name1 for tilt change as function of time\n          v_name2 = variable with name2 for change rate as function of time\n  \n  zero or more keyword/value pairs may be appended\n  keyword = remap or flip or units\n  remap value = x or v or none\n    x = remap coords of atoms in group into deforming box\n    v = remap velocities of all atoms when they cross periodic boundaries\n    none = no remapping of x or v\n  flip value = yes or no\n    allow or disallow box flips when it becomes highly skewed\n  units value = lattice or box\n    lattice = distances are defined in lattice units\n    box = distances are defined in simulation box units\n  \n  \n  ",
    "examples": "fix 1 all deform 1 x final 0.0 9.0 z final 0.0 5.0 units box\n  fix 1 all deform 1 x trate 0.1 y volume z volume\n  fix 1 all deform 1 xy erate 0.001 remap v\n  fix 1 all deform 10 y delta -0.5 0.5 xz vel 1.0\n  \n  \n  ",
    "restrictions": "You cannot apply x, y, or z deformations to a dimension that is\n  shrink-wrapped via the boundary command.\n  You cannot apply xy, yz, or xz deformations to a 2nd dimension (y in\n  xy) that is shrink-wrapped via the boundary command.\n  "
},
{
    "command": "fix deposit",
    "description": "Insert a single atom or molecule into the simulation domain every M\n  timesteps until N atoms or molecules have been inserted.  This is\n  useful for simulating deposition onto a surface.  For the remainder of\n  this doc page, a single inserted atom or molecule is referred to as a\n  “particle”.\n  If inserted particles are individual atoms, they are assigned the\n  specified atom type.  If they are molecules, the type of each atom in\n  the inserted molecule is specified in the file read by the\n  molecule command, and those values are added to the\n  specified atom type.  E.g. if the file specifies atom types 1,2,3, and\n  those are the atom types you want for inserted molecules, then specify\n  type = 0.  If you specify type = 2, the in the inserted molecule\n  will have atom types 3,4,5.\n  All atoms in the inserted particle are assigned to two groups: the\n  default group “all” and the group specified in the fix deposit command\n  (which can also be “all”).\n  If you are computing temperature values which include inserted\n  particles, you will want to use the\n  compute_modify dynamic option, which insures the\n  current number of atoms is used as a normalizing factor each time the\n  temperature is computed.\n  Care must be taken that inserted particles are not too near existing\n  atoms, using the options described below.  When inserting particles\n  above a surface in a non-periodic box (see the\n  boundary command), the possibility of a particle\n  escaping the surface and flying upward should be considered, since the\n  particle may be lost or the box size may grow infinitely large.  A\n  fix wall/reflect command can be used to\n  prevent this behavior.  Note that if a shrink-wrap boundary is used,\n  it is OK to insert the new particle outside the box, however the box\n  will immediately be expanded to include the new particle. When\n  simulating a sputtering experiment it is probably more realistic to\n  ignore those atoms using the thermo_modify\n  command with the lost ignore option and a fixed\n  boundary.\n  The fix deposit command must use the region keyword to define an\n  insertion volume.  The specified region must have been previously\n  defined with a region command.  It must be defined with\n  side = in.\n  \n  Note\n  LAMMPS checks that the specified region is wholly inside the\n  simulation box.  It can do this correctly for orthonormal simulation\n  boxes.  However for triclinic boxes, it only\n  tests against the larger orthonormal box that bounds the tilted\n  simulation box.  If the specified region includes volume outside the\n  tilted box, then an insertion will likely fail, leading to a “lost\n  atoms” error.  Thus for triclinic boxes you should insure the\n  specified region is wholly inside the simulation box.\n  \n  The locations of inserted particles are taken from uniform distributed\n  random numbers, unless the gaussian keyword is used. Then the\n  individual coordinates are taken from a gaussian distribution of\n  width sigma centered on xmid,ymid,zmid.\n  Individual atoms are inserted, unless the mol keyword is used.  It\n  specifies a template-ID previously defined using the\n  molecule command, which reads files that define one or\n  more molecules.  The coordinates, atom types, charges, etc, as well as\n  any bond/angle/etc and special neighbor information for the molecule\n  can be specified in the molecule file.  See the\n  molecule command for details.  The only settings\n  required to be in each file are the coordinates and types of atoms in\n  the molecule.\n  If the molecule template contains more than one molecule, the relative\n  probability of depositing each molecule can be specified by the\n  molfrac keyword.  N relative probabilities, each from 0.0 to 1.0, are\n  specified, where N is the number of molecules in the template.  Each\n  time a molecule is deposited, a random number is used to sample from\n  the list of relative probabilities.  The N values must sum to 1.0.\n  If you wish to insert molecules via the mol keyword, that will be\n  treated as rigid bodies, use the rigid keyword, specifying as its\n  value the ID of a separate fix rigid/small\n  command which also appears in your input script.\n  \n  Note\n  If you wish the new rigid molecules (and other rigid molecules)\n  to be thermostatted correctly via fix rigid/small/nvt\n  or fix rigid/small/npt, then you need to use the\n  “fix_modify dynamic/dof yes” command for the rigid fix.  This is to\n  inform that fix that the molecule count will vary dynamically.\n  \n  If you wish to insert molecules via the mol keyword, that will have\n  their bonds or angles constrained via SHAKE, use the shake keyword,\n  specifying as its value the ID of a separate fix shake command which also appears in your input script.\n  Each timestep a particle is inserted, the coordinates for its atoms\n  are chosen as follows.  For insertion of individual atoms, the\n  “position” referred to in the following description is the coordinate\n  of the atom.  For insertion of molecule, the “position” is the\n  geometric center of the molecule; see the molecule doc\n  page for details.  A random rotation of the molecule around its center\n  point is performed, which determines the coordinates all the\n  individual atoms.\n  A random position within the region insertion volume is generated.  If\n  neither the global or local keyword is used, the random position\n  is the trial position.  If the global keyword is used, the random\n  x,y values are used, but the z position of the new particle is set\n  above the highest current atom in the simulation by a distance\n  randomly chosen between lo/hi.  (For a 2d simulation, this is done for\n  the y position.)  If the local keyword is used, the z position is\n  set a distance between lo/hi above the highest current atom in the\n  simulation that is “nearby” the chosen x,y position.  In this context,\n  “nearby” means the lateral distance (in x,y) between the new and old\n  particles is less than the delta setting.\n  Once a trial x,y,z position has been selected, the insertion is only\n  performed if no current atom in the simulation is within a distance R\n  of any atom in the new particle, including the effect of periodic\n  boundary conditions if applicable.  R is defined by the near\n  keyword.  Note that the default value for R is 0.0, which will allow\n  atoms to strongly overlap if you are inserting where other atoms are\n  present.  This distance test is performed independently for each atom\n  in an inserted molecule, based on the randomly rotated configuration\n  of the molecule.  If this test fails, a new random position within the\n  insertion volume is chosen and another trial is made.  Up to Q\n  attempts are made.  If the particle is not successfully inserted,\n  LAMMPS prints a warning message.\n  \n  Note\n  If you are inserting finite size particles or a molecule or\n  rigid body consisting of finite-size particles, then you should\n  typically set R larger than the distance at which any inserted\n  particle may overlap with either a previously inserted particle or an\n  existing particle.  LAMMPS will issue a warning if R is smaller than\n  this value, based on the radii of existing and inserted particles.\n  \n  The rate option moves the insertion volume in the z direction (3d)\n  or y direction (2d).  This enables particles to be inserted from a\n  successively higher height over time.  Note that this parameter is\n  ignored if the global or local keywords are used, since those\n  options choose a z-coordinate for insertion independently.\n  The vx, vy, and vz components of velocity for the inserted particle\n  are set using the values specified for the vx, vy, and vz\n  keywords.  Note that normally, new particles should be a assigned a\n  negative vertical velocity so that they move towards the surface.  For\n  molecules, the same velocity is given to every particle (no rotation\n  or bond vibration).\n  If the target option is used, the velocity vector of the inserted\n  particle is changed so that it points from the insertion position\n  towards the specified target point.  The magnitude of the velocity is\n  unchanged.  This can be useful, for example, for simulating a\n  sputtering process.  E.g. the target point can be far away, so that\n  all incident particles strike the surface as if they are in an\n  incident beam of particles at a prescribed angle.\n  The orient keyword is only used when molecules are deposited.  By\n  default, each molecule is inserted at a random orientation.  If this\n  keyword is specified, then (rx,ry,rz) is used as an orientation\n  vector, and each inserted molecule is rotated around that vector with\n  a random value from zero to 2*PI.  For a 2d simulation, rx = ry = 0.0\n  is required, since rotations can only be performed around the z axis.\n  The id keyword determines how atom IDs and molecule IDs are assigned\n  to newly deposited particles.  Molecule IDs are only assigned if\n  molecules are being inserted.  For the max setting, the atom and\n  molecule IDs of all current atoms are checked.  Atoms in the new\n  particle are assigned IDs starting with the current maximum plus one.\n  If a molecule is inserted it is assigned an ID = current maximum plus\n  one.  This means that if particles leave the system, the new IDs may\n  replace the lost ones.  For the next setting, the maximum ID of any\n  atom and molecule is stored at the time the fix is defined.  Each time\n  a new particle is added, this value is incremented to assign IDs to\n  the new atom(s) or molecule.  Thus atom and molecule IDs for deposited\n  particles will be consecutive even if particles leave the system over\n  time.\n  The units keyword determines the meaning of the distance units used\n  for the other deposition parameters.  A box value selects standard\n  distance units as defined by the units command,\n  e.g. Angstroms for units = real or metal.  A lattice value means the\n  distance units are in lattice spacings.  The lattice\n  command must have been previously used to define the lattice spacing.\n  Note that the units choice affects all the keyword values that have\n  units of distance or velocity.\n  \n  Note\n  If you are monitoring the temperature of a system where the atom\n  count is changing due to adding particles, you typically should use\n  the compute_modify dynamic yes command for the\n  temperature compute you are using.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  This fix writes the state of the deposition to binary restart files.  This includes information about how many\n  particles have been deposited, the random number generator seed, the\n  next timestep for deposition, etc.  See the\n  read_restart command for info on how to re-specify\n  a fix in an input script that reads a restart file, so that the\n  operation of the fix continues in an uninterrupted fashion.\n  \n  Note\n  For this to work correctly, the timestep must not be changed\n  after reading the restart with reset_timestep.\n  The fix will try to detect it and stop with an error.\n  \n  None of the fix_modify options are relevant to this\n  fix.  No global or per-atom quantities are stored by this fix for\n  access by various output commands.  No parameter\n  of this fix can be used with the start/stop keywords of the\n  run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID deposit N type M seed keyword values ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  deposit = style name of this fix command\n  N = # of atoms or molecules to insert\n  type = atom type to assign to inserted atoms (offset for molecule insertion)\n  M = insert a single atom or molecule every M steps\n  seed = random # seed (positive integer)\n  one or more keyword/value pairs may be appended to args\n  keyword = region or id or global or local or near or gaussian or attempt or rate or vx or vy or vz or mol or rigid or shake or units\n  region value = region-ID\n    region-ID = ID of region to use as insertion volume\n  id value = max or next\n    max = atom ID for new atom(s) is max ID of all current atoms plus one\n    next = atom ID for new atom(s) increments by one for every deposition\n  global values = lo hi\n    lo,hi = put new atom/molecule a distance lo-hi above all other atoms (distance units)\n  local values = lo hi delta\n    lo,hi = put new atom/molecule a distance lo-hi above any nearby atom beneath it (distance units)\n    delta = lateral distance within which a neighbor is considered \"nearby\" (distance units)\n  near value = R\n    R = only insert atom/molecule if further than R from existing particles (distance units)\n  gaussian values = xmid ymid zmid sigma\n    xmid,ymid,zmid = center of the gaussian distribution (distance units)\n    sigma = width of gaussian distribution (distance units)\n  attempt value = Q\n    Q = attempt a single insertion up to Q times\n  rate value = V\n    V = z velocity (y in 2d) at which insertion volume moves (velocity units)\n  vx values = vxlo vxhi\n    vxlo,vxhi = range of x velocities for inserted atom/molecule (velocity units)\n  vy values = vylo vyhi\n    vylo,vyhi = range of y velocities for inserted atom/molecule (velocity units)\n  vz values = vzlo vzhi\n    vzlo,vzhi = range of z velocities for inserted atom/molecule (velocity units)\n  target values = tx ty tz\n    tx,ty,tz = location of target point (distance units)\n  mol value = template-ID\n    template-ID = ID of molecule template specified in a separate molecule command\n  molfrac values = f1 f2 ... fN\n    f1 to fN = relative probability of creating each of N molecules in template-ID\n  rigid value = fix-ID\n    fix-ID = ID of fix rigid/small command\n  shake value = fix-ID\n    fix-ID = ID of fix shake command\n  orient values = rx ry rz\n    rx,ry,rz = vector to randomly rotate an inserted molecule around\n  units value = lattice or box\n    lattice = the geometry is defined in lattice units\n    box = the geometry is defined in simulation box units\n  \n  \n  ",
    "examples": "fix 3 all deposit 1000 2 100 29494 region myblock local 1.0 1.0 1.0 units box\n  fix 2 newatoms deposit 10000 1 500 12345 region disk near 2.0 vz -1.0 -0.8\n  fix 4 sputter deposit 1000 2 500 12235 region sphere vz -1.0 -1.0 target 5.0 5.0 0.0 units lattice\n  fix 5 insert deposit 200 2 100 777 region disk gaussian 5.0 5.0 9.0 1.0 units box\n  \n  \n  ",
    "restrictions": "This fix is part of the MISC package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  The specified insertion region cannot be a “dynamic” region, as\n  defined by the region command.\n  "
},
{
    "command": "fix dpd/energy",
    "description": "Perform constant energy dissipative particle dynamics (DPD-E)\n  integration.  This fix updates the internal energies for particles in\n  the group at each timestep.  It must be used in conjunction with a\n  deterministic integrator (e.g. fix nve) that updates\n  the particle positions and velocities.\n  For fix dpd/energy, the particle internal temperature is related to\n  the particle internal energy through a mesoparticle equation of state.\n  An additional fix must be specified that defines the equation of state\n  for each particle, e.g. fix eos/cv.\n  This fix must be used with the pair_style dpd/fdt/energy command.\n  Note that numerous variants of DPD can be specified by choosing an\n  appropriate combination of the integrator and pair_style dpd/fdt/energy command.  DPD under isoenergetic conditions\n  can be specified by using fix dpd/energy, fix nve and pair_style\n  dpd/fdt/energy.  DPD under isoenthalpic conditions can\n  be specified by using fix dpd/energy, fix nph and pair_style\n  dpd/fdt/energy.  Examples of each DPD variant are provided in the\n  examples/USER/dpd directory.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "fix ID group-ID dpd/energy\n  \n  \n  \n  ID, group-ID are documented in fix command\n  dpd/energy = style name of this fix command\n  \n  ",
    "examples": "fix 1 all dpd/energy\n  \n  \n  ",
    "restrictions": "This command is part of the USER-DPD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  This fix must be used with an additional fix that specifies time\n  integration, e.g. fix nve.\n  The fix dpd/energy requires the dpd atom_style\n  to be used in order to properly account for the particle internal\n  energies and temperature.\n  The fix dpd/energy must be used with an additional fix that specifies the\n  mesoparticle equation of state for each particle.\n  "
},
{
    "command": "fix edpd/source",
    "description": "Fix edpd/source adds a heat source as an external heat flux to each\n  atom in a spherical or cuboid domain, where the source is in units\n  of energy/time.  Fix tdpd/source adds an external concentration\n  source of the chemical species specified by index as an external\n  concentration flux for each atom in a spherical or cuboid domain,\n  where the source is in units of mole/volume/time.\n  This command can be used to give an additional heat/concentration\n  source term to atoms in a simulation, such as for a simulation of a\n  heat conduction with a source term (see Fig.12 in (Li2014))\n  or diffusion with a source term (see Fig.1 in (Li2015)), as\n  an analog of a periodic Poiseuille flow problem.\n  If the sphere keyword is used, the cx,cy,cz,radius defines a\n  spherical domain to apply the source flux to.\n  If the cuboid keyword is used, the cx,cy,cz,dLx,dLy,dLz defines a\n  cuboid domain to apply the source flux to.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID edpd/source keyword values ...\n  fix ID group-ID tdpd/source cc_index keyword values ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  edpd/source or tdpd/source = style name of this fix command\n  index (only specified for tdpd/source) = index of chemical species (1 to Nspecies)\n  keyword = sphere or cuboid\n  sphere values = cx,cy,cz,radius,source\n    cx,cy,cz = x,y,z center of spherical domain (distance units)\n    radius = radius of a spherical domain (distance units)\n    source = heat source or concentration source (flux units, see below)\n  cuboid values = cx,cy,cz,dLx,dLy,dLz,source\n    cx,cy,cz = x,y,z lower left corner of a cuboid domain (distance units)\n    dLx,dLy,dLz = x,y,z side length of a cuboid domain (distance units)\n    source = heat source or concentration source (flux units, see below)\n  \n  \n  ",
    "examples": "fix 1 all edpd/source sphere 0.0 0.0 0.0 5.0 0.01\n  fix 1 all edpd/source cuboid 0.0 0.0 0.0 20.0 10.0 10.0 -0.01\n  fix 1 all tdpd/source 1 sphere 5.0 0.0 0.0 5.0 0.01\n  fix 1 all tdpd/source 2 cuboid 0.0 0.0 0.0 20.0 10.0 10.0 0.01\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-MESODPD package. It is only enabled if\n  LAMMPS was built with that package. See the Build package doc page for more info.\n  Fix edpd/source must be used with the pair_style edpd command.  Fix tdpd/source must be used with the\n  pair_style tdpd command.\n  "
},
{
    "command": "fix drag",
    "description": "Apply a force to each atom in a group to drag it towards the point\n  (x,y,z).  The magnitude of the force is specified by fmag.  If an atom\n  is closer than a distance delta to the point, then the force is not\n  applied.\n  Any of the x,y,z values can be specified as NULL which means do not\n  include that dimension in the distance calculation or force\n  application.\n  This command can be used to steer one or more atoms to a new location\n  in the simulation.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The fix_modify respa option is supported by this\n  fix. This allows to set at which level of the r-RESPA\n  integrator the fix is adding its forces. Default is the outermost level.\n  This fix computes a global 3-vector of forces, which can be accessed\n  by various output commands.  This is the total\n  force on the group of atoms by the drag force.  The vector values\n  calculated by this fix are “extensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID drag x y z fmag delta\n  \n  \n  \n  ID, group-ID are documented in fix command\n  drag = style name of this fix command\n  x,y,z = coord to drag atoms towards\n  fmag = magnitude of force to apply to each atom (force units)\n  delta = cutoff distance inside of which force         is not applied (distance units)\n  \n  ",
    "examples": "fix center small-molecule drag 0.0 10.0 0.0 5.0 2.0\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix drude",
    "description": "Assign each atom type in the system to be one of 3 kinds of atoms\n  within the Drude polarization model. This fix is designed to be used\n  with the thermalized Drude oscillator model.\n  Polarizable models in LAMMPS are described on the Howto polarizable doc page.\n  The three possible types can be designated with an integer (0,1,2)\n  or capital letter (N,C,D):\n  \n  0 or N = non-polarizable atom (not part of Drude model)\n  1 or C = Drude core\n  2 or D = Drude electron\n  \n  ",
    "syntax": "fix ID group-ID drude flag1 flag2 ... flagN\n  \n  \n  \n  ID, group-ID are documented in fix command\n  drude = style name of this fix command\n  flag1 flag2 … flagN = Drude flag for each atom type (1 to N) in the system\n  \n  ",
    "examples": "fix 1 all drude 1 1 0 1 0 2 2 2\n  fix 1 all drude C C N C N D D D\n  \n  \n  ",
    "restrictions": "This fix should be invoked before any other commands that implement\n  the Drude oscillator model, such as fix langevin/drude, fix drude/transform, compute temp/drude, pair_style thole.\n  "
},
{
    "command": "fix drude/transform/direct",
    "description": "Transform the coordinates of Drude oscillators from real to reduced\n  and back for thermalizing the Drude oscillators as described in\n  (Lamoureux) using a Nose-Hoover thermostat.  This fix is\n  designed to be used with the thermalized Drude oscillator model.  Polarizable models in LAMMPS are described\n  on the Howto polarizable doc page.\n  Drude oscillators are a pair of atoms representing a single\n  polarizable atom.  Ideally, the mass of Drude particles would vanish\n  and their positions would be determined self-consistently by iterative\n  minimization of the energy, the cores’ positions being fixed.  It is\n  however more efficient and it yields comparable results, if the Drude\n  oscillators (the motion of the Drude particle relative to the core)\n  are thermalized at a low temperature.  In that case, the Drude\n  particles need a small mass.\n  The thermostats act on the reduced degrees of freedom, which are\n  defined by the following equations.  Note that in these equations\n  upper case denotes atomic or center of mass values and lower case\n  denotes Drude particle or dipole values. Primes denote the transformed\n  (reduced) values, while bare letters denote the original values.\n  Masses:\n  \n  \\[M' = M + m\\]\n  \n  \\[m' = \\frac {M\\, m } {M'}\\]\n  Positions:\n  \n  \\[X' = \\frac {M\\, X + m\\, x} {M'}\\]\n  \n  \\[x' = x - X\\]\n  Velocities:\n  \n  \\[V' = \\frac {M\\, V + m\\, v} {M'}\\]\n  \n  \\[v' = v - V\\]\n  Forces:\n  \n  \\[F' = F + f\\]\n  \n  \\[f' = \\frac { M\\, f - m\\, F} {M'}\\]\n  This transform conserves the total kinetic energy\n  \n  \\[ \\frac 1 2 \\, (M\\, V^2\\ + m\\, v^2)\n  = \\frac 1 2 \\, (M'\\, V'^2\\ + m'\\, v'^2)\\]\n  and the virial defined with absolute positions\n  \n  \\[X\\, F + x\\, f = X'\\, F' + x'\\, f'\\]\n  \n  This fix requires each atom know whether it is a Drude particle or\n  not.  You must therefore use the fix drude command to\n  specify the Drude status of each atom type.\n  \n  Note\n  only the Drude core atoms need to be in the group specified for\n  this fix. A Drude electron will be transformed together with its core\n  even if it is not itself in the group.  It is safe to include Drude\n  electrons or non-polarizable atoms in the group. The non-polarizable\n  atoms will simply not be transformed.\n  \n  \n  This fix does NOT perform time integration. It only transform masses,\n  coordinates, velocities and forces. Thus you must use separate time\n  integration fixes, like fix nve or fix npt to actually update the velocities and positions of\n  atoms.  In order to thermalize the reduced degrees of freedom at\n  different temperatures, two Nose-Hoover thermostats must be defined,\n  acting on two distinct groups.\n  \n  Note\n  The fix drude/transform/direct command must appear before any\n  Nose-Hoover thermostatting fixes.  The fix drude/transform/inverse\n  command must appear after any Nose-Hoover thermostatting fixes.\n  \n  Example:\n  fix fDIRECT all drude/transform/direct\n  fix fNVT gCORES nvt temp 300.0 300.0 100\n  fix fNVT gDRUDES nvt temp 1.0 1.0 100\n  fix fINVERSE all drude/transform/inverse\n  compute TDRUDE all temp/drude\n  thermo_style custom step cpu etotal ke pe ebond ecoul elong press vol temp c_TDRUDE[1] c_TDRUDE[2]\n  \n  \n  In this example, gCORES is the group of the atom cores and gDRUDES\n  is the group of the Drude particles (electrons). The centers of mass\n  of the Drude oscillators will be thermostatted at 300.0 and the\n  internal degrees of freedom will be thermostatted at 1.0.  The\n  temperatures of cores and Drude particles, in center-of-mass and\n  relative coordinates, are calculated using compute temp/drude\n  In addition, if you want to use a barostat to simulate a system at\n  constant pressure, only one of the Nose-Hoover fixes must be npt,\n  the other one should be nvt. You must add a compute temp/com and a\n  fix_modify command so that the temperature of the npt fix be just\n  that of its group (the Drude cores) but the pressure be the overall\n  pressure thermo_press.\n  Example:\n  compute cTEMP_CORE gCORES temp/com\n  fix fDIRECT all drude/transform/direct\n  fix fNPT gCORES npt temp 298.0 298.0 100 iso 1.0 1.0 500\n  fix_modify fNPT temp cTEMP_CORE press thermo_press\n  fix fNVT gDRUDES nvt temp 5.0 5.0 100\n  fix fINVERSE all drude/transform/inverse\n  \n  \n  In this example, gCORES is the group of the atom cores and gDRUDES\n  is the group of the Drude particles. The centers of mass of the Drude\n  oscillators will be thermostatted at 298.0 and the internal degrees of\n  freedom will be thermostatted at 5.0. The whole system will be\n  barostatted at 1.0.\n  In order to avoid the flying ice cube problem (irreversible transfer\n  of linear momentum to the center of mass of the system), you may need\n  to add a fix momentum command:\n  fix fMOMENTUM all momentum 100 linear 1 1 1\n  \n  \n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  ",
    "syntax": "fix ID group-ID style keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  style = drude/transform/direct or drude/transform/inverse\n  \n  ",
    "examples": "fix 3 all drude/transform/direct\n  fix 1 all drude/transform/inverse\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix dt/reset",
    "description": "Reset the timestep size every N steps during a run, so that no atom\n  moves further than the specified Xmax distance, based on current\n  atom velocities and forces.  Optionally an additional criterion is\n  imposed by the emax keyword, so that no atom’s kinetic energy\n  changes by more than the specified Emax.\n  This can be useful when starting from a configuration with overlapping\n  atoms, where forces will be large.  Or it can be useful when running\n  an impact simulation where one or more high-energy atoms collide with\n  a solid, causing a damage cascade.\n  This fix overrides the timestep size setting made by the\n  timestep command.  The new timestep size dt is\n  computed in the following manner.\n  For each atom, the timestep is computed that would cause it to\n  displace Xmax on the next integration step, as a function of its\n  current velocity and force.  Since performing this calculation exactly\n  would require the solution to a quartic equation, a cheaper estimate\n  is generated.  The estimate is conservative in that the atom’s\n  displacement is guaranteed not to exceed Xmax, though it may be\n  smaller.\n  In addition if the emax keyword is used, the specified Emax value\n  is enforced as a limit on how much an atom’s kinetic energy can\n  change.  If the timestep required is even smaller than for the Xmax\n  displacement, then the smaller timestep is used.\n  Given this putative timestep for each atom, the minimum timestep value\n  across all atoms is computed.  Then the Tmin and Tmax bounds are\n  applied, if specified.  If one (or both) is specified as NULL, it is\n  not applied.\n  When the run style is respa, this fix resets the\n  outer loop (largest) timestep, which is the same timestep that the\n  timestep command sets.\n  Note that the cumulative simulation time (in time units), which\n  accounts for changes in the timestep size as a simulation proceeds,\n  can be accessed by the thermo_style time keyword.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.\n  This fix computes a global scalar which can be accessed by various\n  output commands.  The scalar stores the last\n  timestep on which the timestep was reset to a new value.\n  The scalar value calculated by this fix is “intensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID dt/reset N Tmin Tmax Xmax keyword values ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  dt/reset = style name of this fix command\n  N = re-compute dt every N timesteps\n  Tmin = minimum dt allowed which can be NULL (time units)\n  Tmax = maximum dt allowed which can be NULL (time units)\n  Xmax = maximum distance for an atom to move in one timestep (distance units)\n  zero or more keyword/value pairs may be appended\n  keyword = emax or units\n  \n  emax value = Emax\n    Emax = maximum kinetic energy change for an atom in one timestep (energy units)\n  units value = lattice or box\n    lattice = Xmax is defined in lattice units\n    box = Xmax is defined in simulation box units\n  ",
    "examples": "fix 5 all dt/reset 10 1.0e-5 0.01 0.1\n  fix 5 all dt/reset 10 0.01 2.0 0.2 units box\n  fix 5 all dt/reset 5 NULL 0.001 0.5 emax 30 units box\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix efield",
    "description": "Add a force F = qE to each charged atom in the group due to an\n  external electric field being applied to the system.  If the system\n  contains point-dipoles, also add a torque on the dipoles due to the\n  external electric field.\n  For charges, any of the 3 quantities defining the E-field components\n  can be specified as an equal-style or atom-style\n  variable, namely ex, ey, ez.  If the value is a\n  variable, it should be specified as v_name, where name is the variable\n  name.  In this case, the variable will be evaluated each timestep, and\n  its value used to determine the E-field component.\n  For point-dipoles, equal-style variables can be used, but atom-style\n  variables are not currently supported, since they imply a spatial\n  gradient in the electric field which means additional terms with\n  gradients of the field are required for the force and torque on\n  dipoles.\n  Equal-style variables can specify formulas with various mathematical\n  functions, and include thermo_style command\n  keywords for the simulation box parameters and timestep and elapsed\n  time.  Thus it is easy to specify a time-dependent E-field.\n  Atom-style variables can specify the same formulas as equal-style\n  variables but can also include per-atom values, such as atom\n  coordinates.  Thus it is easy to specify a spatially-dependent E-field\n  with optional time-dependence as well.\n  If the region keyword is used, the atom must also be in the\n  specified geometric region in order to have force added\n  to it.\n  \n  Adding a force or torque to atoms implies a change in their potential\n  energy as they move or rotate due to the applied E-field.\n  For dynamics via the “run” command, this energy can be optionally\n  added to the system’s potential energy for thermodynamic output (see\n  below).  For energy minimization via the “minimize” command, this\n  energy must be added to the system’s potential energy to formulate a\n  self-consistent minimization problem (see below).\n  The energy keyword is not allowed if the added field is a constant\n  vector (ex,ey,ez), with all components defined as numeric constants\n  and not as variables.  This is because LAMMPS can compute the energy\n  for each charged particle directly as E = -x dot qE = -q (x*ex + y*ey\n  + z*ez), so that -Grad(E) = F.  Similarly for point-dipole particles\n  the energy can be computed as E = -mu dot E = -(mux*ex + muy*ey +\n  muz*ez).\n  The energy keyword is optional if the added force is defined with\n  one or more variables, and if you are performing dynamics via the\n  run command.  If the keyword is not used, LAMMPS will set\n  the energy to 0.0, which is typically fine for dynamics.\n  The energy keyword is required if the added force is defined with\n  one or more variables, and you are performing energy minimization via\n  the “minimize” command for charged particles.  It is not required for\n  point-dipoles, but a warning is issued since the minimizer in LAMMPS\n  does not rotate dipoles, so you should not expect to be able to\n  minimize the orientation of dipoles in an applied electric field.\n  The energy keyword specifies the name of an atom-style\n  variable which is used to compute the energy of each\n  atom as function of its position.  Like variables used for ex, ey,\n  ez, the energy variable is specified as v_name, where name is the\n  variable name.\n  Note that when the energy keyword is used during an energy\n  minimization, you must insure that the formula defined for the\n  atom-style variable is consistent with the force\n  variable formulas, i.e. that -Grad(E) = F.  For example, if the force\n  due to the electric field were a spring-like F = kx, then the energy\n  formula should be E = -0.5kx^2.  If you don’t do this correctly, the\n  minimization will not converge properly.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The fix_modify energy option is supported by this\n  fix to add the potential “energy” inferred by the added force due to\n  the electric field to the system’s potential energy as part of\n  thermodynamic output.  This is a fictitious\n  quantity but is needed so that the minimize command\n  can include the forces added by this fix in a consistent manner.\n  I.e. there is a decrease in potential energy when atoms move in the\n  direction of the added force due to the electric field.\n  The fix_modify virial option is supported by this\n  fix to add the contribution due to the added forces on atoms to the\n  system’s virial as part of thermodynamic output.\n  The default is virial no\n  The fix_modify respa option is supported by this\n  fix. This allows to set at which level of the r-RESPA\n  integrator the fix adding its forces. Default is the outermost level.\n  This fix computes a global scalar and a global 3-vector of forces,\n  which can be accessed by various output commands.\n  The scalar is the potential energy discussed above.  The vector is the\n  total force added to the group of atoms.  The scalar and vector values\n  calculated by this fix are “extensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  The forces due to this fix are imposed during an energy minimization,\n  invoked by the minimize command.  You should not\n  specify force components with a variable that has time-dependence for\n  use with a minimizer, since the minimizer increments the timestep as\n  the iteration count during the minimization.\n  \n  Note\n  If you want the fictitious potential energy associated with the\n  added forces to be included in the total potential energy of the\n  system (the quantity being minimized), you MUST enable the\n  fix_modify energy option for this fix.\n  \n  ",
    "syntax": "fix ID group-ID efield ex ey ez keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  efield = style name of this fix command\n  ex,ey,ez = E-field component values (electric field units)\n  any of ex,ey,ez can be a variable (see below)\n  zero or more keyword/value pairs may be appended to args\n  keyword = region or energy\n  region value = region-ID\n    region-ID = ID of region atoms must be in to have added force\n  energy value = v_name\n    v_name = variable with name that calculates the potential energy of each atom in the added E-field\n  \n  \n  ",
    "examples": "fix kick external-field efield 1.0 0.0 0.0\n  fix kick external-field efield 0.0 0.0 v_oscillate\n  \n  \n  ",
    "restrictions": "This fix is part of the MISC package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "fix ehex",
    "description": "This fix implements the asymmetric version of the enhanced heat\n  exchange algorithm (Wirnsberger). The eHEX algorithm is\n  an extension of the heat exchange algorithm (Ikeshoji) and\n  adds an additional coordinate integration to account for higher-order\n  truncation terms in the operator splitting.  The original HEX\n  algorithm (implemented as fix heat) is known to\n  exhibit a slight energy drift limiting the accessible simulation times\n  to a few nanoseconds.  This issue is greatly improved by the new\n  algorithm decreasing the energy drift by at least a factor of a\n  hundred (LJ and SPC/E water) with little computational overhead.\n  In both algorithms (non-translational) kinetic energy is constantly\n  swapped between regions (reservoirs) to impose a heat flux onto the\n  system.  The equations of motion are therefore modified if a particle\n  \\(i\\) is located inside a reservoir \\(\\Gamma_k\\) where \\(k>0\\).  We\n  use \\(\\Gamma_0\\) to label those parts of the simulation box which\n  are not thermostatted.)  The input parameter region-ID of this fix\n  corresponds to \\(k\\).  The energy swap is modelled by introducing an\n  additional thermostatting force to the equations of motion, such that\n  the time evolution of coordinates and momenta of particle \\(i\\)\n  becomes (Wirnsberger)\n  \n  \\[\\begin{split}\\dot{\\mathbf r}_i &= \\mathbf v_i,  \\\\\n  \\dot{\\mathbf v}_i &= \\frac{\\mathbf f_i}{m_i} + \\frac{\\mathbf g_i}{m_i}.\\end{split}\\]\n  The thermostatting force is given by\n  \n  \\[\\begin{split}\\mathbf g_i = \\begin{cases}\n  \\frac{m_i}{2}   \\frac{ F_{\\Gamma_{k(\\mathbf r_i)}}}{ K_{\\Gamma_{k(\\mathbf r_i)}}}\n  \\left(\\mathbf v_i -  \\mathbf v_{\\Gamma_{k(\\mathbf r_i)}} \\right) &  \\mbox{$k(\\mathbf r_i)> 0$ (inside a reservoir),} \\\\\n   0                                     &  \\mbox{otherwise, }\n  \\end{cases}\\end{split}\\]\n  where \\(m_i\\) is the mass and \\(k(\\mathbf r_i)\\) maps the particle\n  position to the respective reservoir. The quantity\n  \\(F_{\\Gamma_{k(\\mathbf r_i)}}\\) corresponds to the input parameter\n  F, which is the energy flux into the reservoir. Furthermore,\n  \\(K_{\\Gamma_{k(\\mathbf r_i)}}\\) and \\(v_{\\Gamma_{k(\\mathbf r_i)}}\\)\n  denote the non-translational kinetic energy and the center of mass\n  velocity of that reservoir. The thermostatting force does not affect\n  the center of mass velocities of the individual reservoirs and the\n  entire simulation box. A derivation of the equations and details on\n  the numerical implementation with velocity Verlet in LAMMPS can be\n  found in reference “(Wirnsberger)”#_Wirnsberger.\n  \n  Note\n  This fix only integrates the thermostatting force and must be\n  combined with another integrator, such as fix nve, to\n  solve the full equations of motion.\n  \n  This fix is different from a thermostat such as fix nvt\n  or fix temp/rescale in that energy is\n  added/subtracted continually.  Thus if there is not another mechanism\n  in place to counterbalance this effect, the entire system will heat or\n  cool continuously.\n  \n  Note\n  If heat is subtracted from the system too aggressively so that\n  the group’s kinetic energy would go to zero, then LAMMPS will halt\n  with an error message. Increasing the value of nevery means that\n  heat is added/subtracted less frequently but in larger portions.  The\n  resulting temperature profile will therefore be the same.\n  \n  This fix will default to fix_heat (HEX algorithm) if\n  the keyword hex is specified.\n  \n  Compatibility with SHAKE and RATTLE (rigid molecules):\n  This fix is compatible with fix shake and fix rattle. If either of these constraining algorithms is\n  specified in the input script and the keyword constrain is set, the\n  bond distances will be corrected a second time at the end of the\n  integration step.  It is recommended to specify the keyword com in\n  addition to the keyword constrain. With this option all sites of a\n  constrained cluster are rescaled, if its center of mass is located\n  inside the region. Rescaling all sites of a cluster by the same factor\n  does not introduce any velocity components along fixed bonds. No\n  rescaling takes place if the center of mass lies outside the region.\n  \n  Note\n  You can only use the keyword com along with constrain.\n  \n  To achieve the highest accuracy it is recommended to use fix rattle with the keywords constrain and com as\n  shown in the second example. Only if RATTLE is employed, the velocity\n  constraints will be satisfied.\n  \n  Note\n  Even if RATTLE is used and the keywords com and constrain\n  are both set, the coordinate constraints will not necessarily be\n  satisfied up to the target precision. The velocity constraints are\n  satisfied as long as all sites of a cluster are rescaled (keyword\n  com) and the cluster does not span adjacent reservoirs. The current\n  implementation of the eHEX algorithm introduces a small error in the\n  bond distances, which goes to zero with order three in the\n  timestep. For example, in a simulation of SPC/E water with a timestep\n  of 2 fs the maximum relative error in the bond distances was found to\n  be on the order of \\(10^{-7}\\) for relatively large\n  temperature gradients.  A higher precision can be achieved by\n  decreasing the timestep.\n  \n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID ehex nevery F keyword value\n  \n  \n  \n  ID, group-ID are documented in fix command\n  ehex  = style name of this fix command\n  nevery = add/subtract heat every this many timesteps\n  F = energy flux into the reservoir (energy/time units)\n  zero or more keyword/value pairs may be appended to args\n  keyword = region or constrain or com or hex\n  region value = region-ID\n    region-ID = ID of region (reservoir) atoms must be in for added thermostatting force\n  constrain value = none\n    apply the constraint algorithm (SHAKE or RATTLE) again at the end of the timestep\n  com value = none\n    rescale all sites of a constrained cluster of atom if its COM is in the reservoir\n  hex value = none\n    omit the coordinate correction to recover the HEX algorithm\n  \n  \n  ",
    "examples": "# Lennard-Jones, from examples/in.ehex.lj\n  \n  fix fnve all nve\n  # specify regions rhot and rcold\n  ...\n  fix fhot all ehex 1 0.15 region rhot\n  fix fcold all ehex 1 -0.15 region rcold\n  \n  # SPC/E water, from examples/in.ehex.spce\n  fix fnve all nve\n  # specify regions rhot and rcold\n  ...\n  fix fhot all ehex 1 0.075 region rhot constrain com\n  fix fcold all ehex 1 -0.075 region rcold constrain com\n  fix frattle all rattle 1e-10 400 0 b 1 a 1\n  \n  \n  ",
    "restrictions": "This fix is part of the RIGID package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "fix electron/stopping",
    "description": "This fix implements inelastic energy loss for fast projectiles in solids. It\n  applies a friction force to fast moving atoms to slow them down due to\n  electronic stopping (energy lost via electronic collisions per\n  unit of distance). This fix should be used for simulation of irradiation\n  damage or ion implantation, where the ions can lose noticeable amounts of\n  energy from electron excitations. If the electronic stopping power is not\n  considered, the simulated range of the ions can be severely overestimated\n  (Nordlund98, Nordlund95).\n  The electronic stopping is implemented by applying a friction force\n  to each atom as:\n  \n  \\[\\vec{F}_i = \\vec{F}^0_i - \\frac{\\vec{v}_i}{\\|\\vec{v}_i\\|} \\cdot S_e\\]\n  where \\(\\vec{F}_i\\) is the resulting total force on the atom.\n  \\(\\vec{F}^0_i\\) is the original force applied to the atom, \\(\\vec{v}_i\\) is\n  its velocity and \\(S_e\\) is the stopping power of the ion.\n  \n  Note\n  In addition to electronic stopping, atomic cascades and irradiation\n  simulations require the use of an adaptive timestep (see\n  fix dt/reset) and the repulsive ZBL potential (see\n  ZBL potential) or similar. Without these settings the\n  interaction between the ion and the target atoms will be faulty. It is also\n  common to use in such simulations a thermostat (fix_nvt) in\n  the borders of the simulation cell.\n  \n  \n  Note\n  This fix removes energy from fast projectiles without depositing it as a\n  heat to the simulation cell. Such implementation might lead to the unphysical\n  results when the amount of energy deposited to the electronic system is large,\n  e.g. simulations of Swift Heavy Ions (energy per nucleon of 100 keV/amu or\n  higher) or multiple projectiles. You could compensate energy loss by coupling\n  bulk atoms with some thermostat or control heat transfer between electronic and\n  atomic subsystems with the two-temperature model (fix_ttm).\n  \n  At low velocities the electronic stopping is negligible. The electronic\n  friction is not applied to atoms whose kinetic energy is smaller than Ecut,\n  or smaller than the lowest energy value given in the table in file.\n  Electronic stopping should be applied only when a projectile reaches bulk\n  material. This fix scans neighbor list and excludes atoms with fewer than\n  minneigh neighbors (by default one). If the pair potential cutoff is large,\n  minneigh should be increased, though not above the number of nearest neighbors\n  in bulk material. An alternative is to disable the check for neighbors by\n  setting minneigh to zero and using the region keyword. This is necessary\n  when running simulations of cluster bombardment.\n  If the region keyword is used, the atom must also be in the specified\n  geometric region in order to have electronic stopping applied to\n  it. This is useful if the position of the bulk material is fixed. By default\n  the electronic stopping is applied everywhere in the simulation cell.\n  \n  The energy ranges and stopping powers are read from the file file.\n  Lines starting with # and empty lines are ignored. Otherwise each\n  line must contain exactly N+1 numbers, where N is the number of atom\n  types in the simulation.\n  The first column is the energy for which the stopping powers on that\n  line apply. The energies must be sorted from the smallest to the largest.\n  The other columns are the stopping powers \\(S_e\\) for each atom type,\n  in ascending order, in force units. The stopping powers for\n  intermediate energy values are calculated with linear interpolation between\n  2 nearest points.\n  For example:\n  # This is a comment\n  #       atom-1    atom-2\n  # eV    eV/Ang    eV/Ang  # units metal\n   10        0        0\n  250       60       80\n  750      100      150\n  \n  \n  If an atom which would have electronic stopping applied to it has a\n  kinetic energy higher than the largest energy given in file, LAMMPS\n  will exit with an error message.\n  The stopping power depends on the energy of the ion and the target\n  material. The electronic stopping table can be obtained from\n  scientific publications, experimental databases or by using\n  SRIM software. Other programs such as CasP or\n  PASS can calculate the energy deposited as a function\n  of the impact parameter of the ion; these results can be used\n  to derive the stopping power.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The fix_modify options are not supported.\n  This fix computes a global scalar, which can be accessed by various\n  output commands. The scalar is the total energy\n  loss from electronic stopping applied by this fix since the start of\n  the latest run. It is considered “intensive”.\n  The start/stop keywords of the run command have no effect\n  on this fix.\n  ",
    "syntax": "fix ID group-ID electron/stopping Ecut file keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  electron/stopping = style name of this fix command\n  Ecut = minimum kinetic energy for electronic stopping (energy units)\n  file = name of the file containing the electronic stopping power table\n  zero or more keyword/value pairs may be appended to args\n  keyword = region or minneigh\n  region value = region-ID\n    region-ID = region, whose atoms will be affected by this fix\n  minneigh value = minneigh\n    minneigh = minimum number of neighbors an atom to have stopping applied\n  \n  \n  ",
    "examples": "fix el all electron/stopping 10.0 elstop-table.txt\n  fix el all electron/stopping 10.0 elstop-table.txt minneigh 3\n  fix el mygroup electron/stopping 1.0 elstop-table.txt region bulk\n  \n  \n  ",
    "restrictions": "This pair style is part of the USER-MISC package. It is only enabled if\n  LAMMPS was built with that package. See the Build package\n  doc page for more info.\n  "
},
{
    "command": "fix enforce2d",
    "description": "Zero out the z-dimension velocity and force on each atom in the group.\n  This is useful when running a 2d simulation to insure that atoms do\n  not move from their initial z coordinate.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  The forces due to this fix are imposed during an energy minimization,\n  invoked by the minimize command.\n  ",
    "syntax": "fix ID group-ID enforce2d\n  \n  \n  \n  ID, group-ID are documented in fix command\n  enforce2d = style name of this fix command\n  \n  ",
    "examples": "fix 5 all enforce2d\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  Related commands: none\n  Default: none\n  "
},
{
    "command": "fix eos/cv",
    "description": "Fix eos/cv applies a mesoparticle equation of state to relate the\n  particle internal energy (\\(u_i\\)) to the particle internal temperature\n  (\\(\\theta_i\\)).  The eos/cv mesoparticle equation of state requires\n  the constant-volume heat capacity, and is defined as follows:\n  \n  \\[u_{i} = u^{mech}_{i} + u^{cond}_{i} = C_{V} \\theta_{i}\\]\n  where \\(C_V\\) is the constant-volume heat capacity, \\(u^{cond}\\)\n  is the internal conductive energy, and \\(u^{mech}\\) is the internal\n  mechanical energy.  Note that alternative definitions of the mesoparticle\n  equation of state are possible.\n  ",
    "syntax": "fix ID group-ID eos/cv cv\n  \n  \n  \n  ID, group-ID are documented in fix command\n  eos/cv = style name of this fix command\n  cv = constant-volume heat capacity (energy/temperature units)\n  \n  ",
    "examples": "fix 1 all eos/cv 0.01\n  \n  \n  ",
    "restrictions": "This command is part of the USER-DPD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  This command also requires use of the atom_style dpd\n  command.\n  "
},
{
    "command": "fix eos/table",
    "description": "Fix eos/table applies a tabulated mesoparticle equation of state to\n  relate the particle internal energy (u_i) to the particle internal\n  temperature (dpdTheta_i).\n  Fix eos/table creates interpolation tables of length N from\n  internal energy values listed in a file as a function of internal\n  temperature.\n  The interpolation tables are created by fitting cubic splines to the\n  file values and interpolating energy values at each of N internal\n  temperatures, and vice versa.  During a simulation, these tables are\n  used to interpolate internal energy or temperature values as needed.\n  The interpolation is done with the linear style.\n  For the linear style, the internal temperature is used to find 2\n  surrounding table values from which an internal energy is computed by\n  linear interpolation, and vice versa.\n  The filename specifies a file containing tabulated internal\n  temperature and internal energy values.  The keyword specifies a\n  section of the file.  The format of this file is described below.\n  \n  The format of a tabulated file is as follows (without the\n  parenthesized comments):\n  # EOS TABLE                (one or more comment or blank lines)\n  \n  KEYWORD                    (keyword is first text on line)\n  N 500                      (N  parameter)\n                             (blank)\n  1   1.00 0.000             (index, internal temperature, internal energy)\n  2   1.02 0.001\n  ...\n  500 10.0 0.500\n  \n  \n  A section begins with a non-blank line whose 1st character is not a\n  “#”; blank lines or lines starting with “#” can be used as comments\n  between sections.  The first line begins with a keyword which\n  identifies the section.  The line can contain additional text, but the\n  initial text must match the argument specified in the fix command.\n  The next line lists the number of table entries.  The parameter “N” is\n  required and its value is the number of table entries that follow.\n  Note that this may be different than the N specified in the fix eos/table command.  Let Ntable = N in the fix\n  command, and Nfile = “N” in the tabulated file.  What LAMMPS does is a\n  preliminary interpolation by creating splines using the Nfile\n  tabulated values as nodal points.  It uses these to interpolate as\n  needed to generate energy and temperature values at Ntable different\n  points.  The resulting tables of length Ntable are then used as\n  described above, when computing energy and temperature relationships.\n  This means that if you want the interpolation tables of length Ntable\n  to match exactly what is in the tabulated file (with effectively no\n  preliminary interpolation), you should set Ntable = Nfile.\n  Following a blank line, the next N lines list the tabulated values.\n  On each line, the 1st value is the index from 1 to N, the 2nd value is\n  the internal temperature (in temperature units), the 3rd value is the\n  internal energy (in energy units).\n  Note that the internal temperature and internal energy values must\n  increase from one line to the next.\n  Note that one file can contain many sections, each with a tabulated\n  potential.  LAMMPS reads the file section by section until it finds\n  one that matches the specified keyword.\n  ",
    "syntax": "fix ID group-ID eos/table style file N keyword\n  \n  \n  \n  ID, group-ID are documented in fix command\n  eos/table = style name of this fix command\n  style = linear = method of interpolation\n  file = filename containing the tabulated equation of state\n  N = use N values in linear tables\n  keyword = name of table keyword corresponding to table file\n  \n  ",
    "examples": "fix 1 all eos/table linear eos.table 100000 KEYWORD\n  \n  \n  ",
    "restrictions": "This command is part of the USER-DPD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  This command also requires use of the atom_style dpd\n  command.\n  The equation of state must be a monotonically increasing function.\n  An error will occur if the internal temperature or internal energies\n  are not within the table cutoffs.\n  "
},
{
    "command": "fix eos/table/rx",
    "description": "Fix eos/table/rx applies a tabulated mesoparticle equation\n  of state to relate the concentration-dependent particle internal\n  energy (\\(u_i\\)) to the particle internal temperature (\\(\\theta_i\\)).\n  The concentration-dependent particle internal energy (\\(u_i\\)) is\n  computed according to the following relation:\n  \n  \\[\\begin{split}U_{i} = \\displaystyle\\sum_{j=1}^{m} c_{i,j}(u_{j} + \\Delta H_{f,j}) + \\frac{3k_{b}T}{2} + Nk_{b}T \\\\\\end{split}\\]\n  where m is the number of species, \\(c_{i,j}\\) is the\n  concentration of species j in particle i, \\(u_j\\) is the\n  internal energy of species j, \\(\\Delta H_{f,j} is the heat of\n  formation of species *j*\\ , N is the number of molecules represented\n  by the coarse-grained particle, :math:\\) is the Boltzmann constant,\n  and T is the temperature of the system.  Additionally, it is\n  possible to modify the concentration-dependent particle internal\n  energy relation by adding an energy correction, temperature-dependent\n  correction, and/or a molecule-dependent correction.  An energy\n  correction can be specified as a constant (in energy units).  A\n  temperature correction can be specified by multiplying a temperature\n  correction coefficient by the internal temperature.  A molecular\n  correction can be specified by by multiplying a molecule correction\n  coefficient by the average number of product gas particles in the\n  coarse-grain particle.\n  Fix eos/table/rx creates interpolation tables of length N from m\n  internal energy values of each species \\(u_j\\) listed in a file as a\n  function of internal temperature.  During a simulation, these tables\n  are used to interpolate internal energy or temperature values as needed.\n  The interpolation is done with the linear style.  For the linear style,\n  the internal temperature is used to find 2 surrounding table values from\n  which an internal energy is computed by linear interpolation.  A secant\n  solver is used to determine the internal temperature from the internal energy.\n  The first filename specifies a file containing tabulated internal\n  temperature and m internal energy values for each species \\(u_j\\).\n  The keyword specifies a section of the file.  The format of this\n  file is described below.\n  The second filename specifies a file containing heat of formation\n  \\(\\Delta H_{f,j}\\) for each species.\n  In cases where the coarse-grain particle represents a single molecular\n  species (i.e., no reactions occur and fix rx is not present in the\n  input file), fix eos/table/rx can be applied in a similar manner to\n  fix eos/table within a non-reactive DPD simulation.  In this case,\n  the heat of formation filename is replaced with the heat of formation\n  value for the single species.  Additionally, the energy correction and\n  temperature correction coefficients may also be specified as fix\n  arguments.\n  \n  The format of a tabulated file is as follows (without the\n  parenthesized comments):\n  # EOS TABLE                (one or more comment or blank lines)\n  \n  KEYWORD                    (keyword is first text on line)\n  N 500 h2 no2 n2 ... no     (N  parameter species1 species2 ... speciesN)\n                             (blank)\n  1   1.00 0.000 ... 0.0000  (index, internal temperature, internal energy of species 1, ..., internal energy of species m)\n  2   1.02 0.001 ... 0.0002\n  ...\n  500 10.0 0.500 ... 1.0000\n  \n  \n  A section begins with a non-blank line whose 1st character is not a\n  “#”; blank lines or lines starting with “#” can be used as comments\n  between sections.  The first line begins with a keyword which\n  identifies the section.  The line can contain additional text, but the\n  initial text must match the argument specified in the fix command.\n  The next line lists the number of table entries and the species names\n  that correspond with all the species listed in the reaction equations\n  through the fix rx command.\n  The parameter “N” is required and its value is the number of table\n  entries that follow.  Let Nfile = “N” in the tabulated file.\n  What LAMMPS does is a preliminary interpolation by creating splines\n  using the Nfile tabulated values as nodal points.\n  Following a blank line, the next N lines list the tabulated values.\n  On each line, the 1st value is the index from 1 to N, the 2nd value is\n  the internal temperature (in temperature units), the 3rd value until\n  the m+3 value are the internal energies of the m species (in energy units).\n  Note that all internal temperature and internal energy values must\n  increase from one line to the next.\n  Note that one file can contain many sections, each with a tabulated\n  potential.  LAMMPS reads the file section by section until it finds\n  one that matches the specified keyword.\n  \n  The format of a heat of formation file is as follows (without the\n  parenthesized comments):\n  # HEAT OF FORMATION TABLE  (one or more comment or blank lines)\n  \n                             (blank)\n  h2      0.00               (species name, heat of formation)\n  no2     0.34\n  n2      0.00\n  ...\n  no      0.93\n  \n  \n  Note that the species can be listed in any order.  The tag that is\n  used as the species name must correspond with the tags used to define\n  the reactions with the fix rx command.\n  Alternatively, corrections to the EOS can be included by specifying\n  three additional columns that correspond to the energy correction,\n  the temperature correction coefficient and molecule correction\n  coefficient.  In this case, the format of the file is as follows:\n  # HEAT OF FORMATION TABLE     (one or more comment or blank lines)\n  \n                                (blank)\n  h2      0.00 1.23 0.025  0.0  (species name, heat of formation, energy correction, temperature correction coefficient, molecule correction coefficient)\n  no2     0.34 0.00 0.000 -1.76\n  n2      0.00 0.00 0.000 -1.76\n  ...\n  no      0.93 0.00 0.000 -1.76\n  \n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "fix ID group-ID eos/table/rx style file1 N keyword ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  eos/table/rx = style name of this fix command\n  style = linear = method of interpolation\n  file1 = filename containing the tabulated equation of state\n  N = use N values in linear tables\n  keyword = name of table keyword corresponding to table file\n  file2 = filename containing the heats of formation of each species (optional)\n  deltaHf = heat of formation for a single species in energy units (optional)\n  energyCorr = energy correction in energy units (optional)\n  tempCorrCoeff = temperature correction coefficient (optional)\n  \n  ",
    "examples": "fix 1 all eos/table/rx linear eos.table 10000 KEYWORD thermo.table\n  fix 1 all eos/table/rx linear eos.table 10000 KEYWORD 1.5\n  fix 1 all eos/table/rx linear eos.table 10000 KEYWORD 1.5 0.025 0.0\n  \n  \n  ",
    "restrictions": "This command is part of the USER-DPD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  This command also requires use of the atom_style dpd\n  command.\n  The equation of state must be a monotonically increasing function.\n  An error will occur if the internal temperature or internal energies\n  are not within the table cutoffs.\n  "
},
{
    "command": "fix evaporate",
    "description": "Remove M atoms from the simulation every N steps.  This can be used,\n  for example, to model evaporation of solvent particles or molecules\n  (i.e. drying) of a system.  Every N steps, the number of atoms in the\n  fix group and within the specified region are counted.  M of these are\n  chosen at random and deleted.  If there are less than M eligible\n  particles, then all of them are deleted.\n  If the setting for the molecule keyword is no, then only single\n  atoms are deleted.  In this case, you should insure you do not delete\n  only a portion of a molecule (only some of its atoms), or LAMMPS will\n  soon generate an error when it tries to find those atoms.  LAMMPS will\n  warn you if any of the atoms eligible for deletion have a non-zero\n  molecule ID, but does not check for this at the time of deletion.\n  If the setting for the molecule keyword is yes, then when an atom\n  is chosen for deletion, the entire molecule it is part of is deleted.\n  The count of deleted atoms is incremented by the number of atoms in\n  the molecule, which may make it exceed M.  If the molecule ID of the\n  chosen atom is 0, then it is assumed to not be part of a molecule, and\n  just the single atom is deleted.\n  As an example, if you wish to delete 10 water molecules every N\n  steps, you should set M to 30.  If only the water’s oxygen atoms\n  were in the fix group, then two hydrogen atoms would be deleted when\n  an oxygen atom is selected for deletion, whether the hydrogen atoms\n  are inside the evaporation region or not.\n  Note that neighbor lists are re-built on timesteps that atoms are\n  removed.  Thus you should not remove atoms too frequently or you will\n  incur overhead due to the cost of building neighbor lists.\n  \n  Note\n  If you are monitoring the temperature of a system where the atom\n  count is changing due to evaporation, you typically should use the\n  compute_modify dynamic yes command for the\n  temperature compute you are using.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.\n  This fix computes a global scalar, which can be accessed by various\n  output commands.  The scalar is the cumulative\n  number of deleted atoms.  The scalar value calculated by this fix is\n  “intensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID evaporate N M region-ID seed\n  \n  \n  \n  ID, group-ID are documented in fix command\n  evaporate = style name of this fix command\n  N = delete atoms every this many timesteps\n  M = number of atoms to delete each time\n  region-ID = ID of region within which to perform deletions\n  seed = random number seed to use for choosing atoms to delete\n  zero or more keyword/value pairs may be appended\n  keyword = molecule\n    molecule value = no or yes\n  \n  \n  ",
    "examples": "fix 1 solvent evaporate 1000 10 surface 49892\n  fix 1 solvent evaporate 1000 10 surface 38277 molecule yes\n  \n  \n  ",
    "restrictions": "This fix is part of the MISC package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "fix external",
    "description": "This fix allows external programs that are running LAMMPS through its\n  library interface to modify certain LAMMPS\n  properties on specific timesteps, similar to the way other fixes do.\n  The external driver can be a C/C++ or Fortran program or a Python script.\n  \n  If mode is pf/callback then the fix will make a callback every\n  Ncall timesteps or minimization iterations to the external program.\n  The external program computes forces on atoms by setting values in an\n  array owned by the fix.  The fix then adds these forces to each atom\n  in the group, once every Napply steps, similar to the way the fix addforce command works.  Note that if Ncall >\n  Napply, the force values produced by one callback will persist, and\n  be used multiple times to update atom forces.\n  The callback function “foo” is invoked by the fix as:\n  foo(void *ptr, bigint timestep, int nlocal, tagint *ids, double **x, double **fexternal);\n  \n  \n  The arguments are as follows:\n  \n  ptr = pointer provided by and simply passed back to external driver\n  timestep = current LAMMPS timestep\n  nlocal = # of atoms on this processor\n  ids = list of atom IDs on this processor\n  x = coordinates of atoms on this processor\n  fexternal = forces to add to atoms on this processor\n  \n  Note that timestep is a “bigint” which is defined in src/lmptype.h,\n  typically as a 64-bit integer. And ids is a pointer to type “tagint”\n  which is typically a 32-bit integer unless LAMMPS is compiled with\n  -DLAMMPS_BIGBIG. For more info please see the build settings section of the manual.  Finally, fexternal are the forces\n  returned by the driver program.\n  The fix has a set_callback() method which the external driver can call\n  to pass a pointer to its foo() function.  See the\n  couple/lammps_quest/lmpqst.cpp file in the LAMMPS distribution for an\n  example of how this is done.  This sample application performs\n  classical MD using quantum forces computed by a density functional\n  code Quest.\n  \n  If mode is pf/array then the fix simply stores force values in an\n  array.  The fix adds these forces to each atom in the group, once\n  every Napply steps, similar to the way the fix addforce command works.\n  The name of the public force array provided by the FixExternal\n  class is\n  double **fexternal;\n  \n  \n  It is allocated by the FixExternal class as an (N,3) array where N is\n  the number of atoms owned by a processor.  The 3 corresponds to the\n  fx, fy, fz components of force.\n  It is up to the external program to set the values in this array to\n  the desired quantities, as often as desired.  For example, the driver\n  program might perform an MD run in stages of 1000 timesteps each.  In\n  between calls to the LAMMPS run command, it could retrieve\n  atom coordinates from LAMMPS, compute forces, set values in fexternal,\n  etc.\n  \n  To use this fix during energy minimization, the energy corresponding\n  to the added forces must also be set so as to be consistent with the\n  added forces.  Otherwise the minimization will not converge correctly.\n  This can be done from the external driver by calling this public\n  method of the FixExternal class:\n  void set_energy(double eng);\n  \n  \n  where eng is the potential energy.  Eng is an extensive quantity,\n  meaning it should be the sum over per-atom energies of all affected\n  atoms.  It should also be provided in energy units\n  consistent with the simulation.  See the details below for how to\n  insure this energy setting is used appropriately in a minimization.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The fix_modify energy option is supported by this\n  fix to add the potential “energy” set by the external driver to the\n  system’s potential energy as part of thermodynamic output.  This is a fictitious quantity but is\n  needed so that the minimize command can include the\n  forces added by this fix in a consistent manner.  I.e. there is a\n  decrease in potential energy when atoms move in the direction of the\n  added force.\n  The fix_modify virial option is supported by this\n  fix to add the contribution due to the interactions computed by the\n  external program to the system’s virial as part of thermodynamic output. The default is virial yes\n  This fix computes a global scalar which can be accessed by various\n  output commands.  The scalar is the potential\n  energy discussed above.  The scalar stored by this fix is “extensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  The forces due to this fix are imposed during an energy minimization,\n  invoked by the minimize command.\n  \n  Note\n  If you want the fictitious potential energy associated with the\n  added forces to be included in the total potential energy of the\n  system (the quantity being minimized), you MUST enable the\n  fix_modify energy option for this fix.\n  \n  ",
    "syntax": "fix ID group-ID external mode args\n  \n  \n  \n  ID, group-ID are documented in fix command\n  external = style name of this fix command\n  mode = pf/callback or pf/array\n  pf/callback args = Ncall Napply\n    Ncall = make callback every Ncall steps\n    Napply = apply callback forces every Napply steps\n  pf/array args = Napply\n    Napply = apply array forces every Napply steps\n  \n  \n  ",
    "examples": "fix 1 all external pf/callback 1 1\n  fix 1 all external pf/callback 100 1\n  fix 1 all external pf/array 10\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  Related commands: none\n  Default: none\n  "
},
{
    "command": "fix ffl",
    "description": "Apply a Fast-Forward Langevin Equation (FFL) thermostat as described\n  in (Hijazi). Contrary to\n  fix langevin, this fix performs both\n  thermostatting and evolution of the Hamiltonian equations of motion, so it\n  should not be used together with fix nve – at least not\n  on the same atom groups.\n  The time-evolution of a single particle undergoing Langevin dynamics is described\n  by the equations\n  \n  \\[\\frac {dq}{dt} = \\frac{p}{m},\\]\n  \n  \\[\\frac {dp}{dt} = -\\gamma p + W + F,\\]\n  where \\(F\\) is the physical force, \\(\\gamma\\) is the friction coefficient, and \\(W\\) is a\n  Gaussian random force.\n  The friction coefficient is the inverse of the thermostat parameter : \\(\\gamma = 1/\\tau\\), with \\(\\tau\\) the thermostat parameter tau.\n  The thermostat parameter is given in the time units, \\(\\gamma\\) is in inverse time units.\n  Equilibrium sampling a temperature T is obtained by specifying the\n  target value as the Tstart and Tstop arguments, so that the internal\n  constants depending on the temperature are computed automatically.\n  The random number seed must be a positive integer.  A Marsaglia random\n  number generator is used.  Each processor uses the input seed to\n  generate its own unique seed and its own stream of random numbers.\n  Thus the dynamics of the system will not be identical on two runs on\n  different numbers of processors.\n  The flipping type flip-type can be chosen between 4 types described in\n  (Hijazi). The flipping operation occurs during the thermostatting\n  step and it flips the momenta of the atoms. If no_flip is chosen, no flip\n  will be executed and the integration will be the same as a standard\n  Langevin thermostat (Bussi). The other flipping types are : rescale - hard - soft.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  The instantaneous values of the extended variables are written to\n  binary restart files.  Because the state of the random\n  number generator is not saved in restart files, this means you cannot\n  do “exact” restarts with this fix, where the simulation continues on\n  the same as if no restart had taken place. However, in a statistical\n  sense, a restarted simulation should produce the same behavior.\n  Note however that you should use a different seed each time you\n  restart, otherwise the same sequence of random numbers will be used\n  each time, which might lead to stochastic synchronization and\n  subtle artifacts in the sampling.\n  This fix can ramp its target temperature over multiple runs, using the\n  start and stop keywords of the run command.  See the\n  run command for details of how to do this.\n  The fix_modify energy option is supported by this\n  fix to add the energy change induced by Langevin thermostatting to the\n  system’s potential energy as part of thermodynamic output.\n  This fix computes a global scalar which can be accessed by various\n  output commands.  The scalar is the cumulative\n  energy change due to this fix.  The scalar value calculated by this\n  fix is “extensive”.\n  ",
    "syntax": "fix ID id-group ffl tau Tstart Tstop seed [flip-type]\n  \n  \n  \n  ID, group-ID are documented in fix command\n  ffl = style name of this fix command\n  tau = thermostat parameter (positive real)\n  Tstart, Tstop = temperature ramp during the run\n  seed = random number seed to use for generating noise (positive integer)\n  one more value may be appended\n  flip-type  = determines the flipping type, can be chosen between rescale - no_flip - hard - soft, if no flip type is given, rescale will be chosen by default\n  \n  \n  \n  \n  ",
    "examples": "fix 3 boundary ffl 10 300 300 31415\n  fix 1 all ffl 100 500 500 9265 soft\n  \n  \n  ",
    "restrictions": "In order to perform constant-pressure simulations please use\n  fix press/berendsen, rather than\n  fix npt, to avoid duplicate integration of the\n  equations of motion.\n  This fix is part of the USER-MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "fix filter/corotate",
    "description": "This fix implements a corotational filter for a mollified impulse\n  method. In biomolecular simulations, it allows the usage of larger\n  timesteps for long-range electrostatic interactions.  For details, see\n  (Fath).\n  When using run_style respa for a biomolecular\n  simulation with high-frequency covalent bonds, the outer time-step is\n  restricted to below ~ 4fs due to resonance problems. This fix filters\n  the outer stage of the respa and thus a larger (outer) time-step can\n  be used. Since in large biomolecular simulations the computation of\n  the long-range electrostatic contributions poses a major bottleneck,\n  this can significantly accelerate the simulation.\n  The filter computes a cluster decomposition of the molecular structure\n  following the criteria indicated by the options a, b, t and m. This\n  process is similar to the approach in fix shake,\n  however, the clusters are not kept constrained. Instead, the position\n  is slightly modified only for the computation of long-range forces. A\n  good cluster decomposition constitutes in building clusters which\n  contain the fastest covalent bonds inside clusters.\n  If the clusters are chosen suitably, the run_style respa is stable for outer time-steps of at least 8fs.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about these fixes is written to binary restart files.  None of the fix_modify options\n  are relevant to these fixes.  No global or per-atom quantities are\n  stored by these fixes for access by various output commands.  No parameter of these fixes can be used\n  with the start/stop keywords of the run command.  These\n  fixes are not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID filter/corotate keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  one or more constraint/value pairs are appended\n  constraint = b or a or t or m\n  b values = one or more bond types\n  a values = one or more angle types\n  t values = one or more atom types\n  m value = one or more mass values\n  \n  \n  ",
    "examples": "timestep 8\n  run_style respa 3 2 8 bond 1 pair 2 kspace 3\n  fix cor all filter/corotate m 1.0\n  \n  fix cor all filter/corotate b 4 19 a 3 5 2\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-MISC package. It is only enabled if\n  LAMMPS was built with that package. See the Build package doc page for more info.\n  Currently, it does not support molecule templates.\n  "
},
{
    "command": "fix flow/gauss",
    "description": "This fix implements the Gaussian dynamics (GD) method to simulate a\n  system at constant mass flux (Strong). GD is a\n  nonequilibrium molecular dynamics simulation method that can be used\n  to study fluid flows through pores, pipes, and channels. In its\n  original implementation GD was used to compute the pressure required\n  to achieve a fixed mass flux through an opening.  The flux can be\n  conserved in any combination of the directions, x, y, or z, using\n  xflag,yflag,zflag. This fix does not initialize a net flux through a\n  system, it only conserves the center-of-mass momentum that is present\n  when the fix is declared in the input script. Use the\n  velocity command to generate an initial center-of-mass\n  momentum.\n  GD applies an external fluctuating gravitational field that acts as a\n  driving force to keep the system away from equilibrium. To maintain\n  steady state, a profile-unbiased thermostat must be implemented to\n  dissipate the heat that is added by the driving force. Compute temp/profile can be used to implement a\n  profile-unbiased thermostat.\n  A common use of this fix is to compute a pressure drop across a pipe,\n  pore, or membrane. The pressure profile can be computed in LAMMPS with\n  compute stress/atom and fix ave/chunk, or with the hardy method in fix atc. Note that the simple compute stress/atom method is only accurate away\n  from inhomogeneities in the fluid, such as fixed wall atoms. Further,\n  the computed pressure profile must be corrected for the acceleration\n  applied by GD before computing a pressure drop or comparing it to\n  other methods, such as the pump method (Zhu). The pressure\n  correction is discussed and described in (Strong).\n  For a complete example including the considerations discussed\n  above, see the examples/USER/flow_gauss directory.\n  \n  Note\n  Only the flux of the atoms in group-ID will be conserved. If the\n  velocities of the group-ID atoms are coupled to the velocities of\n  other atoms in the simulation, the flux will not be conserved. For\n  example, in a simulation with fluid atoms and harmonically constrained\n  wall atoms, if a single thermostat is applied to group all, the\n  fluid atom velocities will be coupled to the wall atom velocities, and\n  the flux will not be conserved. This issue can be avoided by\n  thermostatting the fluid and wall groups separately.\n  \n  Adding an acceleration to atoms does work on the system. This added\n  energy can be optionally subtracted from the potential energy for the\n  thermodynamic output (see below) to check that the timestep is small\n  enough to conserve energy. Since the applied acceleration is\n  fluctuating in time, the work cannot be computed from a potential. As\n  a result, computing the work is slightly more computationally\n  expensive than usual, so it is not performed by default. To invoke the\n  work calculation, use the energy keyword. The\n  fix_modify energy option also invokes the work\n  calculation, and overrides an energy no setting here. If neither\n  energy yes or fix_modify energy yes are set, the global scalar\n  computed by the fix will return zero.\n  \n  Note\n  In order to check energy conservation, any other fixes that do\n  work on the system must have fix_modify energy yes set as well. This\n  includes thermostat fixes and any constraints that hold the positions\n  of wall atoms fixed, such as fix spring/self.\n  \n  If this fix is used in a simulation with the rRESPA\n  integrator, the applied acceleration must be computed and applied at the same\n  rRESPA level as the interactions between the flowing fluid and the obstacle.\n  The rRESPA level at which the acceleration is applied can be changed using\n  the fix_modify respa option discussed below. If the\n  flowing fluid and the obstacle interact through multiple interactions that are\n  computed at different rRESPA levels, then there must be a separate flow/gauss\n  fix for each level. For example, if the flowing fluid and obstacle interact\n  through pairwise and long-range Coulomb interactions, which are computed at\n  rRESPA levels 3 and 4, respectively, then there must be two separate\n  flow/gauss fixes, one that specifies fix_modify respa 3 and one with\n  fix_modify respa 4.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  This fix is part of the USER-MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  No information about this fix is written to binary restart files.\n  The fix_modify energy option is supported by this\n  fix to subtract the work done from the\n  system’s potential energy as part of thermodynamic output.\n  The fix_modify respa option is supported by this\n  fix. This allows the user to set at which level of the rRESPA\n  integrator the fix computes and adds the external acceleration. Default is the\n  outermost level.\n  This fix computes a global scalar and a global 3-vector of forces,\n  which can be accessed by various output commands.\n  The scalar is the negative of the work done on the system, see above\n  discussion.  The vector is the total force that this fix applied to\n  the group of atoms on the current timestep.  The scalar and vector\n  values calculated by this fix are “extensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  ",
    "syntax": "fix ID group-ID flow/gauss xflag yflag zflag keyword\n  \n  \n  \n  ID, group-ID are documented in fix command\n  flow/gauss = style name of this fix command\n  xflag,yflag,zflag = 0 or 1\n  0 = do not conserve current in this dimension\n  1 = conserve current in this dimension\n  \n  \n  \n  zero or more keyword/value pairs may be appended\n  keyword = energy\n  energy value = no or yes\n    no = do not compute work done by this fix\n    yes = compute work done by this fix\n  \n  \n  ",
    "examples": "fix GD fluid flow/gauss 1 0 0\n  fix GD fluid flow/gauss 1 1 1 energy yes\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix freeze",
    "description": "Zero out the force and torque on a granular particle.  This is useful\n  for preventing certain particles from moving in a simulation.  The\n  granular pair styles also detect if this fix has been\n  defined and compute interactions between frozen and non-frozen\n  particles appropriately, as if the frozen particle has infinite mass.\n  A similar functionality for normal (point) particles can be obtained\n  using fix setforce.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.\n  This fix computes a global 3-vector of forces, which can be accessed\n  by various output commands.  This is the total\n  force on the group of atoms before the forces on individual atoms are\n  changed by the fix.  The vector values calculated by this fix are\n  “extensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID freeze\n  \n  \n  \n  ID, group-ID are documented in fix command\n  freeze = style name of this fix command\n  \n  ",
    "examples": "fix 2 bottom freeze\n  \n  \n  ",
    "restrictions": "This fix is part of the GRANULAR package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  There can only be a single freeze fix defined.  This is because other\n  the granular pair styles treat frozen particles\n  differently and need to be able to reference a single group to which\n  this fix is applied.\n  "
},
{
    "command": "fix gcmc",
    "description": "This fix performs grand canonical Monte Carlo (GCMC) exchanges of\n  atoms or molecules with an imaginary ideal gas\n  reservoir at the specified T and chemical potential (mu) as discussed\n  in (Frenkel). It also\n  attempts  Monte Carlo (MC) moves (translations and molecule\n  rotations) within the simulation cell or\n  region. If used with the fix nvt\n  command, simulations in the grand canonical ensemble (muVT, constant\n  chemical potential, constant volume, and constant temperature) can be\n  performed.  Specific uses include computing isotherms in microporous\n  materials, or computing vapor-liquid coexistence curves.\n  Every N timesteps the fix attempts both GCMC exchanges\n  (insertions or deletions) and MC moves of gas atoms or molecules.\n  On those timesteps, the average number of attempted GCMC exchanges is X,\n  while the average number of attempted MC moves is M.\n  For GCMC exchanges of either molecular or atomic gasses,\n  these exchanges can be either deletions or insertions,\n  with equal probability.\n  The possible choices for MC moves are translation of an atom,\n  translation of a molecule, and rotation of a molecule.\n  The relative amounts of each are determined by the optional\n  mcmoves keyword (see below).\n  The default behavior is as follows.\n  If the mol keyword is used, only molecule translations\n  and molecule rotations are performed with equal probability.\n  Conversely, if the mol keyword is not used, only atom\n  translations are performed.\n  M should typically be\n  chosen to be approximately equal to the expected number of gas atoms\n  or molecules of the given type within the simulation cell or region,\n  which will result in roughly one MC move per atom or molecule\n  per MC cycle.\n  All inserted particles are always added to two groups: the default\n  group “all” and the fix group specified in the fix command.\n  In addition, particles are also added to any groups\n  specified by the group and grouptype keywords.  If inserted\n  particles are individual atoms, they are assigned the atom type given\n  by the type argument.  If they are molecules, the type argument has no\n  effect and must be set to zero. Instead, the type of each atom in the\n  inserted molecule is specified in the file read by the\n  molecule command.\n  \n  Note\n  Care should be taken to apply fix gcmc only to\n  a group that contains only those atoms and molecules\n  that you wish to manipulate using Monte Carlo.\n  Hence it is generally not a good idea to specify\n  the default group “all” in the fix command, although it is allowed.\n  \n  This fix cannot be used to perform GCMC insertions of gas atoms or\n  molecules other than the exchanged type, but GCMC deletions,\n  and MC translations, and rotations can be performed on any atom/molecule in\n  the fix group.  All atoms in the simulation cell can be moved using\n  regular time integration translations, e.g. via fix nvt,\n  resulting in a hybrid GCMC+MD simulation. A smaller-than-usual\n  timestep size may be needed when running such a hybrid simulation,\n  especially if the inserted molecules are not well equilibrated.\n  This command may optionally use the region keyword to define an\n  exchange and move volume.  The specified region must have been\n  previously defined with a region command.  It must be\n  defined with side = in.  Insertion attempts occur only within the\n  specified region. For non-rectangular regions, random trial points are\n  generated within the rectangular bounding box until a point is found\n  that lies inside the region. If no valid point is generated after 1000\n  trials, no insertion is performed, but it is counted as an attempted\n  insertion.  Move and deletion attempt candidates are selected from gas\n  atoms or molecules within the region. If there are no candidates, no\n  move or deletion is performed, but it is counted as an attempt move or\n  deletion. If an attempted move places the atom or molecule\n  center-of-mass outside the specified region, a new attempted move is\n  generated. This process is repeated until the atom or molecule\n  center-of-mass is inside the specified region.\n  If used with fix nvt, the temperature of the imaginary\n  reservoir, T, should be set to be equivalent to the target temperature\n  used in fix nvt. Otherwise, the imaginary reservoir will not be in\n  thermal equilibrium with the simulation cell. Also, it is important\n  that the temperature used by fix nvt be dynamic/dof, which can be\n  achieved as follows:\n  compute mdtemp mdatoms temp\n  compute_modify mdtemp dynamic/dof yes\n  fix mdnvt mdatoms nvt temp 300.0 300.0 10.0\n  fix_modify mdnvt temp mdtemp\n  \n  \n  Note that neighbor lists are re-built every timestep that this fix is\n  invoked, so you should not set N to be too small.  However, periodic\n  rebuilds are necessary in order to avoid dangerous rebuilds and missed\n  interactions. Specifically, avoid performing so many MC translations\n  per timestep that atoms can move beyond the neighbor list skin\n  distance. See the neighbor command for details.\n  When an atom or molecule is to be inserted, its coordinates are chosen\n  at a random position within the current simulation cell or region, and\n  new atom velocities are randomly chosen from the specified temperature\n  distribution given by T. The effective temperature for new atom\n  velocities can be increased or decreased using the optional keyword\n  tfac_insert (see below). Relative coordinates for atoms in a\n  molecule are taken from the template molecule provided by the\n  user. The center of mass of the molecule is placed at the insertion\n  point. The orientation of the molecule is chosen at random by rotating\n  about this point.\n  Individual atoms are inserted, unless the mol keyword is used.  It\n  specifies a template-ID previously defined using the\n  molecule command, which reads a file that defines the\n  molecule.  The coordinates, atom types, charges, etc., as well as any\n  bonding and special neighbor information for the molecule can\n  be specified in the molecule file.  See the molecule\n  command for details.  The only settings required to be in this file\n  are the coordinates and types of atoms in the molecule.\n  When not using the mol keyword, you should ensure you do not delete\n  atoms that are bonded to other atoms, or LAMMPS will soon generate an\n  error when it tries to find bonded neighbors.  LAMMPS will warn you if\n  any of the atoms eligible for deletion have a non-zero molecule ID,\n  but does not check for this at the time of deletion.\n  If you wish to insert molecules using the mol keyword that will be\n  treated as rigid bodies, use the rigid keyword, specifying as its\n  value the ID of a separate fix rigid/small command\n  which also appears in your input script.\n  \n  Note\n  If you wish the new rigid molecules (and other rigid molecules)\n  to be thermostatted correctly via fix rigid/small/nvt\n  or fix rigid/small/npt, then you need to use the\n  “fix_modify dynamic/dof yes” command for the rigid fix.  This is to\n  inform that fix that the molecule count will vary dynamically.\n  \n  If you wish to insert molecules via the mol keyword, that will have\n  their bonds or angles constrained via SHAKE, use the shake keyword,\n  specifying as its value the ID of a separate fix shake command which also appears in your input script.\n  Optionally, users may specify the relative amounts of different MC\n  moves using the mcmoves keyword. The values Patomtrans,\n  Pmoltrans, Pmolrotate specify the average proportion of\n  atom translations, molecule translations, and molecule rotations,\n  respectively. The values must be non-negative integers or real\n  numbers, with at least one non-zero value. For example, (10,30,0)\n  would result in 25% of the MC moves being atomic translations, 75%\n  molecular translations, and no molecular rotations.\n  Optionally, users may specify the maximum rotation angle for molecular\n  rotations using the maxangle keyword and specifying the angle in\n  degrees. Rotations are performed by generating a random point on the\n  unit sphere and a random rotation angle on the range\n  [0,maxangle). The molecule is then rotated by that angle about an\n  axis passing through the molecule center of mass. The axis is parallel\n  to the unit vector defined by the point on the unit sphere.  The same\n  procedure is used for randomly rotating molecules when they are\n  inserted, except that the maximum angle is 360 degrees.\n  Note that fix gcmc does not use configurational bias MC or any other\n  kind of sampling of intramolecular degrees of freedom.  Inserted\n  molecules can have different orientations, but they will all have the\n  same intramolecular configuration, which was specified in the molecule\n  command input.\n  For atomic gasses, inserted atoms have the specified atom type, but\n  deleted atoms are any atoms that have been inserted or that already\n  belong to the fix group. For molecular gasses, exchanged\n  molecules use the same atom types as in the template molecule supplied\n  by the user.  In both cases, exchanged atoms/molecules are assigned to\n  two groups: the default group “all” and the fix group\n  (which can also be “all”).\n  The chemical potential is a user-specified input parameter defined\n  as:\n  \n  \\[\\mu = \\mu^{id} + \\mu^{ex}\\]\n  The second term mu_ex is the excess chemical potential due to\n  energetic interactions and is formally zero for the fictitious gas\n  reservoir but is non-zero for interacting systems. So, while the\n  chemical potential of the reservoir and the simulation cell are equal,\n  mu_ex is not, and as a result, the densities of the two are generally\n  quite different.  The first term mu_id is the ideal gas contribution\n  to the chemical potential.  mu_id can be related to the density or\n  pressure of the fictitious gas reservoir by:\n  \n  \\[\\begin{split}\\mu^{id}  = & k T \\ln{\\rho \\Lambda^3} \\\\\n            = & k T \\ln{\\frac{\\phi P \\Lambda^3}{k T}}\\end{split}\\]\n  where k is Boltzman’s constant, T is the user-specified\n  temperature, \\(\\rho\\) is the number density, P is the pressure,\n  and \\(\\phi\\) is the fugacity coefficient.  The constant\n  \\(\\Lambda\\) is required for dimensional consistency.  For all unit\n  styles except lj it is defined as the thermal de Broglie wavelength\n  \n  \\[\\Lambda = \\sqrt{ \\frac{h^2}{2 \\pi m k T}}\\]\n  where h is Planck’s constant, and m is the mass of the exchanged atom\n  or molecule.  For unit style lj, \\(\\Lambda\\) is simply set to\n  unity. Note that prior to March 2017, \\(\\Lambda\\) for unit style lj\n  was calculated using the above formula with h set to the rather specific\n  value of 0.18292026.  Chemical potential under the old definition can\n  be converted to an equivalent value under the new definition by\n  subtracting \\(3 k T \\ln(\\Lambda_{old})\\).\n  As an alternative to specifying mu directly, the ideal gas reservoir\n  can be defined by its pressure P using the pressure keyword, in\n  which case the user-specified chemical potential is ignored. The user\n  may also specify the fugacity coefficient \\(\\phi\\) using the\n  fugacity_coeff keyword, which defaults to unity.\n  The full_energy option means that the fix calculates the total\n  potential energy of the entire simulated system, instead of just\n  the energy of the part that is changed. The total system\n  energy before and after the proposed GCMC exchange or MC move\n  is then used in the\n  Metropolis criterion to determine whether or not to accept the\n  proposed change. By default, this option is off,\n  in which case only\n  partial energies are computed to determine the energy difference\n  due to the proposed change.\n  The full_energy option is needed for systems with complicated\n  potential energy calculations, including the following:\n  \n  long-range electrostatics (kspace)\n  many-body pair styles\n  hybrid pair styles\n  eam pair styles\n  tail corrections\n  need to include potential energy contributions from other fixes\n  \n  In these cases, LAMMPS will automatically apply the full_energy\n  keyword and issue a warning message.\n  When the mol keyword is used, the full_energy option also includes\n  the intramolecular energy of inserted and deleted molecules, whereas\n  this energy is not included when full_energy is not used. If this\n  is not desired, the intra_energy keyword can be used to define an\n  amount of energy that is subtracted from the final energy when a\n  molecule is inserted, and subtracted from the initial energy when a molecule\n  is deleted. For molecules that have a non-zero intramolecular energy,\n  this will ensure roughly the same behavior whether or not the\n  full_energy option is used.\n  Inserted atoms and molecules are assigned random velocities based on\n  the specified temperature T. Because the relative velocity of all\n  atoms in the molecule is zero, this may result in inserted molecules\n  that are systematically too cold. In addition, the intramolecular\n  potential energy of the inserted molecule may cause the kinetic energy\n  of the molecule to quickly increase or decrease after insertion.  The\n  tfac_insert keyword allows the user to counteract these effects by\n  changing the temperature used to assign velocities to inserted atoms\n  and molecules by a constant factor. For a particular application, some\n  experimentation may be required to find a value of tfac_insert that\n  results in inserted molecules that equilibrate quickly to the correct\n  temperature.\n  Some fixes have an associated potential energy. Examples of such fixes\n  include: efield, gravity,\n  addforce, langevin,\n  restrain,\n  temp/berendsen,\n  temp/rescale, and wall fixes.\n  For that energy to be included in the total potential energy of the\n  system (the quantity used when performing GCMC exchange and MC moves),\n  you MUST enable\n  the fix_modify energy option for that fix.  The\n  doc pages for individual fix commands specify if this\n  should be done.\n  Use the charge option to insert atoms with a user-specified point\n  charge. Note that doing so will cause the system to become\n  non-neutral.  LAMMPS issues a warning when using long-range\n  electrostatics (kspace) with non-neutral systems. See the compute group/group documentation for more details\n  about simulating non-neutral systems with kspace on.\n  Use of this fix typically will cause the number of atoms to fluctuate,\n  therefore, you will want to use the\n  compute_modify dynamic/dof command to insure that the\n  current number of atoms is used as a normalizing factor each time\n  temperature is computed. A simple example of this is:\n  compute_modify thermo_temp dynamic yes\n  \n  \n  A more complicated example is listed earlier on this page\n  in the context of NVT dynamics.\n  \n  Note\n  If the density of the cell is initially very small or zero, and\n  increases to a much larger density after a period of equilibration,\n  then certain quantities that are only calculated once at the start\n  (kspace parameters) may no longer be accurate.  The\n  solution is to start a new simulation after the equilibrium density\n  has been reached.\n  \n  With some pair_styles, such as Buckingham,\n  Born-Mayer-Huggins and ReaxFF, two\n  atoms placed close to each other may have an arbitrary large, negative\n  potential energy due to the functional form of the potential.  While\n  these unphysical configurations are inaccessible to typical dynamical\n  trajectories, they can be generated by Monte Carlo moves. The\n  overlap_cutoff keyword suppresses these moves by effectively\n  assigning an infinite positive energy to all new configurations that\n  place any pair of atoms closer than the specified overlap cutoff\n  distance.\n  The max and min keywords allow for the restriction of the number\n  of atoms in the simulation. They automatically reject all insertion\n  or deletion moves that would take the system beyond the set boundaries.\n  Should the system already be beyond the boundary, only moves that bring\n  the system closer to the bounds may be accepted.\n  The group keyword adds all inserted atoms to the\n  group of the group-ID value. The grouptype keyword\n  adds all inserted atoms of the specified type to the\n  group of the group-ID value.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  This fix writes the state of the fix to binary restart files.  This includes information about the random\n  number generator seed, the next timestep for MC exchanges,  the number\n  of MC step attempts and successes etc.  See\n  the read_restart command for info on how to\n  re-specify a fix in an input script that reads a restart file, so that\n  the operation of the fix continues in an uninterrupted fashion.\n  \n  Note\n  For this to work correctly, the timestep must not be changed\n  after reading the restart with reset_timestep.\n  The fix will try to detect it and stop with an error.\n  \n  None of the fix_modify options are relevant to this\n  fix.\n  This fix computes a global vector of length 8, which can be accessed\n  by various output commands.  The vector values are\n  the following global cumulative quantities:\n  \n  1 = translation attempts\n  2 = translation successes\n  3 = insertion attempts\n  4 = insertion successes\n  5 = deletion attempts\n  6 = deletion successes\n  7 = rotation attempts\n  8 = rotation successes\n  \n  The vector values calculated by this fix are “extensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID gcmc N X M type seed T mu displace keyword values ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  gcmc = style name of this fix command\n  N = invoke this fix every N steps\n  X = average number of GCMC exchanges to attempt every N steps\n  M = average number of MC moves to attempt every N steps\n  type = atom type for inserted atoms (must be 0 if mol keyword used)\n  seed = random # seed (positive integer)\n  T = temperature of the ideal gas reservoir (temperature units)\n  mu = chemical potential of the ideal gas reservoir (energy units)\n  displace = maximum Monte Carlo translation distance (length units)\n  zero or more keyword/value pairs may be appended to args\n  keyword = mol, region, maxangle, pressure, fugacity_coeff, full_energy, charge, group, grouptype, intra_energy, tfac_insert, or overlap_cutoff\n    mol value = template-ID\n      template-ID = ID of molecule template specified in a separate molecule command\n    mcmoves values = Patomtrans Pmoltrans Pmolrotate\n      Patomtrans = proportion of atom translation MC moves\n      Pmoltrans = proportion of molecule translation MC moves\n      Pmolrotate = proportion of molecule rotation MC moves\n    rigid value = fix-ID\n      fix-ID = ID of fix rigid/small command\n    shake value = fix-ID\n      fix-ID = ID of fix shake command\n    region value = region-ID\n      region-ID = ID of region where GCMC exchanges and MC moves are allowed\n    maxangle value = maximum molecular rotation angle (degrees)\n    pressure value = pressure of the gas reservoir (pressure units)\n    fugacity_coeff value = fugacity coefficient of the gas reservoir (unitless)\n    full_energy = compute the entire system energy when performing GCMC exchanges and MC moves\n    charge value = charge of inserted atoms (charge units)\n    group value = group-ID\n      group-ID = group-ID for inserted atoms (string)\n    grouptype values = type group-ID\n      type = atom type (int)\n      group-ID = group-ID for inserted atoms (string)\n    intra_energy value = intramolecular energy (energy units)\n    tfac_insert value = scale up/down temperature of inserted atoms (unitless)\n    overlap_cutoff value = maximum pair distance for overlap rejection (distance units)\n    max value = Maximum number of molecules allowed in the system\n    min value = Minimum number of molecules allowed in the system\n  \n  \n  ",
    "examples": "fix 2 gas gcmc 10 1000 1000 2 29494 298.0 -0.5 0.01\n  fix 3 water gcmc 10 100 100 0 3456543 3.0 -2.5 0.1 mol my_one_water maxangle 180 full_energy\n  fix 4 my_gas gcmc 1 10 10 1 123456543 300.0 -12.5 1.0 region disk\n  \n  \n  ",
    "restrictions": "This fix is part of the MC package.  It is only enabled if LAMMPS was\n  built with that package.  See the Build package\n  doc page for more info.\n  Do not set “neigh_modify once yes” or else this fix will never be\n  called.  Reneighboring is required.\n  Can be run in parallel, but aspects of the GCMC part will not scale\n  well in parallel. Only usable for 3D simulations.\n  When using fix gcmc in combination with fix shake or fix rigid,\n  only GCMC exchange moves are supported, so the argument\n  M must be zero.\n  Note that very lengthy simulations involving insertions/deletions of\n  billions of gas molecules may run out of atom or molecule IDs and\n  trigger an error, so it is better to run multiple shorter-duration\n  simulations. Likewise, very large molecules have not been tested and\n  may turn out to be problematic.\n  Use of multiple fix gcmc commands in the same input script can be\n  problematic if using a template molecule. The issue is that the\n  user-referenced template molecule in the second fix gcmc command may\n  no longer exist since it might have been deleted by the first fix gcmc\n  command. An existing template molecule will need to be referenced by\n  the user for each subsequent fix gcmc command.\n  "
},
{
    "command": "fix gld",
    "description": "Applies Generalized Langevin Dynamics to a group of atoms, as\n  described in (Baczewski).  This is intended to model the\n  effect of an implicit solvent with a temporally non-local dissipative\n  force and a colored Gaussian random force, consistent with the\n  Fluctuation-Dissipation Theorem.  The functional form of the memory\n  kernel associated with the temporally non-local force is constrained\n  to be a Prony series.\n  \n  Note\n  While this fix bears many similarities to fix langevin, it has one significant\n  difference. Namely, fix gld performs time integration,\n  whereas fix langevin does NOT. To this end, the\n  specification of another fix to perform time integration, such as fix nve, is NOT necessary.\n  \n  With this fix active, the force on the jth atom is given as\n  \n  \\[\\begin{split}{\\bf F}_{j}(t) = & {\\bf F}^C_j(t)-\\int \\limits_{0}^{t} \\Gamma_j(t-s) {\\bf v}_j(s)~\\text{d}s + {\\bf F}^R_j(t) \\\\\n  \\Gamma_j(t-s) = & \\sum \\limits_{k=1}^{N_k} \\frac{c_k}{\\tau_k} e^{-(t-s)/\\tau_k} \\\\\n  \\langle{\\bf F}^R_j(t),{\\bf F}^R_j(s)\\rangle = & \\text{k$_\\text{B}$T} ~\\Gamma_j(t-s)\\end{split}\\]\n  Here, the first term is representative of all conservative (pairwise,\n  bonded, etc) forces external to this fix, the second is the temporally\n  non-local dissipative force given as a Prony series, and the third is\n  the colored Gaussian random force.\n  The Prony series form of the memory kernel is chosen to enable an\n  extended variable formalism, with a number of exemplary mathematical\n  features discussed in (Baczewski). In particular, \\(3N_k\\)\n  extended variables are added to each atom, which effect the action of\n  the memory kernel without having to explicitly evaluate the integral\n  over time in the second term of the force. This also has the benefit\n  of requiring the generation of uncorrelated random forces, rather than\n  correlated random forces as specified in the third term of the force.\n  Presently, the Prony series coefficients are limited to being greater\n  than or equal to zero, and the time constants are limited to being\n  greater than zero. To this end, the value of series MUST be set to\n  pprony, for now. Future updates will allow for negative coefficients\n  and other representations of the memory kernel. It is with these\n  updates in mind that the series option was included.\n  The units of the Prony series coefficients are chosen to be mass per\n  time to ensure that the numerical integration scheme stably approaches\n  the Newtonian and Langevin limits. Details of these limits, and the\n  associated numerical concerns are discussed in\n  (Baczewski).\n  The desired temperature at each timestep is ramped from Tstart to\n  Tstop over the course of the next run.\n  The random # seed must be a positive integer. A Marsaglia random\n  number generator is used. Each processor uses the input seed to\n  generate its own unique seed and its own stream of random\n  numbers. Thus the dynamics of the system will not be identical on two\n  runs on different numbers of processors.\n  \n  The keyword/value option pairs are used in the following ways.\n  The keyword frozen can be used to specify how the extended variables\n  associated with the GLD memory kernel are initialized. Specifying no\n  (the default), the initial values are drawn at random from an\n  equilibrium distribution at Tstart, consistent with the\n  Fluctuation-Dissipation Theorem. Specifying yes, initializes the\n  extended variables to zero.\n  The keyword zero can be used to eliminate drift due to the\n  thermostat. Because the random forces on different atoms are\n  independent, they do not sum exactly to zero. As a result, this fix\n  applies a small random force to the entire system, and the\n  center-of-mass of the system undergoes a slow random walk. If the\n  keyword zero is set to yes, the total random force is set exactly\n  to zero by subtracting off an equal part of it from each atom in the\n  group. As a result, the center-of-mass of a system with zero initial\n  momentum will not drift over time.\n  \n  Restart, run start/stop, minimize info:\n  The instantaneous values of the extended variables are written to\n  binary restart files.  Because the state of the random\n  number generator is not saved in restart files, this means you cannot\n  do “exact” restarts with this fix, where the simulation continues on\n  the same as if no restart had taken place. However, in a statistical\n  sense, a restarted simulation should produce the same behavior.\n  None of the fix_modify options are relevant to this\n  fix.  No global or per-atom quantities are stored by this fix for\n  access by various output commands.\n  This fix can ramp its target temperature over multiple runs, using the\n  start and stop keywords of the run command.  See the\n  run command for details of how to do this.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID gld Tstart Tstop N_k seed series c_1 tau_1 ... c_N_k tau_N_k keyword values ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  gld = style name of this fix command\n  Tstart,Tstop = desired temperature at start/end of run (temperature units)\n  N_k = number of terms in the Prony series representation of the memory kernel\n  seed = random number seed to use for white noise (positive integer)\n  series = pprony is presently the only available option\n  c_k = the weight of the kth term in the Prony series (mass per time units)\n  tau_k = the time constant of the kth term in the Prony series (time units)\n  zero or more keyword/value pairs may be appended\n  keyword = frozen or zero\n    frozen value = no or yes\n      no = initialize extended variables using values drawn from equilibrium distribution at Tstart\n      yes = initialize extended variables to zero (i.e., from equilibrium distribution at zero temperature)\n    zero value = no or yes\n      no = do not set total random force to zero\n      yes = set total random force to zero\n  \n  \n  ",
    "examples": "fix 1 all gld 1.0 1.0 2 82885 pprony 0.5 1.0 1.0 2.0 frozen yes zero yes\n  fix 3 rouse gld 7.355 7.355 4 48823 pprony 107.1 0.02415 186.0 0.04294 428.6 0.09661 1714 0.38643\n  \n  \n  ",
    "restrictions": "This fix is part of the MISC package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "fix gle",
    "description": "Apply a Generalized Langevin Equation (GLE) thermostat as described\n  in (Ceriotti). The formalism allows one to obtain a number\n  of different effects ranging from efficient sampling of all\n  vibrational modes in the system to inexpensive (approximate)\n  modelling of nuclear quantum effects. Contrary to\n  fix langevin, this fix performs both\n  thermostatting and evolution of the Hamiltonian equations of motion, so it\n  should not be used together with fix nve – at least not\n  on the same atom groups.\n  Each degree of freedom in the thermostatted group is supplemented\n  with Ns additional degrees of freedom s, and the equations of motion\n  become\n  dq/dt=p/m\n  d(p,s)/dt=(F,0) - A(p,s) + B dW/dt\n  \n  \n  where F is the physical force, A is the drift matrix (that generalizes\n  the friction in Langevin dynamics), B is the diffusion term and dW/dt\n  un-correlated Gaussian random forces. The A matrix couples the physical\n  (q,p) dynamics with that of the additional degrees of freedom,\n  and makes it possible to obtain effectively a history-dependent\n  noise and friction kernel.\n  The drift matrix should be given as an external file Afile,\n  as a (Ns+1 x Ns+1) matrix in inverse time units. Matrices that are\n  optimal for a given application and the system of choice can be\n  obtained from (GLE4MD).\n  Equilibrium sampling a temperature T is obtained by specifying the\n  target value as the Tstart and Tstop arguments, so that the diffusion\n  matrix that gives canonical sampling for a given A is computed automatically.\n  However, the GLE framework also allow for non-equilibrium sampling, that\n  can be used for instance to model inexpensively zero-point energy\n  effects (Ceriotti2). This is achieved specifying the noneq\n  keyword followed by the name of the file that contains the static covariance\n  matrix for the non-equilibrium dynamics.  Please note, that the covariance\n  matrix is expected to be given in temperature units.\n  Since integrating GLE dynamics can be costly when used together with\n  simple potentials, one can use the every optional keyword to\n  apply the Langevin terms only once every several MD steps, in a\n  multiple time-step fashion. This should be used with care when doing\n  non-equilibrium sampling, but should have no effect on equilibrium\n  averages when using canonical sampling.\n  The random number seed must be a positive integer.  A Marsaglia random\n  number generator is used.  Each processor uses the input seed to\n  generate its own unique seed and its own stream of random numbers.\n  Thus the dynamics of the system will not be identical on two runs on\n  different numbers of processors.\n  Note also that the Generalized Langevin Dynamics scheme that is\n  implemented by the fix gld scheme is closely related\n  to the present one. In fact, it should be always possible to cast the\n  Prony series form of the memory kernel used by GLD into an appropriate\n  input matrix for fix gle. While the GLE scheme is more\n  general, the form used by fix gld can be more directly\n  related to the representation of an implicit solvent environment.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  The instantaneous values of the extended variables are written to\n  binary restart files.  Because the state of the random\n  number generator is not saved in restart files, this means you cannot\n  do “exact” restarts with this fix, where the simulation continues on\n  the same as if no restart had taken place. However, in a statistical\n  sense, a restarted simulation should produce the same behavior.\n  Note however that you should use a different seed each time you\n  restart, otherwise the same sequence of random numbers will be used\n  each time, which might lead to stochastic synchronization and\n  subtle artifacts in the sampling.\n  This fix can ramp its target temperature over multiple runs, using the\n  start and stop keywords of the run command.  See the\n  run command for details of how to do this.\n  The fix_modify energy option is supported by this\n  fix to add the energy change induced by Langevin thermostatting to the\n  system’s potential energy as part of thermodynamic output.\n  This fix computes a global scalar which can be accessed by various\n  output commands.  The scalar is the cumulative\n  energy change due to this fix.  The scalar value calculated by this\n  fix is “extensive”.\n  ",
    "syntax": "fix ID id-group gle Ns Tstart Tstop seed Amatrix [noneq Cmatrix] [every stride]\n  \n  \n  \n  ID, group-ID are documented in fix command\n  gle = style name of this fix command\n  Ns = number of additional fictitious momenta\n  Tstart, Tstop = temperature ramp during the run\n  Amatrix = file to read the drift matrix A from\n  seed = random number seed to use for generating noise (positive integer)\n  zero or more keyword/value pairs may be appended\n  keyword = noneq or every\n    noneq Cmatrix  = file to read the non-equilibrium covariance matrix from\n    every stride   = apply the GLE once every time steps. Reduces the accuracy\n        of the integration of the GLE, but has *no effect* on the accuracy of equilibrium\n        sampling. It might change sampling properties when used together with noneq.\n  \n  \n  ",
    "examples": "fix 3 boundary gle 6 300 300 31415 smart.A\n  fix 1 all gle 6 300 300 31415 qt-300k.A noneq qt-300k.C\n  \n  \n  ",
    "restrictions": "The GLE thermostat in its current implementation should not be used\n  with rigid bodies, SHAKE or RATTLE. It is expected that all the\n  thermostatted degrees of freedom are fully flexible, and the sampled\n  ensemble will not be correct otherwise.\n  In order to perform constant-pressure simulations please use\n  fix press/berendsen, rather than\n  fix npt, to avoid duplicate integration of the\n  equations of motion.\n  This fix is part of the USER-MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "fix gravity",
    "description": "Impose an additional acceleration on each particle in the group.  This\n  fix is typically used with granular systems to include a “gravity”\n  term acting on the macroscopic particles.  More generally, it can\n  represent any kind of driving field, e.g. a pressure gradient inducing\n  a Poiseuille flow in a fluid.  Note that this fix operates differently\n  than the fix addforce command.  The addforce fix\n  adds the same force to each atom, independent of its mass.  This\n  command imparts the same acceleration to each atom (force/mass).\n  The magnitude of the acceleration is specified in force/mass units.\n  For granular systems (LJ units) this is typically 1.0.  See the\n  units command for details.\n  Style chute is typically used for simulations of chute flow where\n  the specified angle is the chute angle, with flow occurring in the +x\n  direction.  For 3d systems, the tilt is away from the z axis; for 2d\n  systems, the tilt is away from the y axis.\n  Style spherical allows an arbitrary 3d direction to be specified for\n  the acceleration vector.  Phi and theta are defined in the usual\n  spherical coordinates.  Thus for acceleration acting in the -z\n  direction, theta would be 180.0 (or -180.0).  Theta = 90.0 and\n  phi = -90.0 would mean acceleration acts in the -y direction.  For\n  2d systems, phi is ignored and theta is an angle in the xy plane\n  where theta = 0.0 is the y-axis.\n  Style vector imposes an acceleration in the vector direction given\n  by (x,y,z).  Only the direction of the vector is important; it’s\n  length is ignored.  For 2d systems, the z component is ignored.\n  Any of the quantities magnitude, angle, phi, theta, x, y,\n  z which define the gravitational magnitude and direction, can be\n  specified as an equal-style variable.  If the value is\n  a variable, it should be specified as v_name, where name is the\n  variable name.  In this case, the variable will be evaluated each\n  timestep, and its value used to determine the quantity.  You should\n  insure that the variable calculates a result in the appropriate units,\n  e.g. force/mass or degrees.\n  Equal-style variables can specify formulas with various mathematical\n  functions, and include thermo_style command\n  keywords for the simulation box parameters and timestep and elapsed\n  time.  Thus it is easy to specify a time-dependent gravitational\n  field.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The fix_modify energy option is supported by this\n  fix to add the gravitational potential energy of the system to the\n  system’s potential energy as part of thermodynamic output.\n  The fix_modify respa option is supported by this\n  fix. This allows to set at which level of the r-RESPA\n  integrator the fix is adding its forces. Default is the outermost level.\n  This fix computes a global scalar which can be accessed by various\n  output commands.  This scalar is the gravitational\n  potential energy of the particles in the defined field, namely mass *\n  (g dot x) for each particles, where x and mass are the particles\n  position and mass, and g is the gravitational field.  The scalar value\n  calculated by this fix is “extensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group gravity magnitude style args\n  \n  \n  \n  ID, group are documented in fix command\n  gravity = style name of this fix command\n  magnitude = size of acceleration (force/mass units)\n  magnitude can be a variable (see below)\n  style = chute or spherical or gradient or vector\n  chute args = angle\n    angle = angle in +x away from -z or -y axis in 3d/2d (in degrees)\n    angle can be a variable (see below)\n  spherical args = phi theta\n    phi = azimuthal angle from +x axis (in degrees)\n    theta = angle from +z or +y axis in 3d/2d (in degrees)\n    phi or theta can be a variable (see below)\n  vector args = x y z\n    x y z = vector direction to apply the acceleration\n    x or y or z can be a variable (see below)\n  \n  \n  ",
    "examples": "fix 1 all gravity 1.0 chute 24.0\n  fix 1 all gravity v_increase chute 24.0\n  fix 1 all gravity 1.0 spherical 0.0 -180.0\n  fix 1 all gravity 10.0 spherical v_phi v_theta\n  fix 1 all gravity 100.0 vector 1 1 0\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix grem",
    "description": "This fix implements the molecular dynamics version of the generalized\n  replica exchange method (gREM) originally developed by (Kim),\n  which uses non-Boltzmann ensembles to sample over first order phase\n  transitions. The is done by defining replicas with an enthalpy\n  dependent effective temperature\n  \n  \\[T_{eff} = \\lambda + \\eta (H - H_0)\\]\n  with \\(\\eta\\) negative and steep enough to only intersect the\n  characteristic microcanonical temperature (Ts) of the system once,\n  ensuring a unimodal enthalpy distribution in that replica.\n  \\(\\lambda\\) is the intercept and effects the generalized ensemble\n  similar to how temperature effects a Boltzmann ensemble. \\(H_0\\)\n  is a reference enthalpy, and is typically set as the lowest desired\n  sampled enthalpy.  Further explanation can be found in our recent\n  papers (Malolepsza).\n  This fix requires a Nose-Hoover thermostat fix reference passed to the\n  grem as thermostat-ID. Two distinct temperatures exist in this\n  generalized ensemble, the effective temperature defined above, and a\n  kinetic temperature that controls the velocity distribution of\n  particles as usual. Either constant volume or constant pressure\n  algorithms can be used.\n  The fix enforces a generalized ensemble in a single replica\n  only. Typically, this ideology is combined with replica exchange with\n  replicas differing by \\(\\lambda\\) only for simplicity, but this is not\n  required. A multi-replica simulation can be run within the LAMMPS\n  environment using the temper/grem command. This\n  utilizes LAMMPS partition mode and requires the number of available\n  processors be on the order of the number of desired replicas. A\n  100-replica simulation would require at least 100 processors (1 per\n  world at minimum). If many replicas are needed on a small number of\n  processors, multi-replica runs can be run outside of LAMMPS.  An\n  example of this can be found in examples/USER/misc/grem and has no\n  limit on the number of replicas per processor. However, this is very\n  inefficient and error prone and should be avoided if possible.\n  In general, defining the generalized ensembles is unique for every\n  system. When starting a many-replica simulation without any knowledge\n  of the underlying microcanonical temperature, there are several tricks\n  we have utilized to optimize the process.  Choosing a less-steep\n  \\(\\eta\\) yields broader distributions, requiring fewer replicas to\n  map the microcanonical temperature.  While this likely struggles from\n  the same sampling problems gREM was built to avoid, it provides quick\n  insight to Ts.  Initially using an evenly-spaced \\(\\lambda\\)\n  distribution identifies regions where small changes in enthalpy lead\n  to large temperature changes. Replicas are easily added where needed.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The thermo_modify press option is supported\n  by this fix to add the rescaled kinetic pressure as part of\n  thermodynamic output.\n  ",
    "syntax": "fix ID group-ID grem lambda eta H0 thermostat-ID\n  \n  \n  \n  ID, group-ID are documented in fix command\n  grem = style name of this fix command\n  lambda = intercept parameter of linear effective temperature function\n  eta = slope parameter of linear effective temperature function\n  H0 = shift parameter of linear effective temperature function\n  thermostat-ID = ID of Nose-Hoover thermostat or barostat used in simulation\n  \n  ",
    "examples": "fix             fxgREM all grem 400 -0.01 -30000 fxnpt\n  thermo_modify   press fxgREM_press\n  \n  fix             fxgREM all grem 502 -0.15 -80000 fxnvt\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-MISC package. It is only enabled if\n  LAMMPS was built with that package. See the Build package doc page for more info.\n  "
},
{
    "command": "fix halt",
    "description": "Check a condition every N steps during a simulation run.  N must be >=1.\n  If the condition is met, exit the run.  In this context a “run” can be\n  dynamics or minimization iterations, as specified by the run or minimize command.\n  The specified group-ID is ignored by this fix.\n  The specified attribute can be one of the options listed above, namely\n  bondmax, tlimit, diskfree, or an equal-style variable referenced as v_name, where “name” is the name of a\n  variable that has been defined previously in the input script.\n  The bondmax attribute will loop over all bonds in the system,\n  compute their current lengths, and set attribute to the longest bond\n  distance.\n  The tlimit attribute queries the elapsed CPU time (in seconds) since\n  the current run began, and sets attribute to that value.  This is an\n  alternative way to limit the length of a simulation run, similar to\n  the timer timeout command.  There are two differences in\n  using this method versus the timer command option.  The first is that\n  the clock starts at the beginning of the current run (not when the\n  timer or fix command is specified), so that any setup time for the run\n  is not included in the elapsed time.  The second is that the timer\n  invocation and syncing across all processors (via MPI_Allreduce) is\n  not performed once every N steps by this command.  Instead it is\n  performed (typically) only a small number of times and the elapsed\n  times are used to predict when the end-of-the-run will be.  Both of\n  these attributes can be useful when performing benchmark calculations\n  for a desired length of time with minimal overhead.  For example, if\n  a run is performing 1000s of timesteps/sec, the overhead for syncing\n  the timer frequently across a large number of processors may be\n  non-negligible.\n  The diskfree attribute will check for available disk space (in\n  megabytes) on supported operating systems. By default it will\n  check the file system of the current working directory.  This\n  can be changed with the optional path keyword, which will take\n  the path to a file or folder on the file system to be checked\n  as argument.  This path must be given with single or double quotes,\n  if it contains blanks or other special characters (like $).\n  Equal-style variables evaluate to a numeric value.  See the\n  variable command for a description.  They calculate\n  formulas which can involve mathematical operations, atom properties,\n  group properties, thermodynamic properties, global values calculated\n  by a compute or fix, or references to other\n  variables.  Thus they are a very general means of\n  computing some attribute of the current system.  For example, the\n  following “bondmax” variable will calculate the same quantity as the\n  hstyle = bondmax option.\n  compute         bdist all bond/local dist\n  compute         bmax all reduce max c_bdist\n  variable        bondmax equal c_bmax\n  \n  \n  Thus these two versions of a fix halt command will do the same thing:\n  fix 10 all halt 1 bondmax > 1.5\n  fix 10 all halt 1 v_bondmax > 1.5\n  \n  \n  The version with “bondmax” will just run somewhat faster, due to less\n  overhead in computing bond lengths and not storing them in a separate\n  compute.\n  The choice of operators listed above are the usual comparison\n  operators.  The XOR operation (exclusive or) is also included as “|^”.\n  In this context, XOR means that if either the attribute or avalue is\n  0.0 and the other is non-zero, then the result is “true”.  Otherwise\n  it is “false”.\n  The specified avalue must be a numeric value.\n  \n  The optional error keyword determines how the current run is halted.\n  If its value is hard, then LAMMPS will stop with an error message.\n  If its value is soft, LAMMPS will exit the current run, but continue\n  to execute subsequent commands in the input script.  However,\n  additional run or minimize commands will be\n  skipped.  For example, this allows a script to output the current\n  state of the system, e.g. via a write_dump or\n  write_restart command.\n  If its value is continue, the behavior is the same as for soft,\n  except subsequent run or minimize commands\n  are executed.  This allows your script to remedy the condition that\n  triggered the halt, if necessary.  Note that you may wish use the\n  unfix command on the fix halt ID, so that the same\n  condition is not immediately triggered in a subsequent run.\n  The optional message keyword determines whether a message is printed\n  to the screen and logfile when the halt condition is triggered.  If\n  message is set to yes, a one line message with the values that\n  triggered the halt is printed.  If message is set to no, no message\n  is printed; the run simply exits.  The latter may be desirable for\n  post-processing tools that extract thermodynamic information from log\n  files.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  ",
    "syntax": "fix ID group-ID halt N attribute operator avalue keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  halt = style name of this fix command\n  N = check halt condition every N steps\n  attribute = bondmax or tlimit or v_name\n  bondmax = length of longest bond in the system (in length units)\n  tlimit = elapsed CPU time (in seconds)\n  diskfree = free disk space (in megabytes)\n  v_name = name of equal-style variable\n  \n  operator = “<” or “<=” or “>” or “>=” or “==” or “!=” or “|^”\n  avalue = numeric value to compare attribute to\n  zero or more keyword/value pairs may be appended\n  keyword = error or message or path\n  error value = hard or soft or continue\n  message value = yes or no\n  path value = path to check for free space (may be in quotes)\n  \n  \n  ",
    "examples": "fix 10 all halt 1 bondmax > 1.5\n  fix 10 all halt 10 v_myCheck != 0 error soft\n  fix 10 all halt 100 diskfree < 100000.0 path \"dump storage/.\"\n  \n  \n  ",
    "restrictions": "The diskfree attribute is currently only supported on Linux and MacOS.\n  "
},
{
    "command": "fix heat",
    "description": "Add non-translational kinetic energy (heat) to a group of atoms in a\n  manner that conserves their aggregate momentum.  Two of these fixes\n  can be used to establish a temperature gradient across a simulation\n  domain by adding heat (energy) to one group of atoms (hot reservoir)\n  and subtracting heat from another (cold reservoir).  E.g. a simulation\n  sampling from the McDLT ensemble.\n  If the region keyword is used, the atom must be in both the group\n  and the specified geometric region in order to have\n  energy added or subtracted to it.  If not specified, then the atoms in\n  the group are affected wherever they may move to.\n  Heat addition/subtraction is performed every N timesteps.  The eflux\n  parameter can be specified as a numeric constant or as a variable (see\n  below).  If it is a numeric constant or equal-style variable which\n  evaluates to a scalar value, then the eflux determines the change in\n  aggregate energy of the entire group of atoms per unit time, e.g. in\n  eV/psec for metal units.  In this case it is an\n  “extensive” quantity, meaning its magnitude should be scaled with the\n  number of atoms in the group.  Note that since eflux has per-time\n  units (i.e. it is a flux), this means that a larger value of N will\n  add/subtract a larger amount of energy each time the fix is invoked.\n  \n  Note\n  The heat-exchange (HEX) algorithm implemented by this fix is\n  known to exhibit a pronounced energy drift. An improved algorithm\n  (eHEX) is available as a fix ehex command and might be\n  preferable if energy conservation is important.\n  \n  If eflux is specified as an atom-style variable (see below), then\n  the variable computes one value per atom.  In this case, each value is\n  the energy flux for a single atom, again in units of energy per unit\n  time.  In this case, each value is an “intensive” quantity, which need\n  not be scaled with the number of atoms in the group.\n  As mentioned above, the eflux parameter can be specified as an\n  equal-style or atom_style variable.  If the value is a\n  variable, it should be specified as v_name, where name is the variable\n  name.  In this case, the variable will be evaluated each timestep, and\n  its value(s) used to determine the flux.\n  Equal-style variables can specify formulas with various mathematical\n  functions, and include thermo_style command\n  keywords for the simulation box parameters and timestep and elapsed\n  time.  Thus it is easy to specify a time-dependent flux.\n  Atom-style variables can specify the same formulas as equal-style\n  variables but can also include per-atom values, such as atom\n  coordinates.  Thus it is easy to specify a spatially-dependent flux\n  with optional time-dependence as well.\n  \n  Note\n  If heat is subtracted from the system too aggressively so that\n  the group’s kinetic energy would go to zero, or any individual atom’s\n  kinetic energy would go to zero for the case where eflux is an\n  atom-style variable, then LAMMPS will halt with an error message.\n  \n  Fix heat is different from a thermostat such as fix nvt\n  or fix temp/rescale in that energy is\n  added/subtracted continually.  Thus if there is not another mechanism\n  in place to counterbalance this effect, the entire system will heat or\n  cool continuously.  You can use multiple heat fixes so that the net\n  energy change is 0.0 or use fix viscous to drain\n  energy from the system.\n  This fix does not change the coordinates of its atoms; it only scales\n  their velocities.  Thus you must still use an integration fix\n  (e.g. fix nve) on the affected atoms.  This fix should\n  not normally be used on atoms that have their temperature controlled\n  by another fix - e.g. fix nvt or fix langevin fix.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.\n  This fix computes a global scalar which can be accessed by various\n  output commands.  This scalar is the most recent\n  value by which velocities were scaled.  The scalar value calculated by\n  this fix is “intensive”.  If eflux is specified as an atom-style\n  variable, this fix computes the average value by which the velocities\n  were scaled for all of the atoms that had their velocities scaled.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID heat N eflux\n  \n  \n  \n  ID, group-ID are documented in fix command\n  heat = style name of this fix command\n  N = add/subtract heat every this many timesteps\n  eflux = rate of heat addition or subtraction (energy/time units)\n  eflux can be a variable (see below)\n  zero or more keyword/value pairs may be appended to args\n  keyword = region\n  region value = region-ID\n    region-ID = ID of region atoms must be in to have added force\n  \n  \n  ",
    "examples": "fix 3 qin heat 1 1.0\n  fix 3 qin heat 10 v_flux\n  fix 4 qout heat 1 -1.0 region top\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix hyper/global",
    "description": "This fix is meant to be used with the hyper command to\n  perform a bond-boost global hyperdynamics (GHD) simulation.  The role\n  of this fix is to a select a single pair of atoms in the system at\n  each timestep to add a global bias potential to, which will alter the\n  dynamics of the system in a manner that effectively accelerates time.\n  This is in contrast to the fix hyper/local\n  command, which can be user to perform a local hyperdynamics (LHD)\n  simulation, by adding a local bias potential to multiple pairs of\n  atoms at each timestep.  GHD can time accelerate a small simulation\n  with up to a few 100 atoms.  For larger systems, LHD is needed to\n  achieve good time acceleration.\n  For a system that undergoes rare transition events, where one or more\n  atoms move over an energy barrier to a new potential energy basin, the\n  effect of the bias potential is to induce more rapid transitions.\n  This can lead to a dramatic speed-up in the rate at which events\n  occurs, without altering their relative frequencies, thus leading to\n  an overall increase in the elapsed real time of the simulation as\n  compared to running for the same number of timesteps with normal MD.\n  See the hyper doc page for a more general discussion of\n  hyperdynamics and citations that explain both GHD and LHD.\n  The equations and logic used by this fix and described here to perform\n  GHD follow the description given in (Voter2013).  The\n  bond-boost form of a bias potential for HD is due to Miron and\n  Fichthorn as described in (Miron).  In LAMMPS we use a\n  simplified version of bond-boost GHD where a single bond in the system\n  is biased at any one timestep.\n  Bonds are defined between each pair of atoms ij, whose \\(R^0_{ij}\\)\n  distance is less than cutbond, when the system is in a quenched state\n  (minimum) energy.  Note that these are not “bonds” in a covalent\n  sense.  A bond is simply any pair of atoms that meet the distance\n  criterion.  Cutbond is an argument to this fix; it is discussed\n  below.  A bond is only formed if one or both of the ij atoms are in\n  the specified group.\n  The current strain of bond ij (when running dynamics) is defined as\n  \n  \\[E_{ij} = \\frac{R_{ij} - R^0_{ij}}{R^0_{ij}}\\]\n  where \\(R_{ij}\\) is the current distance between atoms i and j,\n  and \\(R^0_{ij}\\) is the equilibrium distance in the quenched state.\n  The bias energy \\(V_{ij}\\) of any bond between atoms i and j\n  is defined as\n  \n  \\[V_{ij} = V^{max} \\cdot \\left( 1 - \\left(\\frac{E_{ij}}{q}\\right)^2 \\right) \\textrm{ for } \\left|E_{ij}\\right| < qfactor \\textrm{ or } 0 \\textrm{ otherwise}\\]\n  where the prefactor \\(V^{max}\\) and the cutoff qfactor are arguments to\n  this fix; they are discussed below.  This functional form is an\n  inverse parabola centered at 0.0 with height \\(V^{max}\\) and\n  which goes to 0.0 at +/- qfactor.\n  Let \\(E^{max}\\) be the maximum of \\(\\left| E_{ij} \\right|\\)\n  for all ij bonds in the system on a\n  given timestep.  On that step, \\(V_{ij}\\) is added as a bias potential\n  to only the single bond with strain \\(E^{max}\\), call it\n  \\(V^{max}_{ij}\\).  Note that \\(V^{max}_{ij}\\) will be 0.0\n  if \\(E^{max} >= \\textrm{qfactor}\\) on that timestep.  Also note\n  that \\(V^{max}_{ij}\\) is added to the normal interatomic potential\n  that is computed between all atoms in the system at every step.\n  The derivative of \\(V^{max}_{ij}\\) with respect to the position of\n  each atom in the \\(E^{max}\\) bond gives a bias force\n  \\(F^{max}_{ij}\\) acting on the bond as\n  \n  \\[F^{max}_{ij} = - \\frac{dV^{max}_{ij}}{dE_{ij}} = \\frac{2 V^{max} E-{ij}}{\\textrm{qfactor}^2}   \\textrm{ for } \\left|E_{ij}\\right| < \\textrm{qfactor} \\textrm{ or } 0 \\textrm{ otherwise}\\]\n  which can be decomposed into an equal and opposite force acting on\n  only the two ij atoms in the \\(E^{max}\\) bond.\n  The time boost factor for the system is given each timestep I by\n  \n  \\[B_i = e^{\\beta V^{max}_{ij}}\\]\n  where \\(\\beta = \\frac{1}{kT_{equil}}\\), and \\(T_{equil}\\) is the temperature of the system\n  and an argument to this fix.  Note that \\(B_i >= 1\\) at every step.\n  \n  Note\n  To run a GHD simulation, the input script must also use the fix langevin command to thermostat the atoms at the\n  same Tequil as specified by this fix, so that the system is running\n  constant-temperature (NVT) dynamics.  LAMMPS does not check that this\n  is done.\n  \n  The elapsed time \\(t_{hyper}\\) for a GHD simulation running for N\n  timesteps is simply\n  \n  \\[t_{hyper} = \\sum_{i=1,N} B-i \\cdot dt\\]\n  where dt is the timestep size defined by the timestep\n  command.  The effective time acceleration due to GHD is thus t_hyper /\n  N*dt, where N*dt is elapsed time for a normal MD run of N timesteps.\n  Note that in GHD, the boost factor varies from timestep to timestep.\n  Likewise, which bond has \\(E^{max}\\) strain and thus which pair of\n  atoms the bias potential is added to, will also vary from timestep to timestep.\n  This is in contrast to local hyperdynamics (LHD) where the boost\n  factor is an input parameter; see the fix hyper/local doc page for details.\n  \n  Here is additional information on the input parameters for GHD.\n  The cutbond argument is the cutoff distance for defining bonds\n  between pairs of nearby atoms.  A pair of ij atoms in their\n  equilibrium, minimum-energy configuration, which are separated by a\n  distance \\(R_{ij} < cutbond\\), are flagged as a bonded pair.  Setting\n  cubond to be ~25% larger than the nearest-neighbor distance in a\n  crystalline lattice is a typical choice for solids, so that bonds\n  exist only between nearest neighbor pairs.\n  The qfactor argument is the limiting strain at which the bias\n  potential goes to 0.0.  It is dimensionless, so a value of 0.3 means a\n  bond distance can be up to 30% larger or 30% smaller than the\n  equilibrium (quenched) R0ij distance and the two atoms in the bond\n  could still experience a non-zero bias force.\n  If qfactor is set too large, then transitions from one energy basin\n  to another are affected because the bias potential is non-zero at the\n  transition state (e.g. saddle point).  If qfactor is set too small\n  than little boost is achieved because the \\(E_{ij}\\) strain of some bond in\n  the system will (nearly) always exceed qfactor.  A value of 0.3 for\n  qfactor is typically reasonable.\n  The Vmax argument is the prefactor on the bias potential.  Ideally,\n  tt should be set to a value slightly less than the smallest barrier\n  height for an event to occur.  Otherwise the applied bias potential\n  may be large enough (when added to the interatomic potential) to\n  produce a local energy basin with a maxima in the center.  This can\n  produce artificial energy minima in the same basin that trap an atom.\n  Or if Vmax is even larger, it may induce an atom(s) to rapidly\n  transition to another energy basin.  Both cases are “bad dynamics”\n  which violate the assumptions of GHD that guarantee an accelerated\n  time-accurate trajectory of the system.\n  Note that if Vmax is set too small, the GHD simulation will run\n  correctly.  There will just be fewer events because the hyper time\n  (t_hyper equation above) will be shorter.\n  \n  Note\n  If you have no physical intuition as to the smallest barrier\n  height in your system, a reasonable strategy to determine the largest\n  Vmax you can use for a GHD model, is to run a sequence of\n  simulations with smaller and smaller Vmax values, until the event\n  rate does not change (as a function of hyper time).\n  \n  The Tequil argument is the temperature at which the system is\n  simulated; see the comment above about the fix langevin thermostatting.  It is also part of the\n  beta term in the exponential factor that determines how much boost is\n  achieved as a function of the bias potential.\n  In general, the lower the value of Tequil and the higher the value\n  of Vmax, the more time boost will be achievable by the GHD\n  algorithm.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The fix_modify energy option is supported by this\n  fix to add the energy of the bias potential to the system’s\n  potential energy as part of thermodynamic output.\n  This fix computes a global scalar and global vector of length 12, which\n  can be accessed by various output commands.  The\n  scalar is the magnitude of the bias potential (energy units) applied on\n  the current timestep.  The vector stores the following quantities:\n  \n  1 = boost factor on this step (unitless)\n  2 = max strain \\(E_{ij}\\) of any bond on this step (absolute value, unitless)\n  3 = ID of first atom in the max-strain bond\n  4 = ID of second atom in the max-strain bond\n  5 = average # of bonds/atom on this step\n  6 = fraction of timesteps where the biased bond has bias = 0.0 during this run\n  7 = fraction of timesteps where the biased bond has negative strain during this run\n  8 = max drift distance of any atom during this run (distance units)\n  9 = max bond length during this run (distance units)\n  10 = cumulative hyper time since fix was defined (time units)\n  11 = cumulative count of event timesteps since fix was defined\n  12 = cumulative count of atoms in events since fix was defined\n  \n  The first 5 quantities are for the current timestep.  Quantities 6-9\n  are for the current hyper run.  They are reset each time a new hyper\n  run is performed.  Quantities 19-12 are cumulative across multiple\n  runs (since the point in the input script the fix was defined).\n  For value 8, drift is the distance an atom moves between two quenched\n  states when the second quench determines an event has occurred.  Atoms\n  involved in an event will typically move the greatest distance since\n  others typically remain near their original quenched position.\n  For value 11, events are checked for by the hyper command\n  once every Nevent timesteps.  This value is the count of those\n  timesteps on which one (or more) events was detected.  It is NOT the\n  number of distinct events, since more than one event may occur in the\n  same Nevent time window.\n  For value 12, each time the hyper command checks for an\n  event, it invokes a compute to flag zero or more atoms as\n  participating in one or more events.  E.g. atoms that have displaced\n  more than some distance from the previous quench state.  Value 11 is\n  the cumulative count of the number of atoms participating in any of\n  the events that were found.\n  The scalar and vector values calculated by this fix are all\n  “intensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID hyper/global cutbond qfactor Vmax Tequil\n  \n  \n  \n  ID, group-ID are documented in fix command\n  hyper/global = style name of this fix command\n  cutbond = max distance at which a pair of atoms is considered bonded (distance units)\n  qfactor = max strain at which bias potential goes to 0.0 (unitless)\n  Vmax = height of bias potential (energy units)\n  Tequil = equilibration temperature (temperature units)\n  \n  ",
    "examples": "fix 1 all hyper/global 1.0 0.3 0.8 300.0\n  \n  \n  ",
    "restrictions": "This command can only be used if LAMMPS was built with the REPLICA\n  package.  See the Build package doc page for more\n  info.\n  "
},
{
    "command": "fix hyper/local",
    "description": "This fix is meant to be used with the hyper command to\n  perform a bond-boost local hyperdynamics (LHD) simulation.  The role\n  of this fix is to a select multiple pairs of atoms in the system at\n  each timestep to add a local bias potential to, which will alter the\n  dynamics of the system in a manner that effectively accelerates time.\n  This is in contrast to the fix hyper/global\n  command, which can be user to perform a global hyperdynamics (GHD)\n  simulation, by adding a global bias potential to a single pair of\n  atoms at each timestep.  GHD can time accelerate a small simulation\n  with up to a few 100 atoms.  For larger systems, LHD is needed to\n  achieve good time acceleration.\n  For a system that undergoes rare transition events, where one or more\n  atoms move over an energy barrier to a new potential energy basin, the\n  effect of the bias potential is to induce more rapid transitions.\n  This can lead to a dramatic speed-up in the rate at which events\n  occurs, without altering their relative frequencies, thus leading to\n  an overall increase in the elapsed real time of the simulation as\n  compared to running for the same number of timesteps with normal MD.\n  See the hyper doc page for a more general discussion of\n  hyperdynamics and citations that explain both GHD and LHD.\n  The equations and logic used by this fix and described here to perform\n  LHD follow the description given in (Voter2013).  The\n  bond-boost form of a bias potential for HD is due to Miron and\n  Fichthorn as described in (Miron).\n  To understand this description, you should first read the description\n  of the GHD algorithm on the fix hyper/global\n  doc page.  This description of LHD builds on the GHD description.\n  The definition of bonds and \\(E_{ij}\\) are the same for GHD and LHD.\n  The formulas for \\(V^{max}_{ij}\\) and \\(F^{max}_{ij}\\) are also\n  the same except for a pre-factor \\(C_{ij}\\), explained below.\n  The bias energy \\(V_{ij}\\) applied to a bond ij with maximum strain is\n  \n  \\[V^{max}_{ij} = C_{ij} \\cdot V^{max} \\cdot \\left(1 - \\left(\\frac{E_{ij}}{q}\\right)^2\\right) \\textrm{ for } \\left|E_{ij}\\right| < qfactor \\textrm{ or } 0 \\textrm{ otherwise}\\]\n  The derivative of \\(V^{max}_{ij}\\) with respect to the position of\n  each atom in the ij bond gives a bias force \\(F^{max}_{ij}\\) acting\n  on the bond as\n  \n  \\[F^{max}_{ij} = - \\frac{dV^{max}_{ij}}{dE_{ij}} = 2 C_{ij} V^{max} \\frac{E_{ij}}{qfactor^2} \\textrm{ for } \\left|E_{ij}\\right| < qfactor \\textrm{ or } 0 \\textrm{ otherwise}\\]\n  which can be decomposed into an equal and opposite force acting on\n  only the two atoms i and j in the ij bond.\n  The key difference is that in GHD a bias energy and force is added (on\n  a particular timestep) to only one bond (pair of atoms) in the system,\n  which is the bond with maximum strain \\(E^{max}\\).\n  In LHD, a bias energy and force can be added to multiple bonds\n  separated by the specified Dcut distance or more.  A bond ij is\n  biased if it is the maximum strain bond within its local\n  “neighborhood”, which is defined as the bond ij plus any neighbor\n  bonds within a distance Dcut from ij.  The “distance” between bond\n  ij and bond kl is the minimum distance between any of the ik, il,\n  jk, and jl pairs of atoms.\n  For a large system, multiple bonds will typically meet this\n  requirement, and thus a bias potential \\(V^{max}_{ij}\\) will be\n  applied to many bonds on the same timestep.\n  In LHD, all bonds store a \\(C_{ij}\\) prefactor which appears in\n  the \\(V^{max}_{ij}\\) and \\(F^{max}_{ij}equations above.  Note\n  that the :math:\\) factor scales the strength of the bias energy\n  and forces whenever bond ij is the maximum strain bond in its neighborhood.\n  \\(C_{ij}\\) is initialized to 1.0 when a bond between the ij atoms\n  is first defined.  The specified Btarget factor is then used to adjust the\n  \\(C_{ij}\\) prefactors for each bond every timestep in the following manner.\n  An instantaneous boost factor \\(B_{ij}\\) is computed each timestep\n  for each bond, as\n  \n  \\[B_{ij} = e^{\\beta V^{max}_{kl}}\\]\n  where \\(V^{max}_{kl}\\) is the bias energy of the maxstrain bond kl\n  within bond ij’s neighborhood, \\(\\beta = \\frac{1}{kT_{equil}}\\),\n  and \\(T_{equil}\\) is the temperature of the system and an argument\n  to this fix.\n  \n  Note\n  To run an LHD simulation, the input script must also use the\n  fix langevin command to thermostat the atoms at\n  the same Tequil as specified by this fix, so that the system is\n  running constant-temperature (NVT) dynamics.  LAMMPS does not check\n  that this is done.\n  \n  Note that if ij== kl, then bond ij is a biased bond on that\n  timestep, otherwise it is not.  But regardless, the boost factor\n  \\(B_{ij}\\) can be thought of an estimate of time boost currently\n  being applied within a local region centered on bond ij.  For LHD,\n  we want this to be the specified Btarget value everywhere in the\n  simulation domain.\n  To accomplish this, if \\(B_{ij} < B_{target}\\), the \\(C_{ij}\\)\n  prefactor for bond ij is incremented on the current timestep by an\n  amount proportional to the inverse of the specified \\(\\alpha\\) and\n  the difference (\\(B_{ij} - B_{target}\\)).  Conversely if\n  \\(B_{ij} > B_{target}\\), \\(C_{ij}\\) is decremented by the same\n  amount.  This procedure is termed “boostostatting” in (Voter2013).  It drives all of the individual \\(C_{ij}\\) to\n  values such that when \\(V^{max}_{ij}\\) is applied as a bias to bond\n  ij, the resulting boost factor \\(B_{ij}\\) will be close to\n  \\(B_{target}\\) on average.  Thus the LHD time acceleration factor\n  for the overall system is effectively Btarget.\n  Note that in LHD, the boost factor \\(B_{target}\\) is specified by the user.\n  This is in contrast to global hyperdynamics (GHD) where the boost\n  factor varies each timestep and is computed as a function of \\(V_{max}\\),\n  \\(E_{max}\\), and \\(T_{equil}\\); see the\n  fix hyper/global doc page for details.\n  \n  Here is additional information on the input parameters for LHD.\n  Note that the cutbond, qfactor, and Tequil arguments have the\n  same meaning as for GHD.  The Vmax argument is slightly different.\n  The Dcut, alpha, and Btarget parameters are unique to LHD.\n  The cutbond argument is the cutoff distance for defining bonds\n  between pairs of nearby atoms.  A pair of I,J atoms in their\n  equilibrium, minimum-energy configuration, which are separated by a\n  distance \\(R_{ij} < cutbond\\), are flagged as a bonded pair.  Setting\n  cubond to be ~25% larger than the nearest-neighbor distance in a\n  crystalline lattice is a typical choice for solids, so that bonds\n  exist only between nearest neighbor pairs.\n  The qfactor argument is the limiting strain at which the bias\n  potential goes to 0.0.  It is dimensionless, so a value of 0.3 means a\n  bond distance can be up to 30% larger or 30% smaller than the\n  equilibrium (quenched) \\(R^0_{ij}\\) distance and the two atoms in the bond\n  could still experience a non-zero bias force.\n  If qfactor is set too large, then transitions from one energy basin\n  to another are affected because the bias potential is non-zero at the\n  transition state (e.g. saddle point).  If qfactor is set too small\n  than little boost can be achieved because the \\(E_{ij}\\) strain of\n  some bond in\n  the system will (nearly) always exceed qfactor.  A value of 0.3 for\n  qfactor is typically a reasonable value.\n  The Vmax argument is a fixed prefactor on the bias potential.  There\n  is a also a dynamic prefactor \\(C_{ij}\\), driven by the choice of\n  Btarget as discussed above.  The product of these should be a value less than\n  the smallest barrier height for an event to occur.  Otherwise the\n  applied bias potential may be large enough (when added to the\n  interatomic potential) to produce a local energy basin with a maxima\n  in the center.  This can produce artificial energy minima in the same\n  basin that trap an atom.  Or if \\(C_{ij} \\cdot V^{max}\\) is even\n  larger, it may\n  induce an atom(s) to rapidly transition to another energy basin.  Both\n  cases are “bad dynamics” which violate the assumptions of LHD that\n  guarantee an accelerated time-accurate trajectory of the system.\n  \n  Note\n  It may seem that \\(V^{max}\\) can be set to any value, and\n  \\(C_{ij}\\) will compensate to reduce the overall prefactor\n  if necessary.  However the \\(C_{ij}\\) are initialized to 1.0\n  and the boostostatting procedure typically operates slowly enough\n  that there can be a time period of bad dynamics if \\(V^{max}\\)\n  is set too large.  A better strategy is to set \\(V^{max}\\) to the\n  slightly smaller than the lowest barrier height for an event (the same\n  as for GHD), so that the \\(C_{ij}\\) remain near unity.\n  \n  The Tequil argument is the temperature at which the system is\n  simulated; see the comment above about the fix langevin thermostatting.  It is also part of the\n  beta term in the exponential factor that determines how much boost is\n  achieved as a function of the bias potential.  See the discussion of\n  the Btarget argument below.\n  As discussed above, the Dcut argument is the distance required\n  between two locally maxstrain bonds for them to both be selected as\n  biased bonds on the same timestep.  Computationally, the larger Dcut\n  is, the more work (computation and communication) must be done each\n  timestep within the LHD algorithm.  And the fewer bonds can be\n  simultaneously biased, which may mean the specified Btarget time\n  acceleration cannot be achieved.\n  Physically Dcut should be a long enough distance that biasing two\n  pairs of atoms that close together will not influence the dynamics of\n  each pair.  E.g. something like 2x the cutoff of the interatomic\n  potential.  In practice a Dcut value of ~10 Angstroms seems to work\n  well for many solid-state systems.\n  \n  Note\n  You should insure that ghost atom communication is performed for\n  a distance of at least Dcut + cutevent = the distance one or more\n  atoms move (between quenched states) to be considered an “event”.  It\n  is an argument to the “compute event/displace” command used to detect\n  events.  By default the ghost communication distance is set by the\n  pair_style cutoff, which will typically be < Dcut.  The comm_modify cutoff command should be used to override the ghost\n  cutoff explicitly, e.g.\n  \n  comm_modify cutoff 12.0\n  \n  \n  Note that this fix does not know the cutevent parameter, but uses\n  half the cutbond parameter as an estimate to warn if the ghost\n  cutoff is not long enough.\n  As described above the alpha argument is a pre-factor in the\n  boostostat update equation for each bond’s \\(C_{ij}\\) prefactor.\n  Alpha is specified in time units, similar to other thermostat or barostat\n  damping parameters.  It is roughly the physical time it will take the\n  boostostat to adjust a \\(C_{ij}\\) value from a too high (or too low)\n  value to a correct one.  An alpha setting of a few ps is typically good for\n  solid-state systems.  Note that the alpha argument here is the\n  inverse of the alpha parameter discussed in\n  (Voter2013).\n  The Btarget argument is the desired time boost factor (a value > 1)\n  that all the atoms in the system will experience.  The elapsed time\n  t_hyper for an LHD simulation running for N timesteps is simply\n  \n  \\[t_{hyper} = B_{target} \\cdot N \\cdot dt\\]\n  where dt is the timestep size defined by the timestep\n  command.  The effective time acceleration due to LHD is thus\n  \\(\\frac{t_{hyper}}{N\\cdot dt} = B_{target}\\), where \\(N\\cdot dt\\)\n  is the elapsed time for a normal MD run of N timesteps.\n  You cannot choose an arbitrarily large setting for Btarget.  The\n  maximum value you should choose is\n  \n  \\[B_{target} = e^{\\beta V_{small}}\\]\n  where \\(V_{small}\\) is the smallest event barrier height in your\n  system, \\(\\beta = \\frac{1}{kT_{equil}}\\), and \\(T_{equil}\\)\n  is the specified temperature of the system\n  (both by this fix and the Langevin thermostat).\n  Note that if Btarget is set smaller than this, the LHD simulation\n  will run correctly.  There will just be fewer events because the hyper\n  time (t_hyper equation above) will be shorter.\n  \n  Note\n  If you have no physical intuition as to the smallest barrier\n  height in your system, a reasonable strategy to determine the largest\n  Btarget you can use for an LHD model, is to run a sequence of\n  simulations with smaller and smaller Btarget values, until the event\n  rate does not change (as a function of hyper time).\n  \n  \n  Here is additional information on the optional keywords for this fix.\n  The bound keyword turns on min/max bounds for bias coefficients\n  \\(C_{ij}\\) for all bonds.  \\(C_{ij}\\) is a prefactor for each bond on\n  the bias potential of maximum strength \\(V^{max}\\).  Depending on the\n  choice of alpha and Btarget and Vmax, the boostostatting can cause\n  individual \\(C_{ij}\\) values to fluctuate.  If the fluctuations are too\n  large \\(C_{ij} \\cdot V^{max}\\) can exceed low barrier heights and induce\n  bad event dynamics.  Bounding the \\(C_{ij}\\) values is a way to prevent\n  this.  If Bfrac is set to -1 or any negative value (the default) then no\n  bounds are enforced on \\(C_{ij}\\) values (except they must always\n  be >= 0.0).  A Bfrac setting >= 0.0\n  sets a lower bound of 1.0 - Bfrac and upper bound of 1.0 + Bfrac on each\n  \\(C_{ij}\\) value.  Note that all \\(C_{ij}\\) values are initialized\n  to 1.0 when a bond is created for the first time.  Thus Bfrac limits the\n  bias potential height to Vmax +/- Bfrac*Vmax.\n  The reset keyword allow Vmax to be adjusted dynamically depending on the\n  average value of all \\(C_{ij}\\) prefactors.  This can be useful if you\n  are unsure what value of Vmax will match the Btarget boost for the\n  system.  The \\(C_{ij}\\) values will then adjust in aggregate (up or down)\n  so that \\(C_{ij} \\cdot V^{max}\\) produces a boost of Btarget, but this\n  may conflict with the bound keyword settings.  By using bound and reset\n  together, \\(V^{max}\\) itself can be reset, and desired bounds still applied\n  to the \\(C_{ij}\\) values.\n  A setting for Rfreq of -1 (the default) means Vmax never changes.\n  A setting of 0 means \\(V^{max}\\) is adjusted every time an event occurs and\n  bond pairs are recalculated.  A setting of N > 0 timesteps means\n  \\(V^{max}\\) is adjusted on the first time an event occurs on a timestep >=\n  N steps after the previous adjustment.  The adjustment to \\(V^{max}\\) is\n  computed as follows.  The current average of all \\(C_{ij} \\cdot V^{max}\\)\n  values is computed and the \\(V^{max}\\) is reset to that value.  All\n  \\(C_{ij}\\) values are changed to new prefactors such the new\n  \\(C_{ij} \\cdot V^{max}\\) is the same as it was previously.  If the\n  bound keyword was used, those bounds are enforced on the new \\(C_{ij}\\)\n  values.  Henceforth, new bonds are assigned a \\(C_{ij} = 1.0\\), which\n  means their bias potential magnitude is the new \\(V^{max}\\).\n  The check/ghost keyword turns on extra computation each timestep to\n  compute statistics about ghost atoms used to determine which bonds to\n  bias.  The output of these stats are the vector values 14 and 15,\n  described below.  If this keyword is not enabled, the output\n  of the stats will be zero.\n  The check/bias keyword turns on extra computation and communication\n  to check if any biased bonds are closer than Dcut to each other,\n  which should not be the case if LHD is operating correctly.  Thus it\n  is a debugging check.  The Nevery setting determines how often the\n  check is made.  The error, warn, or ignore setting determines\n  what is done if the count of too-close bonds is not zero.  Either the\n  code will exit, or issue a warning, or silently tally the count.  The\n  count can be output as vector value 17, as described below.  If this\n  keyword is not enabled, the output of that statistic will be 0.\n  Note that both of these computations are costly, hence they are only\n  enabled by these keywords.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The fix_modify energy option is supported by this\n  fix to add the energy of the bias potential to the system’s potential\n  energy as part of thermodynamic output.\n  This fix computes a global scalar and global vector of length 28,\n  which can be accessed by various output commands.\n  The scalar is the magnitude of the bias potential (energy units)\n  applied on the current timestep, summed over all biased bonds.  The\n  vector stores the following quantities:\n  \n  1 = average boost for all bonds on this step (unitless)\n  2 = # of biased bonds on this step\n  3 = max strain \\(E_{ij}\\) of any bond on this step (absolute value, unitless)\n  4 = value of \\(V^{max}\\) on this step (energy units)\n  5 = average bias coeff for all bonds on this step (unitless)\n  6 = min bias coeff for all bonds on this step (unitless)\n  7 = max bias coeff for all bonds on this step (unitless)\n  8 = average # of bonds/atom on this step\n  9 = average neighbor bonds/bond on this step within Dcut\n  10 = average boost for all bonds during this run (unitless)\n  11 = average # of biased bonds/step during this run\n  12 = fraction of biased bonds with no bias during this run\n  13 = fraction of biased bonds with negative strain during this run\n  14 = max bond length during this run (distance units)\n  15 = average bias coeff for all bonds during this run (unitless)\n  16 = min bias coeff for any bond during this run (unitless)\n  17 = max bias coeff for any bond during this run (unitless)\n  18 = max drift distance of any bond atom during this run (distance units)\n  19 = max distance from proc subbox of any ghost atom with maxstrain < qfactor during this run (distance units)\n  20 = max distance outside my box of any ghost atom with any maxstrain during this run (distance units)\n  21 = count of ghost atoms that could not be found on reneighbor steps during this run\n  22 = count of bias overlaps (< Dcut) found during this run\n  23 = cumulative hyper time since fix created (time units)\n  24 = cumulative count of event timesteps since fix created\n  25 = cumulative count of atoms in events since fix created\n  26 = cumulative # of new bonds formed since fix created\n  \n  27 = average boost for biased bonds on this step (unitless)\n  28 = # of bonds with absolute strain >= q on this step\n  The first quantities 1-9 are for the current timestep.  Quantities\n  10-22 are for the current hyper run.  They are reset each time a new\n  hyper run is performed.  Quantities 23-26 are cumulative across\n  multiple runs (since the point in the input script the fix was\n  defined).\n  For value 10, each bond instantaneous boost factor is given by the\n  equation for \\(B_{ij}\\) above.  The total system boost (average across all\n  bonds) fluctuates, but should average to a value close to the\n  specified \\(B_{target}\\).\n  For value 12, the numerator is a count of all biased bonds on each\n  timestep whose bias energy = 0.0 due to \\(E_{ij} >= qfactor\\).  The\n  denominator is the count of all biased bonds on all timesteps.\n  For value 13, the numerator is a count of all biased bonds on each\n  timestep with negative strain.  The denominator is the count of all\n  biased bonds on all timesteps.\n  Values 18-22 are mostly useful for debugging and diagnostic purposes.\n  For value 18, drift is the distance an atom moves between two quenched\n  states when the second quench determines an event has occurred.  Atoms\n  involved in an event will typically move the greatest distance since\n  others typically remain near their original quenched position.\n  For values 19-21, neighbor atoms in the full neighbor list with cutoff\n  Dcut may be ghost atoms outside a processor’s sub-box.  Before the\n  next event occurs they may move further than Dcut away from the\n  sub-box boundary.  Value 19 is the furthest (from the sub-box) any\n  ghost atom in the neighbor list with maxstrain < qfactor was\n  accessed during the run.  Value 20 is the same except that the ghost\n  atom’s maxstrain may be >= qfactor, which may mean it is about to\n  participate in an event.  Value 21 is a count of how many ghost atoms\n  could not be found on reneighbor steps, presumably because they moved\n  too far away due to their participation in an event (which will likely\n  be detected at the next quench).\n  Typical values for 19 and 20 should be slightly larger than Dcut,\n  which accounts for ghost atoms initially at a Dcut distance moving\n  thermally before the next event takes place.\n  Note that for values 19 and 20 to be computed, the optional keyword\n  check/ghost must be specified.  Otherwise these values will be zero.\n  This is because computing them incurs overhead, so the values are only\n  computed if requested.\n  Value 21 should be zero or small.  As explained above a small count\n  likely means some ghost atoms were participating in their own events\n  and moved a longer distance.  If the value is large, it likely means\n  the communication cutoff for ghosts is too close to Dcut leading to\n  many not-found ghost atoms before the next event.  This may lead to a\n  reduced number of bonds being selected for biasing, since the code\n  assumes those atoms are part of highly strained bonds.  As explained\n  above, the comm_modify cutoff command can be used\n  to set a longer cutoff.\n  For value 22, no two bonds should be biased if they are within a\n  Dcut distance of each other.  This value should be zero, indicating\n  that no pair of biased bonds are closer than Dcut from each other.\n  Note that for value 22 to be computed, the optional keyword\n  check/bias must be specified and it determines how often this check\n  is performed.  This is because performing the check incurs overhead,\n  so if only computed as often as requested.\n  The result at the end of the run is the cumulative total from every\n  timestep the check was made.  Note that the value is a count of atoms\n  in bonds which found other atoms in bonds too close, so it is almost\n  always an over-count of the number of too-close bonds.\n  Value 23 is simply the specified boost factor times the number of\n  timesteps times the timestep size.\n  For value 24, events are checked for by the hyper command\n  once every Nevent timesteps.  This value is the count of those\n  timesteps on which one (or more) events was detected.  It is NOT the\n  number of distinct events, since more than one event may occur in the\n  same Nevent time window.\n  For value 25, each time the hyper command checks for an\n  event, it invokes a compute to flag zero or more atoms as\n  participating in one or more events.  E.g. atoms that have displaced\n  more than some distance from the previous quench state.  Value 25 is\n  the cumulative count of the number of atoms participating in any of\n  the events that were found.\n  Value 26 tallies the number of new bonds created by the bond reset\n  operation.  Bonds between a specific I,J pair of atoms may persist for\n  the entire hyperdynamics simulation if neither I or J are involved in\n  an event.\n  Value 27 computes the average boost for biased bonds only on this step.\n  Value 28 is the count of bonds with an absolute value of strain >= q\n  on this step.\n  The scalar and vector values calculated by this fix are all\n  “intensive”.\n  This fix also computes a local vector of length the number of bonds\n  currently in the system.  The value for each bond is its \\(C_{ij}\\)\n  prefactor (bias coefficient).  These values can be can be accessed by various\n  output commands.  A particularly useful one is the\n  fix ave/histo command which can be used to\n  histogram the Cij values to see if they are distributed reasonably\n  close to 1.0, which indicates a good choice of \\(V^{max}\\).\n  The local values calculated by this fix are unitless.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID hyper/local cutbond qfactor Vmax Tequil Dcut alpha Btarget\n  \n  \n  \n  ID, group-ID are documented in fix command\n  hyper/local = style name of this fix command\n  cutbond = max distance at which a pair of atoms is considered bonded (distance units)\n  qfactor = max strain at which bias potential goes to 0.0 (unitless)\n  Vmax = estimated height of bias potential (energy units)\n  Tequil = equilibration temperature (temperature units)\n  Dcut = minimum distance between boosted bonds (distance units)\n  alpha = boostostat relaxation time (time units)\n  Btarget = desired time boost factor (unitless)\n  zero or more keyword/value pairs may be appended\n  keyword = bound or reset or check/ghost or check/bias\n  bound value = Bfrac\n    Bfrac =  -1 or a value >= 0.0\n  reset value = Rfreq\n    Rfreq = -1 or 0 or timestep value > 0\n  check/ghost values = none\n  check/bias values = Nevery error/warn/ignore\n  \n  \n  ",
    "examples": "fix 1 all hyper/local 1.0 0.3 0.8 300.0\n  fix 1 all hyper/local 1.0 0.3 0.8 300.0 bound 0.1 reset 0\n  \n  \n  ",
    "restrictions": "This fix is part of the REPLICA package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package\n  doc page for more info.\n  "
},
{
    "command": "fix imd",
    "description": "This fix implements the “Interactive MD” (IMD) protocol which allows\n  realtime visualization and manipulation of MD simulations through the\n  IMD protocol, as initially implemented in VMD and NAMD.  Specifically\n  it allows LAMMPS to connect an IMD client, for example the VMD visualization program, so that it can monitor the progress of the\n  simulation and interactively apply forces to selected atoms.\n  If LAMMPS is compiled with the pre-processor flag -DLAMMPS_ASYNC_IMD\n  then fix imd will use POSIX threads to spawn a IMD communication\n  thread on MPI rank 0 in order to offload data reading and writing\n  from the main execution thread and potentially lower the inferred\n  latencies for slow communication links. This feature has only been\n  tested under linux.\n  There are example scripts for using this package with LAMMPS in\n  examples/USER/imd. Additional examples and a driver for use with the\n  Novint Falcon game controller as haptic device can be found at:\n  http://sites.google.com/site/akohlmey/software/vrpn-icms.\n  The source code for this fix includes code developed by the\n  Theoretical and Computational Biophysics Group in the Beckman\n  Institute for Advanced Science and Technology at the University of\n  Illinois at Urbana-Champaign.  We thank them for providing a software\n  interface that allows codes like LAMMPS to hook to VMD.\n  Upon initialization of the fix, it will open a communication port on\n  the node with MPI task 0 and wait for an incoming connection.  As soon\n  as an IMD client is connected, the simulation will continue and the\n  fix will send the current coordinates of the fix’s group to the IMD\n  client at every trate MD step. When using r-RESPA, trate applies to\n  the steps of the outmost RESPA level.  During a run with an active IMD\n  connection also the IMD client can request to apply forces to selected\n  atoms of the fix group.\n  The port number selected must be an available network port number.  On\n  many machines, port numbers < 1024 are reserved for accounts with\n  system manager privilege and specific applications. If multiple imd\n  fixes would be active at the same time, each needs to use a different\n  port number.\n  The nowait keyword controls the behavior of the fix when no IMD\n  client is connected. With the default setting of off, LAMMPS will\n  wait until a connection is made before continuing with the\n  execution. Setting nowait to on will have the LAMMPS code be ready\n  to connect to a client, but continue with the simulation. This can for\n  example be used to monitor the progress of an ongoing calculation\n  without the need to be permanently connected or having to download a\n  trajectory file.\n  The trate keyword allows to select how often the coordinate data is\n  sent to the IMD client. It can also be changed on request of the IMD\n  client through an IMD protocol message.  The unwrap keyword allows\n  to send “unwrapped” coordinates to the IMD client that undo the\n  wrapping back of coordinates into the principle unit cell, as done by\n  default in LAMMPS.  The fscale keyword allows to apply a scaling\n  factor to forces transmitted by the IMD client. The IMD protocols\n  stipulates that forces are transferred in kcal/mol/angstrom under the\n  assumption that coordinates are given in angstrom. For LAMMPS runs\n  with different units or as a measure to tweak the forces generated by\n  the manipulation of the IMD client, this option allows to make\n  adjustments.\n  To connect VMD to a listening LAMMPS simulation on the same machine\n  with fix imd enabled, one needs to start VMD and load a coordinate or\n  topology file that matches the fix group.  When the VMD command\n  prompts appears, one types the command line:\n  imd connect localhost 5678\n  \n  \n  This assumes that fix imd was started with 5678 as a port\n  number for the IMD protocol.\n  The steps to do interactive manipulation of a running simulation in\n  VMD are the following:\n  In the Mouse menu of the VMD Main window, select “Mouse -> Force ->\n  Atom”.  You may alternately select “Residue”, or “Fragment” to apply\n  forces to whole residues or fragments. Your mouse can now be used to\n  apply forces to your simulation. Click on an atom, residue, or\n  fragment and drag to apply a force. Click quickly without moving the\n  mouse to turn the force off. You can also use a variety of 3D position\n  trackers to apply forces to your simulation. Game controllers or haptic\n  devices with force-feedback such as the Novint Falcon or Sensable\n  PHANTOM allow you to feel the resistance due to inertia or interactions\n  with neighbors that the atoms experience you are trying to move, as if\n  they were real objects. See the VMD IMD Homepage and the\n  VRPN-ICMS Homepage for more details.\n  If IMD control messages are received, a line of text describing the\n  message and its effect will be printed to the LAMMPS output screen, if\n  screen output is active.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global scalar or vector or per-atom\n  quantities are stored by this fix for access by various output commands.  No parameter of this fix can be used\n  with the start/stop keywords of the run command.  This\n  fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID imd trate port keyword values ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  imd = style name of this fix command\n  port = port number on which the fix listens for an IMD client\n  keyword = unwrap or fscale or trate\n  unwrap arg = on or off\n    off = coordinates are wrapped back into the principal unit cell (default)\n    on = \"unwrapped\" coordinates using the image flags used\n  fscale arg = factor\n    factor = floating point number to scale IMD forces (default: 1.0)\n  trate arg = transmission rate of coordinate data sets (default: 1)\n  nowait arg = on or off\n    off = LAMMPS waits to be connected to an IMD client before continuing (default)\n    on = LAMMPS listens for an IMD client, but continues with the run\n  \n  \n  ",
    "examples": "fix vmd all imd 5678\n  fix comm all imd 8888 trate 5 unwrap on fscale 10.0\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  When used in combination with VMD, a topology or coordinate file has\n  to be loaded, which matches (in number and ordering of atoms) the\n  group the fix is applied to. The fix internally sorts atom IDs by\n  ascending integer value; in VMD (and thus the IMD protocol) those will\n  be assigned 0-based consecutive index numbers.\n  When using multiple active IMD connections at the same time, each\n  needs to use a different port number.\n  Related commands: none\n  Default: none\n  "
},
{
    "command": "fix indent",
    "description": "Insert an indenter within a simulation box.  The indenter repels all\n  atoms in the group that touch it, so it can be used to push into a\n  material or as an obstacle in a flow.  Or it can be used as a\n  constraining wall around a simulation; see the discussion of the\n  side keyword below.\n  The indenter can either be spherical or cylindrical or planar.  You\n  must set one of those 3 keywords.\n  A spherical indenter exerts a force of magnitude\n  \n  \\[F(r) = - K \\left( r - R \\right)^2\\]\n  on each atom where K is the specified force constant, r is the\n  distance from the atom to the center of the indenter, and R is the\n  radius of the indenter.  The force is repulsive and F(r) = 0 for r >\n  R.\n  A cylindrical indenter exerts the same force, except that r is the\n  distance from the atom to the center axis of the cylinder.  The\n  cylinder extends infinitely along its axis.\n  Spherical and cylindrical indenters account for periodic boundaries in\n  two ways.  First, the center point of a spherical indenter (x,y,z) or\n  axis of a cylindrical indenter (c1,c2) is remapped back into the\n  simulation box, if the box is periodic in a particular dimension.\n  This occurs every timestep if the indenter geometry is specified with\n  a variable (see below), e.g. it is moving over time.  Second, the\n  calculation of distance to the indenter center or axis accounts for\n  periodic boundaries.  Both of these mean that an indenter can\n  effectively move through and straddle one or more periodic boundaries.\n  A planar indenter is really an axis-aligned infinite-extent wall\n  exerting the same force on atoms in the system, where R is the\n  position of the plane and r-R is the distance from the plane.  If\n  the side parameter of the plane is specified as lo then it will\n  indent from the lo end of the simulation box, meaning that atoms with\n  a coordinate less than the plane’s current position will be pushed\n  towards the hi end of the box and atoms with a coordinate higher than\n  the plane’s current position will feel no force.  Vice versa if side\n  is specified as hi.\n  Any of the 4 quantities defining a spherical indenter’s geometry can\n  be specified as an equal-style variable, namely x,\n  y, z, or R.  Similarly, for a cylindrical indenter, any of c1,\n  c2, or R, can be a variable.  For a planar indenter, pos can be\n  a variable.  If the value is a variable, it should be specified as\n  v_name, where name is the variable name.  In this case, the variable\n  will be evaluated each timestep, and its value used to define the\n  indenter geometry.\n  Note that equal-style variables can specify formulas with various\n  mathematical functions, and include thermo_style\n  command keywords for the simulation box parameters and timestep and\n  elapsed time.  Thus it is easy to specify indenter properties that\n  change as a function of time or span consecutive runs in a continuous\n  fashion.  For the latter, see the start and stop keywords of the\n  run command and the elaplong keyword of thermo_style custom for details.\n  For example, if a spherical indenter’s x-position is specified as v_x,\n  then this variable definition will keep it’s center at a relative\n  position in the simulation box, 1/4 of the way from the left edge to\n  the right edge, even if the box size changes:\n  variable x equal \"xlo + 0.25*lx\"\n  \n  \n  Similarly, either of these variable definitions will move the indenter\n  from an initial position at 2.5 at a constant velocity of 5:\n  variable x equal \"2.5 + 5*elaplong*dt\"\n  variable x equal vdisplace(2.5,5)\n  \n  \n  If a spherical indenter’s radius is specified as v_r, then these\n  variable definitions will grow the size of the indenter at a specified\n  rate.\n  variable r0 equal 0.0\n  variable rate equal 1.0\n  variable r equal \"v_r0 + step*dt*v_rate\"\n  \n  \n  If the side keyword is specified as out, which is the default,\n  then particles outside the indenter are pushed away from its outer\n  surface, as described above.  This only applies to spherical or\n  cylindrical indenters.  If the side keyword is specified as in,\n  the action of the indenter is reversed.  Particles inside the indenter\n  are pushed away from its inner surface.  In other words, the indenter\n  is now a containing wall that traps the particles inside it.  If the\n  radius shrinks over time, it will squeeze the particles.\n  The units keyword determines the meaning of the distance units used\n  to define the indenter geometry.  A box value selects standard\n  distance units as defined by the units command,\n  e.g. Angstroms for units = real or metal.  A lattice value means the\n  distance units are in lattice spacings.  The lattice\n  command must have been previously used to define the lattice spacing.\n  The (x,y,z) coords of the indenter position are scaled by the x,y,z\n  lattice spacings respectively.  The radius of a spherical or\n  cylindrical indenter is scaled by the x lattice spacing.\n  Note that the units keyword only affects indenter geometry parameters\n  specified directly with numbers, not those specified as variables.  In\n  the latter case, you should use the xlat, ylat, zlat keywords of\n  the thermo_style command if you want to include\n  lattice spacings in a variable formula.\n  The force constant K is not affected by the units keyword.  It is\n  always in force/distance^2 units where force and distance are defined\n  by the units command.  If you wish K to be scaled by the\n  lattice spacing, you can define K with a variable whose formula\n  contains xlat, ylat, zlat keywords of the\n  thermo_style command, e.g.\n  variable k equal 100.0/xlat/xlat\n  fix 1 all indent $k sphere ...\n  \n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The fix_modify energy option is supported by this\n  fix to add the energy of interaction between atoms and the indenter to\n  the system’s potential energy as part of thermodynamic output.  The energy of each particle interacting\n  with the indenter is K/3 (r - R)^3.\n  The fix_modify respa option is supported by this\n  fix. This allows to set at which level of the r-RESPA\n  integrator the fix is adding its forces. Default is the outermost level.\n  This fix computes a global scalar energy and a global 3-vector of\n  forces (on the indenter), which can be accessed by various output commands.  The scalar and vector values calculated\n  by this fix are “extensive”.\n  The forces due to this fix are imposed during an energy minimization,\n  invoked by the minimize command.  Note that if you\n  define the indenter geometry with a variable using a time-dependent\n  formula, LAMMPS uses the iteration count in the minimizer as the\n  timestep.  But it is almost certainly a bad idea to have the indenter\n  change its position or size during a minimization.  LAMMPS does not\n  check if you have done this.\n  \n  Note\n  If you want the atom/indenter interaction energy to be included\n  in the total potential energy of the system (the quantity being\n  minimized), you must enable the fix_modify energy\n  option for this fix.\n  \n  ",
    "syntax": "fix ID group-ID indent K keyword values ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  indent = style name of this fix command\n  K = force constant for indenter surface (force/distance^2 units)\n  one or more keyword/value pairs may be appended\n  keyword = sphere or cylinder or plane or side or units\n  sphere args = x y z R\n    x,y,z = initial position of center of indenter (distance units)\n    R = sphere radius of indenter (distance units)\n    any of x,y,z,R can be a variable (see below)\n  cylinder args = dim c1 c2 R\n    dim = x or y or z = axis of cylinder\n    c1,c2 = coords of cylinder axis in other 2 dimensions (distance units)\n    R = cylinder radius of indenter (distance units)\n    any of c1,c2,R can be a variable (see below)\n  plane args = dim pos side\n    dim = x or y or z = plane perpendicular to this dimension\n    pos = position of plane in dimension x, y, or z (distance units)\n    pos can be a variable (see below)\n    side = lo or hi\n  side value = in or out\n    in = the indenter acts on particles inside the sphere or cylinder\n    out = the indenter acts on particles outside the sphere or cylinder\n  units value = lattice or box\n    lattice = the geometry is defined in lattice units\n    box = the geometry is defined in simulation box units\n  \n  \n  ",
    "examples": "fix 1 all indent 10.0 sphere 0.0 0.0 15.0 3.0\n  fix 1 all indent 10.0 sphere v_x v_y 0.0 v_radius side in\n  fix 2 flow indent 10.0 cylinder z 0.0 0.0 10.0 units box\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  Related commands: none\n  "
},
{
    "command": "fix ipi",
    "description": "This fix enables LAMMPS to be run as a client for the i-PI Python\n  wrapper (IPI) for performing a path integral molecular dynamics\n  (PIMD) simulation.  The philosophy behind i-PI is described in the\n  following publication (IPI-CPC).\n  A version of the i-PI package, containing only files needed for use\n  with LAMMPS, is provided in the tools/i-pi directory.  See the\n  tools/i-pi/manual.pdf for an introduction to i-PI.  The\n  examples/USER/i-pi directory contains example scripts for using i-PI\n  with LAMMPS.\n  In brief, the path integral molecular dynamics is performed by the\n  Python wrapper, while the client (LAMMPS in this case) simply computes\n  forces and energy for each configuration. The communication between\n  the two components takes place using sockets, and is reduced to the\n  bare minimum. All the parameters of the dynamics are specified in the\n  input of i-PI, and all the parameters of the force field must be\n  specified as LAMMPS inputs, preceding the fix ipi command.\n  The server address must be specified by the address argument, and\n  can be either the IP address, the fully-qualified name of the server,\n  or the name of a UNIX socket for local, faster communication. In the\n  case of internet sockets, the port argument specifies the port\n  number on which i-PI is listening, while the unix optional switch\n  specifies that the socket is a UNIX socket.\n  Note that there is no check of data integrity, or that the atomic\n  configurations make sense. It is assumed that the species in the i-PI\n  input are listed in the same order as in the data file of LAMMPS. The\n  initial configuration is ignored, as it will be substituted with the\n  coordinates received from i-PI before forces are ever evaluated.\n  A note of caution when using potentials that contain long-range\n  electrostatics, or that contain parameters that depend on box size:\n  all of these options will be initialized based on the cell size in the\n  LAMMPS-side initial configuration and kept constant during the run.\n  This is required to e.g. obtain reproducible and conserved forces.\n  If the cell varies too wildly, it may be advisable to re-initialize\n  these interactions at each call. This behavior can be requested by\n  setting the reset switch.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  There is no restart information associated with this fix, since all\n  the dynamical parameters are dealt with by i-PI.\n  ",
    "syntax": "fix ID group-ID ipi address port [unix] [reset]\n  \n  \n  \n  ID, group-ID are documented in fix command\n  ipi = style name of this fix command\n  address = internet address (FQDN or IP), or UNIX socket name\n  port = port number (ignored for UNIX sockets)\n  optional keyword = unix, if present uses a unix socket\n  optional keyword = reset, if present reset electrostatics at each call\n  \n  ",
    "examples": "fix 1 all ipi my.server.com 12345\n  fix 1 all ipi mysocket 666 unix reset\n  \n  \n  ",
    "restrictions": "Using this fix on anything other than all atoms requires particular\n  care, since i-PI will know nothing on atoms that are not those whose\n  coordinates are transferred. However, one could use this strategy to\n  define an external potential acting on the atoms that are moved by\n  i-PI.\n  This fix is part of the USER-MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.  Because of the\n  use of UNIX domain sockets, this fix will only work in a UNIX\n  environment.\n  "
},
{
    "command": "fix langevin",
    "description": "Apply a Langevin thermostat as described in (Schneider)\n  to a group of atoms which models an interaction with a background\n  implicit solvent.  Used with fix nve, this command\n  performs Brownian dynamics (BD), since the total force on each atom\n  will have the form:\n  \n  \\[\\begin{split}F = & F_c + F_f + F_r \\\\\n  F_f = & - \\frac{m}{\\mathrm{damp}} v \\\\\n  F_r \\propto & \\sqrt{\\frac{k_B T m}{dt~\\mathrm{damp}}}\\end{split}\\]\n  \\(F_c\\) is the conservative force computed via the usual\n  inter-particle interactions (pair_style,\n  bond_style, etc).  The \\(F_f\\) and \\(F_r\\)\n  terms are added by this fix on a per-particle basis.  See the\n  pair_style dpd/tstat command for a thermostatting\n  option that adds similar terms on a pairwise basis to pairs of\n  interacting particles.\n  \\(F_f\\) is a frictional drag or viscous damping term proportional to\n  the particle’s velocity.  The proportionality constant for each atom is\n  computed as \\(\\frac{m}{\\mathrm{damp}}\\), where m is the mass of the\n  particle and damp is the damping factor specified by the user.\n  \\(F_r\\) is a force due to solvent atoms at a temperature T\n  randomly bumping into the particle.  As derived from the\n  fluctuation/dissipation theorem, its magnitude as shown above is\n  proportional to \\(\\sqrt{\\frac{k_B T m}{dt~\\mathrm{damp}}}\\), where\n  \\(k_B\\) is the Boltzmann constant, T is the desired temperature,\n  m is the mass of the particle, dt is the timestep size, and damp is\n  the damping factor.  Random numbers are used to randomize the direction\n  and magnitude of this force as described in (Dunweg),\n  where a uniform random number is used (instead of a Gaussian random\n  number) for speed.\n  Note that unless you use the omega or angmom keywords, the\n  thermostat effect of this fix is applied to only the translational\n  degrees of freedom for the particles, which is an important\n  consideration for finite-size particles, which have rotational degrees\n  of freedom, are being thermostatted.  The translational degrees of\n  freedom can also have a bias velocity removed from them before\n  thermostatting takes place; see the description below.\n  \n  Note\n  Unlike the fix nvt command which performs Nose/Hoover\n  thermostatting AND time integration, this fix does NOT perform time\n  integration.  It only modifies forces to effect thermostatting.  Thus\n  you must use a separate time integration fix, like fix nve to actually update the velocities and positions of atoms\n  using the modified forces.  Likewise, this fix should not normally be\n  used on atoms that also have their temperature controlled by another\n  fix - e.g. by fix nvt or fix temp/rescale commands.\n  \n  See the Howto thermostat doc page for\n  a discussion of different ways to compute temperature and perform\n  thermostatting.\n  The desired temperature at each timestep is a ramped value during the\n  run from Tstart to Tstop.\n  Tstart can be specified as an equal-style or atom-style\n  variable.  In this case, the Tstop setting is\n  ignored.  If the value is a variable, it should be specified as\n  v_name, where name is the variable name.  In this case, the variable\n  will be evaluated each timestep, and its value used to determine the\n  target temperature.\n  Equal-style variables can specify formulas with various mathematical\n  functions, and include thermo_style command\n  keywords for the simulation box parameters and timestep and elapsed\n  time.  Thus it is easy to specify a time-dependent temperature.\n  Atom-style variables can specify the same formulas as equal-style\n  variables but can also include per-atom values, such as atom\n  coordinates.  Thus it is easy to specify a spatially-dependent\n  temperature with optional time-dependence as well.\n  Like other fixes that perform thermostatting, this fix can be used\n  with compute commands that remove a “bias” from the\n  atom velocities.  E.g. removing the center-of-mass velocity from a\n  group of atoms or removing the x-component of velocity from the\n  calculation.  This is not done by default, but only if the\n  fix_modify command is used to assign a temperature\n  compute to this fix that includes such a bias term.  See the doc pages\n  for individual compute commands to determine which ones\n  include a bias.  In this case, the thermostat works in the following\n  manner: bias is removed from each atom, thermostatting is performed on\n  the remaining thermal degrees of freedom, and the bias is added back\n  in.\n  The damp parameter is specified in time units and determines how\n  rapidly the temperature is relaxed.  For example, a value of 100.0 means\n  to relax the temperature in a timespan of (roughly) 100 time units\n  (\\(\\tau\\) or fs or ps - see the units command).  The\n  damp factor can be thought of as inversely related to the viscosity of\n  the solvent.  I.e. a small relaxation time implies a high-viscosity\n  solvent and vice versa.  See the discussion about \\(\\gamma\\) and\n  viscosity in the documentation for the fix viscous\n  command for more details.\n  The random # seed must be a positive integer.  A Marsaglia random\n  number generator is used.  Each processor uses the input seed to\n  generate its own unique seed and its own stream of random numbers.\n  Thus the dynamics of the system will not be identical on two runs on\n  different numbers of processors.\n  \n  The keyword/value option pairs are used in the following ways.\n  The keyword angmom and omega keywords enable thermostatting of\n  rotational degrees of freedom in addition to the usual translational\n  degrees of freedom.  This can only be done for finite-size particles.\n  A simulation using atom_style sphere defines an omega for finite-size\n  spheres.  A simulation using atom_style ellipsoid defines a finite\n  size and shape for aspherical particles and an angular momentum.\n  The Langevin formulas for thermostatting the rotational degrees of\n  freedom are the same as those above, where force is replaced by\n  torque, m is replaced by the moment of inertia I, and v is replaced by\n  omega (which is derived from the angular momentum in the case of\n  aspherical particles).\n  The rotational temperature of the particles can be monitored by the\n  compute temp/sphere and compute temp/asphere commands with their rotate\n  options.\n  For the omega keyword there is also a scale factor of\n  \\(\\frac{10.0}{3.0}\\) that is applied as a multiplier on the\n  \\(F_f\\) (damping) term in the equation above and of\n  \\(\\sqrt{\\frac{10.0}{3.0}}\\) as a multiplier on the \\(F_r\\) term.\n  This does not affect the thermostatting behavior of the Langevin\n  formalism but insures that the randomized rotational diffusivity of\n  spherical particles is correct.\n  For the angmom keyword a similar scale factor is needed which is\n  \\(\\frac{10.0}{3.0}\\) for spherical particles, but is anisotropic for\n  aspherical particles (e.g. ellipsoids).  Currently LAMMPS only applies\n  an isotropic scale factor, and you can choose its magnitude as the\n  specified value of the angmom keyword.  If your aspherical particles\n  are (nearly) spherical than a value of \\(\\frac{10.0}{3.0} =\n  3.\\overline{3}\\) is a good choice.  If they are highly aspherical, a\n  value of 1.0 is as good a choice as any, since the effects on rotational\n  diffusivity of the particles will be incorrect regardless.  Note that\n  for any reasonable scale factor, the thermostatting effect of the\n  angmom keyword on the rotational temperature of the aspherical\n  particles should still be valid.\n  The keyword scale allows the damp factor to be scaled up or down by\n  the specified factor for atoms of that type.  This can be useful when\n  different atom types have different sizes or masses.  It can be used\n  multiple times to adjust damp for several atom types.  Note that\n  specifying a ratio of 2 increases the relaxation time which is\n  equivalent to the solvent’s viscosity acting on particles with\n  \\(\\frac{1}{2}\\) the diameter.  This is the opposite effect of scale\n  factors used by the fix viscous command, since the\n  damp factor in fix langevin is inversely related to the \\(\\gamma\\)\n  factor in fix viscous.  Also note that the damping factor in fix\n  langevin includes the particle mass in Ff, unlike fix viscous.\n  Thus the mass and size of different atom types should be accounted for\n  in the choice of ratio values.\n  The keyword tally enables the calculation of the cumulative energy\n  added/subtracted to the atoms as they are thermostatted.  Effectively\n  it is the energy exchanged between the infinite thermal reservoir and\n  the particles.  As described below, this energy can then be printed\n  out or added to the potential energy of the system to monitor energy\n  conservation.\n  \n  Note\n  this accumulated energy does NOT include kinetic energy removed\n  by the zero flag. LAMMPS will print a warning when both options are\n  active.\n  \n  The keyword zero can be used to eliminate drift due to the\n  thermostat. Because the random forces on different atoms are\n  independent, they do not sum exactly to zero.  As a result, this fix\n  applies a small random force to the entire system, and the\n  center-of-mass of the system undergoes a slow random walk.  If the\n  keyword zero is set to yes, the total random force is set exactly\n  to zero by subtracting off an equal part of it from each atom in the\n  group.  As a result, the center-of-mass of a system with zero initial\n  momentum will not drift over time.\n  The keyword gjf can be used to run the Gronbech-Jensen/Farago time-discretization of the Langevin model.  As\n  described in the papers cited below, the purpose of this method is to\n  enable longer timesteps to be used (up to the numerical stability\n  limit of the integrator), while still producing the correct Boltzmann\n  distribution of atom positions.\n  The current implementation provides the user with the option to output\n  the velocity in one of two forms: vfull or vhalf, which replaces\n  the outdated option yes. The gjf option vfull outputs the on-site\n  velocity given in Gronbech-Jensen/Farago; this velocity\n  is shown to be systematically lower than the target temperature by a small\n  amount, which grows quadratically with the timestep.\n  The gjf option vhalf outputs the 2GJ half-step velocity given in\n  Gronbech Jensen/Gronbech-Jensen; for linear systems,\n  this velocity is shown to not have any statistical errors for any stable time step.\n  An overview of statistically correct Boltzmann and Maxwell-Boltzmann\n  sampling of true on-site and true half-step velocities is given in\n  Gronbech-Jensen.\n  Regardless of the choice of output velocity, the sampling of the configurational\n  distribution of atom positions is the same, and linearly consistent with the\n  target temperature.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  Because the state of the random number generator\n  is not saved in restart files, this means you cannot do “exact”\n  restarts with this fix, where the simulation continues on the same as\n  if no restart had taken place.  However, in a statistical sense, a\n  restarted simulation should produce the same behavior.\n  The fix_modify temp option is supported by this\n  fix.  You can use it to assign a temperature compute\n  you have defined to this fix which will be used in its thermostatting\n  procedure, as described above.  For consistency, the group used by\n  this fix and by the compute should be the same.\n  The fix_modify energy option is supported by this\n  fix to add the energy change induced by Langevin thermostatting to the\n  system’s potential energy as part of thermodynamic output.  Note that use of this option requires\n  setting the tally keyword to yes.\n  This fix computes a global scalar which can be accessed by various\n  output commands.  The scalar is the cumulative\n  energy change due to this fix.  The scalar value calculated by this\n  fix is “extensive”.  Note that calculation of this quantity requires\n  setting the tally keyword to yes.\n  This fix can ramp its target temperature over multiple runs, using the\n  start and stop keywords of the run command.  See the\n  run command for details of how to do this.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID langevin Tstart Tstop damp seed keyword values ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  langevin = style name of this fix command\n  Tstart,Tstop = desired temperature at start/end of run (temperature units)\n  Tstart can be a variable (see below)\n  damp = damping parameter (time units)\n  seed = random number seed to use for white noise (positive integer)\n  zero or more keyword/value pairs may be appended\n  keyword = angmom or omega or scale or tally or zero\n  angmom value = no or factor\n    no = do not thermostat rotational degrees of freedom via the angular momentum\n    factor = do thermostat rotational degrees of freedom via the angular momentum and apply numeric scale factor as discussed below\n  gjf value = no or vfull or vhalf\n    no = use standard formulation\n    vfull = use Gronbech-Jensen/Farago formulation\n    vhalf = use 2GJ formulation\n  omega value = no or yes\n    no = do not thermostat rotational degrees of freedom via the angular velocity\n    yes = do thermostat rotational degrees of freedom via the angular velocity\n  scale values = type ratio\n    type = atom type (1-N)\n    ratio = factor by which to scale the damping coefficient\n  tally value = no or yes\n    no = do not tally the energy added/subtracted to atoms\n    yes = do tally the energy added/subtracted to atoms\n  zero value = no or yes\n    no = do not set total random force to zero\n    yes = set total random force to zero\n  \n  \n  ",
    "examples": "fix 3 boundary langevin 1.0 1.0 1000.0 699483\n  fix 1 all langevin 1.0 1.1 100.0 48279 scale 3 1.5\n  fix 1 all langevin 1.0 1.1 100.0 48279 angmom 3.333\n  \n  \n  ",
    "restrictions": "For gjf do not choose damp=dt/2. gjf is not compatible\n  with run_style respa.\n  "
},
{
    "command": "fix langevin/drude",
    "description": "Apply two Langevin thermostats as described in (Jiang) for\n  thermalizing the reduced degrees of freedom of Drude oscillators.\n  This link describes how to use the thermalized Drude oscillator model in LAMMPS and polarizable models in LAMMPS\n  are discussed on the Howto polarizable doc\n  page.\n  Drude oscillators are a way to simulate polarizables atoms, by\n  splitting them into a core and a Drude particle bound by a harmonic\n  bond.  The thermalization works by transforming the particles degrees\n  of freedom by these equations.  In these equations upper case denotes\n  atomic or center of mass values and lower case denotes Drude particle\n  or dipole values. Primes denote the transformed (reduced) values,\n  while bare letters denote the original values.\n  Velocities:\n  \n  \\[V' = \\frac {M\\, V + m\\, v} {M'}\\]\n  \n  \\[v' = v - V\\]\n  Masses:\n  \n  \\[M' = M + m\\]\n  \n  \\[m' = \\frac {M\\, m } {M'}\\]\n  The Langevin forces are computed as\n  \n  \\[F' = - \\frac {M'} {\\mathtt{damp_com}}\\, V' + F_r'\\]\n  \n  \\[f' = - \\frac {m'} {\\mathtt{damp_drude}}\\, v' + f_r'\\]\n  \\(F_r'\\) is a random force proportional to\n  \\(\\sqrt { \\frac {2\\, k_B \\mathtt{Tcom}\\, m'}                  {\\mathrm dt\\, \\mathtt{damp_com} }         }\\).\n  \\(f_r'\\) is a random force proportional to\n  \\(\\sqrt { \\frac {2\\, k_B \\mathtt{Tdrude}\\, m'}                  {\\mathrm dt\\, \\mathtt{damp_drude} }         }\\).\n  Then the real forces acting on the particles are computed from the inverse\n  transform:\n  \n  \\[F = \\frac M {M'}\\, F' - f'\\]\n  \n  \\[f = \\frac m {M'}\\, F' + f'\\]\n  This fix also thermostats non-polarizable atoms in the group at\n  temperature Tcom, as if they had a massless Drude partner.  The\n  Drude particles themselves need not be in the group. The center of\n  mass and the dipole are thermostatted iff the core atom is in the\n  group.\n  Note that the thermostat effect of this fix is applied to only the\n  translational degrees of freedom of the particles, which is an\n  important consideration if finite-size particles, which have\n  rotational degrees of freedom, are being thermostatted. The\n  translational degrees of freedom can also have a bias velocity removed\n  from them before thermostatting takes place; see the description below.\n  \n  Note\n  Like the fix langevin command, this fix does\n  NOT perform time integration. It only modifies forces to effect\n  thermostatting. Thus you must use a separate time integration fix, like\n  fix nve or fix nph to actually update the\n  velocities and positions of atoms using the modified forces.\n  Likewise, this fix should not normally be used on atoms that also have\n  their temperature controlled by another fix - e.g. by fix nvt or fix temp/rescale commands.\n  \n  See the Howto thermostat doc page for a\n  discussion of different ways to compute temperature and perform\n  thermostatting.\n  \n  This fix requires each atom know whether it is a Drude particle or\n  not.  You must therefore use the fix drude command to\n  specify the Drude status of each atom type.\n  \n  Note\n  only the Drude core atoms need to be in the group specified for\n  this fix. A Drude electron will be transformed together with its cores\n  even if it is not itself in the group.  It is safe to include Drude\n  electrons or non-polarizable atoms in the group. The non-polarizable\n  atoms will simply be thermostatted as if they had a massless Drude\n  partner (electron).\n  \n  \n  Note\n  Ghost atoms need to know their velocity for this fix to act\n  correctly.  You must use the comm_modify command to\n  enable this, e.g.\n  \n  comm_modify vel yes\n  \n  \n  \n  Tcom is the target temperature of the centers of mass, which would\n  be used to thermostat the non-polarizable atoms.  Tdrude is the\n  (normally low) target temperature of the core-Drude particle pairs\n  (dipoles).  Tcom and Tdrude can be specified as an equal-style\n  variable.  If the value is a variable, it should be\n  specified as v_name, where name is the variable name. In this case,\n  the variable will be evaluated each timestep, and its value used to\n  determine the target temperature.\n  Equal-style variables can specify formulas with various mathematical\n  functions, and include thermo_style command\n  keywords for the simulation box parameters and timestep and elapsed\n  time.  Thus it is easy to specify a time-dependent temperature.\n  Like other fixes that perform thermostatting, this fix can be used with\n  compute commands that remove a “bias” from the atom\n  velocities.  E.g. removing the center-of-mass velocity from a group of\n  atoms.  This is not done by default, but only if the\n  fix_modify command is used to assign a temperature\n  compute to this fix that includes such a bias term.  See the doc pages\n  for individual compute commands to determine which ones\n  include a bias.  In this case, the thermostat works in the following\n  manner: bias is removed from each atom, thermostatting is performed on\n  the remaining thermal degrees of freedom, and the bias is added back\n  in.  NOTE: this feature has not been tested.\n  Note: The temperature thermostatting the core-Drude particle pairs\n  should be chosen low enough, so as to mimic as closely as possible the\n  self-consistent minimization. It must however be high enough, so that\n  the dipoles can follow the local electric field exerted by the\n  neighboring atoms. The optimal value probably depends on the\n  temperature of the centers of mass and on the mass of the Drude\n  particles.\n  damp_com is the characteristic time for reaching thermal equilibrium\n  of the centers of mass.  For example, a value of 100.0 means to relax\n  the temperature of the centers of mass in a timespan of (roughly) 100\n  time units (tau or fmsec or psec - see the units\n  command).  damp_drude is the characteristic time for reaching\n  thermal equilibrium of the dipoles. It is typically a few timesteps.\n  The number seed_com and seed_drude are positive integers. They set\n  the seeds of the Marsaglia random number generators used for\n  generating the random forces on centers of mass and on the\n  dipoles. Each processor uses the input seed to generate its own unique\n  seed and its own stream of random numbers.  Thus the dynamics of the\n  system will not be identical on two runs on different numbers of\n  processors.\n  The keyword zero can be used to eliminate drift due to the\n  thermostat on centers of mass. Because the random forces on different\n  centers of mass are independent, they do not sum exactly to zero.  As\n  a result, this fix applies a small random force to the entire system,\n  and the momentum of the total center of mass of the system undergoes a\n  slow random walk.  If the keyword zero is set to yes, the total\n  random force on the centers of mass is set exactly to zero by\n  subtracting off an equal part of it from each center of mass in the\n  group. As a result, the total center of mass of a system with zero\n  initial momentum will not drift over time.\n  The actual temperatures of cores and Drude particles, in\n  center-of-mass and relative coordinates, respectively, can be\n  calculated using the compute temp/drude\n  command.\n  \n  Usage example for rigid bodies in the NPT ensemble:\n  comm_modify vel yes\n  fix TEMP all langevin/drude 300. 100. 1256 1. 20. 13977 zero yes\n  fix NPH ATOMS rigid/nph/small molecule iso 1. 1. 500.\n  fix NVE DRUDES nve\n  compute TDRUDE all temp/drude\n  thermo_style custom step cpu etotal ke pe ebond ecoul elong press vol temp c_TDRUDE[1] c_TDRUDE[2]\n  \n  \n  Comments:\n  \n  Drude particles should not be in the rigid group, otherwise the Drude\n  oscillators will be frozen and the system will lose its\n  polarizability.\n  zero yes avoids a drift of the center of mass of\n  the system, but is a bit slower.\n  Use two different random seeds to avoid unphysical correlations.\n  Temperature is controlled by the fix langevin/drude, so the\n  time-integration fixes do not thermostat.  Don’t forget to\n  time-integrate both cores and Drude particles.\n  Pressure is time-integrated only once by using nve for Drude\n  particles and nph for atoms/cores (or vice versa). Do not use nph\n  for both.\n  The temperatures of cores and Drude particles are calculated by\n  compute temp/drude\n  Contrary to the alternative thermostatting using Nose-Hoover thermostat\n  fix npt and fix drude/transform, the\n  fix_modify command is not required here, because the fix nph\n  computes the global pressure even if its group is ATOMS. This is\n  what we want. If we thermostatted ATOMS using npt, the pressure\n  should be the global one, but the temperature should be only that of\n  the cores. That’s why the command fix_modify should be called in\n  that case.\n  \n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  Because the state of the random number generator\n  is not saved in restart files, this means you cannot do “exact”\n  restarts with this fix, where the simulation continues on the same as\n  if no restart had taken place.  However, in a statistical sense, a\n  restarted simulation should produce the same behavior.\n  The fix_modify temp option is supported by this\n  fix.  You can use it to assign a temperature compute\n  you have defined to this fix which will be used in its thermostatting\n  procedure, as described above. For consistency, the group used by the\n  compute should include the group of this fix and the Drude particles.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID langevin/drude Tcom damp_com seed_com Tdrude damp_drude seed_drude keyword values ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  langevin/drude = style name of this fix command\n  Tcom = desired temperature of the centers of mass (temperature units)\n  damp_com = damping parameter for the thermostat on centers of mass (time units)\n  seed_com = random number seed to use for white noise of the thermostat on centers of mass (positive integer)\n  Tdrude = desired temperature of the Drude oscillators (temperature units)\n  damp_drude = damping parameter for the thermostat on Drude oscillators (time units)\n  seed_drude = random number seed to use for white noise of the thermostat on Drude oscillators (positive integer)\n  zero or more keyword/value pairs may be appended\n  keyword = zero\n  zero value = no or yes\n    no = do not set total random force on centers of mass to zero\n    yes = set total random force on centers of mass to zero\n  \n  \n  ",
    "examples": "fix 3 all langevin/drude 300.0 100.0 19377 1.0 20.0 83451\n  fix 1 all langevin/drude 298.15 100.0 19377 5.0 10.0 83451 zero yes\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix langevin/eff",
    "description": "Apply a Langevin thermostat as described in (Schneider)\n  to a group of nuclei and electrons in the electron force field model.  Used with fix nve/eff,\n  this command performs Brownian dynamics (BD), since the total force on\n  each atom will have the form:\n  \n  \\[\\begin{split}F   = & F_c + F_f + F_r \\\\\n  F_f = & - \\frac{m}{\\mathrm{damp}} v \\\\\n  F_r \\propto &  \\sqrt{\\frac{k_B T m}{dt~\\mathrm{damp}}}\\end{split}\\]\n  \\(F_c\\) is the conservative force computed via the usual\n  inter-particle interactions (pair_style).\n  The \\(F_f\\) and \\(F_r\\) terms are added by this fix on a\n  per-particle basis.\n  The operation of this fix is exactly like that described by the\n  fix langevin command, except that the\n  thermostatting is also applied to the radial electron velocity for\n  electron particles.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  Because the state of the random number generator is not\n  saved in restart files, this means you cannot do “exact” restarts with\n  this fix, where the simulation continues on the same as if no restart\n  had taken place.  However, in a statistical sense, a restarted\n  simulation should produce the same behavior.\n  The fix_modify temp option is supported by this\n  fix.  You can use it to assign a temperature compute\n  you have defined to this fix which will be used in its thermostatting\n  procedure, as described above.  For consistency, the group used by\n  this fix and by the compute should be the same.\n  The fix_modify energy option is supported by this\n  fix to add the energy change induced by Langevin thermostatting to the\n  system’s potential energy as part of thermodynamic output.  Note that use of this option requires\n  setting the tally keyword to yes.\n  This fix computes a global scalar which can be accessed by various\n  output commands.  The scalar is the cumulative\n  energy change due to this fix.  The scalar value calculated by this\n  fix is “extensive”.  Note that calculation of this quantity requires\n  setting the tally keyword to yes.\n  This fix can ramp its target temperature over multiple runs, using the\n  start and stop keywords of the run command.  See the\n  run command for details of how to do this.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID langevin/eff Tstart Tstop damp seed keyword values ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  langevin/eff = style name of this fix command\n  Tstart,Tstop = desired temperature at start/end of run (temperature units)\n  damp = damping parameter (time units)\n  seed = random number seed to use for white noise (positive integer)\n  zero or more keyword/value pairs may be appended\n  keyword = scale or tally or zero\n    scale values = type ratio\n      type = atom type (1-N)\n      ratio = factor by which to scale the damping coefficient\n    tally values = no or yes\n      no = do not tally the energy added/subtracted to atoms\n      yes = do tally the energy added/subtracted to atoms\n  zero value = no or yes\n    no = do not set total random force to zero\n    yes = set total random force to zero\n  \n  \n  ",
    "examples": "fix 3 boundary langevin/eff 1.0 1.0 10.0 699483\n  fix 1 all langevin/eff 1.0 1.1 10.0 48279 scale 3 1.5\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  This fix is part of the USER-EFF package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "fix langevin/spin",
    "description": "Apply a Langevin thermostat as described in (Mayergoyz) to the\n  magnetic spins associated to the atoms.\n  Used with fix nve/spin, this command performs\n  Brownian dynamics (BD).\n  A random torque and a transverse dissipation are applied to each spin i according to\n  the following stochastic differential equation:\n  \n  \\[ \\frac{d \\vec{s}_{i}}{dt} = \\frac{1}{\\left(1+\\lambda^2 \\right)} \\left( \\left(\n   \\vec{\\omega}_{i} +\\vec{\\eta} \\right) \\times \\vec{s}_{i} + \\lambda\\, \\vec{s}_{i}\n  \\times\\left( \\vec{\\omega}_{i} \\times\\vec{s}_{i} \\right) \\right)\\]\n  with \\(\\lambda\\) the transverse damping, and \\(\\eta\\) a random vector.\n  This equation is referred to as the stochastic Landau-Lifshitz-Gilbert (sLLG)\n  equation.\n  The components of \\(\\eta\\) are drawn from a Gaussian probability\n  law. Their amplitude is defined as a proportion of the temperature of\n  the external thermostat T (in K in metal units).\n  More details about this implementation are reported in (Tranchida).\n  Note: due to the form of the sLLG equation, this fix has to be defined just\n  before the nve/spin fix (and after all other magnetic fixes).\n  As an example:\n  fix 1 all precession/spin zeeman 0.01 0.0 0.0 1.0\n  fix 2 all langevin/spin 300.0 0.01 21\n  fix 3 all nve/spin lattice moving\n  \n  \n  is correct, but defining a force/spin command after the langevin/spin command\n  would give an error message.\n  Note: The random # seed must be a positive integer.  A Marsaglia random\n  number generator is used.  Each processor uses the input seed to\n  generate its own unique seed and its own stream of random numbers.\n  Thus the dynamics of the system will not be identical on two runs on\n  different numbers of processors.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  Because the state of the random number generator\n  is not saved in restart files, this means you cannot do “exact”\n  restarts with this fix, where the simulation continues on the same as\n  if no restart had taken place.  However, in a statistical sense, a\n  restarted simulation should produce the same behavior.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID langevin/spin T Tdamp seed\n  \n  \n  \n  ID, group-ID are documented in fix command\n  langevin/spin = style name of this fix command\n  T = desired temperature of the bath (temperature units, K in metal units)\n  Tdamp = transverse magnetic damping parameter (adim)\n  seed = random number seed to use for white noise (positive integer)\n  \n  ",
    "examples": "fix 2 all langevin/spin 300.0 0.01 21\n  \n  \n  ",
    "restrictions": "The langevin/spin fix is part of the SPIN package.  This style is\n  only enabled if LAMMPS was built with this package.  See the Build package doc page for more info.\n  The numerical integration has to be performed with fix nve/spin\n  when fix langevin/spin is enabled.\n  This fix has to be the last defined magnetic fix before the time\n  integration fix (e.g. fix nve/spin).\n  "
},
{
    "command": "fix latte",
    "description": "This fix style is a wrapper on the self-consistent charge transfer\n  density functional based tight binding (DFTB) code LATTE. If you\n  download and build LATTE, it can be called as a library by LAMMPS via\n  this fix to run dynamics or perform energy minimization using DFTB\n  forces and energies computed by LATTE.\n  LATTE is principally developed and supported by Marc Cawkwell and\n  co-workers at Los Alamos National Laboratory (LANL).  See the full\n  list of contributors in the src/LATTE/README file.\n  To use this fix, the LATTE program needs to be compiled as a library\n  and linked with LAMMPS.  LATTE can be downloaded (or cloned) from\n  https://github.com/lanl/LATTE.\n  Instructions on how to download and build LATTE on your system can be\n  found in the lib/latte/README.  Note that you can also use the “make\n  lib-latte” command from the LAMMPS src directory to automate this\n  process.\n  Once LAMMPS is built with the LATTE package, you can run the example\n  input scripts for molecular dynamics or energy minimization that are\n  found in examples/latte.\n  A step-by-step tutorial can be followed at: LAMMPS-LATTE tutorial\n  The peID argument is not yet supported by fix latte, so it must be\n  specified as NULL.  Eventually it will be used to enable LAMMPS to\n  calculate a Coulomb potential as an alternative to LATTE performing\n  the calculation.\n  \n  LATTE is a code for performing self-consistent charge transfer\n  tight-binding (SC-TB) calculations of total energies and the forces\n  acting on atoms in molecules and solids. This tight-binding method is\n  becoming more and more popular and widely used in chemistry,\n  biochemistry, material science, etc.\n  The SC-TB formalism is derived from an expansion of the Kohn-Sham\n  density functional to second order in charge fluctuations about a\n  reference charge of overlapping atom-centered densities and bond\n  integrals are parameterized using a Slater-Koster tight-binding\n  approach. This procedure, which usually is referred to as the DFTB\n  method has been described in detail by (Elstner) and\n  (Finnis) and coworkers.\n  The work of the LATTE developers follows that of Elstner closely with\n  respect to the physical model.  However, the development of LATTE is\n  geared principally toward large-scale, long duration, microcanonical\n  quantum-based Born-Oppenheimer molecular dynamics (QMD) simulations.\n  One of the main bottlenecks of an electronic structure calculation is\n  the solution of the generalized eigenvalue problem which scales with\n  the cube of the system size O(N^3).\n  The Theoretical and Computer sciences divisions at Los Alamos National\n  Laboratory have accumulated large experience addressing this issue by\n  calculating the density matrix directly instead of using\n  diagonalization. We typically use a recursive sparse Fermi-operator\n  expansion using second-order spectral projection functions\n  (SP2-algorithm), which was introduced by Niklasson in 2002\n  (Niklasson2002), (Rubensson),\n  (Mniszewski).  When the matrices involved in the\n  recursive expansion are sufficiently sparse, the calculation of the\n  density matrix scales linearly as a function of the system size O(N).\n  Another important feature is the extended Lagrangian framework for\n  Born-Oppenheimer molecular dynamics (XL-BOMD)\n  (Niklasson2008) (Niklasson2014),\n  (Niklasson2017) that allows for a drastic reduction\n  or even a complete removal of the iterative self-consistent field\n  optimization.  Often only a single density matrix calculation per\n  molecular dynamics time step is required, yet total energy stability\n  is well maintained.  The SP2 and XL-BOMD techniques enables stable\n  linear scaling MD simulations with a very small computational\n  overhead.  This opens a number of opportunities in many different\n  areas of chemistry and materials science, as we now can simulate\n  larger system sizes and longer time scales\n  (Cawkwell2012), (Negre2016).\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The fix_modify energy option is supported by this\n  fix to add the potential energy computed by LATTE to the system’s\n  potential energy as part of thermodynamic output.\n  The fix_modify virial option is supported by this\n  fix to add the LATTE DFTB contribution to the system’s virial as part\n  of thermodynamic output.  The default is virial\n  yes\n  This fix computes a global scalar which can be accessed by various\n  output commands.  The scalar is the potential\n  energy discussed above.  The scalar value calculated by this fix is\n  “extensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  The DFTB forces computed by LATTE via this fix are imposed during an\n  energy minimization, invoked by the minimize command.\n  \n  Note\n  If you want the potential energy associated with the DFTB\n  forces to be included in the total potential energy of the system (the\n  quantity being minimized), you MUST enable the\n  fix_modify energy option for this fix.\n  \n  ",
    "syntax": "fix ID group-ID latte peID\n  \n  \n  \n  ID, group-ID are documented in fix command\n  latte = style name of this fix command\n  peID = NULL or ID of compute used to calculate per-atom energy\n  \n  ",
    "examples": "fix dftb all latte NULL\n  \n  \n  ",
    "restrictions": "This fix is part of the LATTE package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  You must use metal units, as set by the units command to\n  use this fix.\n  LATTE does not currently compute per-atom energy or per-atom virial\n  contributions.  So they will not show up as part of the calculations\n  performed by the compute pe/atom or compute stress/atom commands.\n  Currently, LAMMPS must be run in serial or as a single MPI task, to\n  use this fix.  This is typically not a bottleneck, since LATTE will be\n  doing 99% or more of the work to compute quantum-accurate forces.\n  \n  Note\n  NEB calculations can be done using this fix using multiple\n  replicas and running LAMMPS in parallel.  However, each replica must\n  be run on a single MPI task.  For details, see the neb\n  command doc page and the -partition command-line switch\n  \n  Related commands: none\n  Default: none\n  \n  (Elstner) M. Elstner, D. Poresag, G. Jungnickel, J. Elsner,\n  M. Haugk, T. Frauenheim, S. Suhai, and G. Seifert, Phys. Rev. B, 58,\n  7260 (1998).\n  (Elstner) M. Elstner, D. Poresag, G. Jungnickel, J. Elsner,\n  M. Haugk, T. Frauenheim, S. Suhai, and G. Seifert, Phys. Rev. B, 58,\n  7260 (1998).\n  (Finnis) M. W. Finnis, A. T. Paxton, M. Methfessel, and M. van\n  Schilfgarde, Phys. Rev. Lett., 81, 5149 (1998).\n  (Mniszewski) S. M. Mniszewski, M. J. Cawkwell, M. E. Wall,\n  J. Mohd-Yusof, N. Bock, T. C.  Germann, and A. M. N. Niklasson,\n  J. Chem. Theory Comput., 11, 4644 (2015).\n  (Niklasson2002) A. M. N. Niklasson, Phys. Rev. B, 66, 155115 (2002).\n  (Rubensson) E. H. Rubensson, A. M. N. Niklasson, SIAM\n  J. Sci. Comput. 36 (2), 147-170, (2014).\n  (Niklasson2008) A. M. N. Niklasson, Phys. Rev. Lett., 100, 123004\n  (2008).\n  (Niklasson2014) A. M. N. Niklasson and M. Cawkwell, J. Chem. Phys.,\n  141, 164123, (2014).\n  (Niklasson2017) A. M. N. Niklasson, J. Chem. Phys., 147, 054103 (2017).\n  (Cawkwell2012) A. M. N. Niklasson, M. J. Cawkwell, Phys. Rev. B, 86\n  (17), 174308 (2012).\n  (Negre2016) C. F. A. Negre, S. M. Mniszewski, M. J. Cawkwell,\n  N. Bock, M. E. Wall, and A. M. N. Niklasson, J. Chem. Theory Comp.,\n  12, 3063 (2016).\n  "
},
{
    "command": "fix lb/fluid",
    "description": "Implement a lattice-Boltzmann fluid on a uniform mesh covering the LAMMPS\n  simulation domain.  The MD particles described by group-ID apply a velocity\n  dependent force to the fluid.\n  The lattice-Boltzmann algorithm solves for the fluid motion governed by\n  the Navier Stokes equations,\n  \n  \\[\\begin{split}\\partial_t \\rho + \\partial_{\\beta}\\left(\\rho u_{\\beta}\\right)= & 0 \\\\\n  \\partial_t\\left(\\rho u_{\\alpha}\\right) + \\partial_{\\beta}\\left(\\rho u_{\\alpha} u_{\\beta}\\right) = & \\partial_{\\beta}\\sigma_{\\alpha \\beta} + F_{\\alpha} + \\partial_{\\beta}\\left(\\eta_{\\alpha \\beta \\gamma \\nu}\\partial_{\\gamma} u_{\\nu}\\right)\\end{split}\\]\n  with,\n  \n  \\[\\eta_{\\alpha \\beta \\gamma \\nu} = \\eta\\left[\\delta_{\\alpha \\gamma}\\delta_{\\beta \\nu} + \\delta_{\\alpha \\nu}\\delta_{\\beta \\gamma} - \\frac{2}{3}\\delta_{\\alpha \\beta}\\delta_{\\gamma \\nu}\\right] + \\Lambda \\delta_{\\alpha \\beta}\\delta_{\\gamma \\nu}\\]\n  where \\(\\rho\\) is the fluid density, u is the local\n  fluid velocity, \\(\\sigma\\) is the stress tensor, F is a local external\n  force, and \\(\\eta\\) and \\(\\Lambda\\) are the shear and bulk viscosities\n  respectively.  Here, we have implemented\n  \n  \\[\\sigma_{\\alpha \\beta} = -P_{\\alpha \\beta} = -\\rho a_0 \\delta_{\\alpha \\beta}\\]\n  with \\(a_0\\) set to \\(\\frac{1}{3} \\frac{dx}{dt}^2\\) by default.\n  The algorithm involves tracking the time evolution of a set of partial\n  distribution functions which evolve according to a velocity\n  discretized version of the Boltzmann equation,\n  \n  \\[\\left(\\partial_t + e_{i\\alpha}\\partial_{\\alpha}\\right)f_i = -\\frac{1}{\\tau}\\left(f_i - f_i^{eq}\\right) + W_i\\]\n  where the first term on the right hand side represents a single time\n  relaxation towards the equilibrium distribution function, and \\(\\tau\\) is a\n  parameter physically related to the viscosity.  On a technical note,\n  we have implemented a 15 velocity model (D3Q15) as default; however,\n  the user can switch to a 19 velocity model (D3Q19) through the use of\n  the D3Q19 keyword.  This fix provides the user with the choice of\n  two algorithms to solve this equation, through the specification of\n  the keyword LBtype.  If LBtype is set equal to 1, the standard\n  finite difference LB integrator is used.  If LBtype is set equal to\n  2, the algorithm of Ollila et al. is used.\n  Physical variables are then defined in terms of moments of the distribution\n  functions,\n  \n  \\[\\begin{split}\\rho = & \\displaystyle\\sum\\limits_{i} f_i \\\\\n  \\rho u_{\\alpha} = & \\displaystyle\\sum\\limits_{i} f_i e_{i\\alpha}\\end{split}\\]\n  Full details of the lattice-Boltzmann algorithm used can be found in\n  Mackay et al..\n  The fluid is coupled to the MD particles described by group-ID through\n  a velocity dependent force.  The contribution to the fluid force on a\n  given lattice mesh site j due to MD particle \\(\\alpha\\) is\n  calculated as:\n  \n  \\[{\\bf F}_{j \\alpha} = \\gamma \\left({\\bf v}_n - {\\bf u}_f \\right) \\zeta_{j\\alpha}\\]\n  where \\(\\mathbf{v}_n\\) is the velocity of the MD particle,\n  \\(\\mathbf{u}_f\\) is the fluid\n  velocity interpolated to the particle location, and \\(\\gamma\\) is the force\n  coupling constant.  \\(\\zeta\\) is a weight assigned to the grid point,\n  obtained by distributing the particle to the nearest lattice sites.\n  For this, the user has the choice between a trilinear stencil, which\n  provides a support of 8 lattice sites, or the immersed boundary method\n  Peskin stencil, which provides a support of 64 lattice sites.  While\n  the Peskin stencil is seen to provide more stable results, the\n  trilinear stencil may be better suited for simulation of objects close\n  to walls, due to its smaller support.  Therefore, by default, the\n  Peskin stencil is used; however the user may switch to the trilinear\n  stencil by specifying the keyword, trilinear.\n  By default, the force coupling constant, \\(\\gamma\\), is calculated\n  according to\n  \n  \\[\\gamma = \\frac{2m_um_v}{m_u+m_v}\\left(\\frac{1}{\\Delta t_{collision}}\\right)\\]\n  Here, \\(m_v\\) is the mass of the MD particle, \\(m_u\\) is a\n  representative fluid mass at the particle location, and \\(\\Delta\n  t_{collision}\\) is a collision time, chosen such that\n  \\(\\frac{\\tau}{\\Delta t_{collision}} = 1\\) (see Mackay and\n  Denniston for full details).  In order to calculate \\(m_u\\),\n  the fluid density is interpolated to the MD particle location, and\n  multiplied by a volume, node_area * \\(dx_{LB}\\), where node_area\n  represents the portion of the surface area of the composite object\n  associated with a given MD particle.  By default, node_area is set\n  equal to \\(dx_{LB}^2\\); however specific values for given atom types\n  can be set using the setArea keyword.\n  The user also has the option of specifying their own value for the\n  force coupling constant, for all the MD particles associated with the\n  fix, through the use of the setGamma keyword.  This may be useful\n  when modelling porous particles.  See Mackay et al. for a\n  detailed description of the method by which the user can choose an\n  appropriate \\(\\gamma\\) value.\n  \n  Note\n  while this fix applies the force of the particles on the fluid,\n  it does not apply the force of the fluid to the particles.  When the\n  force coupling constant is set using the default method, there is only\n  one option to include this hydrodynamic force on the particles, and\n  that is through the use of the lb/viscous fix.\n  This fix adds the hydrodynamic force to the total force acting on the\n  particles, after which any of the built-in LAMMPS integrators can be\n  used to integrate the particle motion.  However, if the user specifies\n  their own value for the force coupling constant, as mentioned in\n  Mackay et al., the built-in LAMMPS integrators may prove to\n  be unstable.  Therefore, we have included our own integrators\n  fix lb/rigid/pc/sphere, and\n  fix lb/pc, to solve for the particle motion in these\n  cases.  These integrators should not be used with the\n  lb/viscous fix, as they add hydrodynamic forces\n  to the particles directly.  In addition, they can not be used if the\n  force coupling constant has been set the default way.\n  \n  \n  Note\n  if the force coupling constant is set using the default method,\n  and the lb/viscous fix is NOT used to add the\n  hydrodynamic force to the total force acting on the particles, this\n  physically corresponds to a situation in which an infinitely massive\n  particle is moving through the fluid (since collisions between the\n  particle and the fluid do not act to change the particle’s velocity).\n  Therefore, the user should set the mass of the particle to be\n  significantly larger than the mass of the fluid at the particle\n  location, in order to approximate an infinitely massive particle (see\n  the dragforce test run for an example).\n  \n  \n  Inside the fix, parameters are scaled by the lattice-Boltzmann\n  timestep, \\(dt_{LB}\\), grid spacing, \\(dx_{LB}\\), and mass unit,\n  \\(dm_{LB}\\).  \\(dt_{LB}\\) is set equal to\n  \\(\\mathrm{nevery}\\cdot dt_{MD}\\), where \\(dt_{MD}\\) is the MD timestep.\n  By default,\n  \\(dm_{LB}\\) is set equal to 1.0, and \\(dx_{LB}\\) is chosen so that\n  \\(\\frac{\\tau}{dt} = \\frac{3\\eta dt}{\\rho dx^2}\\) is approximately equal to 1.\n  However, the user has the option of specifying their own values for\n  \\(dm_{LB}\\), and \\(dx_{LB}\\), by using\n  the optional keywords dm, and dx respectively.\n  \n  Note\n  Care must be taken when choosing both a value for \\(dx_{LB}\\),\n  and a simulation domain size.  This fix uses the same subdivision of\n  the simulation domain among processors as the main LAMMPS program.  In\n  order to uniformly cover the simulation domain with lattice sites, the\n  lengths of the individual LAMMPS sub-domains must all be evenly\n  divisible by \\(dx_{LB}\\).  If the simulation domain size is cubic,\n  with equal lengths in all dimensions, and the default value for\n  \\(dx_{LB}\\) is used, this will automatically be satisfied.\n  \n  Physical parameters describing the fluid are specified through\n  viscosity, density, and a0. If the force coupling constant is\n  set the default way, the surface area associated with the MD particles\n  is specified using the setArea keyword.  If the user chooses to\n  specify a value for the force coupling constant, this is set using the\n  setGamma keyword.  These parameters should all be given in terms of\n  the mass, distance, and time units chosen for the main LAMMPS run, as\n  they are scaled by the LB timestep, lattice spacing, and mass unit,\n  inside the fix.\n  \n  The setArea keyword allows the user to associate a surface area with\n  a given atom type.  For example if a spherical composite object of\n  radius R is represented as a spherical shell of N evenly distributed\n  MD particles, all of the same type, the surface area per particle\n  associated with that atom type should be set equal to \\(\\frac{4\\pi R^2}{N}\\).\n  This keyword should only be used if the force coupling constant,\n  \\(\\gamma\\), is set the default way.\n  The setGamma keyword allows the user to specify their own value for\n  the force coupling constant, \\(\\gamma\\), instead of using the default\n  value.\n  The scaleGamma keyword should be used in conjunction with the\n  setGamma keyword, when the user wishes to specify different \\(\\gamma\\)\n  values for different atom types.  This keyword allows the user to\n  scale the setGamma \\(\\gamma\\) value by a factor, gammaFactor,\n  for a given atom type.\n  The dx keyword allows the user to specify a value for the LB grid\n  spacing.\n  The dm keyword allows the user to specify the LB mass unit.\n  If the a0 keyword is used, the value specified is used for the\n  square of the speed of sound in the fluid.  If this keyword is not\n  present, the speed of sound squared is set equal to\n  \\(\\frac{1}{3}\\left(\\frac{dx_{LB}}{dt_{LB}}\\right)^2\\).\n  Setting \\(a0 > (\\frac{dx_{LB}}{dt_{LB}})^2\\) is not allowed,\n  as this may lead to instabilities.\n  If the noise keyword is used, followed by a positive temperature\n  value, and a positive integer random number seed, a thermal\n  lattice-Boltzmann algorithm is used.  If LBtype is set equal to 1\n  (i.e. the standard LB integrator is chosen), the thermal LB algorithm\n  of Adhikari et al. is used; however if LBtype is set\n  equal to 2 both the LB integrator, and thermal LB algorithm described\n  in Ollila et al. are used.\n  If the calcforce keyword is used, both the fluid force and torque\n  acting on the specified particle group are printed to the screen every\n  N timesteps.\n  If the keyword trilinear is used, the trilinear stencil is used to\n  interpolate the particle nodes onto the fluid mesh.  By default, the\n  immersed boundary method, Peskin stencil is used.  Both of these\n  interpolation methods are described in Mackay et al..\n  If the keyword D3Q19 is used, the 19 velocity (D3Q19) lattice is\n  used by the lattice-Boltzmann algorithm.  By default, the 15 velocity\n  (D3Q15) lattice is used.\n  If the keyword write_restart is used, followed by a positive\n  integer, N, a binary restart file is printed every N LB timesteps.\n  This restart file only contains information about the fluid.\n  Therefore, a LAMMPS restart file should also be written in order to\n  print out full details of the simulation.\n  \n  Note\n  When a large number of lattice grid points are used, the restart\n  files may become quite large.\n  \n  In order to restart the fluid portion of the simulation, the keyword\n  read_restart is specified, followed by the name of the binary\n  lb_fluid restart file to be used.\n  If the zwall_velocity keyword is used y-velocities are assigned to\n  the lower and upper walls.  This keyword requires the presence of\n  walls in the z-direction.  This is set by assigning fixed boundary\n  conditions in the z-direction.  If fixed boundary conditions are\n  present in the z-direction, and this keyword is not used, the walls\n  are assumed to be stationary.\n  If the bodyforce keyword is used, a constant body force is added to\n  the fluid, defined by it’s x, y and z components.\n  If the printfluid keyword is used, followed by a positive integer, N,\n  the fluid densities and velocities at each lattice site are printed to the\n  screen every N timesteps.\n  \n  For further details, as well as descriptions and results of several\n  test runs, see Mackay et al..  Please include a citation to\n  this paper if the lb_fluid fix is used in work contributing to\n  published research.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  Due to the large size of the fluid data, this fix writes it’s own\n  binary restart files, if requested, independent of the main LAMMPS\n  binary restart files; no information about lb_fluid\n  is written to the main LAMMPS binary restart files.\n  None of the fix_modify options are relevant to this\n  fix.  No global or per-atom quantities are stored by this fix for\n  access by various output commands.  No parameter\n  of this fix can be used with the start/stop keywords of the\n  run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID lb/fluid nevery LBtype viscosity density keyword values ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  lb/fluid = style name of this fix command\n  nevery = update the lattice-Boltzmann fluid every this many timesteps\n  LBtype = 1 to use the standard finite difference LB integrator,\n  2 to use the LB integrator of Ollila et al.\n  viscosity = the fluid viscosity (units of mass/(time*length)).\n  density = the fluid density.\n  zero or more keyword/value pairs may be appended\n  keyword = setArea or setGamma or scaleGamma or dx or dm or a0 or noise or calcforce or trilinear or D3Q19 or read_restart or write_restart or zwall_velocity or bodyforce or printfluid\n  setArea values = type node_area\n      type = atom type (1-N)\n      node_area = portion of the surface area of the composite object associated with the particular atom type (used when the force coupling constant is set by default).\n  setGamma values = gamma\n      gamma = user set value for the force coupling constant.\n  scaleGamma values = type gammaFactor\n      type = atom type (1-N)\n      gammaFactor = factor to scale the setGamma gamma value by, for the specified atom type.\n  dx values = dx_LB = the lattice spacing.\n  dm values = dm_LB = the lattice-Boltzmann mass unit.\n  a0 values = a_0_real = the square of the speed of sound in the fluid.\n  noise values = Temperature seed\n      Temperature = fluid temperature.\n      seed = random number generator seed (positive integer)\n  calcforce values = N forcegroup-ID\n      N = output the force and torque every N timesteps\n      forcegroup-ID = ID of the particle group to calculate the force and torque of\n  trilinear values = none (used to switch from the default Peskin interpolation stencil to the trilinear stencil).\n  D3Q19 values = none (used to switch from the default D3Q15, 15 velocity lattice, to the D3Q19, 19 velocity lattice).\n  read_restart values = restart file = name of the restart file to use to restart a fluid run.\n  write_restart values = N = write a restart file every N MD timesteps.\n  zwall_velocity values = velocity_bottom velocity_top = velocities along the y-direction of the bottom and top walls (located at z=zmin and z=zmax).\n  bodyforce values = bodyforcex bodyforcey bodyforcez = the x,y and z components of a constant body force added to the fluid.\n  printfluid values = N = print the fluid density and velocity at each grid point every N timesteps.\n  \n  \n  ",
    "examples": "fix 1 all lb/fluid 1 2 1.0 1.0 setGamma 13.0 dx 4.0 dm 10.0 calcforce sphere1\n  fix 1 all lb/fluid 1 1 1.0 0.0009982071 setArea 1 1.144592082 dx 2.0 dm 0.3 trilinear noise 300.0 8979873\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-LB package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  This fix can only be used with an orthogonal simulation domain.\n  Walls have only been implemented in the z-direction.  Therefore, the\n  boundary conditions, as specified via the main LAMMPS boundary command\n  must be periodic for x and y, and either fixed or periodic for z.\n  Shrink-wrapped boundary conditions are not permitted with this fix.\n  This fix must be used before any of fix lb/viscous, fix lb/momentum, fix lb/rigid/pc/sphere, and/ or fix lb/pc , as the fluid needs to be initialized before\n  any of these routines try to access its properties.  In addition, in\n  order for the hydrodynamic forces to be added to the particles, this\n  fix must be used in conjunction with the\n  lb/viscous fix if the force coupling constant is\n  set by default, or either the lb/viscous fix or\n  one of the lb/rigid/pc/sphere or\n  lb/pc integrators, if the user chooses to specify\n  their own value for the force coupling constant.\n  "
},
{
    "command": "fix lb/momentum",
    "description": "This fix is based on the fix momentum command, and\n  was created to be used in place of that command, when a\n  lattice-Boltzmann fluid is present.\n  Zero the total linear momentum of the system, including both the atoms\n  specified by group-ID and the lattice-Boltzmann fluid every nevery\n  timesteps.  This is accomplished by adjusting the particle velocities\n  and the fluid velocities at each lattice site.\n  \n  Note\n  This fix only considers the linear momentum of the system.\n  \n  By default, the subtraction is performed for each dimension.  This can\n  be changed by specifying the keyword linear, along with a set of\n  three flags set to 0/1 in order to exclude/ include the corresponding\n  dimension.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID lb/momentum nevery keyword values ...\n  \n  \n  \n  ID, group-ID are documented in the fix command\n  lb/momentum = style name of this fix command\n  nevery = adjust the momentum every this many timesteps\n  zero or more keyword/value pairs may be appended\n  keyword = linear\n  linear values = xflag yflag zflag\n    xflag,yflag,zflag = 0/1 to exclude/include each dimension.\n  \n  \n  ",
    "examples": "fix 1 sphere lb/momentum\n  fix 1 all lb/momentum linear 1 1 0\n  \n  \n  ",
    "restrictions": "Can only be used if a lattice-Boltzmann fluid has been created via the\n  fix lb/fluid command, and must come after this\n  command.\n  This fix is part of the USER-LB package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "fix lb/pc",
    "description": "Update the positions and velocities of the individual particles\n  described by group-ID, experiencing velocity-dependent hydrodynamic\n  forces, using the integration algorithm described in Mackay et al..  This integration algorithm should only be used if a\n  user-specified value for the force-coupling constant used in fix lb/fluid has been set; do not use this integration\n  algorithm if the force coupling constant has been set by default.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID lb/pc\n  \n  \n  \n  ID, group-ID are documented in the fix command\n  lb/pc = style name of this fix command\n  \n  ",
    "examples": "fix 1 all lb/pc\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-LB package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  Can only be used if a lattice-Boltzmann fluid has been created via the\n  fix lb/fluid command, and must come after this\n  command.\n  "
},
{
    "command": "fix lb/rigid/pc/sphere",
    "description": "This fix is based on the fix rigid command, and was\n  created to be used in place of that fix, to integrate the equations of\n  motion of spherical rigid bodies when a lattice-Boltzmann fluid is\n  present with a user-specified value of the force-coupling constant.\n  The fix uses the integration algorithm described in Mackay et al. to update the positions, velocities, and orientations of\n  a set of spherical rigid bodies experiencing velocity dependent\n  hydrodynamic forces.  The spherical bodies are assumed to rotate as\n  solid, uniform density spheres, with moments of inertia calculated\n  using the combined sum of the masses of all the constituent particles\n  (which are assumed to be point particles).\n  \n  By default, all of the atoms that this fix acts on experience a\n  hydrodynamic force due to the presence of the lattice-Boltzmann fluid.\n  However, the innerNodes keyword allows the user to specify atoms\n  belonging to a rigid object which do not interact with the\n  lattice-Boltzmann fluid (i.e. these atoms do not feel a hydrodynamic\n  force from the lattice-Boltzmann fluid).  This can be used to\n  distinguish between atoms on the surface of a non-porous object, and\n  those on the inside.\n  This feature can be used, for example, when implementing a hard sphere\n  interaction between two spherical objects.  Instead of interactions\n  occurring between the particles on the surfaces of the two spheres, it\n  is desirable simply to place an atom at the center of each sphere,\n  which does not contribute to the hydrodynamic force, and have these\n  central atoms interact with one another.\n  \n  Apart from the features described above, this fix is very similar to\n  the rigid fix (although it includes fewer optional arguments, and\n  assumes the constituent atoms are point particles); see\n  fix rigid for a complete documentation.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about the rigid and rigid/nve fixes are written to\n  binary restart files.\n  Similar to the fix rigid command: The rigid fix\n  computes a global scalar which can be accessed by various output commands.  The scalar value calculated by these\n  fixes is “intensive”.  The scalar is the current temperature of the\n  collection of rigid bodies.  This is averaged over all rigid bodies\n  and their translational and rotational degrees of freedom.  The\n  translational energy of a rigid body is 1/2 m v^2, where m = total\n  mass of the body and v = the velocity of its center of mass.  The\n  rotational energy of a rigid body is 1/2 I w^2, where I = the moment\n  of inertia tensor of the body and w = its angular velocity.  Degrees\n  of freedom constrained by the force and torque keywords are\n  removed from this calculation.\n  All of these fixes compute a global array of values which can be\n  accessed by various output commands.  The number\n  of rows in the array is equal to the number of rigid bodies.  The\n  number of columns is 15.  Thus for each rigid body, 15 values are\n  stored: the xyz coords of the center of mass (COM), the xyz components\n  of the COM velocity, the xyz components of the force acting on the\n  COM, the xyz components of the torque acting on the COM, and the xyz\n  image flags of the COM, which have the same meaning as image flags for\n  atom positions (see the “dump” command).  The force and torque values\n  in the array are not affected by the force and torque keywords in\n  the fix rigid command; they reflect values before any changes are made\n  by those keywords.\n  The ordering of the rigid bodies (by row in the array) is as follows.\n  For the single keyword there is just one rigid body.  For the\n  molecule keyword, the bodies are ordered by ascending molecule ID.\n  For the group keyword, the list of group IDs determines the ordering\n  of bodies.\n  The array values calculated by these fixes are “intensive”, meaning\n  they are independent of the number of atoms in the simulation.\n  No parameter of these fixes can be used with the start/stop keywords\n  of the run command.  These fixes are not invoked during\n  energy minimization.\n  ",
    "syntax": "fix ID group-ID lb/rigid/pc/sphere bodystyle args keyword values ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  lb/rigid/pc/sphere = style name of this fix command\n  bodystyle = single or molecule or group\n  single args = none\n  molecule args = none\n  group args = N groupID1 groupID2 ...\n    N = # of groups\n  \n  zero or more keyword/value pairs may be appended\n  keyword = force or torque or innerNodes\n  force values = M xflag yflag zflag\n    M = which rigid body from 1-Nbody (see asterisk form below)\n    xflag,yflag,zflag = off/on if component of center-of-mass force is active\n  torque values = M xflag yflag zflag\n    M = which rigid body from 1-Nbody (see asterisk form below)\n    xflag,yflag,zflag = off/on if component of center-of-mass torque is active\n  innerNodes values = innergroup-ID\n    innergroup-ID = ID of the atom group which does not experience a hydrodynamic force from the lattice-Boltzmann fluid\n  \n  \n  ",
    "examples": "fix 1 spheres lb/rigid/pc/sphere\n  fix 1 all lb/rigid/pc/sphere force 1 0 0 innerNodes ForceAtoms\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-LB package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  Can only be used if a lattice-Boltzmann fluid has been created via the\n  fix lb/fluid command, and must come after this\n  command.  Should only be used if the force coupling constant used in\n  fix lb/fluid has been set by the user; this\n  integration fix cannot be used if the force coupling constant is set\n  by default.\n  "
},
{
    "command": "fix lb/viscous",
    "description": "This fix is similar to the fix viscous command, and\n  is to be used in place of that command when a lattice-Boltzmann fluid\n  is present, and the user wishes to integrate the particle motion using\n  one of the built in LAMMPS integrators.\n  This fix adds a force, F = - Gamma*(velocity-fluid_velocity), to each\n  atom, where Gamma is the force coupling constant described in the fix lb/fluid command (which applies an equal and\n  opposite force to the fluid).\n  \n  Note\n  This fix should only be used in conjunction with one of the\n  built in LAMMPS integrators; it should not be used with the fix lb/pc or fix lb/rigid/pc/sphere integrators, which\n  already include the hydrodynamic forces.  These latter fixes should\n  only be used if the force coupling constant has been set by the user\n  (instead of using the default value); if the default force coupling\n  value is used, then this fix provides the only method for adding the\n  hydrodynamic forces to the particles.\n  \n  \n  For further details, as well as descriptions and results of several\n  test runs, see Mackay et al..  Please include a citation to\n  this paper if this fix is used in work contributing to published\n  research.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  As described in the fix viscous documentation:\n  “No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  The forces due to this fix are imposed during an energy minimization,\n  invoked by the minimize command.  This fix should only\n  be used with damped dynamics minimizers that allow for\n  non-conservative forces.  See the min_style command\n  for details.”\n  ",
    "syntax": "fix ID group-ID lb/viscous\n  \n  \n  \n  ID, group-ID are documented in fix command\n  lb/viscous = style name of this fix command\n  \n  ",
    "examples": "fix 1 flow lb/viscous\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-LB package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  Can only be used if a lattice-Boltzmann fluid has been created via the\n  fix lb/fluid command, and must come after this\n  command.\n  This fix should not be used if either the fix lb/pc\n  or fix lb/rigid/pc/sphere integrator is\n  used.\n  "
},
{
    "command": "fix lineforce",
    "description": "Adjust the forces on each atom in the group so that only the component\n  of force along the linear direction specified by the vector (x,y,z)\n  remains.  This is done by subtracting out components of force in the\n  plane perpendicular to the line.\n  If the initial velocity of the atom is 0.0 (or along the line), then\n  it should continue to move along the line thereafter.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  The forces due to this fix are imposed during an energy minimization,\n  invoked by the minimize command.\n  ",
    "syntax": "fix ID group-ID lineforce x y z\n  \n  \n  \n  ID, group-ID are documented in fix command\n  lineforce = style name of this fix command\n  x y z = direction of line as a 3-vector\n  \n  ",
    "examples": "fix hold boundary lineforce 0.0 1.0 1.0\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix manifoldforce",
    "description": "This fix subtracts each time step from the force the component along\n  the normal of the specified manifold.  This can be\n  used in combination with minimize to remove overlap\n  between particles while keeping them (roughly) constrained to the\n  given manifold, e.g. to set up a run with fix nve/manifold/rattle.  I have found that\n  only hftn and quickmin with a very small time step perform\n  adequately though.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID manifoldforce manifold manifold-args ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  manifold = name of the manifold\n  manifold-args = parameters for the manifold\n  \n  ",
    "examples": "fix constrain all manifoldforce sphere 5.0\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-MANIFOLD package. It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  Only use this with min_style hftn or min_style quickmin. If not,\n  the constraints will not be satisfied very well at all. A warning is\n  generated if the min_style is incompatible but no error.\n  "
},
{
    "command": "fix meso",
    "description": "Perform time integration to update position, velocity, internal energy\n  and local density for atoms in the group each timestep. This fix is\n  needed to time-integrate mesoscopic systems where particles carry\n  internal variables such as SPH or DPDE.\n  See this PDF guide to using SPH in\n  LAMMPS.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID meso\n  \n  \n  \n  ID, group-ID are documented in fix command\n  meso = style name of this fix command\n  \n  ",
    "examples": "fix 1 all meso\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-SPH package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "fix meso/move",
    "description": "Perform updates of position, velocity, internal energy and local\n  density for mesoscopic particles in the group each timestep using the\n  specified settings or formulas, without regard to forces on the\n  particles. This can be useful for boundary, solid bodies or other\n  particles, whose movement can influence nearby particles.\n  The operation of this fix is exactly like that described by the\n  fix move command, except that particles’ density,\n  internal energy and extrapolated velocity are also updated.\n  \n  Note\n  The particles affected by this fix should not be time integrated\n  by other fixes (e.g. fix meso, fix meso/stationary), since that will change their\n  positions and velocities twice.\n  \n  \n  Note\n  As particles move due to this fix, they will pass through periodic\n  boundaries and be remapped to the other side of the simulation box,\n  just as they would during normal time integration (e.g. via the fix meso command).  It is up to you to decide whether periodic\n  boundaries are appropriate with the kind of particle motion you are\n  prescribing with this fix.\n  \n  \n  Note\n  As discussed below, particles are moved relative to their initial\n  position at the time the fix is specified.  These initial coordinates\n  are stored by the fix in “unwrapped” form, by using the image flags\n  associated with each particle.  See the dump custom command\n  for a discussion of “unwrapped” coordinates.  See the Atoms section of\n  the read_data command for a discussion of image flags\n  and how they are set for each particle.  You can reset the image flags\n  (e.g. to 0) before invoking this fix by using the set image\n  command.\n  \n  \n  The linear style moves particles at a constant velocity, so that their\n  position X = (x,y,z) as a function of time is given in vector\n  notation as\n  X(t) = X0 + V * delta\n  where X0 = (x0,y0,z0) is their position at the time the fix is\n  specified, V is the specified velocity vector with components\n  (Vx,Vy,Vz), and delta is the time elapsed since the fix was\n  specified.  This style also sets the velocity of each particle to V =\n  (Vx,Vy,Vz).  If any of the velocity components is specified as NULL,\n  then the position and velocity of that component is time integrated\n  the same as the fix meso command would perform, using\n  the corresponding force component on the particle.\n  Note that the linear style is identical to using the variable\n  style with an equal-style variable that uses the\n  vdisplace() function.  E.g.\n  variable V equal 10.0\n  variable x equal vdisplace(0.0,$V)\n  fix 1 boundary move variable v_x NULL NULL v_V NULL NULL\n  \n  \n  The wiggle style moves particles in an oscillatory fashion, so that\n  their position X = (x,y,z) as a function of time is given in vector\n  notation as\n  X(t) = X0 + A sin(omega*delta)\n  where X0 = (x0,y0,z0) is their position at the time the fix is\n  specified, A is the specified amplitude vector with components\n  (Ax,Ay,Az), omega is 2 PI / period, and delta is the time\n  elapsed since the fix was specified.  This style also sets the\n  velocity of each particle to the time derivative of this expression.\n  If any of the amplitude components is specified as NULL, then the\n  position and velocity of that component is time integrated the same as\n  the fix meso command would perform, using the\n  corresponding force component on the particle.\n  Note that the wiggle style is identical to using the variable\n  style with equal-style variables that use the\n  swiggle() and cwiggle() functions.  E.g.\n  variable A equal 10.0\n  variable T equal 5.0\n  variable omega equal 2.0*PI/$T\n  variable x equal swiggle(0.0,$A,$T)\n  variable v equal v_omega*($A-cwiggle(0.0,$A,$T))\n  fix 1 boundary move variable v_x NULL NULL v_v NULL NULL\n  \n  \n  The rotate style rotates particles around a rotation axis R =\n  (Rx,Ry,Rz) that goes through a point P = (Px,Py,Pz).  The period of\n  the rotation is also specified.  The direction of rotation for the\n  particles around the rotation axis is consistent with the right-hand\n  rule: if your right-hand thumb points along R, then your fingers wrap\n  around the axis in the direction of rotation.\n  This style also sets the velocity of each particle to (omega cross\n  Rperp) where omega is its angular velocity around the rotation axis and\n  Rperp is a perpendicular vector from the rotation axis to the particle.\n  The variable style allows the position and velocity components of\n  each particle to be set by formulas specified via the\n  variable command.  Each of the 6 variables is\n  specified as an argument to the fix as v_name, where name is the\n  variable name that is defined elsewhere in the input script.\n  Each variable must be of either the equal or atom style.\n  Equal-style variables compute a single numeric quantity, that can be\n  a function of the timestep as well as of other simulation values.\n  Atom-style variables compute a numeric quantity for each particle, that\n  can be a function per-atom quantities, such as the particle’s position, as\n  well as of the timestep and other simulation values.  Note that this\n  fix stores the original coordinates of each particle (see note below) so\n  that per-atom quantity can be used in an atom-style variable formula.\n  See the variable command for details.\n  The first 3 variables (v_dx,v_dy,v_dz) specified for the variable\n  style are used to calculate a displacement from the particle’s original\n  position at the time the fix was specified.  The second 3 variables\n  (v_vx,v_vy,v_vz) specified are used to compute a velocity for each\n  particle.\n  Any of the 6 variables can be specified as NULL.  If both the\n  displacement and velocity variables for a particular x,y,z component\n  are specified as NULL, then the position and velocity of that\n  component is time integrated the same as the fix meso\n  command would perform, using the corresponding force component on the\n  particle.  If only the velocity variable for a component is specified as\n  NULL, then the displacement variable will be used to set the position\n  of the particle, and its velocity component will not be changed. If only\n  the displacement variable for a component is specified as NULL, then\n  the velocity variable will be used to set the velocity of the particle,\n  and the position of the particle will be time integrated using that\n  velocity.\n  The units keyword determines the meaning of the distance units used\n  to define the linear velocity and wiggle amplitude and rotate\n  origin.  This setting is ignored for the variable style.  A box\n  value selects standard units as defined by the units\n  command, e.g. velocity in Angstroms/fmsec and amplitude and position\n  in Angstroms for units = real.  A lattice value means the velocity\n  units are in lattice spacings per time and the amplitude and position\n  are in lattice spacings.  The lattice command must have\n  been previously used to define the lattice spacing.  Each of these 3\n  quantities may be dependent on the x,y,z dimension, since the lattice\n  spacings can be different in x,y,z.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  This fix writes the original coordinates of moving particles to binary restart files, as well as the initial timestep, so that\n  the motion can be continuous in a restarted simulation.  See the\n  read_restart command for info on how to re-specify\n  a fix in an input script that reads a restart file, so that the\n  operation of the fix continues in an uninterrupted fashion.\n  \n  Note\n  Because the move positions are a function of the current\n  timestep and the initial timestep, you cannot reset the timestep to a\n  different value after reading a restart file, if you expect a fix move\n  command to work in an uninterrupted fashion.\n  \n  None of the fix_modify options are relevant to this\n  fix.\n  This fix produces a per-atom array which can be accessed by various\n  output commands.  The number of columns for each\n  atom is 3, and the columns store the original unwrapped x,y,z coords\n  of each particle.  The per-atom values can be accessed on any timestep.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID meso/move style args keyword values ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  meso/move = style name of this fix command\n  style = linear or wiggle or rotate or variable\n  linear args = Vx Vy Vz\n    Vx,Vy,Vz = components of velocity vector (velocity units), any component can be specified as NULL\n  wiggle args = Ax Ay Az period\n    Ax,Ay,Az = components of amplitude vector (distance units), any component can be specified as NULL\n    period = period of oscillation (time units)\n  rotate args = Px Py Pz Rx Ry Rz period\n    Px,Py,Pz = origin point of axis of rotation (distance units)\n    Rx,Ry,Rz = axis of rotation vector\n    period = period of rotation (time units)\n  variable args = v_dx v_dy v_dz v_vx v_vy v_vz\n    v_dx,v_dy,v_dz = 3 variable names that calculate x,y,z displacement as function of time, any component can be specified as NULL\n    v_vx,v_vy,v_vz = 3 variable names that calculate x,y,z velocity as function of time, any component can be specified as NULL\n  \n  zero or more keyword/value pairs may be appended\n  keyword = units\n  units value = box or lattice\n  \n  \n  ",
    "examples": "fix 1 boundary meso/move wiggle 3.0 0.0 0.0 1.0 units box\n  fix 2 boundary meso/move rotate 0.0 0.0 0.0 0.0 0.0 1.0 5.0\n  fix 2 boundary meso/move variable v_myx v_myy NULL v_VX v_VY NULL\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-SDPD package.  It is only enabled if\n  LAMMPS was built with that package. See the Build package doc page for more info.\n  This fix requires that atoms store density and internal energy as\n  defined by the atom_style meso command.\n  All particles in the group must be mesoscopic SPH/SDPD particles.\n  "
},
{
    "command": "fix meso/stationary",
    "description": "Perform time integration to update internal energy and local density,\n  but not position or velocity for atoms in the group each timestep.\n  This fix is needed for SPH simulations to correctly time-integrate\n  fixed boundary particles which constrain a fluid to a given region in\n  space.\n  See this PDF guide to using SPH in\n  LAMMPS.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID meso/stationary\n  \n  \n  \n  ID, group-ID are documented in fix command\n  meso = style name of this fix command\n  \n  ",
    "examples": "fix 1 boundary meso/stationary\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-SPH package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "fix momentum",
    "description": "Zero the linear and/or angular momentum of the group of atoms every N\n  timesteps by adjusting the velocities of the atoms.  One (or both) of\n  the linear or angular keywords must be specified.\n  If the linear keyword is used, the linear momentum is zeroed by\n  subtracting the center-of-mass velocity of the group from each atom.\n  This does not change the relative velocity of any pair of atoms.  One\n  or more dimensions can be excluded from this operation by setting the\n  corresponding flag to 0.\n  If the angular keyword is used, the angular momentum is zeroed by\n  subtracting a rotational component from each atom.\n  This command can be used to insure the entire collection of atoms (or\n  a subset of them) does not drift or rotate during the simulation due\n  to random perturbations (e.g. fix langevin\n  thermostatting).\n  The rescale keyword enables conserving the kinetic energy of the group\n  of atoms by rescaling the velocities after the momentum was removed.\n  Note that the velocity command can be used to create\n  initial velocities with zero aggregate linear and/or angular momentum.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID momentum N keyword values ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  momentum = style name of this fix command\n  N = adjust the momentum every this many timesteps\n  one or more keyword/value pairs may be appended\n  keyword = linear or angular or rescale\n  linear values = xflag yflag zflag\n    xflag,yflag,zflag = 0/1 to exclude/include each dimension\n  angular values = none\n  rescale values = none\n  \n  \n  ",
    "examples": "fix 1 all momentum 1 linear 1 1 0\n  fix 1 all momentum 1 linear 1 1 1 rescale\n  fix 1 all momentum 100 linear 1 1 1 angular\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix move",
    "description": "Perform updates of position and velocity for atoms in the group each\n  timestep using the specified settings or formulas, without regard to\n  forces on the atoms.  This can be useful for boundary or other atoms,\n  whose movement can influence nearby atoms.\n  \n  Note\n  The atoms affected by this fix should not normally be time\n  integrated by other fixes (e.g. fix nve, fix nvt), since that will change their positions and\n  velocities twice.\n  \n  \n  Note\n  As atoms move due to this fix, they will pass through periodic\n  boundaries and be remapped to the other side of the simulation box,\n  just as they would during normal time integration (e.g. via the fix nve command).  It is up to you to decide whether\n  periodic boundaries are appropriate with the kind of atom motion you\n  are prescribing with this fix.\n  \n  \n  Note\n  As discussed below, atoms are moved relative to their initial\n  position at the time the fix is specified.  These initial coordinates\n  are stored by the fix in “unwrapped” form, by using the image flags\n  associated with each atom.  See the dump custom command\n  for a discussion of “unwrapped” coordinates.  See the Atoms section of\n  the read_data command for a discussion of image flags\n  and how they are set for each atom.  You can reset the image flags\n  (e.g. to 0) before invoking this fix by using the set image\n  command.\n  \n  \n  The linear style moves atoms at a constant velocity, so that their\n  position X = (x,y,z) as a function of time is given in vector\n  notation as\n  X(t) = X0 + V * delta\n  where X0 = (x0,y0,z0) is their position at the time the fix is\n  specified, V is the specified velocity vector with components\n  (Vx,Vy,Vz), and delta is the time elapsed since the fix was\n  specified.  This style also sets the velocity of each atom to V =\n  (Vx,Vy,Vz).  If any of the velocity components is specified as NULL,\n  then the position and velocity of that component is time integrated\n  the same as the fix nve command would perform, using\n  the corresponding force component on the atom.\n  Note that the linear style is identical to using the variable\n  style with an equal-style variable that uses the\n  vdisplace() function.  E.g.\n  variable V equal 10.0\n  variable x equal vdisplace(0.0,$V)\n  fix 1 boundary move variable v_x NULL NULL v_V NULL NULL\n  \n  \n  The wiggle style moves atoms in an oscillatory fashion, so that\n  their position X = (x,y,z) as a function of time is given in vector\n  notation as\n  X(t) = X0 + A sin(omega*delta)\n  where X0 = (x0,y0,z0) is their position at the time the fix is\n  specified, A is the specified amplitude vector with components\n  (Ax,Ay,Az), omega is 2 PI / period, and delta is the time\n  elapsed since the fix was specified.  This style also sets the\n  velocity of each atom to the time derivative of this expression.  If\n  any of the amplitude components is specified as NULL, then the\n  position and velocity of that component is time integrated the same as\n  the fix nve command would perform, using the\n  corresponding force component on the atom.\n  Note that the wiggle style is identical to using the variable\n  style with equal-style variables that use the\n  swiggle() and cwiggle() functions.  E.g.\n  variable A equal 10.0\n  variable T equal 5.0\n  variable omega equal 2.0*PI/$T\n  variable x equal swiggle(0.0,$A,$T)\n  variable v equal v_omega*($A-cwiggle(0.0,$A,$T))\n  fix 1 boundary move variable v_x NULL NULL v_v NULL NULL\n  \n  \n  The rotate style rotates atoms around a rotation axis R =\n  (Rx,Ry,Rz) that goes through a point P = (Px,Py,Pz).  The period of\n  the rotation is also specified.  The direction of rotation for the\n  atoms around the rotation axis is consistent with the right-hand rule:\n  if your right-hand thumb points along R, then your fingers wrap\n  around the axis in the direction of rotation.\n  This style also sets the velocity of each atom to (omega cross Rperp)\n  where omega is its angular velocity around the rotation axis and Rperp\n  is a perpendicular vector from the rotation axis to the atom.  If the\n  defined atom_style assigns an angular velocity or\n  angular momentum or orientation to each atom (atom styles sphere, ellipsoid, line, tri, body), then\n  those properties are also updated appropriately to correspond to the\n  atom’s motion and rotation over time.\n  The variable style allows the position and velocity components of\n  each atom to be set by formulas specified via the\n  variable command.  Each of the 6 variables is\n  specified as an argument to the fix as v_name, where name is the\n  variable name that is defined elsewhere in the input script.\n  Each variable must be of either the equal or atom style.\n  Equal-style variables compute a single numeric quantity, that can be\n  a function of the timestep as well as of other simulation values.\n  Atom-style variables compute a numeric quantity for each atom, that\n  can be a function per-atom quantities, such as the atom’s position, as\n  well as of the timestep and other simulation values.  Note that this\n  fix stores the original coordinates of each atom (see note below) so\n  that per-atom quantity can be used in an atom-style variable formula.\n  See the variable command for details.\n  The first 3 variables (v_dx,v_dy,v_dz) specified for the variable\n  style are used to calculate a displacement from the atom’s original\n  position at the time the fix was specified.  The second 3 variables\n  (v_vx,v_vy,v_vz) specified are used to compute a velocity for each\n  atom.\n  Any of the 6 variables can be specified as NULL.  If both the\n  displacement and velocity variables for a particular x,y,z component\n  are specified as NULL, then the position and velocity of that\n  component is time integrated the same as the fix nve\n  command would perform, using the corresponding force component on the\n  atom.  If only the velocity variable for a component is specified as\n  NULL, then the displacement variable will be used to set the position\n  of the atom, and its velocity component will not be changed.  If only\n  the displacement variable for a component is specified as NULL, then\n  the velocity variable will be used to set the velocity of the atom,\n  and the position of the atom will be time integrated using that\n  velocity.\n  The units keyword determines the meaning of the distance units used\n  to define the linear velocity and wiggle amplitude and rotate\n  origin.  This setting is ignored for the variable style.  A box\n  value selects standard units as defined by the units\n  command, e.g. velocity in Angstroms/fmsec and amplitude and position\n  in Angstroms for units = real.  A lattice value means the velocity\n  units are in lattice spacings per time and the amplitude and position\n  are in lattice spacings.  The lattice command must have\n  been previously used to define the lattice spacing.  Each of these 3\n  quantities may be dependent on the x,y,z dimension, since the lattice\n  spacings can be different in x,y,z.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  This fix writes the original coordinates of moving atoms to binary restart files, as well as the initial timestep, so that\n  the motion can be continuous in a restarted simulation.  See the\n  read_restart command for info on how to re-specify\n  a fix in an input script that reads a restart file, so that the\n  operation of the fix continues in an uninterrupted fashion.\n  \n  Note\n  Because the move positions are a function of the current\n  timestep and the initial timestep, you cannot reset the timestep to a\n  different value after reading a restart file, if you expect a fix move\n  command to work in an uninterrupted fashion.\n  \n  None of the fix_modify options are relevant to this\n  fix.\n  This fix produces a per-atom array which can be accessed by various\n  output commands.  The number of columns for each\n  atom is 3, and the columns store the original unwrapped x,y,z coords\n  of each atom.  The per-atom values can be accessed on any timestep.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  For rRESPA time integration, this fix adjusts the\n  position and velocity of atoms on the outermost rRESPA level.\n  ",
    "syntax": "fix ID group-ID move style args keyword values ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  move = style name of this fix command\n  style = linear or wiggle or rotate or variable\n  linear args = Vx Vy Vz\n    Vx,Vy,Vz = components of velocity vector (velocity units), any component can be specified as NULL\n  wiggle args = Ax Ay Az period\n    Ax,Ay,Az = components of amplitude vector (distance units), any component can be specified as NULL\n    period = period of oscillation (time units)\n  rotate args = Px Py Pz Rx Ry Rz period\n    Px,Py,Pz = origin point of axis of rotation (distance units)\n    Rx,Ry,Rz = axis of rotation vector\n    period = period of rotation (time units)\n  variable args = v_dx v_dy v_dz v_vx v_vy v_vz\n    v_dx,v_dy,v_dz = 3 variable names that calculate x,y,z displacement as function of time, any component can be specified as NULL\n    v_vx,v_vy,v_vz = 3 variable names that calculate x,y,z velocity as function of time, any component can be specified as NULL\n  \n  zero or more keyword/value pairs may be appended\n  keyword = units\n  units value = box or lattice\n  \n  \n  ",
    "examples": "fix 1 boundary move wiggle 3.0 0.0 0.0 1.0 units box\n  fix 2 boundary move rotate 0.0 0.0 0.0 0.0 0.0 1.0 5.0\n  fix 2 boundary move variable v_myx v_myy NULL v_VX v_VY NULL\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix mscg",
    "description": "This fix applies the Multi-Scale Coarse-Graining (MSCG) method to\n  snapshots from a dump file to generate potentials for coarse-grained\n  simulations from all-atom simulations, using a force-matching\n  technique (Izvekov, Noid).\n  It makes use of the MS-CG library, written and maintained by Greg\n  Voth’s group at the University of Chicago, which is freely available\n  on their MS-CG GitHub site.  See instructions\n  on obtaining and installing the MS-CG library in the src/MSCG/README\n  file, which must be done before you build LAMMPS with this fix command\n  and use the command in a LAMMPS input script.\n  An example script using this fix is provided the examples/mscg\n  directory.\n  The general workflow for using LAMMPS in conjunction with the MS-CG\n  library to create a coarse-grained model and run coarse-grained\n  simulations is as follows:\n  \n  Perform all-atom simulations on the system to be coarse grained.\n  Generate a trajectory mapped to the coarse-grained model.\n  Create input files for the MS-CG library.\n  Run the range finder functionality of the MS-CG library.\n  Run the force matching functionality of the MS-CG library.\n  Check the results of the force matching.\n  Run coarse-grained simulations using the new coarse-grained potentials.\n  \n  This fix can perform the range finding and force matching steps 4 and\n  5 of the above workflow when used in conjunction with the\n  rerun command.  It does not perform steps 1-3 and 6-7.\n  Step 2 can be performed using a Python script (what is the name?)\n  provided with the MS-CG library which defines the coarse-grained model\n  and converts a standard LAMMPS dump file for an all-atom simulation\n  (step 1) into a LAMMPS dump file which has the positions of and forces\n  on the coarse-grained beads.\n  In step 3, an input file named “control.in” is needed by the MS-CG\n  library which sets parameters for the range finding and force matching\n  functionalities.  See the examples/mscg/control.in file as an example.\n  And see the documentation provided with the MS-CG library for more\n  info on this file.\n  When this fix is used to perform steps 4 and 5, the MS-CG library also\n  produces additional output files.  The range finder functionality\n  (step 4) outputs files defining pair and bonded interaction ranges.\n  The force matching functionality (step 5) outputs tabulated force\n  files for every interaction in the system. Other diagnostic files can\n  also be output depending on the parameters in the MS-CG library input\n  script.  Again, see the documentation provided with the MS-CG library\n  for more info.\n  \n  The range keyword specifies which MS-CG library functionality should\n  be invoked. If on, the step 4 range finder functionality is invoked.\n  off, the step 5 force matching functionality is invoked.\n  If the name keyword is used, string names are defined to associate\n  with the integer atom types in LAMMPS.  Ntype names must be\n  provided, one for each atom type (1-Ntype).\n  The max keyword specifies the maximum number of bonds, angles, and\n  dihedrals a bead can have in the coarse-grained model.\n  ",
    "syntax": "fix ID group-ID mscg N keyword args ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  mscg = style name of this fix command\n  N = envoke this fix every this many timesteps\n  zero or more keyword/value pairs may be appended\n  keyword = range or name or max\n  range arg = on or off\n    on = range finding functionality is performed\n    off = force matching functionality is performed\n  name args = name1 ... nameN\n    name1,...,nameN = string names for each atom type (1-Ntype)\n  max args = maxb maxa maxd\n    maxb,maxa,maxd = maximum bonds/angles/dihedrals per atom\n  \n  \n  ",
    "examples": "fix 1 all mscg 1\n  fix 1 all mscg 1 range name A B\n  fix 1 all mscg 1 max 4 8 20\n  \n  \n  ",
    "restrictions": "This fix is part of the MSCG package. It is only enabled if LAMMPS was\n  built with that package.  See the Build package\n  doc page for more info.\n  The MS-CG library uses C++11, which may not be supported by older\n  compilers. The MS-CG library also has some additional numeric library\n  dependencies, which are described in its documentation.\n  Currently, the MS-CG library is not setup to run in parallel with MPI,\n  so this fix can only be used in a serial LAMMPS build and run\n  on a single processor.\n  Related commands: none\n  "
},
{
    "command": "fix msst",
    "description": "This command performs the Multi-Scale Shock Technique (MSST)\n  integration to update positions and velocities each timestep to mimic\n  a compressive shock wave passing over the system. See (Reed)\n  for a detailed description of this method.  The MSST varies the cell\n  volume and temperature in such a way as to restrain the system to the\n  shock Hugoniot and the Rayleigh line. These restraints correspond to\n  the macroscopic conservation laws dictated by a shock\n  front. shockvel determines the steady shock velocity that will be\n  simulated.\n  To perform a simulation, choose a value of q that provides volume\n  compression on the timescale of 100 fs to 1 ps.  If the volume is not\n  compressing, either the shock speed is chosen to be below the material\n  sound speed or p0 has been chosen inaccurately.  Volume compression\n  at the start can be sped up by using a non-zero value of tscale. Use\n  the smallest value of tscale that results in compression.\n  Under some special high-symmetry conditions, the pressure (volume)\n  and/or temperature of the system may oscillate for many cycles even\n  with an appropriate choice of mass-like parameter q. Such\n  oscillations have physical significance in some cases.  The optional\n  mu keyword adds an artificial viscosity that helps break the system\n  symmetry to equilibrate to the shock Hugoniot and Rayleigh line more\n  rapidly in such cases.\n  The keyword tscale is a factor between 0 and 1 that determines what\n  fraction of thermal kinetic energy is converted to compressive strain\n  kinetic energy at the start of the simulation.  Setting this parameter\n  to a non-zero value may assist in compression at the start of\n  simulations where it is slow to occur.\n  If keywords e0, p0,or v0 are not supplied, these quantities will\n  be calculated on the first step, after the energy specified by\n  tscale is removed.  The value of e0 is not used in the dynamical\n  equations, but is used in calculating the deviation from the Hugoniot.\n  The keyword beta is a scaling term that can be added to the MSST\n  ionic equations of motion to account for drift in the conserved\n  quantity during long timescale simulations, similar to a Berendsen\n  thermostat. See (Reed) and (Goldman) for more\n  details.  The value of beta must be between 0.0 and 1.0 inclusive.\n  A value of 0.0 means no contribution, a value of 1.0 means a full\n  contribution.\n  Values of shockvel less than a critical value determined by the\n  material response will not have compressive solutions. This will be\n  reflected in lack of significant change of the volume in the MSST.\n  For all pressure styles, the simulation box stays orthogonal in shape.\n  Parrinello-Rahman boundary conditions (tilted box) are supported by\n  LAMMPS, but are not implemented for MSST.\n  This fix computes a temperature and pressure and potential energy each\n  timestep. To do this, the fix creates its own computes of style “temp”\n  “pressure”, and “pe”, as if these commands had been issued:\n  compute fix-ID_MSST_temp all temp\n  compute fix-ID_MSST_press all pressure fix-ID_MSST_temp\n  \n  compute fix-ID_MSST_pe all pe\n  \n  \n  See the compute temp and compute pressure commands for details.  Note that the IDs of the\n  new computes are the fix-ID + “_MSST_temp” or “MSST_press” or\n  “_MSST_pe”.  The group for the new computes is “all”.\n  \n  The dftb keyword is to allow this fix to be used when LAMMPS is\n  being driven by DFTB+, a density-functional tight-binding code. If the\n  keyword dftb is used with a value of yes, then the MSST equations\n  are altered to account for the electron entropy contribution to the\n  Hugonio relations and total energy.  See (Reed2) and\n  (Goldman) for details on this contribution.  In this case,\n  you must define a fix external command in your\n  input script, which is used to callback to DFTB+ during the LAMMPS\n  timestepping.  DFTB+ will communicate its info to LAMMPS via that fix.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  This fix writes the state of all internal variables to binary\n  restart files.  See the read_restart\n  command for info on how to re-specify a fix in an input script that\n  reads a restart file, so that the operation of the fix continues in an\n  uninterrupted fashion.\n  The progress of the MSST can be monitored by printing the global\n  scalar and global vector quantities computed by the fix.\n  The scalar is the cumulative energy change due to the fix. This is\n  also the energy added to the potential energy by the\n  fix_modify energy command.  With this command, the\n  thermo keyword etotal prints the conserved quantity of the MSST\n  dynamic equations. This can be used to test if the MD timestep is\n  sufficiently small for accurate integration of the dynamic\n  equations. See also thermo_style command.\n  The global vector contains four values in this order:\n  [dhugoniot, drayleigh, lagrangian_speed, lagrangian_position]\n  \n  dhugoniot is the departure from the Hugoniot (temperature units).\n  drayleigh is the departure from the Rayleigh line (pressure units).\n  lagrangian_speed is the laboratory-frame Lagrangian speed (particle velocity) of the computational cell (velocity units).\n  lagrangian_position is the computational cell position in the reference frame moving at the shock speed. This is usually a good estimate of distance of the computational cell behind the shock front.\n  \n  To print these quantities to the log file with descriptive column\n  headers, the following LAMMPS commands are suggested:\n  fix              msst all msst z\n  fix_modify       msst energy yes\n  variable dhug    equal f_msst[1]\n  variable dray    equal f_msst[2]\n  variable lgr_vel equal f_msst[3]\n  variable lgr_pos equal f_msst[4]\n  thermo_style     custom step temp ke pe lz pzz etotal v_dhug v_dray v_lgr_vel v_lgr_pos f_msst\n  \n  \n  These fixes compute a global scalar and a global vector of 4\n  quantities, which can be accessed by various output commands.  The scalar values calculated by this fix are\n  “extensive”; the vector values are “intensive”.\n  ",
    "syntax": "fix ID group-ID msst dir shockvel keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  msst = style name of this fix\n  dir = x or y or z\n  shockvel = shock velocity (strictly positive, distance/time units)\n  zero or more keyword value pairs may be appended\n  keyword = q or mu or p0 or v0 or e0 or tscale or beta or dftb\n  q value = cell mass-like parameter (mass^2/distance^4 units)\n  mu value = artificial viscosity (mass/length/time units)\n  p0 value = initial pressure in the shock equations (pressure units)\n  v0 value = initial simulation cell volume in the shock equations (distance^3 units)\n  e0 value = initial total energy (energy units)\n  tscale value = reduction in initial temperature (unitless fraction between 0.0 and 1.0)\n  dftb value = yes or no for whether using MSST in conjunction with DFTB+\n  beta value = scale factor for improved energy conservation\n  \n  \n  ",
    "examples": "fix 1 all msst y 100.0 q 1.0e5 mu 1.0e5\n  fix 2 all msst z 50.0 q 1.0e4 mu 1.0e4  v0 4.3419e+03 p0 3.7797e+03 e0 -9.72360e+02 tscale 0.01\n  fix 1 all msst y 100.0 q 1.0e5 mu 1.0e5 dftb yes beta 0.5\n  \n  \n  ",
    "restrictions": "This fix style is part of the SHOCK package.  It is only enabled if\n  LAMMPS was built with that package. See the Build package doc page for more info.\n  All cell dimensions must be periodic. This fix can not be used with a\n  triclinic cell.  The MSST fix has been tested only for the group-ID\n  all.\n  "
},
{
    "command": "fix mvv/dpd",
    "description": "Perform time integration using the modified velocity-Verlet (MVV)\n  algorithm to update position and velocity (fix mvv/dpd), or position,\n  velocity and temperature (fix mvv/edpd), or position, velocity and\n  concentration (fix mvv/tdpd) for particles in the group each timestep.\n  The modified velocity-Verlet (MVV) algorithm aims to improve the\n  stability of the time integrator by using an extrapolated version of\n  the velocity for the force evaluation:\n  \n  \\[\\begin{split}v(t+\\frac{\\Delta t}{2}) = & v(t) + \\frac{\\Delta t}{2}\\cdot a(t) \\\\\n  r(t+\\Delta t) = & r(t) + \\Delta t\\cdot v(t+\\frac{\\Delta t}{2}) \\\\\n  a(t+\\Delta t) = & \\frac{1}{m}\\cdot F\\left[ r(t+\\Delta t), v(t) +\\lambda \\cdot \\Delta t\\cdot a(t)\\right] \\\\\n  v(t+\\Delta t) = & v(t+\\frac{\\Delta t}{2}) + \\frac{\\Delta t}{2}\\cdot a(t+\\Delta t)\\end{split}\\]\n  where the parameter \\(\\lambda\\) depends on the\n  specific choice of DPD parameters, and needs to be tuned on a\n  case-by-case basis.  Specification of a lambda value is optional.\n  If specified, the setting must be from 0.0 to 1.0.  If not specified,\n  a default value of 0.5 is used, which effectively reproduces the\n  standard velocity-Verlet (VV) scheme.  For more details, see\n  Groot.\n  Fix mvv/dpd updates the position and velocity of each atom.  It can\n  be used with the pair_style mdpd command or other\n  pair styles such as pair dpd.\n  Fix mvv/edpd updates the per-atom temperature, in addition to\n  position and velocity, and must be used with the pair_style edpd command.\n  Fix mvv/tdpd updates the per-atom chemical concentration, in\n  addition to position and velocity, and must be used with the\n  pair_style tdpd command.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID mvv/dpd lambda\n  \n  fix ID group-ID mvv/edpd lambda\n  \n  fix ID group-ID mvv/tdpd lambda\n  \n  \n  \n  ID, group-ID are documented in fix command\n  mvv/dpd, mvv/edpd, mvv/tdpd = style name of this fix command\n  lambda = (optional) relaxation parameter (unitless)\n  \n  ",
    "examples": "fix 1 all mvv/dpd\n  fix 1 all mvv/dpd 0.5\n  fix 1 all mvv/edpd\n  fix 1 all mvv/edpd 0.5\n  fix 1 all mvv/tdpd\n  fix 1 all mvv/tdpd 0.5\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-MESODPD package. It is only enabled if\n  LAMMPS was built with that package. See the Build package doc page for more info.\n  "
},
{
    "command": "fix neb",
    "description": "Add nudging forces to atoms in the group for a multi-replica\n  simulation run via the neb command to perform a nudged\n  elastic band (NEB) calculation for finding the transition state.\n  Hi-level explanations of NEB are given with the neb command\n  and on the Howto replica doc page.  The fix neb\n  command must be used with the “neb” command and defines how\n  inter-replica nudging forces are computed.  A NEB calculation is\n  divided in two stages. In the first stage n replicas are relaxed\n  toward a MEP until convergence.  In the second stage, the climbing\n  image scheme (see (Henkelman2)) is enabled, so that the\n  replica having the highest energy relaxes toward the saddle point\n  (i.e. the point of highest energy along the MEP), and a second\n  relaxation is performed.\n  A key purpose of the nudging forces is to keep the replicas equally\n  spaced.  During the NEB calculation, the 3N-length vector of\n  interatomic force Fi = -Grad(V) for each replica I is altered.  For\n  all intermediate replicas (i.e. for 1 < I < N, except the climbing\n  replica) the force vector becomes:\n  Fi = -Grad(V) + (Grad(V) dot T') T' + Fnudge_parallel + Fnudge_perp\n  \n  \n  T’ is the unit “tangent” vector for replica I and is a function of Ri,\n  Ri-1, Ri+1, and the potential energy of the 3 replicas; it points\n  roughly in the direction of (Ri+i - Ri-1); see the\n  (Henkelman1) paper for details.  Ri are the atomic\n  coordinates of replica I; Ri-1 and Ri+1 are the coordinates of its\n  neighbor replicas.  The term (Grad(V) dot T’) is used to remove the\n  component of the gradient parallel to the path which would tend to\n  distribute the replica unevenly along the path.  Fnudge_parallel is an\n  artificial nudging force which is applied only in the tangent\n  direction and which maintains the equal spacing between replicas (see\n  below for more information).  Fnudge_perp is an optional artificial\n  spring which is applied in a direction perpendicular to the tangent\n  direction and which prevent the paths from forming acute kinks (see\n  below for more information).\n  In the second stage of the NEB calculation, the interatomic force Fi\n  for the climbing replica (the replica of highest energy after the\n  first stage) is changed to:\n  Fi = -Grad(V) + 2 (Grad(V) dot T') T'\n  \n  \n  and the relaxation procedure is continued to a new converged MEP.\n  \n  The keyword parallel specifies how the parallel nudging force is\n  computed.  With a value of neigh, the parallel nudging force is\n  computed as in (Henkelman1) by connecting each\n  intermediate replica with the previous and the next image:\n  Fnudge_parallel = Kspring * (|Ri+1 - Ri| - |Ri - Ri-1|)\n  Note that in this case the specified Kspring is in force/distance\n  units.\n  With a value of ideal, the spring force is computed as suggested in\n  ref`(WeinanE) <WeinanE>`\n  Fnudge_parallel = -Kspring * (RD-RDideal) / (2 * meanDist)\n  where RD is the “reaction coordinate” see neb section, and\n  RDideal is the ideal RD for which all the images are equally spaced.\n  I.e. RDideal = (I-1)*meanDist when the climbing replica is off, where\n  I is the replica number).  The meanDist is the average distance\n  between replicas.  Note that in this case the specified Kspring is\n  in force units.\n  Note that the ideal form of nudging can often be more effective at\n  keeping the replicas equally spaced.\n  \n  The keyword perp specifies if and how a perpendicular nudging force\n  is computed.  It adds a spring force perpendicular to the path in\n  order to prevent the path from becoming too strongly kinked.  It can\n  significantly improve the convergence of the NEB calculation when the\n  resolution is poor.  I.e. when few replicas are used; see\n  (Maras) for details.\n  The perpendicular spring force is given by\n  Fnudge_perp = Kspring2 * F(Ri-1,Ri,Ri+1) (Ri+1 + Ri-1 - 2 Ri)\n  where Kspring2 is the specified value.  F(Ri-1 Ri R+1) is a smooth\n  scalar function of the angle Ri-1 Ri Ri+1.  It is equal to 0.0 when\n  the path is straight and is equal to 1 when the angle Ri-1 Ri Ri+1 is\n  acute.  F(Ri-1 Ri R+1) is defined in (Jonsson).\n  If Kspring2 is set to 0.0 (the default) then no perpendicular spring\n  force is added.\n  \n  By default, no additional forces act on the first and last replicas\n  during the NEB relaxation, so these replicas simply relax toward their\n  respective local minima.  By using the key word end, additional\n  forces can be applied to the first and/or last replicas, to enable\n  them to relax toward a MEP while constraining their energy E to the\n  target energy ETarget.\n  If ETarget>E, the interatomic force Fi for the specified replica becomes:\n  Fi = -Grad(V) + (Grad(V) dot T' + (E-ETarget)*Kspring3) T',  when Grad(V) dot T' < 0\n  Fi = -Grad(V) + (Grad(V) dot T' + (ETarget- E)*Kspring3) T', when Grad(V) dot T' > 0\n  The “spring” constant on the difference in energies is the specified\n  Kspring3 value.\n  When estyle is specified as first, the force is applied to the\n  first replica.  When estyle is specified as last, the force is\n  applied to the last replica.  Note that the end keyword can be used\n  twice to add forces to both the first and last replicas.\n  For both these estyle settings, the target energy ETarget is set\n  to the initial energy of the replica (at the start of the NEB\n  calculation).\n  If the estyle is specified as last/efirst or last/efirst/middle,\n  force is applied to the last replica, but the target energy ETarget\n  is continuously set to the energy of the first replica, as it evolves\n  during the NEB relaxation.\n  The difference between these two estyle options is as follows.  When\n  estyle is specified as last/efirst, no change is made to the\n  inter-replica force applied to the intermediate replicas (neither\n  first or last).  If the initial path is too far from the MEP, an\n  intermediate replica may relax “faster” and reach a lower energy than\n  the last replica.  In this case the intermediate replica will be\n  relaxing toward its own local minima.  This behavior can be prevented\n  by specifying estyle as last/efirst/middle which will alter the\n  inter-replica force applied to intermediate replicas by removing the\n  contribution of the gradient to the inter-replica force.  This will\n  only be done if a particular intermediate replica has a lower energy\n  than the first replica.  This should effectively prevent the\n  intermediate replicas from over-relaxing.\n  After converging a NEB calculation using an estyle of\n  last/efirst/middle, you should check that all intermediate replicas\n  have a larger energy than the first replica. If this is not the case,\n  the path is probably not a MEP.\n  Finally, note that the last replica may never reach the target energy\n  if it is stuck in a local minima which has a larger energy than the\n  target energy.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  The forces due to this fix are imposed during an energy minimization,\n  as invoked by the minimize command via the\n  neb command.\n  ",
    "syntax": "fix ID group-ID neb Kspring keyword value\n  \n  \n  \n  ID, group-ID are documented in fix command\n  neb = style name of this fix command\n  Kspring = spring constant for parallel nudging force (force/distance units or force units, see parallel keyword)\n  zero or more keyword/value pairs may be appended\n  keyword = parallel or perp or end\n  \n  parallel value = neigh or ideal\n    neigh = parallel nudging force based on distance to neighbor replicas (Kspring = force/distance units)\n    ideal = parallel nudging force based on interpolated ideal position (Kspring = force units)\n  perp value = Kspring2\n    Kspring2 = spring constant for perpendicular nudging force (force/distance units)\n  end values = estyle Kspring3\n    estyle = first or last or last/efirst or last/efirst/middle\n      first = apply force to first replica\n      last = apply force to last replica\n      last/efirst = apply force to last replica and set its target energy to that of first replica\n      last/efirst/middle = same as last/efirst plus prevent middle replicas having lower energy than first replica\n    Kspring3 = spring constant for target energy term (1/distance units)\n  ",
    "examples": "fix 1 active neb 10.0\n  fix 2 all neb 1.0 perp 1.0 end last\n  fix 2 all neb 1.0 perp 1.0 end first 1.0 end last 1.0\n  fix 1 all neb 1.0 parallel ideal end last/efirst 1\n  \n  \n  ",
    "restrictions": "This command can only be used if LAMMPS was built with the REPLICA\n  package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "fix neb/spin",
    "description": "Add nudging forces to spins in the group for a multi-replica\n  simulation run via the neb/spin command to perform a\n  geodesic nudged elastic band (GNEB) calculation for finding the\n  transition state.\n  Hi-level explanations of GNEB are given with the\n  neb/spin command and on the\n  Howto replica doc page.\n  The fix neb/spin command must be used with the “neb/spin” command and\n  defines how inter-replica nudging forces are computed.  A GNEB\n  calculation is divided in two stages. In the first stage n replicas\n  are relaxed toward a MEP until convergence.  In the second stage, the\n  climbing image scheme is enabled, so that the replica having the highest\n  energy relaxes toward the saddle point (i.e. the point of highest energy\n  along the MEP), and a second relaxation is performed.\n  The nudging forces are calculated as explained in\n  (BessarabB)).\n  See this reference for more explanation about their expression.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  The forces due to this fix are imposed during an energy minimization,\n  as invoked by the minimize command via the\n  neb/spin command.\n  ",
    "syntax": "fix ID group-ID neb/spin Kspring\n  \n  \n  \n  ID, group-ID are documented in fix command\n  neb/spin = style name of this fix command\n  \n  Kspring = spring constant for parallel nudging force\n  (force/distance units or force units, see parallel keyword)\n  \n  \n  ",
    "examples": "fix 1 active neb/spin 1.0\n  \n  \n  ",
    "restrictions": "This command can only be used if LAMMPS was built with the SPIN\n  package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "fix nvt",
    "description": "These commands perform time integration on Nose-Hoover style\n  non-Hamiltonian equations of motion which are designed to generate\n  positions and velocities sampled from the canonical (nvt),\n  isothermal-isobaric (npt), and isenthalpic (nph) ensembles.  This\n  updates the position and velocity for atoms in the group each\n  timestep.\n  The thermostatting and barostatting is achieved by adding some dynamic\n  variables which are coupled to the particle velocities\n  (thermostatting) and simulation domain dimensions (barostatting).  In\n  addition to basic thermostatting and barostatting, these fixes can\n  also create a chain of thermostats coupled to the particle thermostat,\n  and another chain of thermostats coupled to the barostat\n  variables. The barostat can be coupled to the overall box volume, or\n  to individual dimensions, including the xy, xz and yz tilt\n  dimensions. The external pressure of the barostat can be specified as\n  either a scalar pressure (isobaric ensemble) or as components of a\n  symmetric stress tensor (constant stress ensemble).  When used\n  correctly, the time-averaged temperature and stress tensor of the\n  particles will match the target values specified by Tstart/Tstop and\n  Pstart/Pstop.\n  The equations of motion used are those of Shinoda et al in\n  (Shinoda), which combine the hydrostatic equations of\n  Martyna, Tobias and Klein in (Martyna) with the strain\n  energy proposed by Parrinello and Rahman in\n  (Parrinello).  The time integration schemes closely\n  follow the time-reversible measure-preserving Verlet and rRESPA\n  integrators derived by Tuckerman et al in (Tuckerman).\n  \n  The thermostat parameters for fix styles nvt and npt are specified\n  using the temp keyword.  Other thermostat-related keywords are\n  tchain, tloop and drag, which are discussed below.\n  The thermostat is applied to only the translational degrees of freedom\n  for the particles.  The translational degrees of freedom can also have\n  a bias velocity removed before thermostatting takes place; see the\n  description below.  The desired temperature at each timestep is a\n  ramped value during the run from Tstart to Tstop.  The Tdamp\n  parameter is specified in time units and determines how rapidly the\n  temperature is relaxed.  For example, a value of 10.0 means to relax\n  the temperature in a timespan of (roughly) 10 time units (e.g. tau or\n  fmsec or psec - see the units command).  The atoms in the\n  fix group are the only ones whose velocities and positions are updated\n  by the velocity/position update portion of the integration.\n  \n  Note\n  A Nose-Hoover thermostat will not work well for arbitrary values\n  of Tdamp.  If Tdamp is too small, the temperature can fluctuate\n  wildly; if it is too large, the temperature will take a very long time\n  to equilibrate.  A good choice for many models is a Tdamp of around\n  100 timesteps.  Note that this is NOT the same as 100 time units for\n  most units settings. A simple way to ensure this, is\n  via using an immediate variable expression accessing\n  the thermo property ‘dt’, which is the length of the time step. Example:\n  \n  fix 1 all nvt temp 300.0 300.0 $(100.0*dt)\n  \n  \n  \n  The barostat parameters for fix styles npt and nph is specified\n  using one or more of the iso, aniso, tri, x, y, z, xy,\n  xz, yz, and couple keywords.  These keywords give you the\n  ability to specify all 6 components of an external stress tensor, and\n  to couple various of these components together so that the dimensions\n  they represent are varied together during a constant-pressure\n  simulation.\n  Other barostat-related keywords are pchain, mtk, ploop,\n  nreset, drag, and dilate, which are discussed below.\n  Orthogonal simulation boxes have 3 adjustable dimensions (x,y,z).\n  Triclinic (non-orthogonal) simulation boxes have 6 adjustable\n  dimensions (x,y,z,xy,xz,yz).  The create_box, read data, and read_restart commands\n  specify whether the simulation box is orthogonal or non-orthogonal\n  (triclinic) and explain the meaning of the xy,xz,yz tilt factors.\n  The target pressures for each of the 6 components of the stress tensor\n  can be specified independently via the x, y, z, xy, xz, yz\n  keywords, which correspond to the 6 simulation box dimensions.  For\n  each component, the external pressure or tensor component at each\n  timestep is a ramped value during the run from Pstart to Pstop.\n  If a target pressure is specified for a component, then the\n  corresponding box dimension will change during a simulation.  For\n  example, if the y keyword is used, the y-box length will change.  If\n  the xy keyword is used, the xy tilt factor will change.  A box\n  dimension will not change if that component is not specified, although\n  you have the option to change that dimension via the fix deform command.\n  Note that in order to use the xy, xz, or yz keywords, the\n  simulation box must be triclinic, even if its initial tilt factors are\n  0.0.\n  For all barostat keywords, the Pdamp parameter operates like the\n  Tdamp parameter, determining the time scale on which pressure is\n  relaxed.  For example, a value of 10.0 means to relax the pressure in\n  a timespan of (roughly) 10 time units (e.g. tau or fmsec or psec - see\n  the units command).\n  \n  Note\n  A Nose-Hoover barostat will not work well for arbitrary values\n  of Pdamp.  If Pdamp is too small, the pressure and volume can\n  fluctuate wildly; if it is too large, the pressure will take a very\n  long time to equilibrate.  A good choice for many models is a Pdamp\n  of around 1000 timesteps.  However, note that Pdamp is specified in\n  time units, and that timesteps are NOT the same as time units for most\n  units settings.\n  \n  Regardless of what atoms are in the fix group (the only atoms which\n  are time integrated), a global pressure or stress tensor is computed\n  for all atoms.  Similarly, when the size of the simulation box is\n  changed, all atoms are re-scaled to new positions, unless the keyword\n  dilate is specified with a dilate-group-ID for a group that\n  represents a subset of the atoms.  This can be useful, for example, to\n  leave the coordinates of atoms in a solid substrate unchanged and\n  controlling the pressure of a surrounding fluid.  This option should\n  be used with care, since it can be unphysical to dilate some atoms and\n  not others, because it can introduce large, instantaneous\n  displacements between a pair of atoms (one dilated, one not) that are\n  far from the dilation origin.  Also note that for atoms not in the fix\n  group, a separate time integration fix like fix nve or\n  fix nvt can be used on them, independent of whether they\n  are dilated or not.\n  \n  The couple keyword allows two or three of the diagonal components of\n  the pressure tensor to be “coupled” together.  The value specified\n  with the keyword determines which are coupled.  For example, xz\n  means the Pxx and Pzz components of the stress tensor are coupled.\n  Xyz means all 3 diagonal components are coupled.  Coupling means two\n  things: the instantaneous stress will be computed as an average of the\n  corresponding diagonal components, and the coupled box dimensions will\n  be changed together in lockstep, meaning coupled dimensions will be\n  dilated or contracted by the same percentage every timestep.  The\n  Pstart, Pstop, Pdamp parameters for any coupled dimensions must\n  be identical.  Couple xyz can be used for a 2d simulation; the z\n  dimension is simply ignored.\n  \n  The iso, aniso, and tri keywords are simply shortcuts that are\n  equivalent to specifying several other keywords together.\n  The keyword iso means couple all 3 diagonal components together when\n  pressure is computed (hydrostatic pressure), and dilate/contract the\n  dimensions together.  Using “iso Pstart Pstop Pdamp” is the same as\n  specifying these 4 keywords:\n  x Pstart Pstop Pdamp\n  y Pstart Pstop Pdamp\n  z Pstart Pstop Pdamp\n  couple xyz\n  \n  \n  The keyword aniso means x, y, and z dimensions are controlled\n  independently using the Pxx, Pyy, and Pzz components of the\n  stress tensor as the driving forces, and the specified scalar external\n  pressure.  Using “aniso Pstart Pstop Pdamp” is the same as specifying\n  these 4 keywords:\n  x Pstart Pstop Pdamp\n  y Pstart Pstop Pdamp\n  z Pstart Pstop Pdamp\n  couple none\n  \n  \n  The keyword tri means x, y, z, xy, xz, and yz dimensions\n  are controlled independently using their individual stress components\n  as the driving forces, and the specified scalar pressure as the\n  external normal stress.  Using “tri Pstart Pstop Pdamp” is the same as\n  specifying these 7 keywords:\n  x Pstart Pstop Pdamp\n  y Pstart Pstop Pdamp\n  z Pstart Pstop Pdamp\n  xy 0.0 0.0 Pdamp\n  yz 0.0 0.0 Pdamp\n  xz 0.0 0.0 Pdamp\n  couple none\n  \n  \n  \n  In some cases (e.g. for solids) the pressure (volume) and/or\n  temperature of the system can oscillate undesirably when a Nose/Hoover\n  barostat and thermostat is applied.  The optional drag keyword will\n  damp these oscillations, although it alters the Nose/Hoover equations.\n  A value of 0.0 (no drag) leaves the Nose/Hoover formalism unchanged.\n  A non-zero value adds a drag term; the larger the value specified, the\n  greater the damping effect.  Performing a short run and monitoring the\n  pressure and temperature is the best way to determine if the drag term\n  is working.  Typically a value between 0.2 to 2.0 is sufficient to\n  damp oscillations after a few periods. Note that use of the drag\n  keyword will interfere with energy conservation and will also change\n  the distribution of positions and velocities so that they do not\n  correspond to the nominal NVT, NPT, or NPH ensembles.\n  An alternative way to control initial oscillations is to use chain\n  thermostats. The keyword tchain determines the number of thermostats\n  in the particle thermostat. A value of 1 corresponds to the original\n  Nose-Hoover thermostat. The keyword pchain specifies the number of\n  thermostats in the chain thermostatting the barostat degrees of\n  freedom. A value of 0 corresponds to no thermostatting of the\n  barostat variables.\n  The mtk keyword controls whether or not the correction terms due to\n  Martyna, Tuckerman, and Klein are included in the equations of motion\n  (Martyna).  Specifying no reproduces the original\n  Hoover barostat, whose volume probability distribution function\n  differs from the true NPT and NPH ensembles by a factor of 1/V.  Hence\n  using yes is more correct, but in many cases the difference is\n  negligible.\n  The keyword tloop can be used to improve the accuracy of integration\n  scheme at little extra cost.  The initial and final updates of the\n  thermostat variables are broken up into tloop sub-steps, each of\n  length dt/tloop. This corresponds to using a first-order\n  Suzuki-Yoshida scheme (Tuckerman).  The keyword ploop\n  does the same thing for the barostat thermostat.\n  The keyword nreset controls how often the reference dimensions used\n  to define the strain energy are reset.  If this keyword is not used,\n  or is given a value of zero, then the reference dimensions are set to\n  those of the initial simulation domain and are never changed. If the\n  simulation domain changes significantly during the simulation, then\n  the final average pressure tensor will differ significantly from the\n  specified values of the external stress tensor.  A value of nstep\n  means that every nstep timesteps, the reference dimensions are set\n  to those of the current simulation domain.\n  The scaleyz, scalexz, and scalexy keywords control whether or\n  not the corresponding tilt factors are scaled with the associated box\n  dimensions when barostatting triclinic periodic cells.  The default\n  values yes will turn on scaling, which corresponds to adjusting the\n  linear dimensions of the cell while preserving its shape.  Choosing\n  no ensures that the tilt factors are not scaled with the box\n  dimensions. See below for restrictions and default values in different\n  situations. In older versions of LAMMPS, scaling of tilt factors was\n  not performed. The old behavior can be recovered by setting all three\n  scale keywords to no.\n  The flip keyword allows the tilt factors for a triclinic box to\n  exceed half the distance of the parallel box length, as discussed\n  below.  If the flip value is set to yes, the bound is enforced by\n  flipping the box when it is exceeded.  If the flip value is set to\n  no, the tilt will continue to change without flipping.  Note that if\n  applied stress induces large deformations (e.g. in a liquid), this\n  means the box shape can tilt dramatically and LAMMPS will run less\n  efficiently, due to the large volume of communication needed to\n  acquire ghost atoms around a processor’s irregular-shaped sub-domain.\n  For extreme values of tilt, LAMMPS may also lose atoms and generate an\n  error.\n  The fixedpoint keyword specifies the fixed point for barostat volume\n  changes. By default, it is the center of the box.  Whatever point is\n  chosen will not move during the simulation.  For example, if the lower\n  periodic boundaries pass through (0,0,0), and this point is provided\n  to fixedpoint, then the lower periodic boundaries will remain at\n  (0,0,0), while the upper periodic boundaries will move twice as\n  far. In all cases, the particle trajectories are unaffected by the\n  chosen value, except for a time-dependent constant translation of\n  positions.\n  If the update keyword is used with the dipole value, then the\n  orientation of the dipole moment of each particle is also updated\n  during the time integration.  This option should be used for models\n  where a dipole moment is assigned to finite-size particles,\n  e.g. spheroids via use of the atom_style hybrid sphere dipole command.\n  The default dipole orientation integrator can be changed to the\n  Dullweber-Leimkuhler-McLachlan integration scheme\n  (Dullweber) when using update with the value\n  dipole/dlm. This integrator is symplectic and time-reversible,\n  giving better energy conservation and allows slightly longer timesteps\n  at only a small additional computational cost.\n  \n  \n  Note\n  Using a barostat coupled to tilt dimensions xy, xz, yz can\n  sometimes result in arbitrarily large values of the tilt dimensions,\n  i.e. a dramatically deformed simulation box.  LAMMPS allows the tilt\n  factors to grow a small amount beyond the normal limit of half the box\n  length (0.6 times the box length), and then performs a box “flip” to\n  an equivalent periodic cell.  See the discussion of the flip keyword\n  above, to allow this bound to be exceeded, if desired.\n  \n  The flip operation is described in more detail in the doc page for\n  fix deform.  Both the barostat dynamics and the atom\n  trajectories are unaffected by this operation.  However, if a tilt\n  factor is incremented by a large amount (1.5 times the box length) on\n  a single timestep, LAMMPS can not accommodate this event and will\n  terminate the simulation with an error. This error typically indicates\n  that there is something badly wrong with how the simulation was\n  constructed, such as specifying values of Pstart that are too far\n  from the current stress value, or specifying a timestep that is too\n  large. Triclinic barostatting should be used with care. This also is\n  true for other barostat styles, although they tend to be more\n  forgiving of insults. In particular, it is important to recognize that\n  equilibrium liquids can not support a shear stress and that\n  equilibrium solids can not support shear stresses that exceed the\n  yield stress.\n  One exception to this rule is if the 1st dimension in the tilt factor\n  (x for xy) is non-periodic.  In that case, the limits on the tilt\n  factor are not enforced, since flipping the box in that dimension does\n  not change the atom positions due to non-periodicity.  In this mode,\n  if you tilt the system to extreme angles, the simulation will simply\n  become inefficient due to the highly skewed simulation box.\n  \n  Note\n  Unlike the fix temp/berendsen command\n  which performs thermostatting but NO time integration, these fixes\n  perform thermostatting/barostatting AND time integration.  Thus you\n  should not use any other time integration fix, such as fix nve on atoms to which this fix is applied.  Likewise,\n  fix nvt and fix npt should not normally be used on atoms that also\n  have their temperature controlled by another fix - e.g. by fix langevin or fix temp/rescale\n  commands.\n  \n  See the Howto thermostat and Howto barostat doc pages for a discussion of different\n  ways to compute temperature and perform thermostatting and\n  barostatting.\n  \n  These fixes compute a temperature and pressure each timestep.  To do\n  this, the thermostat and barostat fixes create their own computes of\n  style “temp” and “pressure”, as if one of these sets of commands had\n  been issued:\n  For fix nvt:\n  compute fix-ID_temp group-ID temp\n  \n  \n  For fix npt and fix nph:\n  compute fix-ID_temp all temp\n  compute fix-ID_press all pressure fix-ID_temp\n  \n  \n  For fix nvt, the group for the new temperature compute is the same as\n  the fix group.  For fix npt and fix nph, the group for both the new\n  temperature and pressure compute is “all” since pressure is computed\n  for the entire system.  In the case of fix nph, the temperature\n  compute is not used for thermostatting, but just for a kinetic-energy\n  contribution to the pressure.  See the compute temp and compute pressure\n  commands for details.  Note that the IDs of the new computes are the\n  fix-ID + underscore + “temp” or fix_ID + underscore + “press”.\n  Note that these are NOT the computes used by thermodynamic output (see\n  the thermo_style command) with ID = thermo_temp\n  and thermo_press.  This means you can change the attributes of these\n  fix’s temperature or pressure via the\n  compute_modify command.  Or you can print this\n  temperature or pressure during thermodynamic output via the\n  thermo_style custom command using the appropriate\n  compute-ID.  It also means that changing attributes of thermo_temp\n  or thermo_press will have no effect on this fix.\n  Like other fixes that perform thermostatting, fix nvt and fix npt can\n  be used with compute commands that calculate a\n  temperature after removing a “bias” from the atom velocities.\n  E.g. removing the center-of-mass velocity from a group of atoms or\n  only calculating temperature on the x-component of velocity or only\n  calculating temperature for atoms in a geometric region.  This is not\n  done by default, but only if the fix_modify command\n  is used to assign a temperature compute to this fix that includes such\n  a bias term.  See the doc pages for individual compute commands to determine which ones include a bias.  In\n  this case, the thermostat works in the following manner: the current\n  temperature is calculated taking the bias into account, bias is\n  removed from each atom, thermostatting is performed on the remaining\n  thermal degrees of freedom, and the bias is added back in.\n  \n  These fixes can be used with either the verlet or respa\n  integrators. When using one of the barostat fixes\n  with respa, LAMMPS uses an integrator constructed\n  according to the following factorization of the Liouville propagator\n  (for two rRESPA levels):\n  \n  \\[\\begin{split}\\exp \\left(\\mathrm{i} L \\Delta t \\right) = & \\hat{E}\n  \\exp \\left(\\mathrm{i} L_{\\rm T\\textrm{-}baro} \\frac{\\Delta t}{2} \\right)\n  \\exp \\left(\\mathrm{i} L_{\\rm T\\textrm{-}part} \\frac{\\Delta t}{2} \\right)\n  \\exp \\left(\\mathrm{i} L_{\\epsilon , 2} \\frac{\\Delta t}{2} \\right)\n  \\exp \\left(\\mathrm{i} L_{2}^{(2)} \\frac{\\Delta t}{2} \\right) \\\\\n  &\\times \\left[\n  \\exp \\left(\\mathrm{i} L_{2}^{(1)} \\frac{\\Delta t}{2n} \\right)\n  \\exp \\left(\\mathrm{i} L_{\\epsilon , 1} \\frac{\\Delta t}{2n} \\right)\n  \\exp \\left(\\mathrm{i} L_1 \\frac{\\Delta t}{n} \\right)\n  \\exp \\left(\\mathrm{i} L_{\\epsilon , 1} \\frac{\\Delta t}{2n} \\right)\n  \\exp \\left(\\mathrm{i} L_{2}^{(1)} \\frac{\\Delta t}{2n} \\right)\n  \\right]^n \\\\\n  &\\times\n  \\exp \\left(\\mathrm{i} L_{2}^{(2)} \\frac{\\Delta t}{2} \\right)\n  \\exp \\left(\\mathrm{i} L_{\\epsilon , 2} \\frac{\\Delta t}{2} \\right)\n  \\exp \\left(\\mathrm{i} L_{\\rm T\\textrm{-}part} \\frac{\\Delta t}{2} \\right)\n  \\exp \\left(\\mathrm{i} L_{\\rm T\\textrm{-}baro} \\frac{\\Delta t}{2} \\right) \\\\\n  &+ \\mathcal{O} \\left(\\Delta t^3 \\right)\\end{split}\\]\n  This factorization differs somewhat from that of Tuckerman et al, in\n  that the barostat is only updated at the outermost rRESPA level,\n  whereas Tuckerman’s factorization requires splitting the pressure into\n  pieces corresponding to the forces computed at each rRESPA level. In\n  theory, the latter method will exhibit better numerical stability. In\n  practice, because Pdamp is normally chosen to be a large multiple of\n  the outermost rRESPA timestep, the barostat dynamics are not the\n  limiting factor for numerical stability. Both factorizations are\n  time-reversible and can be shown to preserve the phase space measure\n  of the underlying non-Hamiltonian equations of motion.\n  \n  Note\n  This implementation has been shown to conserve linear momentum\n  up to machine precision under NVT dynamics. Under NPT dynamics,\n  for a system with zero initial total linear momentum, the total\n  momentum fluctuates close to zero. It may occasionally undergo brief\n  excursions to non-negligible values, before returning close to zero.\n  Over long simulations, this has the effect of causing the center-of-mass\n  to undergo a slow random walk. This can be mitigated by resetting\n  the momentum at infrequent intervals using the\n  fix momentum command.\n  \n  \n  The fix npt and fix nph commands can be used with rigid bodies or\n  mixtures of rigid bodies and non-rigid particles (e.g. solvent).  But\n  there are also fix rigid/npt and fix rigid/nph commands, which are typically a more natural\n  choice.  See the doc page for those commands for more discussion of\n  the various ways to do this.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  These fixes writes the state of all the thermostat and barostat\n  variables to binary restart files.  See the\n  read_restart command for info on how to re-specify\n  a fix in an input script that reads a restart file, so that the\n  operation of the fix continues in an uninterrupted fashion.\n  The fix_modify temp and press options are\n  supported by these fixes.  You can use them to assign a\n  compute you have defined to this fix which will be used\n  in its thermostatting or barostatting procedure, as described above.\n  If you do this, note that the kinetic energy derived from the compute\n  temperature should be consistent with the virial term computed using\n  all atoms for the pressure.  LAMMPS will warn you if you choose to\n  compute temperature on a subset of atoms.\n  \n  Note\n  If both the temp and press keywords are used in a single\n  thermo_modify command (or in two separate commands), then the order in\n  which the keywords are specified is important.  Note that a pressure compute defines its own temperature compute as\n  an argument when it is specified.  The temp keyword will override\n  this (for the pressure compute being used by fix npt), but only if the\n  temp keyword comes after the press keyword.  If the temp keyword\n  comes before the press keyword, then the new pressure compute\n  specified by the press keyword will be unaffected by the temp\n  setting.\n  \n  The fix_modify energy option is supported by these\n  fixes to add the energy change induced by Nose/Hoover thermostatting\n  and barostatting to the system’s potential energy as part of\n  thermodynamic output.\n  These fixes compute a global scalar and a global vector of quantities,\n  which can be accessed by various output commands.\n  The scalar value calculated by these fixes is “extensive”; the vector\n  values are “intensive”.\n  The scalar is the cumulative energy change due to the fix.\n  The vector stores internal Nose/Hoover thermostat and barostat\n  variables.  The number and meaning of the vector values depends on\n  which fix is used and the settings for keywords tchain and pchain,\n  which specify the number of Nose/Hoover chains for the thermostat and\n  barostat.  If no thermostatting is done, then tchain is 0.  If no\n  barostatting is done, then pchain is 0.  In the following list,\n  “ndof” is 0, 1, 3, or 6, and is the number of degrees of freedom in\n  the barostat.  Its value is 0 if no barostat is used, else its value\n  is 6 if any off-diagonal stress tensor component is barostatted, else\n  its value is 1 if couple xyz is used or couple xy for a 2d\n  simulation, otherwise its value is 3.\n  The order of values in the global vector and their meaning is as\n  follows.  The notation means there are tchain values for eta, followed\n  by tchain for eta_dot, followed by ndof for omega, etc:\n  \n  eta[tchain] = particle thermostat displacements (unitless)\n  eta_dot[tchain] = particle thermostat velocities (1/time units)\n  omega[ndof] = barostat displacements (unitless)\n  omega_dot[ndof] = barostat velocities (1/time units)\n  etap[pchain] = barostat thermostat displacements (unitless)\n  etap_dot[pchain] = barostat thermostat velocities (1/time units)\n  PE_eta[tchain] = potential energy of each particle thermostat displacement (energy units)\n  KE_eta_dot[tchain] = kinetic energy of each particle thermostat velocity (energy units)\n  PE_omega[ndof] = potential energy of each barostat displacement (energy units)\n  KE_omega_dot[ndof] = kinetic energy of each barostat velocity (energy units)\n  PE_etap[pchain] = potential energy of each barostat thermostat displacement (energy units)\n  KE_etap_dot[pchain] = kinetic energy of each barostat thermostat velocity (energy units)\n  PE_strain[1] = scalar strain energy (energy units)\n  \n  These fixes can ramp their external temperature and pressure over\n  multiple runs, using the start and stop keywords of the\n  run command.  See the run command for details of\n  how to do this.\n  These fixes are not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID style_name keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  style_name = nvt or npt or nph\n  one or more keyword/value pairs may be appended\n  keyword = temp or iso or aniso or tri or x or y or z or xy or yz or xz or couple or tchain or pchain or mtk or tloop or ploop or nreset or drag or dilate or scalexy or scaleyz or scalexz or flip or fixedpoint or update\n    temp values = Tstart Tstop Tdamp\n      Tstart,Tstop = external temperature at start/end of run\n      Tdamp = temperature damping parameter (time units)\n    iso or aniso or tri values = Pstart Pstop Pdamp\n      Pstart,Pstop = scalar external pressure at start/end of run (pressure units)\n      Pdamp = pressure damping parameter (time units)\n    x or y or z or xy or yz or xz values = Pstart Pstop Pdamp\n      Pstart,Pstop = external stress tensor component at start/end of run (pressure units)\n      Pdamp = stress damping parameter (time units)\n    couple = none or xyz or xy or yz or xz\n    tchain value = N\n      N = length of thermostat chain (1 = single thermostat)\n    pchain values = N\n      N length of thermostat chain on barostat (0 = no thermostat)\n    mtk value = yes or no = add in MTK adjustment term or not\n    tloop value = M\n      M = number of sub-cycles to perform on thermostat\n    ploop value = M\n      M = number of sub-cycles to perform on barostat thermostat\n    nreset value = reset reference cell every this many timesteps\n    drag value = Df\n      Df = drag factor added to barostat/thermostat (0.0 = no drag)\n    dilate value = dilate-group-ID\n      dilate-group-ID = only dilate atoms in this group due to barostat volume changes\n    scalexy value = yes or no = scale xy with ly\n    scaleyz value = yes or no = scale yz with lz\n    scalexz value = yes or no = scale xz with lz\n    flip value = yes or no = allow or disallow box flips when it becomes highly skewed\n    fixedpoint values = x y z\n      x,y,z = perform barostat dilation/contraction around this point (distance units)\n    update value = dipole or dipole/dlm\n      dipole = update dipole orientation (only for sphere variants)\n      dipole/dlm = use DLM integrator to update dipole orientation (only for sphere variants)\n  \n  \n  ",
    "examples": "fix 1 all nvt temp 300.0 300.0 100.0\n  fix 1 water npt temp 300.0 300.0 100.0 iso 0.0 0.0 1000.0\n  fix 2 jello npt temp 300.0 300.0 100.0 tri 5.0 5.0 1000.0\n  fix 2 ice nph x 1.0 1.0 0.5 y 2.0 2.0 0.5 z 3.0 3.0 0.5 yz 0.1 0.1 0.5 xz 0.2 0.2 0.5 xy 0.3 0.3 0.5 nreset 1000\n  \n  \n  ",
    "restrictions": "X, y, z cannot be barostatted if the associated dimension is not\n  periodic.  Xy, xz, and yz can only be barostatted if the\n  simulation domain is triclinic and the 2nd dimension in the keyword\n  (y dimension in xy) is periodic.  Z, xz, and yz, cannot be\n  barostatted for 2D simulations.  The create_box,\n  read data, and read_restart\n  commands specify whether the simulation box is orthogonal or\n  non-orthogonal (triclinic) and explain the meaning of the xy,xz,yz\n  tilt factors.\n  For the temp keyword, the final Tstop cannot be 0.0 since it would\n  make the external T = 0.0 at some timestep during the simulation which\n  is not allowed in the Nose/Hoover formulation.\n  The scaleyz yes and scalexz yes keyword/value pairs can not be used\n  for 2D simulations. scaleyz yes, scalexz yes, and scalexy yes options\n  can only be used if the 2nd dimension in the keyword is periodic,\n  and if the tilt factor is not coupled to the barostat via keywords\n  tri, yz, xz, and xy.\n  These fixes can be used with dynamic groups as defined by the\n  group command.  Likewise they can be used with groups to\n  which atoms are added or deleted over time, e.g. a deposition\n  simulation.  However, the conservation properties of the thermostat\n  and barostat are defined for systems with a static set of atoms.  You\n  may observe odd behavior if the atoms in a group vary dramatically\n  over time or the atom count becomes very small.\n  "
},
{
    "command": "fix nvt/eff",
    "description": "These commands perform time integration on Nose-Hoover style\n  non-Hamiltonian equations of motion for nuclei and electrons in the\n  group for the electron force field model.  The fixes\n  are designed to generate positions and velocities sampled from the\n  canonical (nvt), isothermal-isobaric (npt), and isenthalpic (nph)\n  ensembles.  This is achieved by adding some dynamic variables which\n  are coupled to the particle velocities (thermostatting) and simulation\n  domain dimensions (barostatting).  In addition to basic thermostatting\n  and barostatting, these fixes can also create a chain of thermostats\n  coupled to the particle thermostat, and another chain of thermostats\n  coupled to the barostat variables. The barostat can be coupled to the\n  overall box volume, or to individual dimensions, including the xy,\n  xz and yz tilt dimensions. The external pressure of the barostat\n  can be specified as either a scalar pressure (isobaric ensemble) or as\n  components of a symmetric stress tensor (constant stress ensemble).\n  When used correctly, the time-averaged temperature and stress tensor\n  of the particles will match the target values specified by\n  Tstart/Tstop and Pstart/Pstop.\n  The operation of these fixes is exactly like that described by the\n  fix nvt, npt, and nph commands, except that the radius\n  and radial velocity of electrons are also updated.  Likewise the\n  temperature and pressure calculated by the fix, using the computes it\n  creates (as discussed in the fix nvt, npt, and nph\n  doc page), are performed with computes that include the eFF contribution\n  to the temperature or kinetic energy from the electron radial velocity.\n  \n  Note\n  there are two different pressures that can be reported for eFF\n  when defining the pair_style (see pair eff/cut to\n  understand these settings), one (default) that considers electrons do\n  not contribute radial virial components (i.e. electrons treated as\n  incompressible ‘rigid’ spheres) and one that does.  The radial\n  electronic contributions to the virials are only tallied if the\n  flexible pressure option is set, and this will affect both global and\n  per-atom quantities.  In principle, the true pressure of a system is\n  somewhere in between the rigid and the flexible eFF pressures, but,\n  for most cases, the difference between these two pressures will not be\n  significant over long-term averaged runs (i.e. even though the energy\n  partitioning changes, the total energy remains similar).\n  \n  \n  Note\n  currently, there is no available option for the user to set or\n  create temperature distributions that include the radial electronic\n  degrees of freedom with the velocity command, so the\n  the user must allow for these degrees of freedom to equilibrate\n  (i.e. equi-partitioning of energy) through time integration.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  See the doc page for the fix nvt, npt, and nph commands\n  for details.\n  ",
    "syntax": "fix ID group-ID style_name keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  style_name = nvt/eff or npt/eff or nph/eff\n  one or more keyword value pairs may be appended\n  keyword = temp or iso or aniso or tri or x or y or z or xy or yz or xz or couple or tchain or pchain or mtk or tloop or ploop or nreset or drag or dilate\n    temp values = Tstart Tstop Tdamp\n      Tstart,Tstop = external temperature at start/end of run\n      Tdamp = temperature damping parameter (time units)\n    iso or aniso or tri values = Pstart Pstop Pdamp\n      Pstart,Pstop = scalar external pressure at start/end of run (pressure units)\n      Pdamp = pressure damping parameter (time units)\n    x or y or z or xy or yz or xz values = Pstart Pstop Pdamp\n      Pstart,Pstop = external stress tensor component at start/end of run (pressure units)\n      Pdamp = stress damping parameter (time units)\n    couple = none or xyz or xy or yz or xz\n    tchain value = length of thermostat chain (1 = single thermostat)\n    pchain values = length of thermostat chain on barostat (0 = no thermostat)\n    mtk value = yes or no = add in MTK adjustment term or not\n    tloop value = number of sub-cycles to perform on thermostat\n    ploop value = number of sub-cycles to perform on barostat thermostat\n    nreset value = reset reference cell every this many timesteps\n    drag value = drag factor added to barostat/thermostat (0.0 = no drag)\n    dilate value = all or partial\n  \n  \n  ",
    "examples": "fix 1 all nvt/eff temp 300.0 300.0 0.1\n  fix 1 part npt/eff temp 300.0 300.0 0.1 iso 0.0 0.0 1.0\n  fix 2 part npt/eff temp 300.0 300.0 0.1 tri 5.0 5.0 1.0\n  fix 2 ice nph/eff x 1.0 1.0 0.5 y 2.0 2.0 0.5 z 3.0 3.0 0.5 yz 0.1 0.1 0.5 xz 0.2 0.2 0.5 xy 0.3 0.3 0.5 nreset 1000\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-EFF package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  Other restriction discussed on the doc page for the fix nvt, npt, and nph commands also apply.\n  \n  Note\n  The temperature for systems (regions or groups) with only\n  electrons and no nuclei is 0.0 (i.e. not defined) in the current\n  temperature calculations, a practical example would be a uniform\n  electron gas or a very hot plasma, where electrons remain delocalized\n  from the nuclei.  This is because, even though electron virials are\n  included in the temperature calculation, these are averaged over the\n  nuclear degrees of freedom only.  In such cases a corrective term must\n  be added to the pressure to get the correct kinetic contribution.\n  \n  "
},
{
    "command": "fix nvt/uef",
    "description": "This fix can be used to simulate non-equilibrium molecular dynamics\n  (NEMD) under diagonal flow fields, including uniaxial and bi-axial\n  flow.  Simulations under continuous extensional flow may be carried\n  out for an indefinite amount of time.  It is an implementation of the\n  boundary conditions from (Dobson), and also uses numerical\n  lattice reduction as was proposed by (Hunt). The lattice\n  reduction algorithm is from (Semaev). The fix is intended for\n  simulations of homogeneous flows, and integrates the SLLOD equations\n  of motion, originally proposed by Hoover and Ladd (see (Evans and Morriss)).  Additional detail about this implementation can be\n  found in (Nicholson and Rutledge).\n  Note that NEMD simulations of a continuously strained system can be\n  performed using the fix deform, fix nvt/sllod, and compute temp/deform commands.\n  The applied flow field is set by the eps keyword. The values\n  edot_x and edot_y correspond to the strain rates in the xx and yy\n  directions.  It is implicitly assumed that the flow field is\n  traceless, and therefore the strain rate in the zz direction is eqal\n  to -(edot_x + edot_y).\n  \n  Note\n  Due to an instability in the SLLOD equations under extension,\n  fix momentum should be used to regularly reset the\n  linear momentum.\n  \n  The boundary conditions require a simulation box that does not have a\n  consistent alignment relative to the applied flow field. Since LAMMPS\n  utilizes an upper-triangular simulation box, it is not possible to\n  express the evolving simulation box in the same coordinate system as\n  the flow field.  This fix keeps track of two coordinate systems: the\n  flow frame, and the upper triangular LAMMPS frame. The coordinate\n  systems are related to each other through the QR decomposition, as is\n  illustrated in the image below.\n  \n  During most molecular dynamics operations, the system is represented\n  in the LAMMPS frame. Only when the positions and velocities are\n  updated is the system rotated to the flow frame, and it is rotated\n  back to the LAMMPS frame immediately afterwards. For this reason, all\n  vector-valued quantities (except for the tensors from\n  compute pressure/uef and\n  compute temp/uef) will be computed in the\n  LAMMPS frame. Rotationally invariant scalar quantities like the\n  temperature and hydrostatic pressure are frame-invariant and will be\n  computed correctly. Additionally, the system is in the LAMMPS frame\n  during all of the output steps, and therefore trajectory files made\n  using the dump command will be in the LAMMPS frame unless the\n  dump cfg/uef command is used.\n  \n  Temperature control is achieved with the default Nose-Hoover style\n  thermostat documented in fix npt. When this fix is\n  active, only the peculiar velocity of each atom is stored, defined as\n  the velocity relative to the streaming velocity. This is in contrast\n  to fix nvt/sllod, which uses a lab-frame\n  velocity, and removes the contribution from the streaming velocity in\n  order to compute the temperature.\n  Pressure control is achieved using the default Nose-Hoover barostat\n  documented in fix npt. There are two ways to control the\n  pressure using this fix. The first method involves using the ext\n  keyword along with the iso pressure style. With this method, the\n  pressure is controlled by scaling the simulation box isotropically to\n  achieve the average pressure only in the directions specified by\n  ext.  For example, if the ext value is set to xy, the average\n  pressure (Pxx+Pyy)/2 will be controlled.\n  This example command will control the total hydrostatic pressure under\n  uniaxial tension:\n  fix f1 all npt/uef temp 0.7 0.7 0.5 iso 1 1 5 erate -0.5 -0.5 ext xyz\n  \n  \n  This example command will control the average stress in compression\n  directions, which would typically correspond to free surfaces under\n  drawing with uniaxial tension:\n  fix f2 all npt/uef temp 0.7 0.7 0.5 iso 1 1 5 erate -0.5 -0.5 ext xy\n  \n  \n  The second method for pressure control involves setting the normal\n  stresses using the x, y , and/or z keywords. When using this\n  method, the same pressure must be specified via Pstart and Pstop\n  for all dimensions controlled. Any choice of pressure conditions that\n  would cause LAMMPS to compute a deviatoric stress are not permissible\n  and will result in an error. Additionally, all dimensions with\n  controlled stress must have the same applied strain rate. The ext\n  keyword must be set to the default value (xyz) when using this\n  method.\n  For example, the following commands will work:\n  fix f3 all npt/uef temp 0.7 0.7 0.5 x 1 1 5 y 1 1 5 erate -0.5 -0.5\n  fix f4 all npt/uef temp 0.7 0.7 0.5 z 1 1 5 erate 0.5 0.5\n  \n  \n  The following commands will not work:\n  fix f5 all npt/uef temp 0.7 0.7 0.5 x 1 1 5 z 1 1 5 erate -0.5 -0.5\n  fix f6 all npt/uef temp 0.7 0.7 0.5 x 1 1 5 z 2 2 5 erate 0.5 0.5\n  \n  \n  \n  These fix computes a temperature and pressure each timestep.  To do\n  this, it creates its own computes of style “temp/uef” and\n  “pressure/uef”, as if one of these two sets of commands had been\n  issued:\n  compute fix-ID_temp group-ID temp/uef\n  compute fix-ID_press group-ID pressure/uef fix-ID_temp\n  \n  compute fix-ID_temp all temp/uef\n  compute fix-ID_press all pressure/uef fix-ID_temp\n  \n  \n  See the compute temp/uef and compute pressure/uef commands for details.  Note\n  that the IDs of the new computes are the fix-ID + underscore + “temp”\n  or fix_ID + underscore + “press”.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  The fix writes the state of all the thermostat and barostat variables,\n  as well as the cumulative strain applied, to binary restart files.  See the read_restart command\n  for info on how to re-specify a fix in an input script that reads a\n  restart file, so that the operation of the fix continues in an\n  uninterrupted fashion.\n  \n  Note\n  It is not necessary to set the strain keyword when resuming a\n  run from a restart file. Only for resuming from data files, which do\n  not contain the cumulative applied strain, will this keyword be\n  necessary.\n  \n  This fix can be used with the fix_modify temp and\n  press options. The temperature and pressure computes used must be of\n  type temp/uef and pressure/uef.\n  This fix computes the same global scalar and vector quantities as fix npt.\n  The fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID style_name erate edot_x edot_y temp Tstart Tstop Tdamp keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  style_name = nvt/uef or npt/uef\n  Tstart, Tstop, and Tdamp are documented in the fix npt command\n  edot_x and edot_y are the strain rates in the x and y directions (1/(time units))\n  one or more keyword/value pairs may be appended\n  keyword = ext or strain or iso or x or y or z or tchain or pchain or tloop or ploop or mtk\n    ext value = x or y or z or xy or yz or xz = external dimensions\n      sets the external dimensions used to calculate the scalar pressure\n    strain values = e_x e_y = initial strain\n      usually not needed, but may be needed to resume a run with a data file.\n    iso, x, y, z, tchain, pchain, tloop, ploop, mtk keywords\n      documented by the fix npt command\n  \n  \n  ",
    "examples": "fix uniax_nvt all nvt/uef temp 400 400 100 erate 0.00001 -0.000005\n  fix biax_nvt all nvt/uef temp 400 400 100 erate 0.000005 0.000005\n  fix uniax_npt all npt/uef temp 400 400 300 iso 1 1 3000 erate 0.00001 -0.000005 ext yz\n  fix biax_npt all npt/uef temp 400 400 100 erate -0.00001 0.000005 x 1 1 3000\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-UEF package. It is only enabled if LAMMPS\n  was built with that package. See the Build package doc page for more info.\n  Due to requirements of the boundary conditions, when the strain\n  keyword is set to zero (or unset), the initial simulation box must be\n  cubic and have style triclinic. If the box is initially of type ortho,\n  use change_box before invoking the fix.\n  \n  Note\n  When resuming from restart files, you may need to use box tilt large since lammps has internal criteria from lattice\n  reduction that are not the same as the criteria in the numerical\n  lattice reduction algorithm.\n  \n  "
},
{
    "command": "fix nph/asphere",
    "description": "Perform constant NPH integration to update position, velocity,\n  orientation, and angular velocity each timestep for aspherical or\n  ellipsoidal particles in the group using a Nose/Hoover pressure\n  barostat.  P is pressure; H is enthalpy.  This creates a system\n  trajectory consistent with the isenthalpic ensemble.\n  This fix differs from the fix nph command, which assumes\n  point particles and only updates their position and velocity.\n  Additional parameters affecting the barostat are specified by keywords\n  and values documented with the fix nph command.  See,\n  for example, discussion of the aniso, and dilate keywords.\n  The particles in the fix group are the only ones whose velocities and\n  positions are updated by the velocity/position update portion of the\n  NPH integration.\n  Regardless of what particles are in the fix group, a global pressure is\n  computed for all particles.  Similarly, when the size of the simulation\n  box is changed, all particles are re-scaled to new positions, unless the\n  keyword dilate is specified with a value of partial, in which case\n  only the particles in the fix group are re-scaled.  The latter can be\n  useful for leaving the coordinates of particles in a solid substrate\n  unchanged and controlling the pressure of a surrounding fluid.\n  \n  This fix computes a temperature and pressure each timestep.  To do\n  this, the fix creates its own computes of style “temp/asphere” and\n  “pressure”, as if these commands had been issued:\n  compute fix-ID_temp all temp/asphere\n  compute fix-ID_press all pressure fix-ID_temp\n  \n  \n  See the compute temp/asphere and compute pressure commands for details.  Note that the\n  IDs of the new computes are the fix-ID + underscore + “temp” or fix_ID\n  + underscore + “press”, and the group for the new computes is “all”\n  since pressure is computed for the entire system.\n  Note that these are NOT the computes used by thermodynamic output (see\n  the thermo_style command) with ID = thermo_temp\n  and thermo_press.  This means you can change the attributes of this\n  fix’s temperature or pressure via the\n  compute_modify command or print this temperature\n  or pressure during thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\n  It also means that changing attributes of thermo_temp or\n  thermo_press will have no effect on this fix.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  This fix writes the state of the Nose/Hoover barostat to binary restart files.  See the read_restart\n  command for info on how to re-specify a fix in an input script that\n  reads a restart file, so that the operation of the fix continues in an\n  uninterrupted fashion.\n  The fix_modify temp and press options are\n  supported by this fix.  You can use them to assign a\n  compute you have defined to this fix which will be used\n  in its thermostatting or barostatting procedure.  If you do this, note\n  that the kinetic energy derived from the compute temperature should be\n  consistent with the virial term computed using all atoms for the\n  pressure.  LAMMPS will warn you if you choose to compute temperature\n  on a subset of atoms.\n  The fix_modify energy option is supported by this\n  fix to add the energy change induced by Nose/Hoover barostatting to\n  the system’s potential energy as part of thermodynamic output.\n  This fix computes the same global scalar and global vector of\n  quantities as does the fix nph command.\n  This fix can ramp its target pressure over multiple runs, using the\n  start and stop keywords of the run command.  See the\n  run command for details of how to do this.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID nph/asphere args keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  nph/asphere = style name of this fix command\n  additional barostat related keyword/value pairs from the fix nph command can be appended\n  \n  ",
    "examples": "fix 1 all nph/asphere iso 0.0 0.0 1000.0\n  fix 2 all nph/asphere x 5.0 5.0 1000.0\n  fix 2 all nph/asphere x 5.0 5.0 1000.0 drag 0.2\n  fix 2 water nph/asphere aniso 0.0 0.0 1000.0 dilate partial\n  \n  \n  ",
    "restrictions": "This fix is part of the ASPHERE package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  This fix requires that atoms store torque and angular momentum and a\n  quaternion as defined by the atom_style ellipsoid\n  command.\n  All particles in the group must be finite-size.  They cannot be point\n  particles, but they can be aspherical or spherical as defined by their\n  shape attribute.\n  "
},
{
    "command": "fix nph/body",
    "description": "Perform constant NPH integration to update position, velocity,\n  orientation, and angular velocity each timestep for body\n  particles in the group using a Nose/Hoover pressure\n  barostat.  P is pressure; H is enthalpy.  This creates a system\n  trajectory consistent with the isenthalpic ensemble.\n  This fix differs from the fix nph command, which assumes\n  point particles and only updates their position and velocity.\n  Additional parameters affecting the barostat are specified by keywords\n  and values documented with the fix nph command.  See,\n  for example, discussion of the aniso, and dilate keywords.\n  The particles in the fix group are the only ones whose velocities and\n  positions are updated by the velocity/position update portion of the\n  NPH integration.\n  Regardless of what particles are in the fix group, a global pressure is\n  computed for all particles.  Similarly, when the size of the simulation\n  box is changed, all particles are re-scaled to new positions, unless the\n  keyword dilate is specified with a value of partial, in which case\n  only the particles in the fix group are re-scaled.  The latter can be\n  useful for leaving the coordinates of particles in a solid substrate\n  unchanged and controlling the pressure of a surrounding fluid.\n  \n  This fix computes a temperature and pressure each timestep.  To do\n  this, the fix creates its own computes of style “temp/body” and\n  “pressure”, as if these commands had been issued:\n  compute fix-ID_temp all temp/body\n  compute fix-ID_press all pressure fix-ID_temp\n  \n  \n  See the compute temp/body and compute pressure commands for details.  Note that the\n  IDs of the new computes are the fix-ID + underscore + “temp” or fix_ID\n  + underscore + “press”, and the group for the new computes is “all”\n  since pressure is computed for the entire system.\n  Note that these are NOT the computes used by thermodynamic output (see\n  the thermo_style command) with ID = thermo_temp\n  and thermo_press.  This means you can change the attributes of this\n  fix’s temperature or pressure via the\n  compute_modify command or print this temperature\n  or pressure during thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\n  It also means that changing attributes of thermo_temp or\n  thermo_press will have no effect on this fix.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  This fix writes the state of the Nose/Hoover barostat to binary restart files.  See the read_restart\n  command for info on how to re-specify a fix in an input script that\n  reads a restart file, so that the operation of the fix continues in an\n  uninterrupted fashion.\n  The fix_modify temp and press options are\n  supported by this fix.  You can use them to assign a\n  compute you have defined to this fix which will be used\n  in its thermostatting or barostatting procedure.  If you do this, note\n  that the kinetic energy derived from the compute temperature should be\n  consistent with the virial term computed using all atoms for the\n  pressure.  LAMMPS will warn you if you choose to compute temperature\n  on a subset of atoms.\n  The fix_modify energy option is supported by this\n  fix to add the energy change induced by Nose/Hoover barostatting to\n  the system’s potential energy as part of thermodynamic output.\n  This fix computes the same global scalar and global vector of\n  quantities as does the fix nph command.\n  This fix can ramp its target pressure over multiple runs, using the\n  start and stop keywords of the run command.  See the\n  run command for details of how to do this.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID nph/body args keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  nph/body = style name of this fix command\n  additional barostat related keyword/value pairs from the fix nph command can be appended\n  \n  ",
    "examples": "fix 1 all nph/body iso 0.0 0.0 1000.0\n  fix 2 all nph/body x 5.0 5.0 1000.0\n  fix 2 all nph/body x 5.0 5.0 1000.0 drag 0.2\n  fix 2 water nph/body aniso 0.0 0.0 1000.0 dilate partial\n  \n  \n  ",
    "restrictions": "This fix is part of the BODY package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  This fix requires that atoms store torque and angular momentum and a\n  quaternion as defined by the atom_style body\n  command.\n  "
},
{
    "command": "fix nph/sphere",
    "description": "Perform constant NPH integration to update position, velocity, and\n  angular velocity each timestep for finite-size spherical particles in\n  the group using a Nose/Hoover pressure barostat.  P is pressure; H is\n  enthalpy.  This creates a system trajectory consistent with the\n  isenthalpic ensemble.\n  This fix differs from the fix nph command, which assumes\n  point particles and only updates their position and velocity.\n  If the disc keyword is used, then each particle is treated as a 2d\n  disc (circle) instead of as a sphere.  This is only possible for 2d\n  simulations, as defined by the dimension keyword.\n  The only difference between discs and spheres in this context is their\n  moment of inertia, as used in the time integration.\n  Additional parameters affecting the barostat are specified by keywords\n  and values documented with the fix nph command.  See,\n  for example, discussion of the aniso, and dilate keywords.\n  The particles in the fix group are the only ones whose velocities and\n  positions are updated by the velocity/position update portion of the\n  NPH integration.\n  Regardless of what particles are in the fix group, a global pressure is\n  computed for all particles.  Similarly, when the size of the simulation\n  box is changed, all particles are re-scaled to new positions, unless the\n  keyword dilate is specified with a value of partial, in which case\n  only the particles in the fix group are re-scaled.  The latter can be\n  useful for leaving the coordinates of particles in a solid substrate\n  unchanged and controlling the pressure of a surrounding fluid.\n  \n  This fix computes a temperature and pressure each timestep.  To do\n  this, the fix creates its own computes of style “temp/sphere” and\n  “pressure”, as if these commands had been issued:\n  compute fix-ID_temp all temp/sphere\n  compute fix-ID_press all pressure fix-ID_temp\n  \n  \n  See the compute temp/sphere and compute pressure commands for details.  Note that the\n  IDs of the new computes are the fix-ID + underscore + “temp” or fix_ID\n  + underscore + “press”, and the group for the new computes is “all”\n  since pressure is computed for the entire system.\n  Note that these are NOT the computes used by thermodynamic output (see\n  the thermo_style command) with ID = thermo_temp\n  and thermo_press.  This means you can change the attributes of this\n  fix’s temperature or pressure via the\n  compute_modify command or print this temperature\n  or pressure during thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\n  It also means that changing attributes of thermo_temp or\n  thermo_press will have no effect on this fix.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  This fix writes the state of the Nose/Hoover barostat to binary restart files.  See the read_restart\n  command for info on how to re-specify a fix in an input script that\n  reads a restart file, so that the operation of the fix continues in an\n  uninterrupted fashion.\n  The fix_modify temp and press options are\n  supported by this fix.  You can use them to assign a\n  compute you have defined to this fix which will be used\n  in its thermostatting or barostatting procedure.  If you do this, note\n  that the kinetic energy derived from the compute temperature should be\n  consistent with the virial term computed using all atoms for the\n  pressure.  LAMMPS will warn you if you choose to compute temperature\n  on a subset of atoms.\n  The fix_modify energy option is supported by this\n  fix to add the energy change induced by Nose/Hoover barostatting to\n  the system’s potential energy as part of thermodynamic output.\n  This fix computes the same global scalar and global vector of\n  quantities as does the fix nph command.\n  This fix can ramp its target pressure over multiple runs, using the\n  start and stop keywords of the run command.  See the\n  run command for details of how to do this.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID nph/sphere args keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  nph/sphere = style name of this fix command\n  keyword = disc\n  disc value = none = treat particles as 2d discs, not spheres\n  \n  additional barostat related keyword/value pairs from the fix nph command can be appended\n  \n  ",
    "examples": "fix 1 all nph/sphere iso 0.0 0.0 1000.0\n  fix 2 all nph/sphere x 5.0 5.0 1000.0\n  fix 2 all nph/sphere x 5.0 5.0 1000.0 disc\n  fix 2 all nph/sphere x 5.0 5.0 1000.0 drag 0.2\n  fix 2 water nph/sphere aniso 0.0 0.0 1000.0 dilate partial\n  \n  \n  ",
    "restrictions": "This fix requires that atoms store torque and angular velocity (omega)\n  and a radius as defined by the atom_style sphere\n  command.\n  All particles in the group must be finite-size spheres.  They cannot\n  be point particles.\n  Use of the disc keyword is only allowed for 2d simulations, as\n  defined by the dimension keyword.\n  "
},
{
    "command": "fix nphug",
    "description": "This command is a variant of the Nose-Hoover\n  fix npt fix style.\n  It performs time integration of the Hugoniostat equations\n  of motion developed by Ravelo et al. (Ravelo).\n  These equations compress the system to a state with average\n  axial stress or pressure equal to the specified target value\n  and that satisfies the Rankine-Hugoniot (RH)\n  jump conditions for steady shocks.\n  The compression can be performed\n  either\n  hydrostatically (using keyword iso, aniso, or tri) or uniaxially\n  (using keywords x, y, or z).  In the hydrostatic case,\n  the cell dimensions change dynamically so that the average axial stress\n  in all three directions converges towards the specified target value.\n  In the uniaxial case, the chosen cell dimension changes dynamically\n  so that the average\n  axial stress in that direction converges towards the target value. The\n  other two cell dimensions are kept fixed (zero lateral strain).\n  This leads to the following additional restrictions on the keywords:\n  \n  One and only one of the following keywords should be used: iso, aniso, tri, x, y, z\n  The specified initial and final target pressures must be the same.\n  The keywords xy, xz, yz may not be used.\n  The only admissible value for the couple keyword is xyz, which has the same effect as keyword iso\n  The temp keyword must be used to specify the time constant for kinetic energy relaxation, but initial and final target temperature values are ignored.\n  \n  Essentially, a Hugoniostat simulation is an NPT simulation in which the\n  user-specified target temperature is replaced with a time-dependent\n  target temperature Tt obtained from the following equation:\n  \n  \\[T_t - T = \\frac{\\left(\\frac{1}{2}\\left(P + P_0\\right)\\left(V_0 - V\\right) + E_0 - E\\right)}{N_{dof} k_B } = \\Delta\\]\n  where T and \\(T_t\\) are the instantaneous and target temperatures,\n  P and \\(P_0\\) are the instantaneous and reference pressures or axial stresses,\n  depending on whether hydrostatic or uniaxial compression is being\n  performed, V and \\(V_0\\) are the instantaneous and reference volumes,\n  E and \\(E_0\\) are the instantaneous and reference internal energy (potential\n  plus kinetic), \\(N_{dof}\\) is the number of degrees of freedom used in the\n  definition of temperature, and \\(k_B\\) is the Boltzmann constant. \\(\\Delta\\) is the\n  negative deviation of the instantaneous temperature from the target temperature.\n  When the system reaches a stable equilibrium, the value of \\(\\Delta\\) should\n  fluctuate about zero.\n  The values of \\(E_0\\), \\(V_0\\), and \\(P_0\\) are the instantaneous values at the start of\n  the simulation. These can be overridden using the fix_modify keywords e0,\n  v0, and p0 described below.\n  \n  \n  Note\n  Unlike the fix temp/berendsen command\n  which performs thermostatting but NO time integration, this fix\n  performs thermostatting/barostatting AND time integration.  Thus you\n  should not use any other time integration fix, such as fix nve on atoms to which this fix is applied.  Likewise,\n  this fix should not be used on atoms that have their temperature\n  controlled by another fix - e.g. by fix langevin or fix temp/rescale commands.\n  \n  \n  This fix computes a temperature and pressure at each timestep.  To do\n  this, the fix creates its own computes of style “temp” and “pressure”,\n  as if one of these two sets of commands had been issued:\n  compute fix-ID_temp group-ID temp\n  compute fix-ID_press group-ID pressure fix-ID_temp\n  \n  compute fix-ID_temp all temp\n  compute fix-ID_press all pressure fix-ID_temp\n  \n  \n  See the compute temp and compute pressure commands for details.  Note that the\n  IDs of the new computes are the fix-ID + underscore + “temp” or fix_ID\n  + underscore + “press”.  The group for\n  the new computes is “all” since pressure is computed for the entire\n  system.\n  Note that these are NOT the computes used by thermodynamic output (see\n  the thermo_style command) with ID = thermo_temp\n  and thermo_press.  This means you can change the attributes of this\n  fix’s temperature or pressure via the\n  compute_modify command or print this temperature\n  or pressure during thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\n  It also means that changing attributes of thermo_temp or\n  thermo_press will have no effect on this fix.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  This fix writes the values of \\(E_0\\), \\(V_0\\), and \\(P_0\\),\n  as well as the state of all the thermostat and barostat variables to\n  binary restart files.  See the read_restart command for info on how to re-specify a fix in an input\n  script that reads a restart file, so that the operation of the fix\n  continues in an uninterrupted fashion.\n  The fix_modify e0, v0 and p0 keywords can be\n  used to define the values of \\(E_0\\), \\(V_0\\), and\n  \\(P_0\\). Note the the values for e0 and v0 are extensive, and so\n  must correspond to the total energy and volume of the entire system, not\n  energy and volume per atom. If any of these quantities are not\n  specified, then the instantaneous value in the system at the start of\n  the simulation is used.\n  The fix_modify temp and press options are\n  supported by these fixes.  You can use them to assign a\n  compute you have defined to this fix which will be used\n  in its thermostatting or barostatting procedure, as described above.\n  If you do this, note that the kinetic energy derived from the compute\n  temperature should be consistent with the virial term computed using\n  all atoms for the pressure.  LAMMPS will warn you if you choose to\n  compute temperature on a subset of atoms.\n  The fix_modify energy option is supported by these\n  fixes to add the energy change induced by Nose/Hoover thermostatting\n  and barostatting to the system’s potential energy as part of\n  thermodynamic output. Either way, this energy is *not*\n  included in the definition of internal energy E when calculating the value\n  of Delta in the above equation.\n  These fixes compute a global scalar and a global vector of quantities,\n  which can be accessed by various output commands.\n  The scalar value calculated by these fixes is “extensive”; the vector\n  values are “intensive”.\n  The scalar is the cumulative energy change due to the fix.\n  The vector stores three quantities unique to this fix (\\(\\Delta\\), Us, and up),\n  followed by all the internal Nose/Hoover thermostat and barostat\n  variables defined for fix npt. Delta is the deviation\n  of the temperature from the target temperature, given by the above equation.\n  Us and up are the shock and particle velocity corresponding to a steady\n  shock calculated from the RH conditions. They have units of distance/time.\n  ",
    "syntax": "fix ID group-ID nphug keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  one or more keyword value pairs may be appended\n  keyword = temp or iso or aniso or tri or x or y or z or couple or tchain or pchain or mtk or tloop or ploop or nreset or drag or dilate or scaleyz or scalexz or scalexy\n    temp values = Value1 Value2 Tdamp\n      Value1, Value2 = Nose-Hoover target temperatures, ignored by Hugoniostat\n      Tdamp = temperature damping parameter (time units)\n    iso or aniso or tri values = Pstart Pstop Pdamp\n      Pstart,Pstop = scalar external pressures, must be equal (pressure units)\n      Pdamp = pressure damping parameter (time units)\n    x or y or z or xy or yz or xz values = Pstart Pstop Pdamp\n      Pstart,Pstop = external stress tensor components, must be equal (pressure units)\n      Pdamp = stress damping parameter (time units)\n    couple = none or xyz or xy or yz or xz\n    tchain value = length of thermostat chain (1 = single thermostat)\n    pchain values = length of thermostat chain on barostat (0 = no thermostat)\n    mtk value = yes or no = add in MTK adjustment term or not\n    tloop value = number of sub-cycles to perform on thermostat\n    ploop value = number of sub-cycles to perform on barostat thermostat\n    nreset value = reset reference cell every this many timesteps\n    drag value = drag factor added to barostat/thermostat (0.0 = no drag)\n    dilate value = all or partial\n    scaleyz value = yes or no = scale yz with lz\n    scalexz value = yes or no = scale xz with lz\n    scalexy value = yes or no = scale xy with ly\n  \n  \n  ",
    "examples": "fix myhug all nphug temp 1.0 1.0 10.0 z 40.0 40.0 70.0\n  fix myhug all nphug temp 1.0 1.0 10.0 iso 40.0 40.0 70.0 drag 200.0 tchain 1 pchain 0\n  \n  \n  ",
    "restrictions": "This fix style is part of the SHOCK package.  It is only enabled if\n  LAMMPS was built with that package. See the Build package doc page for more info.\n  All the usual restrictions for fix npt apply,\n  plus the additional ones mentioned above.\n  "
},
{
    "command": "fix npt/asphere",
    "description": "Perform constant NPT integration to update position, velocity,\n  orientation, and angular velocity each timestep for aspherical or\n  ellipsoidal particles in the group using a Nose/Hoover temperature\n  thermostat and Nose/Hoover pressure barostat.  P is pressure; T is\n  temperature.  This creates a system trajectory consistent with the\n  isothermal-isobaric ensemble.\n  This fix differs from the fix npt command, which\n  assumes point particles and only updates their position and velocity.\n  The thermostat is applied to both the translational and rotational\n  degrees of freedom for the aspherical particles, assuming a compute is\n  used which calculates a temperature that includes the rotational\n  degrees of freedom (see below).  The translational degrees of freedom\n  can also have a bias velocity removed from them before thermostatting\n  takes place; see the description below.\n  Additional parameters affecting the thermostat and barostat are\n  specified by keywords and values documented with the fix npt command.  See, for example, discussion of the temp,\n  iso, aniso, and dilate keywords.\n  The particles in the fix group are the only ones whose velocities and\n  positions are updated by the velocity/position update portion of the\n  NPT integration.\n  Regardless of what particles are in the fix group, a global pressure is\n  computed for all particles.  Similarly, when the size of the simulation\n  box is changed, all particles are re-scaled to new positions, unless the\n  keyword dilate is specified with a value of partial, in which case\n  only the particles in the fix group are re-scaled.  The latter can be\n  useful for leaving the coordinates of particles in a solid substrate\n  unchanged and controlling the pressure of a surrounding fluid.\n  \n  This fix computes a temperature and pressure each timestep.  To do\n  this, the fix creates its own computes of style “temp/asphere” and\n  “pressure”, as if these commands had been issued:\n  compute fix-ID_temp all temp/asphere\n  compute fix-ID_press all pressure fix-ID_temp\n  \n  \n  See the compute temp/asphere and compute pressure commands for details.  Note that the\n  IDs of the new computes are the fix-ID + underscore + “temp” or fix_ID\n  + underscore + “press”, and the group for the new computes is “all”\n  since pressure is computed for the entire system.\n  Note that these are NOT the computes used by thermodynamic output (see\n  the thermo_style command) with ID = thermo_temp\n  and thermo_press.  This means you can change the attributes of this\n  fix’s temperature or pressure via the\n  compute_modify command or print this temperature\n  or pressure during thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\n  It also means that changing attributes of thermo_temp or\n  thermo_press will have no effect on this fix.\n  Like other fixes that perform thermostatting, this fix can be used\n  with compute commands that calculate a temperature\n  after removing a “bias” from the atom velocities.  E.g. removing the\n  center-of-mass velocity from a group of atoms or only calculating\n  temperature on the x-component of velocity or only calculating\n  temperature for atoms in a geometric region.  This is not done by\n  default, but only if the fix_modify command is used\n  to assign a temperature compute to this fix that includes such a bias\n  term.  See the doc pages for individual compute commands to determine which ones include a bias.  In\n  this case, the thermostat works in the following manner: the current\n  temperature is calculated taking the bias into account, bias is\n  removed from each atom, thermostatting is performed on the remaining\n  thermal degrees of freedom, and the bias is added back in.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  This fix writes the state of the Nose/Hoover thermostat and barostat\n  to binary restart files.  See the\n  read_restart command for info on how to re-specify\n  a fix in an input script that reads a restart file, so that the\n  operation of the fix continues in an uninterrupted fashion.\n  The fix_modify temp and press options are\n  supported by this fix.  You can use them to assign a\n  compute you have defined to this fix which will be used\n  in its thermostatting or barostatting procedure.  If you do this, note\n  that the kinetic energy derived from the compute temperature should be\n  consistent with the virial term computed using all atoms for the\n  pressure.  LAMMPS will warn you if you choose to compute temperature\n  on a subset of atoms.\n  The fix_modify energy option is supported by this\n  fix to add the energy change induced by Nose/Hoover thermostatting and\n  barostatting to the system’s potential energy as part of\n  thermodynamic output.\n  This fix computes the same global scalar and global vector of\n  quantities as does the fix npt command.\n  This fix can ramp its target temperature and pressure over multiple\n  runs, using the start and stop keywords of the run\n  command.  See the run command for details of how to do\n  this.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID npt/asphere keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  npt/asphere = style name of this fix command\n  additional thermostat and barostat related keyword/value pairs from the fix npt command can be appended\n  \n  ",
    "examples": "fix 1 all npt/asphere temp 300.0 300.0 100.0 iso 0.0 0.0 1000.0\n  fix 2 all npt/asphere temp 300.0 300.0 100.0 x 5.0 5.0 1000.0\n  fix 2 all npt/asphere temp 300.0 300.0 100.0 x 5.0 5.0 1000.0 drag 0.2\n  fix 2 water npt/asphere temp 300.0 300.0 100.0 aniso 0.0 0.0 1000.0 dilate partial\n  \n  \n  ",
    "restrictions": "This fix is part of the ASPHERE package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  This fix requires that atoms store torque and angular momentum and a\n  quaternion as defined by the atom_style ellipsoid\n  command.\n  All particles in the group must be finite-size.  They cannot be point\n  particles, but they can be aspherical or spherical as defined by their\n  shape attribute.\n  "
},
{
    "command": "fix npt/body",
    "description": "Perform constant NPT integration to update position, velocity,\n  orientation, and angular velocity each timestep for body\n  particles in the group using a Nose/Hoover temperature\n  thermostat and Nose/Hoover pressure barostat.  P is pressure; T is\n  temperature.  This creates a system trajectory consistent with the\n  isothermal-isobaric ensemble.\n  This fix differs from the fix npt command, which\n  assumes point particles and only updates their position and velocity.\n  The thermostat is applied to both the translational and rotational\n  degrees of freedom for the body particles, assuming a compute is\n  used which calculates a temperature that includes the rotational\n  degrees of freedom (see below).  The translational degrees of freedom\n  can also have a bias velocity removed from them before thermostatting\n  takes place; see the description below.\n  Additional parameters affecting the thermostat and barostat are\n  specified by keywords and values documented with the fix npt command.  See, for example, discussion of the temp,\n  iso, aniso, and dilate keywords.\n  The particles in the fix group are the only ones whose velocities and\n  positions are updated by the velocity/position update portion of the\n  NPT integration.\n  Regardless of what particles are in the fix group, a global pressure is\n  computed for all particles.  Similarly, when the size of the simulation\n  box is changed, all particles are re-scaled to new positions, unless the\n  keyword dilate is specified with a value of partial, in which case\n  only the particles in the fix group are re-scaled.  The latter can be\n  useful for leaving the coordinates of particles in a solid substrate\n  unchanged and controlling the pressure of a surrounding fluid.\n  \n  This fix computes a temperature and pressure each timestep.  To do\n  this, the fix creates its own computes of style “temp/body” and\n  “pressure”, as if these commands had been issued:\n  compute fix-ID_temp all temp/body\n  compute fix-ID_press all pressure fix-ID_temp\n  \n  \n  See the compute temp/body and compute pressure commands for details.  Note that the\n  IDs of the new computes are the fix-ID + underscore + “temp” or fix_ID\n  + underscore + “press”, and the group for the new computes is “all”\n  since pressure is computed for the entire system.\n  Note that these are NOT the computes used by thermodynamic output (see\n  the thermo_style command) with ID = thermo_temp\n  and thermo_press.  This means you can change the attributes of this\n  fix’s temperature or pressure via the\n  compute_modify command or print this temperature\n  or pressure during thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\n  It also means that changing attributes of thermo_temp or\n  thermo_press will have no effect on this fix.\n  Like other fixes that perform thermostatting, this fix can be used\n  with compute commands that calculate a temperature\n  after removing a “bias” from the atom velocities.  E.g. removing the\n  center-of-mass velocity from a group of atoms or only calculating\n  temperature on the x-component of velocity or only calculating\n  temperature for atoms in a geometric region.  This is not done by\n  default, but only if the fix_modify command is used\n  to assign a temperature compute to this fix that includes such a bias\n  term.  See the doc pages for individual compute commands to determine which ones include a bias.  In\n  this case, the thermostat works in the following manner: the current\n  temperature is calculated taking the bias into account, bias is\n  removed from each atom, thermostatting is performed on the remaining\n  thermal degrees of freedom, and the bias is added back in.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  This fix writes the state of the Nose/Hoover thermostat and barostat\n  to binary restart files.  See the\n  read_restart command for info on how to re-specify\n  a fix in an input script that reads a restart file, so that the\n  operation of the fix continues in an uninterrupted fashion.\n  The fix_modify temp and press options are\n  supported by this fix.  You can use them to assign a\n  compute you have defined to this fix which will be used\n  in its thermostatting or barostatting procedure.  If you do this, note\n  that the kinetic energy derived from the compute temperature should be\n  consistent with the virial term computed using all atoms for the\n  pressure.  LAMMPS will warn you if you choose to compute temperature\n  on a subset of atoms.\n  The fix_modify energy option is supported by this\n  fix to add the energy change induced by Nose/Hoover thermostatting and\n  barostatting to the system’s potential energy as part of\n  thermodynamic output.\n  This fix computes the same global scalar and global vector of\n  quantities as does the fix npt command.\n  This fix can ramp its target temperature and pressure over multiple\n  runs, using the start and stop keywords of the run\n  command.  See the run command for details of how to do\n  this.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID npt/body keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  npt/body = style name of this fix command\n  additional thermostat and barostat related keyword/value pairs from the fix npt command can be appended\n  \n  ",
    "examples": "fix 1 all npt/body temp 300.0 300.0 100.0 iso 0.0 0.0 1000.0\n  fix 2 all npt/body temp 300.0 300.0 100.0 x 5.0 5.0 1000.0\n  fix 2 all npt/body temp 300.0 300.0 100.0 x 5.0 5.0 1000.0 drag 0.2\n  fix 2 water npt/body temp 300.0 300.0 100.0 aniso 0.0 0.0 1000.0 dilate partial\n  \n  \n  ",
    "restrictions": "This fix is part of the BODY package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  This fix requires that atoms store torque and angular momentum and a\n  quaternion as defined by the atom_style body\n  command.\n  "
},
{
    "command": "fix npt/cauchy",
    "description": "This command performs time integration on Nose-Hoover style\n  non-Hamiltonian equations of motion which are designed to generate\n  positions and velocities sampled from the isothermal-isobaric (npt)\n  ensembles.  This updates the position and velocity for atoms in the\n  group each timestep and the box dimensions.\n  The thermostatting and barostatting is achieved by adding some dynamic\n  variables which are coupled to the particle velocities\n  (thermostatting) and simulation domain dimensions (barostatting).  In\n  addition to basic thermostatting and barostatting, this fix can\n  also create a chain of thermostats coupled to the particle thermostat,\n  and another chain of thermostats coupled to the barostat\n  variables. The barostat can be coupled to the overall box volume, or\n  to individual dimensions, including the xy, xz and yz tilt\n  dimensions. The external pressure of the barostat can be specified as\n  either a scalar pressure (isobaric ensemble) or as components of a\n  symmetric stress tensor (constant stress ensemble).  When used\n  correctly, the time-averaged temperature and stress tensor of the\n  particles will match the target values specified by Tstart/Tstop and\n  Pstart/Pstop.\n  The equations of motion used are those of Shinoda et al in\n  (Shinoda), which combine the hydrostatic equations of\n  Martyna, Tobias and Klein in (Martyna) with the strain\n  energy proposed by Parrinello and Rahman in\n  (Parrinello).  The time integration schemes closely\n  follow the time-reversible measure-preserving Verlet and rRESPA\n  integrators derived by Tuckerman et al in (Tuckerman).\n  \n  The thermostat parameters are specified using the temp keyword.\n  Other thermostat-related keywords are tchain, tloop and drag,\n  which are discussed below.\n  The thermostat is applied to only the translational degrees of freedom\n  for the particles.  The translational degrees of freedom can also have\n  a bias velocity removed before thermostatting takes place; see the\n  description below.  The desired temperature at each timestep is a\n  ramped value during the run from Tstart to Tstop.  The Tdamp\n  parameter is specified in time units and determines how rapidly the\n  temperature is relaxed.  For example, a value of 10.0 means to relax\n  the temperature in a timespan of (roughly) 10 time units (e.g. tau or\n  fmsec or psec - see the units command).  The atoms in the\n  fix group are the only ones whose velocities and positions are updated\n  by the velocity/position update portion of the integration.\n  \n  Note\n  A Nose-Hoover thermostat will not work well for arbitrary values\n  of Tdamp.  If Tdamp is too small, the temperature can fluctuate\n  wildly; if it is too large, the temperature will take a very long time\n  to equilibrate.  A good choice for many models is a Tdamp of around\n  100 timesteps.  Note that this is NOT the same as 100 time units for\n  most units settings.\n  \n  \n  The barostat parameters are specified using one or more of the iso,\n  aniso, tri, x, y, z, xy, xz, yz, and couple keywords.\n  These keywords give you the ability to specify all 6 components of an\n  external stress tensor, and to couple various of these components\n  together so that the dimensions they represent are varied together\n  during a constant-pressure simulation.\n  Other barostat-related keywords are pchain, mtk, ploop,\n  nreset, drag, and dilate, which are discussed below.\n  Orthogonal simulation boxes have 3 adjustable dimensions (x,y,z).\n  Triclinic (non-orthogonal) simulation boxes have 6 adjustable\n  dimensions (x,y,z,xy,xz,yz).  The create_box, read data, and read_restart commands\n  specify whether the simulation box is orthogonal or non-orthogonal\n  (triclinic) and explain the meaning of the xy,xz,yz tilt factors.\n  The target pressures for each of the 6 components of the stress tensor\n  can be specified independently via the x, y, z, xy, xz, yz\n  keywords, which correspond to the 6 simulation box dimensions.  For\n  each component, the external pressure or tensor component at each\n  timestep is a ramped value during the run from Pstart to Pstop.\n  If a target pressure is specified for a component, then the\n  corresponding box dimension will change during a simulation.  For\n  example, if the y keyword is used, the y-box length will change.  If\n  the xy keyword is used, the xy tilt factor will change.  A box\n  dimension will not change if that component is not specified, although\n  you have the option to change that dimension via the fix deform command.\n  Note that in order to use the xy, xz, or yz keywords, the\n  simulation box must be triclinic, even if its initial tilt factors are\n  0.0.\n  For all barostat keywords, the Pdamp parameter operates like the\n  Tdamp parameter, determining the time scale on which pressure is\n  relaxed.  For example, a value of 10.0 means to relax the pressure in\n  a timespan of (roughly) 10 time units (e.g. tau or fmsec or psec - see\n  the units command).\n  \n  Note\n  A Nose-Hoover barostat will not work well for arbitrary values\n  of Pdamp.  If Pdamp is too small, the pressure and volume can\n  fluctuate wildly; if it is too large, the pressure will take a very\n  long time to equilibrate.  A good choice for many models is a Pdamp\n  of around 1000 timesteps.  However, note that Pdamp is specified in\n  time units, and that timesteps are NOT the same as time units for most\n  units settings.\n  \n  Regardless of what atoms are in the fix group (the only atoms which\n  are time integrated), a global pressure or stress tensor is computed\n  for all atoms.  Similarly, when the size of the simulation box is\n  changed, all atoms are re-scaled to new positions, unless the keyword\n  dilate is specified with a dilate-group-ID for a group that\n  represents a subset of the atoms.  This can be useful, for example, to\n  leave the coordinates of atoms in a solid substrate unchanged and\n  controlling the pressure of a surrounding fluid.  This option should\n  be used with care, since it can be unphysical to dilate some atoms and\n  not others, because it can introduce large, instantaneous\n  displacements between a pair of atoms (one dilated, one not) that are\n  far from the dilation origin.  Also note that for atoms not in the fix\n  group, a separate time integration fix like fix nve or\n  fix nvt can be used on them, independent of whether they\n  are dilated or not.\n  \n  The couple keyword allows two or three of the diagonal components of\n  the pressure tensor to be “coupled” together.  The value specified\n  with the keyword determines which are coupled.  For example, xz\n  means the Pxx and Pzz components of the stress tensor are coupled.\n  Xyz means all 3 diagonal components are coupled.  Coupling means two\n  things: the instantaneous stress will be computed as an average of the\n  corresponding diagonal components, and the coupled box dimensions will\n  be changed together in lockstep, meaning coupled dimensions will be\n  dilated or contracted by the same percentage every timestep.  The\n  Pstart, Pstop, Pdamp parameters for any coupled dimensions must\n  be identical.  Couple xyz can be used for a 2d simulation; the z\n  dimension is simply ignored.\n  \n  The iso, aniso, and tri keywords are simply shortcuts that are\n  equivalent to specifying several other keywords together.\n  The keyword iso means couple all 3 diagonal components together when\n  pressure is computed (hydrostatic pressure), and dilate/contract the\n  dimensions together.  Using “iso Pstart Pstop Pdamp” is the same as\n  specifying these 4 keywords:\n  x Pstart Pstop Pdamp\n  y Pstart Pstop Pdamp\n  z Pstart Pstop Pdamp\n  couple xyz\n  \n  \n  The keyword aniso means x, y, and z dimensions are controlled\n  independently using the Pxx, Pyy, and Pzz components of the\n  stress tensor as the driving forces, and the specified scalar external\n  pressure.  Using “aniso Pstart Pstop Pdamp” is the same as specifying\n  these 4 keywords:\n  x Pstart Pstop Pdamp\n  y Pstart Pstop Pdamp\n  z Pstart Pstop Pdamp\n  couple none\n  \n  \n  The keyword tri means x, y, z, xy, xz, and yz dimensions\n  are controlled independently using their individual stress components\n  as the driving forces, and the specified scalar pressure as the\n  external normal stress.  Using “tri Pstart Pstop Pdamp” is the same as\n  specifying these 7 keywords:\n  x Pstart Pstop Pdamp\n  y Pstart Pstop Pdamp\n  z Pstart Pstop Pdamp\n  xy 0.0 0.0 Pdamp\n  yz 0.0 0.0 Pdamp\n  xz 0.0 0.0 Pdamp\n  couple none\n  \n  \n  \n  In some cases (e.g. for solids) the pressure (volume) and/or\n  temperature of the system can oscillate undesirably when a Nose/Hoover\n  barostat and thermostat is applied.  The optional drag keyword will\n  damp these oscillations, although it alters the Nose/Hoover equations.\n  A value of 0.0 (no drag) leaves the Nose/Hoover formalism unchanged.\n  A non-zero value adds a drag term; the larger the value specified, the\n  greater the damping effect.  Performing a short run and monitoring the\n  pressure and temperature is the best way to determine if the drag term\n  is working.  Typically a value between 0.2 to 2.0 is sufficient to\n  damp oscillations after a few periods. Note that use of the drag\n  keyword will interfere with energy conservation and will also change\n  the distribution of positions and velocities so that they do not\n  correspond to the nominal NVT, NPT, or NPH ensembles.\n  An alternative way to control initial oscillations is to use chain\n  thermostats. The keyword tchain determines the number of thermostats\n  in the particle thermostat. A value of 1 corresponds to the original\n  Nose-Hoover thermostat. The keyword pchain specifies the number of\n  thermostats in the chain thermostatting the barostat degrees of\n  freedom. A value of 0 corresponds to no thermostatting of the\n  barostat variables.\n  The mtk keyword controls whether or not the correction terms due to\n  Martyna, Tuckerman, and Klein are included in the equations of motion\n  (Martyna).  Specifying no reproduces the original\n  Hoover barostat, whose volume probability distribution function\n  differs from the true NPT and NPH ensembles by a factor of 1/V.  Hence\n  using yes is more correct, but in many cases the difference is\n  negligible.\n  The keyword tloop can be used to improve the accuracy of integration\n  scheme at little extra cost.  The initial and final updates of the\n  thermostat variables are broken up into tloop sub-steps, each of\n  length dt/tloop. This corresponds to using a first-order\n  Suzuki-Yoshida scheme (Tuckerman).  The keyword ploop\n  does the same thing for the barostat thermostat.\n  The keyword nreset controls how often the reference dimensions used\n  to define the strain energy are reset.  If this keyword is not used,\n  or is given a value of zero, then the reference dimensions are set to\n  those of the initial simulation domain and are never changed. If the\n  simulation domain changes significantly during the simulation, then\n  the final average pressure tensor will differ significantly from the\n  specified values of the external stress tensor.  A value of nstep\n  means that every nstep timesteps, the reference dimensions are set\n  to those of the current simulation domain.\n  The scaleyz, scalexz, and scalexy keywords control whether or\n  not the corresponding tilt factors are scaled with the associated box\n  dimensions when barostatting triclinic periodic cells.  The default\n  values yes will turn on scaling, which corresponds to adjusting the\n  linear dimensions of the cell while preserving its shape.  Choosing\n  no ensures that the tilt factors are not scaled with the box\n  dimensions. See below for restrictions and default values in different\n  situations. In older versions of LAMMPS, scaling of tilt factors was\n  not performed. The old behavior can be recovered by setting all three\n  scale keywords to no.\n  The flip keyword allows the tilt factors for a triclinic box to\n  exceed half the distance of the parallel box length, as discussed\n  below.  If the flip value is set to yes, the bound is enforced by\n  flipping the box when it is exceeded.  If the flip value is set to\n  no, the tilt will continue to change without flipping.  Note that if\n  applied stress induces large deformations (e.g. in a liquid), this\n  means the box shape can tilt dramatically and LAMMPS will run less\n  efficiently, due to the large volume of communication needed to\n  acquire ghost atoms around a processor’s irregular-shaped sub-domain.\n  For extreme values of tilt, LAMMPS may also lose atoms and generate an\n  error.\n  The fixedpoint keyword specifies the fixed point for barostat volume\n  changes. By default, it is the center of the box.  Whatever point is\n  chosen will not move during the simulation.  For example, if the lower\n  periodic boundaries pass through (0,0,0), and this point is provided\n  to fixedpoint, then the lower periodic boundaries will remain at\n  (0,0,0), while the upper periodic boundaries will move twice as\n  far. In all cases, the particle trajectories are unaffected by the\n  chosen value, except for a time-dependent constant translation of\n  positions.\n  \n  \n  Note\n  Using a barostat coupled to tilt dimensions xy, xz, yz can\n  sometimes result in arbitrarily large values of the tilt dimensions,\n  i.e. a dramatically deformed simulation box.  LAMMPS allows the tilt\n  factors to grow a small amount beyond the normal limit of half the box\n  length (0.6 times the box length), and then performs a box “flip” to\n  an equivalent periodic cell.  See the discussion of the flip keyword\n  above, to allow this bound to be exceeded, if desired.\n  \n  The flip operation is described in more detail in the doc page for\n  fix deform.  Both the barostat dynamics and the atom\n  trajectories are unaffected by this operation.  However, if a tilt\n  factor is incremented by a large amount (1.5 times the box length) on\n  a single timestep, LAMMPS can not accommodate this event and will\n  terminate the simulation with an error. This error typically indicates\n  that there is something badly wrong with how the simulation was\n  constructed, such as specifying values of Pstart that are too far\n  from the current stress value, or specifying a timestep that is too\n  large. Triclinic barostatting should be used with care. This also is\n  true for other barostat styles, although they tend to be more\n  forgiving of insults. In particular, it is important to recognize that\n  equilibrium liquids can not support a shear stress and that\n  equilibrium solids can not support shear stresses that exceed the\n  yield stress.\n  One exception to this rule is if the 1st dimension in the tilt factor\n  (x for xy) is non-periodic.  In that case, the limits on the tilt\n  factor are not enforced, since flipping the box in that dimension does\n  not change the atom positions due to non-periodicity.  In this mode,\n  if you tilt the system to extreme angles, the simulation will simply\n  become inefficient due to the highly skewed simulation box.\n  \n  Note\n  Unlike the fix temp/berendsen command\n  which performs thermostatting but NO time integration, this fix\n  performs thermostatting/barostatting AND time integration.  Thus you\n  should not use any other time integration fix, such as fix nve on atoms to which this fix is applied.  Likewise,\n  fix npt/cauchy should not normally be used on atoms that also\n  have their temperature controlled by another fix - e.g. by fix langevin or fix temp/rescale\n  commands.\n  \n  See the Howto thermostat and Howto barostat doc pages for a discussion of different\n  ways to compute temperature and perform thermostatting and\n  barostatting.\n  \n  This fix compute a temperature and pressure each timestep.  To do\n  this, the fix creates its own computes of style “temp” and “pressure”,\n  as if one of these sets of commands had been issued:\n  compute fix-ID_temp all temp\n  compute fix-ID_press all pressure fix-ID_temp\n  \n  \n  The group for both the new temperature and pressure compute is “all”\n  since pressure is computed for the entire system.  See the compute temp and compute pressure\n  commands for details.  Note that the IDs of the new computes are the\n  fix-ID + underscore + “temp” or fix_ID + underscore + “press”.\n  Note that these are NOT the computes used by thermodynamic output (see\n  the thermo_style command) with ID = thermo_temp\n  and thermo_press.  This means you can change the attributes of these\n  fix’s temperature or pressure via the\n  compute_modify command.  Or you can print this\n  temperature or pressure during thermodynamic output via the\n  thermo_style custom command using the appropriate\n  compute-ID.  It also means that changing attributes of thermo_temp\n  or thermo_press will have no effect on this fix.\n  Like other fixes that perform thermostatting, fix npt/cauchy can\n  be used with compute commands that calculate a\n  temperature after removing a “bias” from the atom velocities.\n  E.g. removing the center-of-mass velocity from a group of atoms or\n  only calculating temperature on the x-component of velocity or only\n  calculating temperature for atoms in a geometric region.  This is not\n  done by default, but only if the fix_modify command\n  is used to assign a temperature compute to this fix that includes such\n  a bias term.  See the doc pages for individual compute commands to determine which ones include a bias.  In\n  this case, the thermostat works in the following manner: the current\n  temperature is calculated taking the bias into account, bias is\n  removed from each atom, thermostatting is performed on the remaining\n  thermal degrees of freedom, and the bias is added back in.\n  \n  This fix can be used with either the verlet or respa\n  integrators. When using this fix\n  with respa, LAMMPS uses an integrator constructed\n  according to the following factorization of the Liouville propagator\n  (for two rRESPA levels):\n  \n  \\[\\begin{split}\\exp \\left(\\mathrm{i} L \\Delta t \\right) = & \\hat{E}\n  \\exp \\left(\\mathrm{i} L_{\\rm T\\textrm{-}baro} \\frac{\\Delta t}{2} \\right)\n  \\exp \\left(\\mathrm{i} L_{\\rm T\\textrm{-}part} \\frac{\\Delta t}{2} \\right)\n  \\exp \\left(\\mathrm{i} L_{\\epsilon , 2} \\frac{\\Delta t}{2} \\right)\n  \\exp \\left(\\mathrm{i} L_{2}^{(2)} \\frac{\\Delta t}{2} \\right) \\\\\n  &\\times \\left[\n  \\exp \\left(\\mathrm{i} L_{2}^{(1)} \\frac{\\Delta t}{2n} \\right)\n  \\exp \\left(\\mathrm{i} L_{\\epsilon , 1} \\frac{\\Delta t}{2n} \\right)\n  \\exp \\left(\\mathrm{i} L_1 \\frac{\\Delta t}{n} \\right)\n  \\exp \\left(\\mathrm{i} L_{\\epsilon , 1} \\frac{\\Delta t}{2n} \\right)\n  \\exp \\left(\\mathrm{i} L_{2}^{(1)} \\frac{\\Delta t}{2n} \\right)\n  \\right]^n \\\\\n  &\\times\n  \\exp \\left(\\mathrm{i} L_{2}^{(2)} \\frac{\\Delta t}{2} \\right)\n  \\exp \\left(\\mathrm{i} L_{\\epsilon , 2} \\frac{\\Delta t}{2} \\right)\n  \\exp \\left(\\mathrm{i} L_{\\rm T\\textrm{-}part} \\frac{\\Delta t}{2} \\right)\n  \\exp \\left(\\mathrm{i} L_{\\rm T\\textrm{-}baro} \\frac{\\Delta t}{2} \\right) \\\\\n  &+ \\mathcal{O} \\left(\\Delta t^3 \\right)\\end{split}\\]\n  This factorization differs somewhat from that of Tuckerman et al, in\n  that the barostat is only updated at the outermost rRESPA level,\n  whereas Tuckerman’s factorization requires splitting the pressure into\n  pieces corresponding to the forces computed at each rRESPA level. In\n  theory, the latter method will exhibit better numerical stability. In\n  practice, because Pdamp is normally chosen to be a large multiple of\n  the outermost rRESPA timestep, the barostat dynamics are not the\n  limiting factor for numerical stability. Both factorizations are\n  time-reversible and can be shown to preserve the phase space measure\n  of the underlying non-Hamiltonian equations of motion.\n  \n  Note\n  Under NPT dynamics, for a system with zero initial total linear\n  momentum, the total momentum fluctuates close to zero.  It may occasionally\n  undergo brief excursions to non-negligible values, before returning close\n  to zero.  Over long simulations, this has the effect of causing the\n  center-of-mass to undergo a slow random walk. This can be mitigated by\n  resetting the momentum at infrequent intervals using the\n  fix momentum command.\n  \n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  This fix writes the state of all the thermostat and barostat\n  variables to binary restart files.  See the\n  read_restart command for info on how to re-specify\n  a fix in an input script that reads a restart file, so that the\n  operation of the fix continues in an uninterrupted fashion.\n  The fix_modify temp and press options are\n  supported by this fix.  You can use them to assign a\n  compute you have defined to this fix which will be used\n  in its thermostatting or barostatting procedure, as described above.\n  If you do this, note that the kinetic energy derived from the compute\n  temperature should be consistent with the virial term computed using\n  all atoms for the pressure.  LAMMPS will warn you if you choose to\n  compute temperature on a subset of atoms.\n  \n  Note\n  If both the temp and press keywords are used in a single\n  thermo_modify command (or in two separate commands), then the order in\n  which the keywords are specified is important.  Note that a pressure compute defines its own temperature compute as\n  an argument when it is specified.  The temp keyword will override\n  this (for the pressure compute being used by fix npt), but only if the\n  temp keyword comes after the press keyword.  If the temp keyword\n  comes before the press keyword, then the new pressure compute\n  specified by the press keyword will be unaffected by the temp\n  setting.\n  \n  The fix_modify energy option is supported by this\n  fix to add the energy change induced by Nose/Hoover thermostatting\n  and barostatting to the system’s potential energy as part of\n  thermodynamic output.\n  This fix computes a global scalar and a global vector of quantities,\n  which can be accessed by various output commands.\n  The scalar value calculated by this fix is “extensive”; the vector\n  values are “intensive”.\n  The scalar is the cumulative energy change due to the fix.\n  The vector stores internal Nose/Hoover thermostat and barostat\n  variables.  The number and meaning of the vector values depends on\n  which fix is used and the settings for keywords tchain and pchain,\n  which specify the number of Nose/Hoover chains for the thermostat and\n  barostat.  If no thermostatting is done, then tchain is 0.  If no\n  barostatting is done, then pchain is 0.  In the following list,\n  “ndof” is 0, 1, 3, or 6, and is the number of degrees of freedom in\n  the barostat.  Its value is 0 if no barostat is used, else its value\n  is 6 if any off-diagonal stress tensor component is barostatted, else\n  its value is 1 if couple xyz is used or couple xy for a 2d\n  simulation, otherwise its value is 3.\n  The order of values in the global vector and their meaning is as\n  follows.  The notation means there are tchain values for eta, followed\n  by tchain for eta_dot, followed by ndof for omega, etc:\n  \n  eta[tchain] = particle thermostat displacements (unitless)\n  eta_dot[tchain] = particle thermostat velocities (1/time units)\n  omega[ndof] = barostat displacements (unitless)\n  omega_dot[ndof] = barostat velocities (1/time units)\n  etap[pchain] = barostat thermostat displacements (unitless)\n  etap_dot[pchain] = barostat thermostat velocities (1/time units)\n  PE_eta[tchain] = potential energy of each particle thermostat displacement (energy units)\n  KE_eta_dot[tchain] = kinetic energy of each particle thermostat velocity (energy units)\n  PE_omega[ndof] = potential energy of each barostat displacement (energy units)\n  KE_omega_dot[ndof] = kinetic energy of each barostat velocity (energy units)\n  PE_etap[pchain] = potential energy of each barostat thermostat displacement (energy units)\n  KE_etap_dot[pchain] = kinetic energy of each barostat thermostat velocity (energy units)\n  PE_strain[1] = scalar strain energy (energy units)\n  \n  This fix can ramp its external temperature and pressure over\n  multiple runs, using the start and stop keywords of the\n  run command.  See the run command for details of\n  how to do this.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID style_name keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  style_name = npt/cauchy\n  one or more keyword/value pairs may be appended\n  keyword = temp or iso or aniso or tri or x or y or z or xy or yz or xz or couple or tchain or pchain or mtk or tloop or ploop or nreset or drag or dilate or scalexy or scaleyz or scalexz or flip or fixedpoint or update\n  temp values = Tstart Tstop Tdamp\n    Tstart,Tstop = external temperature at start/end of run\n    Tdamp = temperature damping parameter (time units)\n  iso or aniso or tri values = Pstart Pstop Pdamp\n    Pstart,Pstop = scalar external pressure at start/end of run (pressure units)\n    Pdamp = pressure damping parameter (time units)\n  x or y or z or xy or yz or xz values = Pstart Pstop Pdamp\n    Pstart,Pstop = external stress tensor component at start/end of run (pressure units)\n    Pdamp = stress damping parameter (time units)\n  couple = none or xyz or xy or yz or xz\n  tchain value = N\n    N = length of thermostat chain (1 = single thermostat)\n  pchain values = N\n    N length of thermostat chain on barostat (0 = no thermostat)\n  mtk value = yes or no = add in MTK adjustment term or not\n  tloop value = M\n    M = number of sub-cycles to perform on thermostat\n  ploop value = M\n    M = number of sub-cycles to perform on barostat thermostat\n  nreset value = reset reference cell every this many timesteps\n  drag value = Df\n    Df = drag factor added to barostat/thermostat (0.0 = no drag)\n  dilate value = dilate-group-ID\n    dilate-group-ID = only dilate atoms in this group due to barostat volume changes\n  scalexy value = yes or no = scale xy with ly\n  scaleyz value = yes or no = scale yz with lz\n  scalexz value = yes or no = scale xz with lz\n  flip value = yes or no = allow or disallow box flips when it becomes highly skewed\n  cauchystat cauchystat values = alpha continue\n    alpha = strength of Cauchy stress control parameter\n    continue = yes or no = whether of not to continue from a previous run\n  fixedpoint values = x y z\n    x,y,z = perform barostat dilation/contraction around this point (distance units)\n  \n  \n  ",
    "examples": "fix 1 water npt/cauchy temp 300.0 300.0 100.0 iso 0.0 0.0 1000.0\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  X, y, z cannot be barostatted if the associated dimension is not\n  periodic.  Xy, xz, and yz can only be barostatted if the\n  simulation domain is triclinic and the 2nd dimension in the keyword\n  (y dimension in xy) is periodic.  Z, xz, and yz, cannot be\n  barostatted for 2D simulations.  The create_box,\n  read data, and read_restart\n  commands specify whether the simulation box is orthogonal or\n  non-orthogonal (triclinic) and explain the meaning of the xy,xz,yz\n  tilt factors.\n  For the temp keyword, the final Tstop cannot be 0.0 since it would\n  make the external T = 0.0 at some timestep during the simulation which\n  is not allowed in the Nose/Hoover formulation.\n  The scaleyz yes and scalexz yes keyword/value pairs can not be used\n  for 2D simulations. scaleyz yes, scalexz yes, and scalexy yes options\n  can only be used if the 2nd dimension in the keyword is periodic,\n  and if the tilt factor is not coupled to the barostat via keywords\n  tri, yz, xz, and xy.\n  Without the cauchystat keyword, the barostat algorithm\n  controls the Second-Piola Kirchhoff stress, which is a stress measure\n  referred to the unmodified (initial) simulation box.  If the box\n  deforms substantially during the equilibration, the difference between\n  the set values and the final true (Cauchy) stresses can be\n  considerable.\n  The cauchystat keyword modifies the barostat as per Miller et\n  al. (Miller)_”#nc-Miller” so that the Cauchy stress is controlled.\n  alpha is the non-dimensional parameter, typically set to 0.001 or\n  0.01 that determines how aggressively the algorithm drives the system\n  towards the set Cauchy stresses.  Larger values of alpha will modify\n  the system more quickly, but can lead to instabilities.  Smaller\n  values will lead to longer convergence time.  Since alpha also\n  influences how much the stress fluctuations deviate from the\n  equilibrium fluctuations, it should be set as small as possible.\n  A continue value of yes indicates that the fix is subsequent to a\n  previous run with the npt/cauchy fix, and the intention is to continue\n  from the converged stress state at the end of the previous run.  This\n  may be required, for example, when implementing a multi-step loading/unloading\n  sequence over several fixes.\n  Setting alpha to zero is not permitted.  To “turn off” the\n  cauchystat control and thus restore the equilibrium stress\n  fluctuations, two subsequent fixes should be used.  In the first, the\n  cauchystat flag is used and the simulation box equilibrates to the\n  correct shape for the desired stresses.  In the second, the fix\n  statement is identical except that the cauchystat keyword is removed\n  (along with related alpha and continue values). This restores the\n  original Parrinello-Rahman algorithm, but now with the correct simulation\n  box shape from the first fix.\n  This fix can be used with dynamic groups as defined by the\n  group command.  Likewise it can be used with groups to\n  which atoms are added or deleted over time, e.g. a deposition\n  simulation.  However, the conservation properties of the thermostat\n  and barostat are defined for systems with a static set of atoms.  You\n  may observe odd behavior if the atoms in a group vary dramatically\n  over time or the atom count becomes very small.\n  "
},
{
    "command": "fix npt/sphere",
    "description": "Perform constant NPT integration to update position, velocity, and\n  angular velocity each timestep for finite-sizex spherical particles in\n  the group using a Nose/Hoover temperature thermostat and Nose/Hoover\n  pressure barostat.  P is pressure; T is temperature.  This creates a\n  system trajectory consistent with the isothermal-isobaric ensemble.\n  This fix differs from the fix npt command, which\n  assumes point particles and only updates their position and velocity.\n  The thermostat is applied to both the translational and rotational\n  degrees of freedom for the spherical particles, assuming a compute is\n  used which calculates a temperature that includes the rotational\n  degrees of freedom (see below).  The translational degrees of freedom\n  can also have a bias velocity removed from them before thermostatting\n  takes place; see the description below.\n  If the disc keyword is used, then each particle is treated as a 2d\n  disc (circle) instead of as a sphere.  This is only possible for 2d\n  simulations, as defined by the dimension keyword.\n  The only difference between discs and spheres in this context is their\n  moment of inertia, as used in the time integration.\n  Additional parameters affecting the thermostat and barostat are\n  specified by keywords and values documented with the fix npt command.  See, for example, discussion of the temp,\n  iso, aniso, and dilate keywords.\n  The particles in the fix group are the only ones whose velocities and\n  positions are updated by the velocity/position update portion of the\n  NPT integration.\n  Regardless of what particles are in the fix group, a global pressure is\n  computed for all particles.  Similarly, when the size of the simulation\n  box is changed, all particles are re-scaled to new positions, unless the\n  keyword dilate is specified with a value of partial, in which case\n  only the particles in the fix group are re-scaled.  The latter can be\n  useful for leaving the coordinates of particles in a solid substrate\n  unchanged and controlling the pressure of a surrounding fluid.\n  \n  This fix computes a temperature and pressure each timestep.  To do\n  this, the fix creates its own computes of style “temp/sphere” and\n  “pressure”, as if these commands had been issued:\n  compute fix-ID_temp all temp/sphere\n  compute fix-ID_press all pressure fix-ID_temp\n  \n  \n  See the compute temp/sphere and compute pressure commands for details.  Note that the\n  IDs of the new computes are the fix-ID + underscore + “temp” or fix_ID\n  + underscore + “press”, and the group for the new computes is “all”\n  since pressure is computed for the entire system.\n  Note that these are NOT the computes used by thermodynamic output (see\n  the thermo_style command) with ID = thermo_temp\n  and thermo_press.  This means you can change the attributes of this\n  fix’s temperature or pressure via the\n  compute_modify command or print this temperature\n  or pressure during thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\n  It also means that changing attributes of thermo_temp or\n  thermo_press will have no effect on this fix.\n  Like other fixes that perform thermostatting, this fix can be used\n  with compute commands that calculate a temperature\n  after removing a “bias” from the atom velocities.  E.g. removing the\n  center-of-mass velocity from a group of atoms or only calculating\n  temperature on the x-component of velocity or only calculating\n  temperature for atoms in a geometric region.  This is not done by\n  default, but only if the fix_modify command is used\n  to assign a temperature compute to this fix that includes such a bias\n  term.  See the doc pages for individual compute commands to determine which ones include a bias.  In\n  this case, the thermostat works in the following manner: the current\n  temperature is calculated taking the bias into account, bias is\n  removed from each atom, thermostatting is performed on the remaining\n  thermal degrees of freedom, and the bias is added back in.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  This fix writes the state of the Nose/Hoover thermostat and barostat\n  to binary restart files.  See the\n  read_restart command for info on how to re-specify\n  a fix in an input script that reads a restart file, so that the\n  operation of the fix continues in an uninterrupted fashion.\n  The fix_modify temp and press options are\n  supported by this fix.  You can use them to assign a\n  compute you have defined to this fix which will be used\n  in its thermostatting or barostatting procedure.  If you do this, note\n  that the kinetic energy derived from the compute temperature should be\n  consistent with the virial term computed using all atoms for the\n  pressure.  LAMMPS will warn you if you choose to compute temperature\n  on a subset of atoms.\n  The fix_modify energy option is supported by this\n  fix to add the energy change induced by Nose/Hoover thermostatting and\n  barostatting to the system’s potential energy as part of\n  thermodynamic output.\n  This fix computes the same global scalar and global vector of\n  quantities as does the fix npt command.\n  This fix can ramp its target temperature and pressure over multiple\n  runs, using the start and stop keywords of the run\n  command.  See the run command for details of how to do\n  this.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID npt/sphere keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  npt/sphere = style name of this fix command\n  zero or more keyword/value pairs may be appended\n  keyword = disc\n  \n  disc value = none = treat particles as 2d discs, not spheres\n  \n  additional thermostat and barostat related keyword/value pairs from the fix npt command can be appended\n  \n  ",
    "examples": "fix 1 all npt/sphere temp 300.0 300.0 100.0 iso 0.0 0.0 1000.0\n  fix 2 all npt/sphere temp 300.0 300.0 100.0 x 5.0 5.0 1000.0\n  fix 2 all npt/sphere temp 300.0 300.0 100.0 x 5.0 5.0 1000.0 disc\n  fix 2 all npt/sphere temp 300.0 300.0 100.0 x 5.0 5.0 1000.0 drag 0.2\n  fix 2 water npt/sphere temp 300.0 300.0 100.0 aniso 0.0 0.0 1000.0 dilate partial\n  \n  \n  ",
    "restrictions": "This fix requires that atoms store torque and angular velocity (omega)\n  and a radius as defined by the atom_style sphere\n  command.\n  All particles in the group must be finite-size spheres.  They cannot\n  be point particles.\n  Use of the disc keyword is only allowed for 2d simulations, as\n  defined by the dimension keyword.\n  "
},
{
    "command": "fix numdiff",
    "description": "Calculate forces through finite difference calculations of energy\n  versus position.  These forces can be compared to analytic forces\n  computed by pair styles, bond styles, etc.  This can be useful for\n  debugging or other purposes.\n  The group specified with the command means only atoms within the group\n  have their averages computed.  Results are set to 0.0 for atoms not in\n  the group.\n  This fix performs a loop over all atoms in the group.  For each atom\n  and each component of force it adds delta to the position, and\n  computes the new energy of the entire system.  It then subtracts\n  delta from the original position and again computes the new energy\n  of the system.  It then restores the original position.  That\n  component of force is calculated as the difference in energy divided\n  by two times delta.\n  \n  Note\n  It is important to choose a suitable value for delta, the magnitude of\n  atom displacements that are used to generate finite difference\n  approximations to the exact forces.  For typical systems, a value in\n  the range of 1 part in 1e4 to 1e5 of the typical separation distance\n  between atoms in the liquid or solid state will be sufficient.\n  However, the best value will depend on a multitude of factors\n  including the stiffness of the interatomic potential, the thermodynamic\n  state of the material being probed, and so on. The only way to be sure\n  that you have made a good choice is to do a sensitivity study on a\n  representative atomic configuration, sweeping over a wide range of\n  values of delta.  If delta is too small, the output forces will vary\n  erratically due to truncation effects. If delta is increased beyond a\n  certain point, the output forces will start to vary smoothly with\n  delta, due to growing contributions from higher order derivatives. In\n  between these two limits, the numerical force values should be largely\n  independent of delta.\n  \n  \n  Note\n  The cost of each energy evaluation is essentially the cost of an MD\n  timestep.  Thus invoking this fix once for a 3d system has a cost\n  of 6N timesteps, where N is the total number of atoms in the system\n  (assuming all atoms are included in the group).  So this fix can be\n  very expensive to use for large systems.\n  \n  \n  The Nevery argument specifies on what timesteps the force will\n  be used calculated by finite difference.\n  The delta argument specifies the positional displacement each\n  atom will undergo.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options are\n  relevant to this fix.\n  This fix produces a per-atom array which can be accessed by various\n  output commands, which stores the components of\n  the force on each atom as calculated by finite difference.  The\n  per-atom values can only be accessed on timesteps that are multiples\n  of Nevery since that is when the finite difference forces are\n  calculated.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is invoked during energy\n  minimization.\n  ",
    "syntax": "fix ID group-ID numdiff Nevery delta\n  \n  \n  \n  ID, group-ID are documented in fix command\n  numdiff = style name of this fix command\n  Nevery = calculate force by finite difference every this many timesteps\n  delta = finite difference displacement length (distance units)\n  \n  ",
    "examples": "fix 1 all numdiff 1 0.0001\n  fix 1 all numdiff 10 1e-6\n  fix 1 all numdiff 100 0.01\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix nve",
    "description": "Perform constant NVE integration to update position and velocity for\n  atoms in the group each timestep.  V is volume; E is energy.  This\n  creates a system trajectory consistent with the microcanonical\n  ensemble.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID nve\n  \n  \n  \n  ID, group-ID are documented in fix command\n  nve = style name of this fix command\n  \n  ",
    "examples": "fix 1 all nve\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix nve/asphere",
    "description": "Perform constant NVE integration to update position, velocity,\n  orientation, and angular velocity for aspherical particles in the\n  group each timestep.  V is volume; E is energy.  This creates a system\n  trajectory consistent with the microcanonical ensemble.\n  This fix differs from the fix nve command, which\n  assumes point particles and only updates their position and velocity.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "fix ID group-ID nve/asphere\n  \n  \n  \n  ID, group-ID are documented in fix command\n  nve/asphere = style name of this fix command\n  \n  ",
    "examples": "fix 1 all nve/asphere\n  \n  \n  ",
    "restrictions": "This fix is part of the ASPHERE package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  This fix requires that atoms store torque and angular momentum and a\n  quaternion as defined by the atom_style ellipsoid\n  command.\n  All particles in the group must be finite-size.  They cannot be point\n  particles, but they can be aspherical or spherical as defined by their\n  shape attribute.\n  "
},
{
    "command": "fix nve/asphere/noforce",
    "description": "Perform updates of position and orientation, but not velocity or\n  angular momentum for atoms in the group each timestep.  In other\n  words, the force and torque on the atoms is ignored and their velocity\n  and angular momentum are not updated.  The atom velocities and\n  angular momenta are used to update their positions and orientation.\n  This is useful as an implicit time integrator for Fast Lubrication\n  Dynamics, since the velocity and angular momentum are updated by the\n  pair_style lubricuteU command.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID nve/asphere/noforce\n  \n  \n  \n  ID, group-ID are documented in fix command\n  nve/asphere/noforce = style name of this fix command\n  \n  ",
    "examples": "fix 1 all nve/asphere/noforce\n  \n  \n  ",
    "restrictions": "This fix is part of the ASPHERE package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  This fix requires that atoms store torque and angular momentum and a\n  quaternion as defined by the atom_style ellipsoid\n  command.\n  All particles in the group must be finite-size.  They cannot be point\n  particles, but they can be aspherical or spherical as defined by their\n  shape attribute.\n  "
},
{
    "command": "fix nve/awpmd",
    "description": "Perform constant NVE integration to update position and velocity for\n  nuclei and electrons in the group for the Antisymmetrized Wave Packet Molecular Dynamics model.  V is volume; E is energy.\n  This creates a system trajectory consistent with the microcanonical\n  ensemble.\n  The operation of this fix is exactly like that described by the fix nve command, except that the width and width-velocity of\n  the electron wave functions are also updated.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID nve/awpmd\n  \n  \n  \n  ID, group-ID are documented in fix command\n  nve/awpmd = style name of this fix command\n  \n  ",
    "examples": "fix 1 all nve/awpmd\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-AWPMD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "fix nve/body",
    "description": "Perform constant NVE integration to update position, velocity,\n  orientation, and angular velocity for body particles in the group each\n  timestep.  V is volume; E is energy.  This creates a system trajectory\n  consistent with the microcanonical ensemble.  See the Howto body doc page for more details on using body\n  particles.\n  This fix differs from the fix nve command, which\n  assumes point particles and only updates their position and velocity.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID nve/body\n  \n  \n  \n  ID, group-ID are documented in fix command\n  nve/body = style name of this fix command\n  \n  ",
    "examples": "fix 1 all nve/body\n  \n  \n  ",
    "restrictions": "This fix is part of the BODY package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  This fix requires that atoms store torque and angular momentum and a\n  quaternion as defined by the atom_style body\n  command.\n  All particles in the group must be body particles.  They cannot be\n  point particles.\n  "
},
{
    "command": "fix nve/dot",
    "description": "Apply a rigid-body integrator as described in (Davidchack)\n  to a group of atoms, but without Langevin dynamics.\n  This command performs Molecular dynamics (MD)\n  via a velocity-Verlet algorithm and an evolution operator that rotates\n  the quaternion degrees of freedom, similar to the scheme outlined in (Miller).\n  This command is the equivalent of the fix nve/dotc/langevin\n  without damping and noise and can be used to determine the stability range\n  in a NVE ensemble prior to using the Langevin-type DOTC-integrator\n  (see also fix nve/dotc/langevin).\n  The command is equivalent to the fix nve.\n  The particles are always considered to have a finite size.\n  An example input file can be found in /examples/USER/cgdna/examples/duplex1/.\n  Further details of the implementation and stability of the integrator are contained in (Henrich).\n  The preprint version of the article can be found here.\n  ",
    "syntax": "fix ID group-ID nve/dot\n  \n  \n  \n  ID, group-ID are documented in fix command\n  nve/dot = style name of this fix command\n  \n  ",
    "examples": "fix 1 all nve/dot\n  \n  \n  ",
    "restrictions": "These pair styles can only be used if LAMMPS was built with the\n  USER-CGDNA package and the MOLECULE and ASPHERE package.\n  See the Build package doc page for more info.\n  "
},
{
    "command": "fix nve/dotc/langevin",
    "description": "Apply a rigid-body Langevin-type integrator of the kind “Langevin C”\n  as described in (Davidchack)\n  to a group of atoms, which models an interaction with an implicit background\n  solvent.  This command performs Brownian dynamics (BD)\n  via a technique that splits the integration into a deterministic Hamiltonian\n  part and the Ornstein-Uhlenbeck process for noise and damping.\n  The quaternion degrees of freedom are updated though an evolution\n  operator which performs a rotation in quaternion space, preserves\n  the quaternion norm and is akin to (Miller).\n  In terms of syntax this command has been closely modelled on the\n  fix langevin and its angmom option. But it combines\n  the fix nve and the fix langevin in\n  one single command. The main feature is improved stability\n  over the standard integrator, permitting slightly larger timestep sizes.\n  \n  Note\n  Unlike the fix langevin this command performs\n  also time integration of the translational and quaternion degrees of freedom.\n  \n  The total force on each atom will have the form:\n  \n  \\[\\begin{split}F =   & F_c + F_f + F_r \\\\\n  F_f = & - \\frac{m}{\\mathrm{damp}} v \\\\\n  F_r \\propto & \\sqrt{\\frac{k_B T m}{dt~\\mathrm{damp}}}\\end{split}\\]\n  \\(F_c\\) is the conservative force computed via the usual\n  inter-particle interactions (pair_style,\n  bond_style, etc). The \\(F_f\\) and \\(F_r\\)\n  terms are implicitly taken into account by this fix on a per-particle\n  basis.\n  \\(F_f\\) is a frictional drag or viscous damping term proportional to\n  the particle’s velocity.  The proportionality constant for each atom is\n  computed as \\(\\frac{m}{\\mathrm{damp}}\\), where m is the mass of\n  the particle and damp is the damping factor specified by the user.\n  \\(F_r\\) is a force due to solvent atoms at a temperature T\n  randomly bumping into the particle.  As derived from the\n  fluctuation/dissipation theorem, its magnitude as shown above is\n  proportional to \\(\\sqrt{\\frac{k_B T m}{dt~\\mathrm{damp}}}\\), where\n  \\(k_B\\) is the Boltzmann constant, T is the desired temperature,\n  m is the mass of the particle, dt is the timestep size, and damp is\n  the damping factor.  Random numbers are used to randomize the direction\n  and magnitude of this force as described in (Dunweg),\n  where a uniform random number is used (instead of a Gaussian random\n  number) for speed.\n  \n  Tstart and Tstop have to be constant values, i.e. they cannot\n  be variables. If used together with the oxDNA force field for\n  coarse-grained simulation of DNA please note that T = 0.1 in oxDNA units\n  corresponds to T = 300 K.\n  The damp parameter is specified in time units and determines how\n  rapidly the temperature is relaxed.  For example, a value of 0.03\n  means to relax the temperature in a timespan of (roughly) 0.03 time\n  units tau (see the units command).\n  The damp factor can be thought of as inversely related to the\n  viscosity of the solvent, i.e. a small relaxation time implies a\n  high-viscosity solvent and vice versa.  See the discussion about gamma\n  and viscosity in the documentation for the fix viscous command for more details.\n  Note that the value 78.9375 in the second example above corresponds\n  to a diffusion constant, which is about an order of magnitude larger\n  than realistic ones. This has been used to sample configurations faster\n  in Brownian dynamics simulations.\n  The random # seed must be a positive integer. A Marsaglia random\n  number generator is used.  Each processor uses the input seed to\n  generate its own unique seed and its own stream of random numbers.\n  Thus the dynamics of the system will not be identical on two runs on\n  different numbers of processors.\n  The keyword/value option has to be used in the following way:\n  This fix has to be used together with the angmom keyword. The\n  particles are always considered to have a finite size.\n  The keyword angmom enables thermostatting of the rotational degrees of\n  freedom in addition to the usual translational degrees of freedom.\n  The scale factor after the angmom keyword gives the ratio of the\n  rotational to the translational friction coefficient.\n  An example input file can be found in examples/USER/cgdna/examples/duplex2/.\n  Further details of the implementation and stability of the integrators are contained in (Henrich).\n  The preprint version of the article can be found here.\n  ",
    "syntax": "fix ID group-ID nve/dotc/langevin Tstart Tstop damp seed keyword value\n  \n  \n  \n  ID, group-ID are documented in fix command\n  nve/dotc/langevin = style name of this fix command\n  Tstart,Tstop = desired temperature at start/end of run (temperature units)\n  damp = damping parameter (time units)\n  seed = random number seed to use for white noise (positive integer)\n  keyword = angmom\n  angmom value = factor\n    factor = do thermostat rotational degrees of freedom via the angular momentum and apply numeric scale factor as discussed below\n  \n  \n  ",
    "examples": "fix 1 all nve/dotc/langevin 1.0 1.0 0.03 457145 angmom 10\n  fix 1 all nve/dotc/langevin 0.1 0.1 78.9375 457145 angmom 10\n  \n  \n  ",
    "restrictions": "These pair styles can only be used if LAMMPS was built with the\n  USER-CGDNA package and the MOLECULE and ASPHERE package.\n  See the Build package doc page for more info.\n  "
},
{
    "command": "fix nve/eff",
    "description": "Perform constant NVE integration to update position and velocity for\n  nuclei and electrons in the group for the electron force field model.  V is volume; E is energy.  This creates a\n  system trajectory consistent with the microcanonical ensemble.\n  The operation of this fix is exactly like that described by the fix nve command, except that the radius and radial velocity\n  of electrons are also updated.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID nve/eff\n  \n  \n  \n  ID, group-ID are documented in fix command\n  nve/eff = style name of this fix command\n  \n  ",
    "examples": "fix 1 all nve/eff\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-EFF package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "fix nve/limit",
    "description": "Perform constant NVE updates of position and velocity for atoms in the\n  group each timestep.  A limit is imposed on the maximum distance an\n  atom can move in one timestep.  This is useful when starting a\n  simulation with a configuration containing highly overlapped atoms.\n  Normally this would generate huge forces which would blow atoms out of\n  the simulation box, causing LAMMPS to stop with an error.\n  Using this fix can overcome that problem.  Forces on atoms must still\n  be computable (which typically means 2 atoms must have a separation\n  distance > 0.0).  But large velocities generated by large forces are\n  reset to a value that corresponds to a displacement of length xmax\n  in a single timestep.  Xmax is specified in distance units; see the\n  units command for details.  The value of xmax should be\n  consistent with the neighbor skin distance and the frequency of\n  neighbor list re-building, so that pairwise interactions are not\n  missed on successive timesteps as atoms move.  See the\n  neighbor and neigh_modify commands\n  for details.\n  Note that if a velocity reset occurs the integrator will not conserve\n  energy.  On steps where no velocity resets occur, this integrator is\n  exactly like the fix nve command.  Since forces are\n  unaltered, pressures computed by thermodynamic output will still be\n  very large for overlapped configurations.\n  \n  Note\n  You should not use fix shake in conjunction\n  with this fix.  That is because fix shake applies constraint forces\n  based on the predicted positions of atoms after the next timestep.\n  It has no way of knowing the timestep may change due to this fix,\n  which will cause the constraint forces to be invalid.  A better\n  strategy is to turn off fix shake when performing initial dynamics\n  that need this fix, then turn fix shake on when doing normal dynamics\n  with a fixed-size timestep.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.\n  This fix computes a global scalar which can be accessed by various\n  output commands.  The scalar is the count of how\n  many updates of atom’s velocity/position were limited by the maximum\n  distance criterion.  This should be roughly the number of atoms so\n  affected, except that updates occur at both the beginning and end of a\n  timestep in a velocity Verlet timestepping algorithm.  This is a\n  cumulative quantity for the current run, but is re-initialized to zero\n  each time a run is performed.  The scalar value calculated by this fix\n  is “extensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID nve/limit xmax\n  \n  \n  \n  ID, group-ID are documented in fix command\n  nve = style name of this fix command\n  xmax = maximum distance an atom can move in one timestep (distance units)\n  \n  ",
    "examples": "fix 1 all nve/limit 0.1\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix nve/line",
    "description": "Perform constant NVE integration to update position, velocity,\n  orientation, and angular velocity for line segment particles in the\n  group each timestep.  V is volume; E is energy.  This creates a system\n  trajectory consistent with the microcanonical ensemble.  See Howto spherical doc page for an overview of using line\n  segment particles.\n  This fix differs from the fix nve command, which\n  assumes point particles and only updates their position and velocity.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID nve/line\n  \n  \n  \n  ID, group-ID are documented in fix command\n  nve/line = style name of this fix command\n  \n  ",
    "examples": "fix 1 all nve/line\n  \n  \n  ",
    "restrictions": "This fix is part of the ASPHERE package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  This fix requires that particles be line segments as defined by the\n  atom_style line command.\n  "
},
{
    "command": "fix nve/manifold/rattle",
    "description": "Perform constant NVE integration to update position and velocity for\n  atoms constrained to a curved surface (manifold) in the group each\n  timestep. The constraint is handled by RATTLE (Andersen)\n  written out for the special case of single-particle constraints as\n  explained in (Paquay).  V is volume; E is energy. This way,\n  the dynamics of particles constrained to curved surfaces can be\n  studied. If combined with fix langevin, this\n  generates Brownian motion of particles constrained to a curved\n  surface. For a list of currently supported manifolds and their\n  parameters, see the Howto manifold doc page.\n  Note that the particles must initially be close to the manifold in\n  question. If not, RATTLE will not be able to iterate until the\n  constraint is satisfied, and an error is generated. For simple\n  manifolds this can be achieved with region and create_atoms\n  commands, but for more complex surfaces it might be more useful to\n  write a script.\n  The manifold args may be equal-style variables, like so:\n  variable R equal \"ramp(5.0,3.0)\"\n  fix shrink_sphere all nve/manifold/rattle 1e-4 10 sphere v_R\n  \n  \n  In this case, the manifold parameter will change in time according to\n  the variable.  This is not a problem for the time integrator as long\n  as the change of the manifold is slow with respect to the dynamics of\n  the particles.  Note that if the manifold has to exert work on the\n  particles because of these changes, the total energy might not be\n  conserved.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID nve/manifold/rattle tol maxit manifold manifold-args keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  nve/manifold/rattle = style name of this fix command\n  tol = tolerance to which Newton iteration must converge\n  maxit = maximum number of iterations to perform\n  manifold = name of the manifold\n  manifold-args = parameters for the manifold\n  one or more keyword/value pairs may be appended\n  keyword = every\n    every values = N\n      N = print info about iteration every N steps. N = 0 means no output\n  \n  \n  ",
    "examples": "fix 1 all nve/manifold/rattle 1e-4 10 sphere 5.0\n  fix step all nve/manifold/rattle 1e-8 100 ellipsoid 2.5 2.5 5.0 every 25\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-MANIFOLD package. It is only enabled if\n  LAMMPS was built with that package. See the Build package doc page for more info.\n  "
},
{
    "command": "fix nve/noforce",
    "description": "Perform updates of position, but not velocity for atoms in the group\n  each timestep.  In other words, the force on the atoms is ignored and\n  their velocity is not updated.  The atom velocities are used to update\n  their positions.\n  This can be useful for wall atoms, when you set their velocities, and\n  want the wall to move (or stay stationary) in a prescribed fashion.\n  This can also be accomplished via the fix setforce\n  command, but with fix nve/noforce, the forces on the wall atoms are\n  unchanged, and can thus be printed by the dump command or\n  queried with an equal-style variable that uses the\n  fcm() group function to compute the total force on the group of atoms.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID nve\n  \n  \n  \n  ID, group-ID are documented in fix command\n  nve/noforce = style name of this fix command\n  \n  ",
    "examples": "fix 3 wall nve/noforce\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix nve/sphere",
    "description": "Perform constant NVE integration to update position, velocity, and\n  angular velocity for finite-size spherical particles in the group each\n  timestep.  V is volume; E is energy.  This creates a system trajectory\n  consistent with the microcanonical ensemble.\n  This fix differs from the fix nve command, which\n  assumes point particles and only updates their position and velocity.\n  If the update keyword is used with the dipole value, then the\n  orientation of the dipole moment of each particle is also updated\n  during the time integration.  This option should be used for models\n  where a dipole moment is assigned to finite-size particles,\n  e.g. spheroids via use of the atom_style hybrid sphere dipole command.\n  The default dipole orientation integrator can be changed to the\n  Dullweber-Leimkuhler-McLachlan integration scheme\n  (Dullweber) when using update with the value\n  dipole/dlm. This integrator is symplectic and time-reversible,\n  giving better energy conservation and allows slightly longer timesteps\n  at only a small additional computational cost.\n  If the disc keyword is used, then each particle is treated as a 2d\n  disc (circle) instead of as a sphere.  This is only possible for 2d\n  simulations, as defined by the dimension keyword.\n  The only difference between discs and spheres in this context is their\n  moment of inertia, as used in the time integration.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID nve/sphere\n  \n  \n  \n  ID, group-ID are documented in fix command\n  nve/sphere = style name of this fix command\n  zero or more keyword/value pairs may be appended\n  keyword = update or disc\n  update value = dipole or dipole/dlm\n    dipole = update orientation of dipole moment during integration\n    dipole/dlm = use DLM integrator to update dipole orientation\n  disc value = none = treat particles as 2d discs, not spheres\n  \n  \n  ",
    "examples": "fix 1 all nve/sphere\n  fix 1 all nve/sphere update dipole\n  fix 1 all nve/sphere disc\n  fix 1 all nve/sphere update dipole/dlm\n  \n  \n  ",
    "restrictions": "This fix requires that atoms store torque and angular velocity (omega)\n  and a radius as defined by the atom_style sphere\n  command.  If the dipole keyword is used, then they must also store a\n  dipole moment as defined by the atom_style dipole\n  command.\n  All particles in the group must be finite-size spheres.  They cannot\n  be point particles.\n  Use of the disc keyword is only allowed for 2d simulations, as\n  defined by the dimension keyword.\n  "
},
{
    "command": "fix nve/spin",
    "description": "Perform a symplectic integration for the spin or spin-lattice system.\n  The lattice keyword defines if the spins are integrated on a lattice\n  of fixed atoms (lattice = frozen), or if atoms are moving\n  (lattice = moving).\n  The first case corresponds to a spin dynamics calculation, and\n  the second to a spin-lattice calculation.\n  By default a spin-lattice integration is performed (lattice = moving).\n  The nve/spin fix applies a Suzuki-Trotter decomposition to\n  the equations of motion of the spin lattice system, following the scheme:\n  \n  according to the implementation reported in (Omelyan).\n  A sectoring method enables this scheme for parallel calculations.\n  The implementation of this sectoring algorithm is reported\n  in (Tranchida).\n  ",
    "syntax": "fix ID group-ID nve/spin keyword values\n  \n  \n  \n  ID, group-ID are documented in fix command\n  nve/spin = style name of this fix command\n  keyword = lattice\n  lattice value = moving or frozen\n    moving = integrate both spin and atomic degress of freedom\n    frozen = integrate spins on a fixed lattice\n  \n  \n  ",
    "examples": "fix 3 all nve/spin lattice moving\n  fix 1 all nve/spin lattice frozen\n  \n  \n  ",
    "restrictions": "This fix style can only be used if LAMMPS was built with the SPIN\n  package.  See the Build package doc page for more\n  info.\n  To use the spin algorithm, it is necessary to define a map with\n  the atom_modify command. Typically, by adding the command:\n  atom_modify map array\n  \n  \n  before you create the simulation box. Note that the keyword “hash”\n  instead of “array” is also valid.\n  "
},
{
    "command": "fix nve/tri",
    "description": "Perform constant NVE integration to update position, velocity,\n  orientation, and angular momentum for triangular particles in the\n  group each timestep.  V is volume; E is energy.  This creates a system\n  trajectory consistent with the microcanonical ensemble.  See the\n  Howto spherical doc page for an overview of\n  using triangular particles.\n  This fix differs from the fix nve command, which\n  assumes point particles and only updates their position and velocity.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID nve/tri\n  \n  \n  \n  ID, group-ID are documented in fix command\n  nve/tri = style name of this fix command\n  \n  ",
    "examples": "fix 1 all nve/tri\n  \n  \n  ",
    "restrictions": "This fix is part of the ASPHERE package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  This fix requires that particles be triangles as defined by the\n  atom_style tri command.\n  "
},
{
    "command": "fix nvk",
    "description": "Perform constant kinetic energy integration using the Gaussian\n  thermostat to update position and velocity for atoms in the group each\n  timestep.  V is volume; K is kinetic energy. This creates a system\n  trajectory consistent with the isokinetic ensemble.\n  The equations of motion used are those of Minary et al in\n  (Minary), a variant of those initially given by Zhang in\n  (Zhang).\n  The kinetic energy will be held constant at its value given when fix\n  nvk is initiated. If a different kinetic energy is desired, the\n  velocity command should be used to change the kinetic\n  energy prior to this fix.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID nvk\n  \n  \n  \n  ID, group-ID are documented in fix command\n  nvk = style name of this fix command\n  \n  ",
    "examples": "fix 1 all nvk\n  \n  \n  ",
    "restrictions": "The Gaussian thermostat only works when it is applied to all atoms in\n  the simulation box. Therefore, the group must be set to all.\n  This fix has not yet been implemented to work with the RESPA integrator.\n  This fix is part of the USER-MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  Related commands: none\n  Default: none\n  \n  (Minary) Minary, Martyna, and Tuckerman, J Chem Phys, 18, 2510 (2003).\n  (Zhang) Zhang, J Chem Phys, 106, 6102 (1997).\n  "
},
{
    "command": "fix nvt/asphere",
    "description": "Perform constant NVT integration to update position, velocity,\n  orientation, and angular velocity each timestep for aspherical or\n  ellipsoidal particles in the group using a Nose/Hoover temperature\n  thermostat.  V is volume; T is temperature.  This creates a system\n  trajectory consistent with the canonical ensemble.\n  This fix differs from the fix nvt command, which\n  assumes point particles and only updates their position and velocity.\n  The thermostat is applied to both the translational and rotational\n  degrees of freedom for the aspherical particles, assuming a compute is\n  used which calculates a temperature that includes the rotational\n  degrees of freedom (see below).  The translational degrees of freedom\n  can also have a bias velocity removed from them before thermostatting\n  takes place; see the description below.\n  Additional parameters affecting the thermostat are specified by\n  keywords and values documented with the fix nvt\n  command.  See, for example, discussion of the temp and drag\n  keywords.\n  This fix computes a temperature each timestep.  To do this, the fix\n  creates its own compute of style “temp/asphere”, as if this command\n  had been issued:\n  compute fix-ID_temp group-ID temp/asphere\n  \n  \n  See the compute temp/asphere command for\n  details.  Note that the ID of the new compute is the fix-ID +\n  underscore + “temp”, and the group for the new compute is the same as\n  the fix group.\n  Note that this is NOT the compute used by thermodynamic output (see\n  the thermo_style command) with ID = thermo_temp.\n  This means you can change the attributes of this fix’s temperature\n  (e.g. its degrees-of-freedom) via the\n  compute_modify command or print this temperature\n  during thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\n  It also means that changing attributes of thermo_temp will have no\n  effect on this fix.\n  Like other fixes that perform thermostatting, this fix can be used\n  with compute commands that calculate a temperature\n  after removing a “bias” from the atom velocities.  E.g. removing the\n  center-of-mass velocity from a group of atoms or only calculating\n  temperature on the x-component of velocity or only calculating\n  temperature for atoms in a geometric region.  This is not done by\n  default, but only if the fix_modify command is used\n  to assign a temperature compute to this fix that includes such a bias\n  term.  See the doc pages for individual compute commands to determine which ones include a bias.  In\n  this case, the thermostat works in the following manner: the current\n  temperature is calculated taking the bias into account, bias is\n  removed from each atom, thermostatting is performed on the remaining\n  thermal degrees of freedom, and the bias is added back in.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  This fix writes the state of the Nose/Hoover thermostat to binary restart files.  See the read_restart\n  command for info on how to re-specify a fix in an input script that\n  reads a restart file, so that the operation of the fix continues in an\n  uninterrupted fashion.\n  The fix_modify temp option is supported by this\n  fix.  You can use it to assign a compute you have\n  defined to this fix which will be used in its thermostatting\n  procedure.\n  The fix_modify energy option is supported by this\n  fix to add the energy change induced by Nose/Hoover thermostatting to\n  the system’s potential energy as part of thermodynamic output.\n  This fix computes the same global scalar and global vector of\n  quantities as does the fix nvt command.\n  This fix can ramp its target temperature over multiple runs, using the\n  start and stop keywords of the run command.  See the\n  run command for details of how to do this.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID nvt/asphere keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  nvt/asphere = style name of this fix command\n  additional thermostat related keyword/value pairs from the fix nvt command can be appended\n  \n  ",
    "examples": "fix 1 all nvt/asphere temp 300.0 300.0 100.0\n  fix 1 all nvt/asphere temp 300.0 300.0 100.0 drag 0.2\n  \n  \n  ",
    "restrictions": "This fix is part of the ASPHERE package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  This fix requires that atoms store torque and angular momentum and a\n  quaternion as defined by the atom_style ellipsoid\n  command.\n  All particles in the group must be finite-size.  They cannot be point\n  particles, but they can be aspherical or spherical as defined by their\n  shape attribute.\n  "
},
{
    "command": "fix nvt/body",
    "description": "Perform constant NVT integration to update position, velocity,\n  orientation, and angular velocity each timestep for body\n  particles in the group using a Nose/Hoover temperature\n  thermostat.  V is volume; T is temperature.  This creates a system\n  trajectory consistent with the canonical ensemble.\n  This fix differs from the fix nvt command, which\n  assumes point particles and only updates their position and velocity.\n  The thermostat is applied to both the translational and rotational\n  degrees of freedom for the body particles, assuming a compute is\n  used which calculates a temperature that includes the rotational\n  degrees of freedom (see below).  The translational degrees of freedom\n  can also have a bias velocity removed from them before thermostatting\n  takes place; see the description below.\n  Additional parameters affecting the thermostat are specified by\n  keywords and values documented with the fix nvt\n  command.  See, for example, discussion of the temp and drag\n  keywords.\n  This fix computes a temperature each timestep.  To do this, the fix\n  creates its own compute of style “temp/body”, as if this command\n  had been issued:\n  compute fix-ID_temp group-ID temp/body\n  \n  \n  See the compute temp/body command for\n  details.  Note that the ID of the new compute is the fix-ID +\n  underscore + “temp”, and the group for the new compute is the same as\n  the fix group.\n  Note that this is NOT the compute used by thermodynamic output (see\n  the thermo_style command) with ID = thermo_temp.\n  This means you can change the attributes of this fix’s temperature\n  (e.g. its degrees-of-freedom) via the\n  compute_modify command or print this temperature\n  during thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\n  It also means that changing attributes of thermo_temp will have no\n  effect on this fix.\n  Like other fixes that perform thermostatting, this fix can be used\n  with compute commands that calculate a temperature\n  after removing a “bias” from the atom velocities.  E.g. removing the\n  center-of-mass velocity from a group of atoms or only calculating\n  temperature on the x-component of velocity or only calculating\n  temperature for atoms in a geometric region.  This is not done by\n  default, but only if the fix_modify command is used\n  to assign a temperature compute to this fix that includes such a bias\n  term.  See the doc pages for individual compute commands to determine which ones include a bias.  In\n  this case, the thermostat works in the following manner: the current\n  temperature is calculated taking the bias into account, bias is\n  removed from each atom, thermostatting is performed on the remaining\n  thermal degrees of freedom, and the bias is added back in.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  This fix writes the state of the Nose/Hoover thermostat to binary restart files.  See the read_restart\n  command for info on how to re-specify a fix in an input script that\n  reads a restart file, so that the operation of the fix continues in an\n  uninterrupted fashion.\n  The fix_modify temp option is supported by this\n  fix.  You can use it to assign a compute you have\n  defined to this fix which will be used in its thermostatting\n  procedure.\n  The fix_modify energy option is supported by this\n  fix to add the energy change induced by Nose/Hoover thermostatting to\n  the system’s potential energy as part of thermodynamic output.\n  This fix computes the same global scalar and global vector of\n  quantities as does the fix nvt command.\n  This fix can ramp its target temperature over multiple runs, using the\n  start and stop keywords of the run command.  See the\n  run command for details of how to do this.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID nvt/body keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  nvt/body = style name of this fix command\n  additional thermostat related keyword/value pairs from the fix nvt command can be appended\n  \n  ",
    "examples": "fix 1 all nvt/body temp 300.0 300.0 100.0\n  fix 1 all nvt/body temp 300.0 300.0 100.0 drag 0.2\n  \n  \n  ",
    "restrictions": "This fix is part of the BODY package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  This fix requires that atoms store torque and angular momentum and a\n  quaternion as defined by the atom_style body\n  command.\n  "
},
{
    "command": "fix nvt/manifold/rattle",
    "description": "This fix combines the RATTLE-based (Andersen) time\n  integrator of fix nve/manifold/rattle\n  (Paquay) with a Nose-Hoover-chain thermostat to sample the\n  canonical ensemble of particles constrained to a curved surface\n  (manifold). This sampling does suffer from discretization bias of\n  O(dt).  For a list of currently supported manifolds and their\n  parameters, see the Howto manifold doc page.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID nvt/manifold/rattle tol maxit manifold manifold-args keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  nvt/manifold/rattle = style name of this fix command\n  tol = tolerance to which Newton iteration must converge\n  maxit = maximum number of iterations to perform\n  manifold = name of the manifold\n  manifold-args = parameters for the manifold\n  one or more keyword/value pairs may be appended\n  keyword = temp or tchain or every\n    temp values = Tstart Tstop Tdamp\n      Tstart, Tstop = external temperature at start/end of run\n      Tdamp = temperature damping parameter (time units)\n    tchain value = N\n      N = length of thermostat chain (1 = single thermostat)\n    every value = N\n      N = print info about iteration every N steps. N = 0 means no output\n  \n  \n  ",
    "examples": "fix 1 all nvt/manifold/rattle 1e-4 10 cylinder 3.0 temp 1.0 1.0 10.0\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-MANIFOLD package. It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "fix nvt/sllod",
    "description": "Perform constant NVT integration to update positions and velocities\n  each timestep for atoms in the group using a Nose/Hoover temperature\n  thermostat.  V is volume; T is temperature.  This creates a system\n  trajectory consistent with the canonical ensemble.\n  This thermostat is used for a simulation box that is changing size\n  and/or shape, for example in a non-equilibrium MD (NEMD) simulation.\n  The size/shape change is induced by use of the fix deform command, so each point in the simulation box\n  can be thought of as having a “streaming” velocity.  This\n  position-dependent streaming velocity is subtracted from each atom’s\n  actual velocity to yield a thermal velocity which is used for\n  temperature computation and thermostatting.  For example, if the box\n  is being sheared in x, relative to y, then points at the bottom of the\n  box (low y) have a small x velocity, while points at the top of the\n  box (hi y) have a large x velocity.  These velocities do not\n  contribute to the thermal “temperature” of the atom.\n  \n  Note\n  Fix deform has an option for remapping either\n  atom coordinates or velocities to the changing simulation box.  To use\n  fix nvt/sllod, fix deform should NOT remap atom positions, because fix\n  nvt/sllod adjusts the atom positions and velocities to create a\n  velocity profile that matches the changing box size/shape.  Fix deform\n  SHOULD remap atom velocities when atoms cross periodic boundaries\n  since that is consistent with maintaining the velocity profile created\n  by fix nvt/sllod.  LAMMPS will give an error if this setting is not\n  consistent.\n  \n  The SLLOD equations of motion, originally proposed by Hoover and Ladd\n  (see (Evans and Morriss)), were proven to be equivalent to\n  Newton’s equations of motion for shear flow by (Evans and Morriss). They were later shown to generate the desired\n  velocity gradient and the correct production of work by stresses for\n  all forms of homogeneous flow by (Daivis and Todd).  As\n  implemented in LAMMPS, they are coupled to a Nose/Hoover chain\n  thermostat in a velocity Verlet formulation, closely following the\n  implementation used for the fix nvt command.\n  \n  Note\n  A recent (2017) book by (Daivis and Todd)\n  discusses use of the SLLOD method and non-equilibrium MD (NEMD)\n  thermostatting generally, for both simple and complex fluids,\n  e.g. molecular systems.  The latter can be tricky to do correctly.\n  \n  Additional parameters affecting the thermostat are specified by\n  keywords and values documented with the fix nvt\n  command.  See, for example, discussion of the temp and drag\n  keywords.\n  This fix computes a temperature each timestep.  To do this, the fix\n  creates its own compute of style “temp/deform”, as if this command had\n  been issued:\n  compute fix-ID_temp group-ID temp/deform\n  \n  \n  See the compute temp/deform command for\n  details.  Note that the ID of the new compute is the fix-ID +\n  underscore + “temp”, and the group for the new compute is the same as\n  the fix group.\n  Note that this is NOT the compute used by thermodynamic output (see\n  the thermo_style command) with ID = thermo_temp.\n  This means you can change the attributes of this fix’s temperature\n  (e.g. its degrees-of-freedom) via the\n  compute_modify command or print this temperature\n  during thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\n  It also means that changing attributes of thermo_temp will have no\n  effect on this fix.\n  Like other fixes that perform thermostatting, this fix can be used\n  with compute commands that calculate a temperature\n  after removing a “bias” from the atom velocities.  E.g. removing the\n  center-of-mass velocity from a group of atoms or only calculating\n  temperature on the x-component of velocity or only calculating\n  temperature for atoms in a geometric region.  This is not done by\n  default, but only if the fix_modify command is used\n  to assign a temperature compute to this fix that includes such a bias\n  term.  See the doc pages for individual compute commands to determine which ones include a bias.  In\n  this case, the thermostat works in the following manner: the current\n  temperature is calculated taking the bias into account, bias is\n  removed from each atom, thermostatting is performed on the remaining\n  thermal degrees of freedom, and the bias is added back in.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  This fix writes the state of the Nose/Hoover thermostat to binary restart files.  See the read_restart\n  command for info on how to re-specify a fix in an input script that\n  reads a restart file, so that the operation of the fix continues in an\n  uninterrupted fashion.\n  The fix_modify temp option is supported by this\n  fix.  You can use it to assign a compute you have\n  defined to this fix which will be used in its thermostatting\n  procedure.\n  The fix_modify energy option is supported by this\n  fix to add the energy change induced by Nose/Hoover thermostatting to\n  the system’s potential energy as part of thermodynamic output.\n  This fix computes the same global scalar and global vector of\n  quantities as does the fix nvt command.\n  This fix can ramp its target temperature over multiple runs, using the\n  start and stop keywords of the run command.  See the\n  run command for details of how to do this.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID nvt/sllod keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  nvt/sllod = style name of this fix command\n  additional thermostat related keyword/value pairs from the fix nvt command can be appended\n  \n  ",
    "examples": "fix 1 all nvt/sllod temp 300.0 300.0 100.0\n  fix 1 all nvt/sllod temp 300.0 300.0 100.0 drag 0.2\n  \n  \n  ",
    "restrictions": "This fix works best without Nose-Hoover chain thermostats, i.e. using\n  tchain = 1.  Setting tchain to larger values can result in poor\n  equilibration.\n  "
},
{
    "command": "fix nvt/sllod/eff",
    "description": "Perform constant NVT integration to update positions and velocities\n  each timestep for nuclei and electrons in the group for the electron force field model, using a Nose/Hoover temperature\n  thermostat.  V is volume; T is temperature.  This creates a system\n  trajectory consistent with the canonical ensemble.\n  The operation of this fix is exactly like that described by the fix nvt/sllod command, except that the radius and\n  radial velocity of electrons are also updated and thermostatted.\n  Likewise the temperature calculated by the fix, using the compute it\n  creates (as discussed in the fix nvt, npt, and nph doc\n  page), is performed with a compute temp/deform/eff command that includes\n  the eFF contribution to the temperature from the electron radial\n  velocity.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  This fix writes the state of the Nose/Hoover thermostat to binary restart files.  See the read_restart\n  command for info on how to re-specify a fix in an input script that\n  reads a restart file, so that the operation of the fix continues in an\n  uninterrupted fashion.\n  The fix_modify temp option is supported by this\n  fix.  You can use it to assign a compute you have\n  defined to this fix which will be used in its thermostatting\n  procedure.\n  The fix_modify energy option is supported by this\n  fix to add the energy change induced by Nose/Hoover thermostatting to\n  the system’s potential energy as part of thermodynamic output.\n  This fix computes the same global scalar and global vector of\n  quantities as does the fix nvt/eff command.\n  This fix can ramp its target temperature over multiple runs, using the\n  start and stop keywords of the run command.  See the\n  run command for details of how to do this.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID nvt/sllod/eff keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  nvt/sllod/eff = style name of this fix command\n  additional thermostat related keyword/value pairs from the fix nvt/eff command can be appended\n  \n  ",
    "examples": "fix 1 all nvt/sllod/eff temp 300.0 300.0 0.1\n  fix 1 all nvt/sllod/eff temp 300.0 300.0 0.1 drag 0.2\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-EFF package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  This fix works best without Nose-Hoover chain thermostats, i.e. using\n  tchain = 1.  Setting tchain to larger values can result in poor\n  equilibration.\n  "
},
{
    "command": "fix nvt/sphere",
    "description": "Perform constant NVT integration to update position, velocity, and\n  angular velocity each timestep for finite-size spherical particles in\n  the group using a Nose/Hoover temperature thermostat.  V is volume; T\n  is temperature.  This creates a system trajectory consistent with the\n  canonical ensemble.\n  This fix differs from the fix nvt command, which\n  assumes point particles and only updates their position and velocity.\n  The thermostat is applied to both the translational and rotational\n  degrees of freedom for the spherical particles, assuming a compute is\n  used which calculates a temperature that includes the rotational\n  degrees of freedom (see below).  The translational degrees of freedom\n  can also have a bias velocity removed from them before thermostatting\n  takes place; see the description below.\n  If the disc keyword is used, then each particle is treated as a 2d\n  disc (circle) instead of as a sphere.  This is only possible for 2d\n  simulations, as defined by the dimension keyword.\n  The only difference between discs and spheres in this context is their\n  moment of inertia, as used in the time integration.\n  Additional parameters affecting the thermostat are specified by\n  keywords and values documented with the fix nvt\n  command.  See, for example, discussion of the temp and drag\n  keywords.\n  This fix computes a temperature each timestep.  To do this, the fix\n  creates its own compute of style “temp/sphere”, as if this command\n  had been issued:\n  compute fix-ID_temp group-ID temp/sphere\n  \n  \n  See the compute temp/sphere command for\n  details.  Note that the ID of the new compute is the fix-ID +\n  underscore + “temp”, and the group for the new compute is the same as\n  the fix group.\n  Note that this is NOT the compute used by thermodynamic output (see\n  the thermo_style command) with ID = thermo_temp.\n  This means you can change the attributes of this fix’s temperature\n  (e.g. its degrees-of-freedom) via the\n  compute_modify command or print this temperature\n  during thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\n  It also means that changing attributes of thermo_temp will have no\n  effect on this fix.\n  Like other fixes that perform thermostatting, this fix can be used\n  with compute commands that calculate a temperature\n  after removing a “bias” from the atom velocities.  E.g. removing the\n  center-of-mass velocity from a group of atoms or only calculating\n  temperature on the x-component of velocity or only calculating\n  temperature for atoms in a geometric region.  This is not done by\n  default, but only if the fix_modify command is used\n  to assign a temperature compute to this fix that includes such a bias\n  term.  See the doc pages for individual compute commands to determine which ones include a bias.  In\n  this case, the thermostat works in the following manner: the current\n  temperature is calculated taking the bias into account, bias is\n  removed from each atom, thermostatting is performed on the remaining\n  thermal degrees of freedom, and the bias is added back in.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  This fix writes the state of the Nose/Hoover thermostat to binary restart files.  See the read_restart\n  command for info on how to re-specify a fix in an input script that\n  reads a restart file, so that the operation of the fix continues in an\n  uninterrupted fashion.\n  The fix_modify temp option is supported by this\n  fix.  You can use it to assign a compute you have\n  defined to this fix which will be used in its thermostatting\n  procedure.\n  The fix_modify energy option is supported by this\n  fix to add the energy change induced by Nose/Hoover thermostatting to\n  the system’s potential energy as part of thermodynamic output.\n  This fix computes the same global scalar and global vector of\n  quantities as does the fix nvt command.\n  This fix can ramp its target temperature over multiple runs, using the\n  start and stop keywords of the run command.  See the\n  run command for details of how to do this.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID nvt/sphere keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  nvt/sphere = style name of this fix command\n  zero or more keyword/value pairs may be appended\n  keyword = disc\n  disc value = none = treat particles as 2d discs, not spheres\n  \n  additional thermostat related keyword/value pairs from the fix nvt command can be appended\n  \n  ",
    "examples": "fix 1 all nvt/sphere temp 300.0 300.0 100.0\n  fix 1 all nvt/sphere temp 300.0 300.0 100.0 disc\n  fix 1 all nvt/sphere temp 300.0 300.0 100.0 drag 0.2\n  \n  \n  ",
    "restrictions": "This fix requires that atoms store torque and angular velocity (omega)\n  and a radius as defined by the atom_style sphere\n  command.\n  All particles in the group must be finite-size spheres.  They cannot\n  be point particles.\n  Use of the disc keyword is only allowed for 2d simulations, as\n  defined by the dimension keyword.\n  "
},
{
    "command": "fix oneway",
    "description": "Enforce that particles in the group and in a given region can only\n  move in one direction.  This is done by reversing a particle’s\n  velocity component, if it has the wrong sign in the specified\n  dimension.  The effect is that the particle moves in one direction\n  only.\n  This can be used, for example, as a simple model of a semi-permeable\n  membrane, or as an implementation of Maxwell’s demon.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID oneway N region-ID direction\n  \n  \n  \n  ID, group-ID are documented in fix command\n  oneway = style name of this fix command\n  N = apply this fix every this many timesteps\n  region-ID = ID of region where fix is active\n  direction = x or -x or y or -y or z or -z = coordinate and direction of the oneway constraint\n  \n  ",
    "examples": "fix ions oneway 10 semi -x\n  fix all oneway 1 left -z\n  fix all oneway 1 right z\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix orient/fcc",
    "description": "The fix applies an orientation-dependent force to atoms near a planar\n  grain boundary which can be used to induce grain boundary migration\n  (in the direction perpendicular to the grain boundary plane).  The\n  motivation and explanation of this force and its application are\n  described in (Janssens). The adaptation to bcc crystals\n  is described in (Wicaksono1). The computed force is only\n  applied to atoms in the fix group.\n  The basic idea is that atoms in one grain (on one side of the\n  boundary) have a potential energy dE added to them.  Atoms in the\n  other grain have 0.0 potential energy added.  Atoms near the boundary\n  (whose neighbor environment is intermediate between the two grain\n  orientations) have an energy between 0.0 and dE added.  This creates\n  an effective driving force to reduce the potential energy of atoms\n  near the boundary by pushing them towards one of the grain\n  orientations.  For dir = 1 and dE > 0, the boundary will thus move so\n  that the grain described by file0 grows and the grain described by\n  file1 shrinks.  Thus this fix is designed for simulations of two-grain\n  systems, either with one grain boundary and free surfaces parallel to\n  the boundary, or a system with periodic boundary conditions and two\n  equal and opposite grain boundaries.  In either case, the entire\n  system can displace during the simulation, and such motion should be\n  accounted for in measuring the grain boundary velocity.\n  The potential energy added to atom I is given by these formulas\n  \n  \\[\\begin{split} \\xi_{i} = & \\sum_{j=1}^{12} \\left| \\mathbf{r}_{j} - \\mathbf{r}_{j}^{\\rm I} \\right| \\qquad\\qquad\\left(1\\right) \\\\\n   \\\\\n  \\xi_{\\rm IJ} = & \\sum_{j=1}^{12} \\left| \\mathbf{r}_{j}^{\\rm J} - \\mathbf{r}_{j}^{\\rm I} \\right| \\qquad\\qquad\\left(2\\right)\\\\\n  \\\\\n  \\xi_{\\rm low}  = & {\\rm cutlo} \\, \\xi_{\\rm IJ}  \\qquad\\qquad\\qquad\\left(3\\right)\\\\\n  \\xi_{\\rm high}  = & {\\rm cuthi} \\, \\xi_{\\rm IJ} \\qquad\\qquad\\qquad\\left(4\\right) \\\\\n  \\\\\n  \\omega_{i} = & \\frac{\\pi}{2} \\frac{\\xi_{i} - \\xi_{\\rm low}}{\\xi_{\\rm high} - \\xi_{\\rm low}} \\qquad\\qquad\\left(5\\right)\\\\\n  \\\\\n  u_{i}  = & 0 \\quad\\quad\\qquad\\qquad\\qquad \\textrm{ for } \\qquad \\xi_{i} < \\xi_{\\rm low}\\\\\n         = & {\\rm dE}\\,\\frac{1 - \\cos(2 \\omega_{i})}{2}\n   \\qquad \\mathrm{ for }\\qquad \\xi_{\\rm low} < \\xi_{i} < \\xi_{\\rm high}  \\quad \\left(6\\right) \\\\\n         = & {\\rm dE} \\quad\\qquad\\qquad\\qquad\\textrm{ for } \\qquad \\xi_{\\rm high} < \\xi_{i}\\end{split}\\]\n  which are fully explained in (Janssens).  For fcc crystals\n  this order parameter Xi for atom I in equation (1) is a sum over the\n  12 nearest neighbors of atom I. For bcc crystals it is the\n  corresponding sum of the 8 nearest neighbors. Rj is the vector from\n  atom I to its neighbor J, and RIj is a vector in the reference\n  (perfect) crystal.  That is, if dir = 0/1, then RIj is a vector to an\n  atom coord from file 0/1.  Equation (2) gives the expected value of\n  the order parameter XiIJ in the other grain.  Hi and lo cutoffs are\n  defined in equations (3) and (4), using the input parameters cutlo\n  and cuthi as thresholds to avoid adding grain boundary energy when\n  the deviation in the order parameter from 0 or 1 is small (e.g. due to\n  thermal fluctuations in a perfect crystal).  The added potential\n  energy Ui for atom I is given in equation (6) where it is interpolated\n  between 0 and dE using the two threshold Xi values and the Wi value of\n  equation (5).\n  The derivative of this energy expression gives the force on each atom\n  which thus depends on the orientation of its neighbors relative to the\n  2 grain orientations.  Only atoms near the grain boundary feel a net\n  force which tends to drive them to one of the two grain orientations.\n  In equation (1), the reference vector used for each neighbor is the\n  reference vector closest to the actual neighbor position.  This means\n  it is possible two different neighbors will use the same reference\n  vector.  In such cases, the atom in question is far from a perfect\n  orientation and will likely receive the full dE addition, so the\n  effect of duplicate reference vector usage is small.\n  The dir parameter determines which grain wants to grow at the\n  expense of the other.  A value of 0 means the first grain will shrink;\n  a value of 1 means it will grow.  This assumes that dE is positive.\n  The reverse will be true if dE is negative.\n  The alat parameter is the cubic lattice constant for the fcc or bcc\n  material and is only used to compute a cutoff distance of 1.57 * alat\n  / sqrt(2) for finding the 12 or 8 nearest neighbors of each atom\n  (which should be valid for an fcc or bcc crystal).  A longer/shorter\n  cutoff can be imposed by adjusting alat.  If a particular atom has\n  less than 12 or 8 neighbors within the cutoff, the order parameter of\n  equation (1) is effectively multiplied by 12 or 8 divided by the\n  actual number of neighbors within the cutoff.\n  The dE parameter is the maximum amount of additional energy added to\n  each atom in the grain which wants to shrink.\n  The cutlo and cuthi parameters are used to reduce the force added\n  to bulk atoms in each grain far away from the boundary.  An atom in\n  the bulk surrounded by neighbors at the ideal grain orientation would\n  compute an order parameter of 0 or 1 and have no force added.\n  However, thermal vibrations in the solid will cause the order\n  parameters to be greater than 0 or less than 1.  The cutoff parameters\n  mask this effect, allowing forces to only be added to atoms with\n  order-parameters between the cutoff values.\n  File0 and file1 are filenames for the two grains which each\n  contain 6 vectors (6 lines with 3 values per line) which specify the\n  grain orientations.  Each vector is a displacement from a central atom\n  (0,0,0) to a nearest neighbor atom in an fcc lattice at the proper\n  orientation.  The vector lengths should all be identical since an fcc\n  lattice has a coordination number of 12.  Only 6 are listed due to\n  symmetry, so the list must include one from each pair of\n  equal-and-opposite neighbors.  A pair of orientation files for a\n  Sigma=5 tilt boundary are shown below. A tutorial that can help for\n  writing the orientation files is given in (Wicaksono2)\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The fix_modify energy option is supported by this\n  fix to add the potential energy of atom interactions with the grain\n  boundary driving force to the system’s potential energy as part of\n  thermodynamic output.\n  The fix_modify respa option is supported by these\n  fixes. This allows to set at which level of the r-RESPA\n  integrator a fix is adding its forces. Default is the outermost level.\n  This fix calculates a global scalar which can be accessed by various\n  output commands.  The scalar is the potential\n  energy change due to this fix.  The scalar value calculated by this\n  fix is “extensive”.\n  This fix also calculates a per-atom array which can be accessed by\n  various output commands.  The array stores the\n  order parameter Xi and normalized order parameter (0 to 1) for each\n  atom.  The per-atom values can be accessed on any timestep.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID oneway N region-ID direction\n  \n  \n  \n  ID, group-ID are documented in fix command\n  oneway = style name of this fix command\n  N = apply this fix every this many timesteps\n  region-ID = ID of region where fix is active\n  direction = x or -x or y or -y or z or -z = coordinate and direction of the oneway constraint\n  \n  ",
    "examples": "fix gb all orient/fcc 0 1 4.032008 0.001 0.25 0.75 xi.vec chi.vec\n  fix gb all orient/bcc 0 1 2.882 0.001 0.25 0.75 ngb.left ngb.right\n  \n  \n  ",
    "restrictions": "This fix is part of the MISC package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  This fix should only be used with fcc or bcc lattices.\n  "
},
{
    "command": "fix phonon",
    "description": "Calculate the dynamical matrix from molecular dynamics simulations\n  based on fluctuation-dissipation theory for a group of atoms.\n  Consider a crystal with \\(N\\) unit cells in three dimensions labeled\n  \\(l = (l_1, l_2, l_3)\\) where \\(l_i\\) are integers.  Each unit cell is\n  defined by three linearly independent vectors \\(\\mathbf{a}_1\\),\n  \\(\\mathbf{a}_2\\), \\(\\mathbf{a}_3\\) forming a parallelepiped,\n  containing \\(K\\) basis atoms labeled \\(k\\).\n  Based on fluctuation-dissipation theory, the force constant\n  coefficients of the system in reciprocal space are given by\n  (Campana , Kong)\n  \n  \\[\\mathbf{\\Phi}_{k\\alpha,k^\\prime \\beta}(\\mathbf{q}) = k_B T \\mathbf{G}^{-1}_{k\\alpha,k^\\prime \\beta}(\\mathbf{q})\\]\n  where \\(\\mathbf{G}\\) is the Green’s functions coefficients given by\n  \n  \\[\\mathbf{G}_{k\\alpha,k^\\prime \\beta}(\\mathbf{q}) = \\left< \\mathbf{u}_{k\\alpha}(\\mathbf{q}) \\bullet \\mathbf{u}_{k^\\prime \\beta}^*(\\mathbf{q}) \\right>\\]\n  where \\(\\left< \\ldots \\right>\\) denotes the ensemble average, and\n  \n  \\[\\mathbf{u}_{k\\alpha}(\\mathbf{q}) = \\sum_l \\mathbf{u}_{l k \\alpha} \\exp{(i\\mathbf{qr}_l)}\\]\n  is the \\(\\alpha\\) component of the atomic displacement for the \\(k\\)\n  th atom in the unit cell in reciprocal space at \\(\\mathbf{q}\\). In\n  practice, the Green’s functions coefficients can also be measured\n  according to the following formula,\n  \n  \\[\\mathbf{G}_{k\\alpha,k^\\prime \\beta}(\\mathbf{q}) =\n  \\left< \\mathbf{R}_{k \\alpha}(\\mathbf{q}) \\bullet \\mathbf{R}^*_{k^\\prime \\beta}(\\mathbf{q}) \\right>\n  - \\left<\\mathbf{R}\\right>_{k \\alpha}(\\mathbf{q}) \\bullet \\left<\\mathbf{R}\\right>^*_{k^\\prime \\beta}(\\mathbf{q})\\]\n  where \\(\\mathbf{R}\\) is the instantaneous positions of atoms, and\n  \\(\\left<\\mathbf{R}\\right>\\) is the averaged atomic positions. It\n  gives essentially the same results as the displacement method and is\n  easier to implement in an MD code.\n  Once the force constant matrix is known, the dynamical matrix\n  \\(\\mathbf{D}\\) can then be obtained by\n  \n  \\[\\mathbf{D}_{k\\alpha, k^\\prime\\beta}(\\mathbf{q}) =\n  (m_k m_{k^\\prime})^{-\\frac{1}{2}} \\mathbf{\\Phi}_{k \\alpha, k^\\prime \\beta}(\\mathbf{q})\\]\n  whose eigenvalues are exactly the phonon frequencies at \\(\\mathbf{q}\\).\n  This fix uses positions of atoms in the specified group and calculates\n  two-point correlations.  To achieve this. the positions of the atoms\n  are examined every Nevery steps and are Fourier-transformed into\n  reciprocal space, where the averaging process and correlation\n  computation is then done.  After every Noutput measurements, the\n  matrix \\(\\mathbf{G}(\\mathbf{q})\\) is calculated and inverted to\n  obtain the elastic stiffness coefficients.  The dynamical matrices are\n  then constructed and written to prefix.bin.timestep files in binary\n  format and to the file prefix.log for each wave-vector\n  \\(\\mathbf{q}\\).\n  A detailed description of this method can be found in\n  (Kong2011).\n  The sysdim keyword is optional.  If specified with a value smaller\n  than the dimensionality of the LAMMPS simulation, its value is used\n  for the dynamical matrix calculation.  For example, using LAMMPS ot\n  model a 2D or 3D system, the phonon dispersion of a 1D atomic chain\n  can be computed using sysdim = 1.\n  The nasr keyword is optional.  An iterative procedure is employed to\n  enforce the acoustic sum rule on \\(\\Phi\\) at \\(\\Gamma\\), and the number\n  provided by keyword nasr gives the total number of iterations. For a\n  system whose unit cell has only one atom, nasr = 1 is sufficient;\n  for other systems, nasr = 10 is typically sufficient.\n  The map_file contains the mapping information between the lattice\n  indices and the atom IDs, which tells the code which atom sits at\n  which lattice point; the lattice indices start from 0. An auxiliary\n  code, latgen, can be employed to\n  generate the compatible map file for various crystals.\n  In case one simulates a non-periodic system, where the whole simulation\n  box is treated as a unit cell, one can set map_file as GAMMA, so\n  that the mapping info will be generated internally and a file is not\n  needed. In this case, the dynamical matrix at only the gamma-point\n  will/can be evaluated. Please keep in mind that fix-phonon is designed\n  for cyrstals, it will be inefficient and even degrade the performance\n  of lammps in case the unit cell is too large.\n  The calculated dynamical matrix elements are written out in\n  energy/distance^2/mass units.  The coordinates for q\n  points in the log file is in the units of the basis vectors of the\n  corresponding reciprocal lattice.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The fix_modify temp option is supported by this\n  fix. You can use it to change the temperature compute from thermo_temp\n  to the one that reflects the true temperature of atoms in the group.\n  No global scalar or vector or per-atom quantities are stored by this\n  fix for access by various output commands.\n  Instead, this fix outputs its initialization information (including\n  mapping information) and the calculated dynamical matrices to the file\n  prefix.log, with the specified prefix.  The dynamical matrices are\n  also written to files prefix.bin.timestep in binary format.  These\n  can be read by the post-processing tool in tools/phonon to compute the\n  phonon density of states and/or phonon dispersion curves.\n  No parameter of this fix can be used with the start/stop keywords\n  of the run command.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID phonon N Noutput Nwait map_file prefix keyword values ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  phonon = style name of this fix command\n  N = measure the Green’s function every this many timesteps\n  Noutput = output the dynamical matrix every this many measurements\n  Nwait = wait this many timesteps before measuring\n  map_file = file or GAMMA\n  file is the file that contains the mapping info between atom ID and the lattice indices.\n  GAMMA flags to treate the whole simulation box as a unit cell, so that the mapping\n  info can be generated internally. In this case, dynamical matrix at only the gamma-point\n  will/can be evaluated.\n  \n  prefix = prefix for output files\n  one or none keyword/value pairs may be appended\n  keyword = sysdim or nasr\n  sysdim value = d\n    d = dimension of the system, usually the same as the MD model dimension\n  nasr value = n\n    n = number of iterations to enforce the acoustic sum rule\n  \n  \n  ",
    "examples": "fix 1 all phonon 20 5000 200000 map.in LJ1D sysdim 1\n  fix 1 all phonon 20 5000 200000 map.in EAM3D\n  fix 1 all phonon 10 5000 500000 GAMMA EAM0D nasr 100\n  \n  \n  ",
    "restrictions": "This fix assumes a crystalline system with periodical lattice. The\n  temperature of the system should not exceed the melting temperature to\n  keep the system in its solid state.\n  This fix is part of the USER-PHONON package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  This fix requires LAMMPS be built with an FFT library.  See the Build settings doc page for details.\n  "
},
{
    "command": "fix pimd",
    "description": "This command performs quantum molecular dynamics simulations based on\n  the Feynman path integral to include effects of tunneling and\n  zero-point motion.  In this formalism, the isomorphism of a quantum\n  partition function for the original system to a classical partition\n  function for a ring-polymer system is exploited, to efficiently sample\n  configurations from the canonical ensemble (Feynman).\n  The classical partition function and its components are given\n  by the following equations:\n  \n  \\[\\begin{split}Z = & \\int d{\\bf q} d{\\bf p} \\cdot \\textrm{exp} [ -\\beta H_{eff} ] \\\\\n  H_{eff} = & \\bigg(\\sum_{i=1}^P \\frac{p_i^2}{2m_i}\\bigg) + V_{eff} \\\\\n  V_{eff} = & \\sum_{i=1}^P \\bigg[ \\frac{mP}{2\\beta^2 \\hbar^2} (q_i - q_{i+1})^2 + \\frac{1}{P} V(q_i)\\bigg]\\end{split}\\]\n  The interested user is referred to any of the numerous references on\n  this methodology, but briefly, each quantum particle in a path\n  integral simulation is represented by a ring-polymer of P quasi-beads,\n  labeled from 1 to P.  During the simulation, each quasi-bead interacts\n  with beads on the other ring-polymers with the same imaginary time\n  index (the second term in the effective potential above).  The\n  quasi-beads also interact with the two neighboring quasi-beads through\n  the spring potential in imaginary-time space (first term in effective\n  potential).  To sample the canonical ensemble, a Nose-Hoover massive\n  chain thermostat is applied (Tuckerman).  With the\n  massive chain algorithm, a chain of NH thermostats is coupled to each\n  degree of freedom for each quasi-bead.  The keyword temp sets the\n  target temperature for the system and the keyword nhc sets the\n  number Nc of thermostats in each chain.  For example, for a\n  simulation of N particles with P beads in each ring-polymer, the total\n  number of NH thermostats would be 3 x N x P x Nc.\n  \n  Note\n  This fix implements a complete velocity-verlet integrator\n  combined with NH massive chain thermostat, so no other time\n  integration fix should be used.\n  \n  The method keyword determines what style of PIMD is performed.  A\n  value of pimd is standard PIMD.  A value of nmpimd is for\n  normal-mode PIMD.  A value of cmd is for centroid molecular dynamics\n  (CMD).  The difference between the styles is as follows.\n  In standard PIMD, the value used for a bead’s fictitious mass is\n  arbitrary.  A common choice is to use Mi = m/P, which results in the\n  mass of the entire ring-polymer being equal to the real quantum\n  particle.  But it can be difficult to efficiently integrate the\n  equations of motion for the stiff harmonic interactions in the ring\n  polymers.\n  A useful way to resolve this issue is to integrate the equations of\n  motion in a normal mode representation, using Normal Mode\n  Path-Integral Molecular Dynamics (NMPIMD) (Cao1).  In NMPIMD,\n  the NH chains are attached to each normal mode of the ring-polymer and\n  the fictitious mass of each mode is chosen as Mk = the eigenvalue of\n  the Kth normal mode for k > 0. The k = 0 mode, referred to as the\n  zero-frequency mode or centroid, corresponds to overall translation of\n  the ring-polymer and is assigned the mass of the real particle.\n  Motion of the centroid can be effectively uncoupled from the other\n  normal modes by scaling the fictitious masses to achieve a partial\n  adiabatic separation.  This is called a Centroid Molecular Dynamics\n  (CMD) approximation (Cao2).  The time-evolution (and resulting\n  dynamics) of the quantum particles can be used to obtain centroid time\n  correlation functions, which can be further used to obtain the true\n  quantum correlation function for the original system.  The CMD method\n  also uses normal modes to evolve the system, except only the k > 0\n  modes are thermostatted, not the centroid degrees of freedom.\n  The keyword fmass sets a further scaling factor for the fictitious\n  masses of beads, which can be used for the Partial Adiabatic CMD\n  (Hone), or to be set as P, which results in the fictitious\n  masses to be equal to the real particle masses.\n  The keyword sp is a scaling factor on Planck’s constant, which can\n  be useful for debugging or other purposes.  The default value of 1.0\n  is appropriate for most situations.\n  The PIMD algorithm in LAMMPS is implemented as a hyper-parallel scheme\n  as described in (Calhoun).  In LAMMPS this is done by using\n  multi-replica feature in LAMMPS, where each\n  quasi-particle system is stored and simulated on a separate partition\n  of processors.  The following diagram illustrates this approach.  The\n  original system with 2 ring polymers is shown in red.  Since each ring\n  has 4 quasi-beads (imaginary time slices), there are 4 replicas of the\n  system, each running on one of the 4 partitions of processors.  Each\n  replica (shown in green) owns one quasi-bead in each ring.\n  \n  To run a PIMD simulation with M quasi-beads in each ring polymer using\n  N MPI tasks for each partition’s domain-decomposition, you would use P\n  = MxN processors (cores) and run the simulation as follows:\n  mpirun -np P lmp_mpi -partition MxN -in script\n  \n  \n  Note that in the LAMMPS input script for a multi-partition simulation,\n  it is often very useful to define a uloop-style variable such as\n  variable ibead uloop M pad\n  \n  \n  where M is the number of quasi-beads (partitions) used in the\n  calculation.  The uloop variable can then be used to manage I/O\n  related tasks for each of the partitions, e.g.\n  dump dcd all dcd 10 system_${ibead}.dcd\n  restart 1000 system_${ibead}.restart1 system_${ibead}.restart2\n  read_restart system_${ibead}.restart2\n  \n  \n  ",
    "syntax": "fix ID group-ID pimd keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  pimd = style name of this fix command\n  zero or more keyword/value pairs may be appended\n  keyword = method or fmass or sp or temp or nhc\n  method value = pimd or nmpimd or cmd\n  fmass value = scaling factor on mass\n  sp value = scaling factor on Planck constant\n  temp value = temperature (temperarate units)\n  nhc value = Nc = number of chains in Nose-Hoover thermostat\n  \n  \n  ",
    "examples": "fix 1 all pimd method nmpimd fmass 1.0 sp 2.0 temp 300.0 nhc 4\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  A PIMD simulation can be initialized with a single data file read via\n  the read_data command.  However, this means all\n  quasi-beads in a ring polymer will have identical positions and\n  velocities, resulting in identical trajectories for all quasi-beads.\n  To avoid this, users can simply initialize velocities with different\n  random number seeds assigned to each partition, as defined by the\n  uloop variable, e.g.\n  velocity all create 300.0 1234${ibead} rot yes dist gaussian\n  \n  \n  "
},
{
    "command": "fix planeforce",
    "description": "Adjust the forces on each atom in the group so that only the\n  components of force in the plane specified by the normal vector\n  (x,y,z) remain.  This is done by subtracting out the component of\n  force perpendicular to the plane.\n  If the initial velocity of the atom is 0.0 (or in the plane), then it\n  should continue to move in the plane thereafter.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  The forces due to this fix are imposed during an energy minimization,\n  invoked by the minimize command.\n  ",
    "syntax": "fix ID group-ID planeforce x y z\n  \n  \n  \n  ID, group-ID are documented in fix command\n  planeforce = style name of this fix command\n  x y z = 3-vector that is normal to the plane\n  \n  ",
    "examples": "fix hold boundary planeforce 1.0 0.0 0.0\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix plumed",
    "description": "This fix instructs LAMMPS to call the PLUMED library, which\n  allows one to perform various forms of trajectory analysis on the fly\n  and to also use methods such as umbrella sampling and metadynamics to\n  enhance the sampling of phase space.\n  The documentation included here only describes the fix plumed command\n  itself.  This command is LAMMPS specific, whereas most of the\n  functionality implemented in PLUMED will work with a range of MD codes,\n  and when PLUMED is used as a stand alone code for analysis.  The full\n  documentation for PLUMED is available online and included\n  in the PLUMED source code.  The PLUMED library development is hosted at\n  https://github.com/plumed/plumed2\n  A detailed discussion of the code can be found in (PLUMED).\n  There is an example input for using this package with LAMMPS in the\n  examples/USER/plumed directory.\n  \n  The command to make LAMMPS call PLUMED during a run requires two keyword\n  value pairs pointing to the PLUMED input file and an output file for the\n  PLUMED log. The user must specify these arguments every time PLUMED is\n  to be used.  Furthermore, the fix plumed command should appear in the\n  LAMMPS input file after relevant input parameters (e.g. the timestep)\n  have been set.\n  The group-ID entry is ignored. LAMMPS will always pass all the atoms\n  to PLUMED and there can only be one instance of the plumed fix at a\n  time. The way the plumed fix is implemented ensures that the minimum\n  amount of information required is communicated.  Furthermore, PLUMED\n  supports multiple, completely independent collective variables, multiple\n  independent biases and multiple independent forms of analysis.  There is\n  thus really no restriction in functionality by only allowing only one\n  plumed fix in the LAMMPS input.\n  The plumedfile keyword allows the user to specify the name of the\n  PLUMED input file.  Instructions as to what should be included in a\n  plumed input file can be found in the documentation for PLUMED\n  The outfile keyword allows the user to specify the name of a file in\n  which to output the PLUMED log.  This log file normally just repeats the\n  information that is contained in the input file to confirm it was\n  correctly read and parsed.  The names of the files in which the results\n  are stored from the various analysis options performed by PLUMED will\n  be specified by the user in the PLUMED input file.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  When performing a restart of a calculation that involves PLUMED you must\n  include a RESTART command in the PLUMED input file as detailed in the\n  PLUMED documentation.  When the restart command is found in\n  the PLUMED input PLUMED will append to the files that were generated in\n  the run that was performed previously.  No part of the PLUMED restart\n  data is included in the LAMMPS restart files.  Furthermore, any history\n  dependent bias potentials that were accumulated in previous calculations\n  will be read in when the RESTART command is included in the PLUMED\n  input.\n  The fix_modify energy option is not supported by\n  this fix.\n  Nothing is computed by this fix that can be accessed by any of the\n  output commands within LAMMPS.  All the quantities\n  of interest can be output by commands that are native to PLUMED,\n  however.\n  ",
    "syntax": "fix ID group-ID plumed keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  plumed = style name of this fix command\n  keyword = plumedfile or outfile\n  plumedfile arg = name of PLUMED input file to use (default: NULL)\n  outfile arg = name of file on which to write the PLUMED log (default: NULL)\n  \n  \n  ",
    "examples": "fix pl all plumed all plumed plumedfile plumed.dat outfile p.log\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-PLUMED package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  There can only be one plumed fix active at a time.\n  "
},
{
    "command": "fix poems",
    "description": "Treats one or more sets of atoms as coupled rigid bodies.  This means\n  that each timestep the total force and torque on each rigid body is\n  computed and the coordinates and velocities of the atoms are updated\n  so that the collection of bodies move as a coupled set.  This can be\n  useful for treating a large biomolecule as a collection of connected,\n  coarse-grained particles.\n  The coupling, associated motion constraints, and time integration is\n  performed by the software package Parallelizable Open source Efficient Multibody Software (POEMS) which computes the\n  constrained rigid-body motion of articulated (jointed) multibody\n  systems (Anderson).  POEMS was written and is distributed\n  by Prof Kurt Anderson, his graduate student Rudranarayan Mukherjee,\n  and other members of his group at Rensselaer Polytechnic Institute\n  (RPI).  Rudranarayan developed the LAMMPS/POEMS interface.  For\n  copyright information on POEMS and other details, please refer to the\n  documents in the poems directory distributed with LAMMPS.\n  This fix updates the positions and velocities of the rigid atoms with\n  a constant-energy time integration, so you should not update the same\n  atoms via other fixes (e.g. nve, nvt, npt, temp/rescale, langevin).\n  Each body must have a non-degenerate inertia tensor, which means if\n  must contain at least 3 non-collinear atoms.  Which atoms are in which\n  bodies can be defined via several options.\n  For option group, each of the listed groups is treated as a rigid\n  body.  Note that only atoms that are also in the fix group are\n  included in each rigid body.\n  For option molecule, each set of atoms in the group with a different\n  molecule ID is treated as a rigid body.\n  For option file, sets of atoms are read from the specified file and\n  each set is treated as a rigid body.  Each line of the file specifies\n  a rigid body in the following format:\n  ID type atom1-ID atom2-ID atom3-ID …\n  ID as an integer from 1 to M (the number of rigid bodies).  Type is\n  any integer; it is not used by the fix poems command.  The remaining\n  arguments are IDs of atoms in the rigid body, each typically from 1 to\n  N (the number of atoms in the system).  Only atoms that are also in\n  the fix group are included in each rigid body.  Blank lines and lines\n  that begin with ‘#’ are skipped.\n  A connection between a pair of rigid bodies is inferred if one atom is\n  common to both bodies.  The POEMS solver treats that atom as a\n  spherical joint with 3 degrees of freedom.  Currently, a collection of\n  bodies can only be connected by joints as a linear chain.  The entire\n  collection of rigid bodies can represent one or more chains.  Other\n  connection topologies (tree, ring) are not allowed, but will be added\n  later.  Note that if no joints exist, it is more efficient to use the\n  fix rigid command to simulate the system.\n  When the poems fix is defined, it will print out statistics on the\n  total # of clusters, bodies, joints, atoms involved.  A cluster in\n  this context means a set of rigid bodies connected by joints.\n  For computational efficiency, you should turn off pairwise and bond\n  interactions within each rigid body, as they no longer contribute to\n  the motion.  The “neigh_modify exclude” and “delete_bonds” commands\n  can be used to do this if each rigid body is a group.\n  For computational efficiency, you should only define one fix poems\n  which includes all the desired rigid bodies.  LAMMPS will allow\n  multiple poems fixes to be defined, but it is more expensive.\n  The degrees-of-freedom removed by coupled rigid bodies are accounted\n  for in temperature and pressure computations.  Similarly, the rigid\n  body contribution to the pressure virial is also accounted for.  The\n  latter is only correct if forces within the bodies have been turned\n  off, and there is only a single fix poems defined.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The fix_modify bodyforces option is supported by\n  this fix style to set whether per-body forces and torques are computed\n  early or late in a timestep, i.e. at the post-force stage or at the\n  final-integrate stage, respectively.\n  No global or per-atom quantities are stored by this fix for access by\n  various output commands.  No parameter of this fix\n  can be used with the start/stop keywords of the run\n  command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID plumed keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  plumed = style name of this fix command\n  keyword = plumedfile or outfile\n  plumedfile arg = name of PLUMED input file to use (default: NULL)\n  outfile arg = name of file on which to write the PLUMED log (default: NULL)\n  \n  \n  ",
    "examples": "fix 3 fluid poems group clump1 clump2 clump3\n  fix 3 fluid poems file cluster.list\n  \n  \n  ",
    "restrictions": "This fix is part of the POEMS package.  It is only enabled if LAMMPS\n  was built with that package, which also requires the POEMS library be\n  built and linked with LAMMPS.  See the Build package doc page for more info.\n  "
},
{
    "command": "fix pour",
    "description": "Insert finite-size particles or molecules into the simulation box\n  every few timesteps within a specified region until N particles or\n  molecules have been inserted.  This is typically used to model the\n  pouring of granular particles into a container under the influence of\n  gravity.  For the remainder of this doc page, a single inserted atom\n  or molecule is referred to as a “particle”.\n  If inserted particles are individual atoms, they are assigned the\n  specified atom type.  If they are molecules, the type of each atom in\n  the inserted molecule is specified in the file read by the\n  molecule command, and those values are added to the\n  specified atom type.  E.g. if the file specifies atom types 1,2,3, and\n  those are the atom types you want for inserted molecules, then specify\n  type = 0.  If you specify type = 2, the in the inserted molecule\n  will have atom types 3,4,5.\n  All atoms in the inserted particle are assigned to two groups: the\n  default group “all” and the group specified in the fix pour command\n  (which can also be “all”).\n  This command must use the region keyword to define an insertion\n  volume.  The specified region must have been previously defined with a\n  region command.  It must be of type block or a z-axis\n  cylinder and must be defined with side = in.  The cylinder style\n  of region can only be used with 3d simulations.\n  Individual atoms are inserted, unless the mol keyword is used.  It\n  specifies a template-ID previously defined using the\n  molecule command, which reads a file that defines the\n  molecule.  The coordinates, atom types, center-of-mass, moments of\n  inertia, etc, as well as any bond/angle/etc and special neighbor\n  information for the molecule can be specified in the molecule file.\n  See the molecule command for details.  The only\n  settings required to be in this file are the coordinates and types of\n  atoms in the molecule.\n  If the molecule template contains more than one molecule, the relative\n  probability of depositing each molecule can be specified by the\n  molfrac keyword.  N relative probabilities, each from 0.0 to 1.0, are\n  specified, where N is the number of molecules in the template.  Each\n  time a molecule is inserted, a random number is used to sample from\n  the list of relative probabilities.  The N values must sum to 1.0.\n  If you wish to insert molecules via the mol keyword, that will be\n  treated as rigid bodies, use the rigid keyword, specifying as its\n  value the ID of a separate fix rigid/small\n  command which also appears in your input script.\n  \n  Note\n  If you wish the new rigid molecules (and other rigid molecules)\n  to be thermostatted correctly via fix rigid/small/nvt\n  or fix rigid/small/npt, then you need to use the\n  “fix_modify dynamic/dof yes” command for the rigid fix.  This is to\n  inform that fix that the molecule count will vary dynamically.\n  \n  If you wish to insert molecules via the mol keyword, that will have\n  their bonds or angles constrained via SHAKE, use the shake keyword,\n  specifying as its value the ID of a separate fix shake command which also appears in your input script.\n  Each timestep particles are inserted, they are placed randomly inside\n  the insertion volume so as to mimic a stream of poured particles.  If\n  they are molecules they are also oriented randomly.  Each atom in the\n  particle is tested for overlaps with existing particles, including\n  effects due to periodic boundary conditions if applicable.  If an\n  overlap is detected, another random insertion attempt is made; see the\n  vol keyword discussion below.  The larger the volume of the\n  insertion region, the more particles that can be inserted at any one\n  timestep.  Particles are inserted again after enough time has elapsed\n  that the previously inserted particles fall out of the insertion\n  volume under the influence of gravity.  Insertions continue every so\n  many timesteps until the desired # of particles has been inserted.\n  \n  Note\n  If you are monitoring the temperature of a system where the\n  particle count is changing due to adding particles, you typically\n  should use the compute_modify dynamic yes\n  command for the temperature compute you are using.\n  \n  \n  All other keywords are optional with defaults as shown below.\n  The diam option is only used when inserting atoms and specifies the\n  diameters of inserted particles.  There are 3 styles: one, range,\n  or poly.  For one, all particles will have diameter D.  For\n  range, the diameter of each particle will be chosen randomly and\n  uniformly between the specified Dlo and Dhi bounds.  For poly, a\n  series of Npoly diameters is specified.  For each diameter a\n  percentage value from 0.0 to 1.0 is also specified.  The Npoly\n  percentages must sum to 1.0.  For the example shown above with “diam 2\n  0.7 0.4 1.5 0.6”, all inserted particles will have a diameter of 0.7\n  or 1.5.  40% of the particles will be small; 60% will be large.\n  Note that for molecule insertion, the diameters of individual atoms in\n  the molecule can be specified in the file read by the\n  molecule command.  If not specified, the diameter of\n  each atom in the molecule has a default diameter of 1.0.\n  The id option has two settings which are used to determine the atom\n  or molecule IDs to assign to inserted particles/molecules.  In both\n  cases a check is done of the current system to find the maximum\n  current atom and molecule ID of any existing particle.  Newly inserted\n  particles and molecules are assigned IDs that increment those max\n  values.  For the max setting, which is the default, this check is\n  done at every insertion step, which allows for particles to leave the\n  system, and their IDs to potentially be re-used.  For the next\n  setting this check is done only once when the fix is specified, which\n  can be more efficient if you are sure particles will not be added in\n  some other way.\n  The vol option specifies what volume fraction of the insertion\n  volume will be filled with particles.  For particles with a size\n  specified by the diam range keyword, they are assumed to all be of\n  maximum diameter Dhi for purposes of computing their contribution to\n  the volume fraction.\n  The higher the volume fraction value, the more particles are inserted\n  each timestep.  Since inserted particles cannot overlap, the maximum\n  volume fraction should be no higher than about 0.6.  Each timestep\n  particles are inserted, LAMMPS will make up to a total of M tries to\n  insert the new particles without overlaps, where M = # of inserted\n  particles * Nattempt.  If LAMMPS is unsuccessful at completing all\n  insertions, it prints a warning.\n  The dens and vel options enable inserted particles to have a range\n  of densities or xy velocities.  The specific values for a particular\n  inserted particle will be chosen randomly and uniformly between the\n  specified bounds.  Internally, the density value for a particle is\n  converted to a mass, based on the radius (volume) of the particle.\n  The vz or vy value for option vel assigns a z-velocity (3d) or\n  y-velocity (2d) to each inserted particle.\n  The rate option moves the insertion volume in the z direction (3d)\n  or y direction (2d).  This enables pouring particles from a\n  successively higher height over time.\n  The ignore option is useful when running a simulation that used line\n  segment (2d) or triangle (3d) particles, typically to define\n  boundaries for spherical granular particles to interact with.  See the\n  atom_style line or tri command for details.  Lines\n  and triangles store their size, and if the size is large it may\n  overlap (in a spherical sense) with the insertion region, even if the\n  line/triangle is oriented such that there is no actual overlap.  This\n  can prevent particles from being inserted.  The ignore keyword\n  causes the overlap check to skip any line or triangle particles.\n  Obviously you should only use it if there is in fact no overlap of the\n  line or triangle particles with the insertion region.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  This means you must be careful when restarting a\n  pouring simulation, when the restart file was written in the middle of\n  the pouring operation.  Specifically, you should use a new fix pour\n  command in the input script for the restarted simulation that\n  continues the operation.  You will need to adjust the arguments of the\n  original fix pour command to do this.\n  Also note that because the state of the random number generator is not\n  saved in restart files, you cannot do “exact” restarts with this fix,\n  where the simulation continues on the same as if no restart had taken\n  place.  However, in a statistical sense, a restarted simulation should\n  produce the same behavior if you adjust the fix pour parameters\n  appropriately.\n  None of the fix_modify options are relevant to this\n  fix.  No global or per-atom quantities are stored by this fix for\n  access by various output commands.  No parameter\n  of this fix can be used with the start/stop keywords of the\n  run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID pour N type seed keyword values ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  pour = style name of this fix command\n  N = # of particles to insert\n  type = atom type to assign to inserted particles (offset for molecule insertion)\n  seed = random # seed (positive integer)\n  one or more keyword/value pairs may be appended to args\n  keyword = region or diam or vol or rate or dens or vel or mol or rigid or shake or ignore\n  region value = region-ID\n    region-ID = ID of region to use as insertion volume\n  diam values = dstyle args\n    dstyle = one or range or poly\n      one args = D\n        D = single diameter for inserted particles (distance units)\n      range args = Dlo Dhi\n        Dlo,Dhi = range of diameters for inserted particles (distance units)\n      poly args = Npoly D1 P1 D2 P2 ...\n        Npoly = # of (D,P) pairs\n        D1,D2,... = diameter for subset of inserted particles (distance units)\n        P1,P2,... = percentage of inserted particles with this diameter (0-1)\n  id values = idflag\n    idflag = max or next = how to choose IDs for inserted particles and molecules\n  vol values = fraction Nattempt\n    fraction = desired volume fraction for filling insertion volume\n    Nattempt = max # of insertion attempts per particle\n  rate value = V\n    V = z velocity (3d) or y velocity (2d) at which\n        insertion volume moves (velocity units)\n  dens values = Rholo Rhohi\n    Rholo,Rhohi = range of densities for inserted particles (mass/volume units)\n  vel values (3d) = vxlo vxhi vylo vyhi vz\n  vel values (2d) = vxlo vxhi vy\n    vxlo,vxhi = range of x velocities for inserted particles (velocity units)\n    vylo,vyhi = range of y velocities for inserted particles (velocity units)\n    vz = z velocity (3d) assigned to inserted particles (velocity units)\n    vy = y velocity (2d) assigned to inserted particles (velocity units)\n  mol value = template-ID\n    template-ID = ID of molecule template specified in a separate molecule command\n  molfrac values = f1 f2 ... fN\n    f1 to fN = relative probability of creating each of N molecules in template-ID\n  rigid value = fix-ID\n    fix-ID = ID of fix rigid/small command\n  shake value = fix-ID\n    fix-ID = ID of fix shake command\n  ignore value = none\n    skip any line or triangle particles when detecting possible\n      overlaps with inserted particles\n  \n  \n  ",
    "examples": "fix 3 all pour 1000 2 29494 region myblock\n  fix 2 all pour 10000 1 19985583 region disk vol 0.33 100 rate 1.0 diam range 0.9 1.1\n  fix 2 all pour 10000 1 19985583 region disk diam poly 2 0.7 0.4 1.5 0.6\n  fix ins all pour 500 1 4767548 vol 0.8 10 region slab mol object rigid myRigid\n  \n  \n  ",
    "restrictions": "This fix is part of the GRANULAR package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  For 3d simulations, a gravity fix in the -z direction must be defined\n  for use in conjunction with this fix.  For 2d simulations, gravity\n  must be defined in the -y direction.\n  The specified insertion region cannot be a “dynamic” region, as\n  defined by the region command.\n  "
},
{
    "command": "fix precession/spin",
    "description": "This fix applies a precession torque to each magnetic spin in the group.\n  Style zeeman is used for the simulation of the interaction\n  between the magnetic spins in the defined group and an external\n  magnetic field:\n  \n  \\[H_{Zeeman} = -g \\sum_{i=0}^{N}\\mu_{i}\\, \\vec{s}_{i} \\cdot\\vec{B}_{ext}\\]\n  with:\n  \n  \\(\\vec{B}_{ext}\\) the external magnetic field (in T)\n  \\(g\\) the Lande factor (hard-coded as \\(g=2.0\\))\n  \\(\\vec{s}_i\\) the unitary vector describing the orientation of spin \\(i\\)\n  \\(\\mu_i\\) the atomic moment of spin \\(i\\) given as a multiple of the\n  Bohr magneton \\(\\mu_B\\) (for example, \\(\\mu_i \\approx 2.2\\) in bulk iron).\n  \n  The field value in Tesla is multiplied by the gyromagnetic\n  ratio, \\(g \\cdot \\mu_B/\\hbar\\), converting it into a precession frequency in\n  rad.THz (in metal units and with \\(\\mu_B = 5.788 eV/T\\)).\n  As a comparison, the figure below displays the simulation of a\n  single spin (of norm \\(\\mu_i = 1.0\\)) submitted to an external\n  magnetic field of \\(\\vert B_{ext}\\vert = 10.0\\; \\mathrm{Tesla}\\) (and oriented along the z\n  axis).\n  The upper plot shows the average magnetization along the\n  external magnetic field axis and the lower plot the Zeeman\n  energy, both as a function of temperature.\n  The reference result is provided by the plot of the Langevin\n  function for the same parameters.\n  \n  The temperature effects are accounted for by connecting the spin\n  \\(i\\) to a thermal bath using a Langevin thermostat (see\n  fix langevin/spin for the definition of\n  this thermostat).\n  Style anisotropy is used to simulate an easy axis or an easy plane\n  for the magnetic spins in the defined group:\n  \n  \\[H_{aniso}  = -\\sum_{{ i}=1}^{N} K_{an}(\\mathbf{r}_{i})\\, \\left( \\vec{s}_{i} \\cdot \\vec{n}_{i} \\right)^2\\]\n  with \\(n\\) defining the direction of the anisotropy, and \\(K\\) (in eV) its intensity.\n  If \\(K > 0\\), an easy axis is defined, and if \\(K < 0\\), an easy plane is defined.\n  Style cubic is used to simulate a cubic anisotropy, with three\n  possible easy axis for the magnetic spins in the defined group:\n  \n  \\[H_{cubic} = -\\sum_{{ i}=1}^{N} K_{1}\n  \\Big[\n  \\left(\\vec{s}_{i} \\cdot \\vec{n_1} \\right)^2\n  \\left(\\vec{s}_{i} \\cdot \\vec{n_2} \\right)^2 +\n  \\left(\\vec{s}_{i} \\cdot \\vec{n_2} \\right)^2\n  \\left(\\vec{s}_{i} \\cdot \\vec{n_3} \\right)^2 +\n  \\left(\\vec{s}_{i} \\cdot \\vec{n_1} \\right)^2\n  \\left(\\vec{s}_{i} \\cdot \\vec{n_3} \\right)^2 \\Big]\n  +K_{2}^{(c)} \\left(\\vec{s}_{i} \\cdot \\vec{n_1} \\right)^2\n  \\left(\\vec{s}_{i} \\cdot \\vec{n_2} \\right)^2\n  \\left(\\vec{s}_{i} \\cdot \\vec{n_3} \\right)^2\\]\n  with \\(K_1\\) and \\(K_{2c}\\) (in eV) the intensity coefficients and\n  \\(\\vec{n}_1\\), \\(\\vec{n}_2\\) and \\(\\vec{n}_3\\) defining the three anisotropic directions\n  defined by the command (from n1x to n3z).\n  For \\(\\vec{n}_1 = (1 0 0)\\), \\(\\vec{n}_2 = (0 1 0)\\), and \\(\\vec{n}_3 = (0 0 1)\\), \\(K_1 < 0\\) defines an\n  iron type anisotropy (easy axis along the \\((0 0 1)\\)-type cube\n  edges), and \\(K_1 > 0\\) defines a nickel type anisotropy (easy axis\n  along the \\((1 1 1)\\)-type cube diagonals).\n  \\(K_2^c > 0\\) also defines easy axis along the \\((1 1 1)\\)-type cube\n  diagonals.\n  See chapter 2 of (Skomski) for more details on cubic\n  anisotropies.\n  In all cases, the choice of \\((x y z)\\) only imposes the vector\n  directions for the forces. Only the direction of the vector is\n  important; its length is ignored (the entered vectors are\n  normalized).\n  Those styles can be combined within one single command line.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  By default, the energy associated to this fix is not added to the potential\n  energy of the system.\n  The fix_modify energy option is supported by this fix\n  to add this magnetic potential energy to the potential energy of the system,\n  fix             1 all precession/spin zeeman 1.0 0.0 0.0 1.0\n  fix_modify      1 energy yes\n  \n  \n  This fix computes a global scalar which can be accessed by various\n  output commands.\n  No information about this fix is written to binary restart files.\n  ",
    "syntax": "fix ID group precession/spin style args\n  \n  \n  \n  ID, group are documented in fix command\n  precession/spin = style name of this fix command\n  style = zeeman or anisotropy or cubic\n  zeeman args = H x y z\n    H = intensity of the magnetic field (in Tesla)\n    x y z = vector direction of the field\n  anisotropy args = K x y z\n    K = intensity of the magnetic anisotropy (in eV)\n    x y z = vector direction of the anisotropy\n  cubic args = K1 K2c n1x n1y n1x n2x n2y n2z n3x n3y n3z\n    K1 and K2c = intensity of the magnetic anisotropy (in eV)\n    n1x to n3z = three direction vectors of the cubic anisotropy\n  \n  \n  ",
    "examples": "fix 1 all precession/spin zeeman 0.1 0.0 0.0 1.0\n  fix 1 3 precession/spin anisotropy 0.001 0.0 0.0 1.0\n  fix 1 iron precession/spin cubic 0.001 0.0005 1.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0\n  fix 1 all precession/spin zeeman 0.1 0.0 0.0 1.0 anisotropy 0.001 0.0 0.0 1.0\n  \n  \n  ",
    "restrictions": "The precession/spin style is part of the SPIN package.  This style\n  is only enabled if LAMMPS was built with this package, and if the\n  atom_style “spin” was declared.  See the Build package doc page for more info.\n  "
},
{
    "command": "fix press/berendsen",
    "description": "Reset the pressure of the system by using a Berendsen barostat\n  (Berendsen), which rescales the system volume and\n  (optionally) the atoms coordinates within the simulation box every\n  timestep.\n  Regardless of what atoms are in the fix group, a global pressure is\n  computed for all atoms.  Similarly, when the size of the simulation\n  box is changed, all atoms are re-scaled to new positions, unless the\n  keyword dilate is specified with a value of partial, in which case\n  only the atoms in the fix group are re-scaled.  The latter can be\n  useful for leaving the coordinates of atoms in a solid substrate\n  unchanged and controlling the pressure of a surrounding fluid.\n  \n  Note\n  Unlike the fix npt or fix nph\n  commands which perform Nose/Hoover barostatting AND time integration,\n  this fix does NOT perform time integration.  It only modifies the box\n  size and atom coordinates to effect barostatting.  Thus you must use a\n  separate time integration fix, like fix nve or fix nvt to actually update the positions and velocities of\n  atoms.  This fix can be used in conjunction with thermostatting fixes\n  to control the temperature, such as fix nvt or fix langevin or fix temp/berendsen.\n  \n  See the Howto baroostat doc page for a\n  discussion of different ways to perform barostatting.\n  \n  The barostat is specified using one or more of the iso, aniso,\n  x, y, z, and couple keywords.  These keywords give you the\n  ability to specify the 3 diagonal components of an external stress\n  tensor, and to couple various of these components together so that the\n  dimensions they represent are varied together during a\n  constant-pressure simulation.  Unlike the fix npt and\n  fix nph commands, this fix cannot be used with triclinic\n  (non-orthogonal) simulation boxes to control all 6 components of the\n  general pressure tensor.\n  The target pressures for each of the 3 diagonal components of the\n  stress tensor can be specified independently via the x, y, z,\n  keywords, which correspond to the 3 simulation box dimensions.  For\n  each component, the external pressure or tensor component at each\n  timestep is a ramped value during the run from Pstart to Pstop.\n  If a target pressure is specified for a component, then the\n  corresponding box dimension will change during a simulation.  For\n  example, if the y keyword is used, the y-box length will change.  A\n  box dimension will not change if that component is not specified,\n  although you have the option to change that dimension via the fix deform command.\n  For all barostat keywords, the Pdamp parameter determines the time\n  scale on which pressure is relaxed.  For example, a value of 10.0\n  means to relax the pressure in a timespan of (roughly) 10 time units\n  (tau or fmsec or psec - see the units command).\n  \n  Note\n  A Berendsen barostat will not work well for arbitrary values of\n  Pdamp.  If Pdamp is too small, the pressure and volume can\n  fluctuate wildly; if it is too large, the pressure will take a very\n  long time to equilibrate.  A good choice for many models is a Pdamp\n  of around 1000 timesteps.  However, note that Pdamp is specified in\n  time units, and that timesteps are NOT the same as time units for most\n  units settings.\n  \n  \n  Note\n  The relaxation time is actually also a function of the bulk\n  modulus of the system (inverse of isothermal compressibility).  The\n  bulk modulus has units of pressure and is the amount of pressure that\n  would need to be applied (isotropically) to reduce the volume of the\n  system by a factor of 2 (assuming the bulk modulus was a constant,\n  independent of density, which it’s not).  The bulk modulus can be set\n  via the keyword modulus.  The Pdamp parameter is effectively\n  multiplied by the bulk modulus, so if the pressure is relaxing faster\n  than expected or desired, increasing the bulk modulus has the same\n  effect as increasing Pdamp.  The converse is also true.  LAMMPS does\n  not attempt to guess a correct value of the bulk modulus; it just uses\n  10.0 as a default value which gives reasonable relaxation for a\n  Lennard-Jones liquid, but will be way off for other materials and way\n  too small for solids.  Thus you should experiment to find appropriate\n  values of Pdamp and/or the modulus when using this fix.\n  \n  \n  The couple keyword allows two or three of the diagonal components of\n  the pressure tensor to be “coupled” together.  The value specified\n  with the keyword determines which are coupled.  For example, xz\n  means the Pxx and Pzz components of the stress tensor are coupled.\n  Xyz means all 3 diagonal components are coupled.  Coupling means two\n  things: the instantaneous stress will be computed as an average of the\n  corresponding diagonal components, and the coupled box dimensions will\n  be changed together in lockstep, meaning coupled dimensions will be\n  dilated or contracted by the same percentage every timestep.  The\n  Pstart, Pstop, Pdamp parameters for any coupled dimensions must\n  be identical.  Couple xyz can be used for a 2d simulation; the z\n  dimension is simply ignored.\n  \n  The iso and aniso keywords are simply shortcuts that are\n  equivalent to specifying several other keywords together.\n  The keyword iso means couple all 3 diagonal components together when\n  pressure is computed (hydrostatic pressure), and dilate/contract the\n  dimensions together.  Using “iso Pstart Pstop Pdamp” is the same as\n  specifying these 4 keywords:\n  x Pstart Pstop Pdamp\n  y Pstart Pstop Pdamp\n  z Pstart Pstop Pdamp\n  couple xyz\n  \n  \n  The keyword aniso means x, y, and z dimensions are controlled\n  independently using the Pxx, Pyy, and Pzz components of the\n  stress tensor as the driving forces, and the specified scalar external\n  pressure.  Using “aniso Pstart Pstop Pdamp” is the same as specifying\n  these 4 keywords:\n  x Pstart Pstop Pdamp\n  y Pstart Pstop Pdamp\n  z Pstart Pstop Pdamp\n  couple none\n  \n  \n  \n  This fix computes a temperature and pressure each timestep.  To do\n  this, the fix creates its own computes of style “temp” and “pressure”,\n  as if these commands had been issued:\n  compute fix-ID_temp group-ID temp\n  compute fix-ID_press group-ID pressure fix-ID_temp\n  \n  \n  See the compute temp and compute pressure commands for details.  Note that the\n  IDs of the new computes are the fix-ID + underscore + “temp” or fix_ID\n  + underscore + “press”, and the group for the new computes is the same\n  as the fix group.\n  Note that these are NOT the computes used by thermodynamic output (see\n  the thermo_style command) with ID = thermo_temp\n  and thermo_press.  This means you can change the attributes of this\n  fix’s temperature or pressure via the\n  compute_modify command or print this temperature\n  or pressure during thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\n  It also means that changing attributes of thermo_temp or\n  thermo_press will have no effect on this fix.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The fix_modify temp and press options are\n  supported by this fix.  You can use them to assign a\n  compute you have defined to this fix which will be used\n  in its temperature and pressure calculations.  If you do this, note\n  that the kinetic energy derived from the compute temperature should be\n  consistent with the virial term computed using all atoms for the\n  pressure.  LAMMPS will warn you if you choose to compute temperature\n  on a subset of atoms.\n  No global or per-atom quantities are stored by this fix for access by\n  various output commands.\n  This fix can ramp its target pressure over multiple runs, using the\n  start and stop keywords of the run command.  See the\n  run command for details of how to do this.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID press/berendsen keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  press/berendsen = style name of this fix command\n  one or more keyword value pairs may be appended\n  keyword = iso or aniso or x or y or z or couple or dilate or modulus\n    iso or aniso values = Pstart Pstop Pdamp\n      Pstart,Pstop = scalar external pressure at start/end of run (pressure units)\n      Pdamp = pressure damping parameter (time units)\n    x or y or z values = Pstart Pstop Pdamp\n      Pstart,Pstop = external stress tensor component at start/end of run (pressure units)\n      Pdamp = stress damping parameter (time units)\n    couple = none or xyz or xy or yz or xz\n    modulus value = bulk modulus of system (pressure units)\n    dilate value = all or partial\n  \n  \n  ",
    "examples": "fix 1 all press/berendsen iso 0.0 0.0 1000.0\n  fix 2 all press/berendsen aniso 0.0 0.0 1000.0 dilate partial\n  \n  \n  ",
    "restrictions": "Any dimension being adjusted by this fix must be periodic.\n  "
},
{
    "command": "fix print",
    "description": "Print a text string every N steps during a simulation run.  This can\n  be used for diagnostic purposes or as a debugging tool to monitor some\n  quantity during a run.  The text string must be a single argument, so\n  it should be enclosed in double quotes if it is more than one word.\n  If it contains variables it must be enclosed in double quotes to\n  insure they are not evaluated when the input script line is read, but\n  will instead be evaluated each time the string is printed.\n  Instead of a numeric value, N can be specified as an equal-style variable, which should be specified as v_name, where\n  name is the variable name.  In this case, the variable is evaluated at\n  the beginning of a run to determine the next timestep at which the\n  string will be written out.  On that timestep, the variable will be\n  evaluated again to determine the next timestep, etc.\n  Thus the variable should return timestep values.  See the stagger()\n  and logfreq() and stride() math functions for equal-style variables, as examples of useful functions to use in\n  this context. For example, the following commands will print output at\n  timesteps 10,20,30,100,200,300,1000,2000,etc:\n  variable        s equal logfreq(10,3,10)\n  fix extra all print v_s \"Coords of marker atom = $x $y $z\"\n  \n  \n  The specified group-ID is ignored by this fix.\n  See the variable command for a description of equal\n  style variables which are the most useful ones to use with the fix\n  print command, since they are evaluated afresh each timestep that the\n  fix print line is output.  Equal-style variables calculate formulas\n  involving mathematical operations, atom properties, group properties,\n  thermodynamic properties, global values calculated by a\n  compute or fix, or references to other\n  variables.\n  If the file or append keyword is used, a filename is specified to\n  which the output generated by this fix will be written.  If file is\n  used, then the filename is overwritten if it already exists.  If\n  append is used, then the filename is appended to if it already\n  exists, or created if it does not exist.\n  If the screen keyword is used, output by this fix to the screen and\n  logfile can be turned on or off as desired.\n  The title keyword allow specification of the string that will be\n  printed as the first line of the output file, assuming the file\n  keyword was used.  By default, the title line is as follows:\n  # Fix print output for fix ID\n  \n  \n  where ID is replaced with the fix-ID.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID print N string keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  print = style name of this fix command\n  N = print every N steps; N can be a variable (see below)\n  string = text string to print with optional variable names\n  zero or more keyword/value pairs may be appended\n  keyword = file or append or screen or title\n  file value = filename\n  append value = filename\n  screen value = yes or no\n  title value = string\n    string =  text to print as 1st line of output file\n  \n  \n  ",
    "examples": "fix extra all print 100 \"Coords of marker atom = $x $y $z\"\n  fix extra all print 100 \"Coords of marker atom = $x $y $z\" file coord.txt\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix propel/self",
    "description": "Adds a force of a constant magnitude to each atom in the group. The nature in\n  which the force is added depends on the mode.\n  For mode = velocity, the active force acts along the velocity vector of\n  each atom. This can be interpreted as a velocity-dependent friction,\n  such as proposed by (Erdmann).\n  For mode = quat the force is applied along the axis obtained\n  by rotating the x-axis along the atom’s quaternion. In other words, the\n  force is along the x-axis in the atom’s body frame. This mode requires\n  all atoms in the group to have a quaternion, so atom_style should\n  either be ellipsoid or body.  In combination with Langevin thermostat\n  for translation and rotation in the overdamped regime, the quaternion\n  mode corresponds to the active Brownian particle model introduced by\n  (Henkes), (Bialke) and (Fily).\n  By default, this fix is applied to all atoms in the group. You can\n  override this behavior by specifying the atom types the fix should work\n  on through the types keyword.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  This fix is not imposed  during minimization.\n  ",
    "syntax": "fix ID group-ID propel/self mode magnitude keyword values ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  propel/self = style name of this fix command\n  mode = velocity or quat\n  magnitude = magnitude of the active force\n  one or more keyword/value pairs may be appended to args\n  keyword = types\n  types values = one or more atom types\n  \n  \n  ",
    "examples": "fix active_group all propel/self velocity 1.0\n  fix constant_velocity all viscous 1.0\n  \n  fix active_group all propel/self quat 1.0\n  \n  fix active all propel/self quat 1.0 types 1 2 4\n  \n  \n  ",
    "restrictions": "In quat mode, this fix makes use of per-atom quaternions to take\n  into account the fact that the orientation can rotate and hence the\n  direction of the active force can change. The quat mode\n  of this fix only works with atom_style ellipsoid.\n  "
},
{
    "command": "fix property/atom",
    "description": "Create one or more additional per-atom vectors to store information\n  about atoms and to use during a simulation.  The specified group-ID\n  is ignored by this fix.\n  The atom style used for a simulation defines a set of per-atom\n  properties, as explained on the atom_style and\n  read_data doc pages.  The latter command allows these\n  properties to be defined for each atom in the system when a data file\n  is read.  This fix will augment the set of properties with new custom\n  ones. This can be useful in several scenarios.\n  If the atom style does not define molecule IDs, per-atom charge,\n  or per-atom mass, they can be added using the mol, q or rmass\n  keywords.  This can be useful, e.g, to define “molecules” to use as\n  rigid bodies with the fix rigid command, or just to\n  carry around an extra flag with the atoms (stored as a molecule ID)\n  that can be used to group atoms without having to use the group\n  command (which is limited to a total of 32 groups including all).\n  Another application would be to use the rmass flag in order to have\n  per-atom masses instead of per-type masses, for example this can be\n  useful to study isotope effects with partial isotope substitution.\n  Please see below for an example of simulating a mixture\n  of light and heavy water with the TIP4P water potential.\n  An alternative to using fix property/atom in these ways is to\n  use an atom style that does define molecule IDs or charge or per-atom\n  mass (indirectly via diameter and density) or to use a hybrid atom\n  style that combines two or more atom styles\n  to provide the union of all atom properties. However, this has two\n  practical drawbacks:  first, it typically necessitates changing the\n  format of the data file, which can be tedious for large systems;\n  and second, it may define additional properties that are not needed\n  such as bond lists, which has some overhead when there are no bonds.\n  In the future, we may add additional per-atom properties similar to\n  mol, q or rmass, which “turn-on” specific properties defined\n  by some atom styles, so they can be used by atom styles that do not\n  define them.\n  More generally, the i_name and d_name vectors allow one or more\n  new custom per-atom properties to be defined.  Each name must be\n  unique and can use alphanumeric or underscore characters.  These\n  vectors can store whatever values you decide are useful in your\n  simulation.  As explained below there are several ways to initialize\n  and access and output these values, both via input script commands and\n  in new code that you add to LAMMPS.\n  This is effectively a simple way to add per-atom properties to a model\n  without needing to write code for a new atom style\n  that defines the properties.  Note however that implementing a new\n  atom style allows new atom properties to be more tightly and\n  seamlessly integrated with the rest of the code.\n  The new atom properties encode values that migrate with atoms to new\n  processors and are written to restart files.  If you want the new\n  properties to also be defined for ghost atoms, then use the ghost\n  keyword with a value of yes.  This will invoke extra communication\n  when ghost atoms are created (at every re-neighboring) to insure the\n  new properties are also defined for the ghost atoms.\n  \n  Note\n  If you use this command with the mol, q or rmass vectors,\n  then you most likely want to set ghost yes, since these properties\n  are stored with ghost atoms if you use an atom_style\n  that defines them, and many LAMMPS operations that use molecule IDs or\n  charge, such as neighbor lists and pair styles, will expect ghost\n  atoms to have these values.  LAMMPS will issue a warning it you define\n  those vectors but do not set ghost yes.\n  \n  \n  Note\n  The properties for ghost atoms are not updated every timestep,\n  but only once every few steps when neighbor lists are re-built.  Thus\n  the ghost keyword is suitable for static properties, like molecule\n  IDs, but not for dynamic properties that change every step.  For the\n  latter, the code you add to LAMMPS to change the properties will also\n  need to communicate their new values to/from ghost atoms, an operation\n  that can be invoked from within a pair style or\n  fix or compute that you write.\n  \n  \n  Note\n  If this fix is defined after the simulation box is created,\n  a ‘run 0’ command should be issued to properly initialize the storage\n  created by this fix.\n  \n  \n  This fix is one of a small number that can be defined in an input\n  script before the simulation box is created or atoms are defined.\n  This is so it can be used with the read_data command\n  as described below.\n  Per-atom properties that are defined by the atom style are initialized when atoms are created, e.g. by\n  the read_data or create_atoms\n  commands.  The per-atom properties defined by this fix are not.  So\n  you need to initialize them explicitly.  This can be done by the\n  read_data command, using its fix keyword and\n  passing it the fix-ID of this fix.\n  Thus these commands:\n  fix prop all property/atom mol d_flag\n  read_data data.txt fix prop NULL Molecules\n  \n  \n  would allow a data file to have a section like this:\n  Molecules\n  \n  1 4 1.5\n  2 4 3.0\n  3 10 1.0\n  4 10 1.0\n  5 10 1.0\n  ...\n  N 763 4.5\n  \n  \n  where N is the number of atoms, and the first field on each line is\n  the atom-ID, followed by a molecule-ID and a floating point value that\n  will be stored in a new property called “flag”.  Note that the list of\n  per-atom properties can be in any order.\n  Another way of initializing the new properties is via the\n  set command.  For example, if you wanted molecules\n  defined for every set of 10 atoms, based on their atom-IDs,\n  these commands could be used:\n  fix prop all property/atom mol\n  variable cluster atom ((id-1)/10)+1\n  set atom * mol v_cluster\n  \n  \n  The atom-style variable will create values for atoms\n  with IDs 31,32,33,…40 that are 4.0,4.1,4.2,…,4.9.  When the\n  set commands assigns them to the molecule ID for each atom,\n  they will be truncated to an integer value, so atoms 31-40 will all be\n  assigned a molecule ID of 4.\n  Note that atomfile-style variables can also be used in\n  place of atom-style variables, which means in this case that the\n  molecule IDs could be read-in from a separate file and assigned by the\n  set command.  This allows you to initialize new per-atom\n  properties in a completely general fashion.\n  \n  For new atom properties specified as i_name or d_name, the\n  compute property/atom command can access\n  their values.  This means that the values can be output via the dump custom command, accessed by fixes like fix ave/atom, accessed by other computes like compute reduce, or used in atom-style variables.\n  For example, these commands will output two new properties to a custom\n  dump file:\n  fix prop all property/atom i_flag1 d_flag2\n  compute 1 all property/atom i_flag1 d_flag2\n  dump 1 all custom 100 tmp.dump id x y z c_1[1] c_1[2]\n  \n  \n  \n  If you wish to add new pair styles,\n  fixes, or computes that use the per-atom\n  properties defined by this fix, see the Modify atom\n  doc page which has details on how the properties can be accessed from\n  added classes.\n  \n  Example for using per-atom masses with TIP4P water to\n  study isotope effects. When setting up simulations with the TIP4P pair styles for water, you have to provide exactly\n  one atom type each to identify the water oxygen and hydrogen\n  atoms. Since the atom mass is normally tied to the atom type, this\n  makes it impossible to study multiple isotopes in the same simulation.\n  With fix property/atom rmass however, the per-type masses are\n  replaced by per-atom masses. Asumming you have a working input deck\n  for regular TIP4P water, where water oxygen is atom type 1 and water\n  hydrogen is atom type 2, the following lines of input script convert\n  this to using per-atom masses:\n  fix Isotopes all property/atom rmass ghost yes\n  set type 1 mass 15.9994\n  set type 2 mass 1.008\n  \n  \n  When writing out the system data with the write_data\n  command, there will be a new section named with the fix-ID\n  (i.e. Isotopes in this case). Alternatively, you can take an\n  existing data file and just add this Isotopes section with\n  one line per atom containing atom-ID and mass. Either way, the\n  extended data file can be read back with:\n  fix Isotopes all property/atom rmass ghost yes\n  read_data tip4p-isotopes.data fix Isotopes NULL Isotopes\n  \n  \n  Please note that the first Isotopes refers to the fix-ID\n  and the second to the name of the section. The following input\n  script code will now change the first 100 water molecules in this\n  example to heavy water:\n  group hwat id 2:300:3\n  group hwat id 3:300:3\n  set group hwat mass 2.0141018\n  \n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  This fix writes the per-atom values it stores to binary restart files, so that the values can be restored when a\n  simulation is restarted.  See the read_restart\n  command for info on how to re-specify a fix in an input script that\n  reads a restart file, so that the operation of the fix continues in an\n  uninterrupted fashion.\n  None of the fix_modify options are relevant to this\n  fix.  No global or per-atom quantities are stored by this fix for\n  access by various output commands.  No parameter\n  of this fix can be used with the start/stop keywords of the\n  run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID property/atom vec1 vec2 ... keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  property/atom = style name of this fix command\n  vec1,vec2,… = mol or q or rmass or i_name or d_name\n  mol = molecule IDs\n  q = charge\n  rmass = per-atom mass\n  i_name = new integer vector referenced by name\n  d_name = new floating-point vector referenced by name\n  \n  zero of more keyword/value pairs may be appended\n  keyword = ghost\n  ghost value = no or yes for whether ghost atom info in communicated\n  \n  \n  ",
    "examples": "fix 1 all property/atom mol\n  fix 1 all property/atom i_myflag1 i_myflag2\n  fix 1 all property/atom d_sx d_sy d_sz\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix python/invoke",
    "description": "This fix allows you to call a Python function during a simulation run.\n  The callback is either executed after forces have been applied to atoms\n  or at the end of every N time steps.\n  Callback functions must be declared in the global scope of the\n  active Python interpreter. This can either be done by defining it\n  inline using the python command or by importing functions from other\n  Python modules. If LAMMPS is driven using the library interface from\n  Python, functions defined in the driving Python interpreter can also\n  be executed.\n  Each callback is given a pointer object as first argument. This can be\n  used to initialize an instance of the lammps Python interface, which\n  gives access to the LAMMPS state from Python.\n  \n  Warning\n  While you can access the state of LAMMPS via library functions\n  from these callbacks, trying to execute input script commands will in the best\n  case not work or in the worst case result in undefined behavior.\n  \n  ",
    "syntax": "fix ID group-ID python/invoke N callback function_name\n  \n  \n  \n  ID, group-ID are ignored by this fix\n  python/invoke = style name of this fix command\n  N = execute every N steps\n  callback = post_force or end_of_step\n  post_force = callback after force computations on atoms every N time steps\n  end_of_step = callback after every N time steps\n  \n  \n  ",
    "examples": "python post_force_callback here \"\"\"\n  from lammps import lammps\n  \n  def post_force_callback(lammps_ptr, vflag):\n      lmp = lammps(ptr=lammps_ptr)\n      # access LAMMPS state using Python interface\n  \"\"\"\n  \n  python end_of_step_callback here \"\"\"\n  def end_of_step_callback(lammps_ptr):\n      lmp = lammps(ptr=lammps_ptr)\n      # access LAMMPS state using Python interface\n  \"\"\"\n  \n  fix pf  all python/invoke 50 post_force post_force_callback\n  fix eos all python/invoke 50 end_of_step end_of_step_callback\n  \n  \n  ",
    "restrictions": "This fix is part of the PYTHON package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  Building LAMMPS with the PYTHON package will link LAMMPS with the\n  Python library on your system.  Settings to enable this are in the\n  lib/python/Makefile.lammps file.  See the lib/python/README file for\n  information on those settings.\n  "
},
{
    "command": "fix python/move",
    "description": "The python/move fix style provides a way to define ways how particles\n  are moved during an MD run from python script code, that is loaded from\n  a file into LAMMPS and executed at the various steps where other fixes\n  can be executed. This python script must contain specific python class\n  definitions.\n  This allows to implement complex position updates and also modified\n  time integration methods. Due to python being an interpreted language,\n  however, the performance of this fix can be moderately to significantly\n  slower than the corresponding C++ code. For specific cases, this\n  performance penalty can be limited through effective use of NumPy.\n  \n  The python module file has to start with the following code:\n  from __future__ import print_function\n  import lammps\n  import ctypes\n  import traceback\n  import numpy as np\n  #\n  class LAMMPSFix(object):\n      def __init__(self, ptr, group_name=\"all\"):\n          self.lmp = lammps.lammps(ptr=ptr)\n          self.group_name = group_name\n  #\n  class LAMMPSFixMove(LAMMPSFix):\n      def __init__(self, ptr, group_name=\"all\"):\n          super(LAMMPSFixMove, self).__init__(ptr, group_name)\n  #\n      def init(self):\n          pass\n  #\n      def initial_integrate(self, vflag):\n          pass\n  #\n      def final_integrate(self):\n          pass\n  #\n      def initial_integrate_respa(self, vflag, ilevel, iloop):\n          pass\n  #\n      def final_integrate_respa(self, ilevel, iloop):\n          pass\n  #\n      def reset_dt(self):\n          pass\n  \n  \n  Any classes implementing new atom motion functionality have to be\n  derived from the LAMMPSFixMove class, overriding the available\n  methods as needed.\n  Examples for how to do this are in the examples/python folder.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix python/move pymodule.CLASS\n  \n  \n  pymodule.CLASS = use class CLASS in module/file pymodule to compute how to move atoms\n  ",
    "examples": "fix  1 all python/move py_nve.NVE\n  fix  1 all python/move py_nve.NVE_OPT\n  \n  \n  ",
    "restrictions": "This pair style is part of the PYTHON package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "fix qbmsst",
    "description": "This command performs the Quantum-Bath coupled Multi-Scale Shock\n  Technique (QBMSST) integration. See (Qi) for a detailed\n  description of this method.  QBMSST provides description of the\n  thermodynamics and kinetics of shock processes while incorporating\n  quantum nuclear effects.  The shockvel setting determines the steady\n  shock velocity that will be simulated along direction dir.\n  Quantum nuclear effects (fix qtb) can be crucial\n  especially when the temperature of the initial state is below the\n  classical limit or there is a great change in the zero point energies\n  between the initial and final states. Theoretical post processing\n  quantum corrections of shock compressed water and methane have been\n  reported as much as 30% of the temperatures (Goldman).  A\n  self-consistent method that couples the shock to a quantum thermal\n  bath described by a colored noise Langevin thermostat has been\n  developed by Qi et al (Qi) and applied to shocked methane.  The\n  onset of chemistry is reported to be at a pressure on the shock\n  Hugoniot that is 40% lower than observed with classical molecular\n  dynamics.\n  It is highly recommended that the system be already in an equilibrium\n  state with a quantum thermal bath at temperature of T_init.  The fix\n  command fix qtb at constant temperature T_init could\n  be used before applying this command to introduce self-consistent\n  quantum nuclear effects into the initial state.\n  The parameters q, mu, e0, p0, v0 and tscale are described\n  in the command fix msst. The values of e0, p0, or\n  v0 will be calculated on the first step if not specified.  The\n  parameter of damp, f_max, and N_f are described in the command\n  fix qtb.\n  The fix qbmsst command couples the shock system to a quantum thermal\n  bath with a rate that is proportional to the change of the total\n  energy of the shock system, \\(E^{tot} - E^{tot}_0\\).\n  Here \\(E^{etot}\\) consists of both the system energy and a thermal\n  term, see (Qi), and \\(E^{tot}_0 = e0\\) is the\n  initial total energy.\n  The eta (\\(\\eta\\)) parameter is a unitless coupling constant\n  between the shock system and the quantum thermal bath. A small \\(\\eta\\)\n  value cannot adjust the quantum temperature fast enough during the\n  temperature ramping period of shock compression while large \\(\\eta\\)\n  leads to big temperature oscillation. A value of \\(\\eta\\) between 0.3 and\n  1 is usually appropriate for simulating most systems under shock\n  compression. We observe that different values of \\(\\eta\\) lead to almost\n  the same final thermodynamic state behind the shock, as expected.\n  The quantum temperature is updated every beta (\\(\\beta\\)) steps\n  with an integration time interval \\(\\beta\\) times longer than the\n  simulation time step. In that case, \\(E^{tot}\\) is taken as its\n  average over the past \\(\\beta\\) steps. The temperature of the quantum\n  thermal bath \\(T^{qm}\\) changes dynamically according to\n  the following equation where \\(\\Delta_t\\) is the MD time step and\n  \\(\\gamma\\) is the friction constant which is equal to the inverse\n  of the damp parameter.\n  \n  \\[\\frac{dT^{qm}}{dt} = \\gamma\\eta\\sum^\\beta_{l=1}\\frac{E^{tot}(t-l\\Delta t) - E^{tot}_0}{3\\beta N k_B}\\]\n  The parameter T_init is the initial temperature of the quantum\n  thermal bath and the system before shock loading.\n  For all pressure styles, the simulation box stays orthorhombic in\n  shape. Parrinello-Rahman boundary conditions (tilted box) are\n  supported by LAMMPS, but are not implemented for QBMSST.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  Because the state of the random number generator is not written to\n  binary restart files, this fix cannot be restarted\n  “exactly” in an uninterrupted fashion. However, in a statistical\n  sense, a restarted simulation should produce similar behaviors of the\n  system as if it is not interrupted.  To achieve such a restart, one\n  should write explicitly the same value for q, mu, damp, f_max,\n  N_f, eta, and beta and set tscale = 0 if the system is\n  compressed during the first run.\n  The progress of the QBMSST can be monitored by printing the global\n  scalar and global vector quantities computed by the fix.  The global\n  vector contains five values in this order:\n  [dhugoniot, drayleigh, lagrangian_speed, lagrangian_position,\n  quantum_temperature]\n  \n  dhugoniot is the departure from the Hugoniot (temperature units).\n  drayleigh is the departure from the Rayleigh line (pressure units).\n  lagrangian_speed is the laboratory-frame Lagrangian speed (particle velocity) of the computational cell (velocity units).\n  lagrangian_position is the computational cell position in the reference frame moving at the shock speed. This is the distance of the computational cell behind the shock front.\n  quantum_temperature is the temperature of the quantum thermal bath \\(T^{qm}\\).\n  \n  To print these quantities to the log file with descriptive column\n  headers, the following LAMMPS commands are suggested. Here the\n  fix_modify energy command is also enabled to allow\n  the thermo keyword etotal to print the quantity \\(E^{tot}\\).  See\n  also the thermo_style command.\n  fix             fix_id all msst z\n  fix_modify      fix_id energy yes\n  variable        dhug    equal f_fix_id[1]\n  variable        dray    equal f_fix_id[2]\n  variable        lgr_vel equal f_fix_id[3]\n  variable        lgr_pos equal f_fix_id[4]\n  variable        T_qm    equal f_fix_id[5]\n  thermo_style    custom  step temp ke pe lz pzz etotal v_dhug v_dray v_lgr_vel v_lgr_pos v_T_qm f_fix_id\n  \n  \n  The global scalar under the entry f_fix_id is the quantity of thermo\n  energy as an extra part of \\(E^{tot}\\). This global scalar and the\n  vector of 5 quantities can be accessed by various output commands.\n  It is worth noting that the temp keyword\n  under the thermo_style command print the\n  instantaneous classical temperature \\(T^{cl}\\) as described\n  in the command fix qtb.\n  ",
    "syntax": "fix ID group-ID qbmsst dir shockvel keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  qbmsst = style name of this fix\n  dir = x or y or z\n  shockvel = shock velocity (strictly positive, velocity units)\n  zero or more keyword/value pairs may be appended\n  keyword = q or mu or p0 or v0 or e0 or tscale or damp or seedor f_max or N_f or eta or beta or T_init\n  q value = cell mass-like parameter (mass^2/distance^4 units)\n  mu value = artificial viscosity (mass/distance/time units)\n  p0 value = initial pressure in the shock equations (pressure units)\n  v0 value = initial simulation cell volume in the shock equations (distance^3 units)\n  e0 value = initial total energy (energy units)\n  tscale value = reduction in initial temperature (unitless fraction between 0.0 and 1.0)\n  damp value = damping parameter (time units) inverse of friction gamma\n  seed value = random number seed (positive integer)\n  f_max value = upper cutoff frequency of the vibration spectrum (1/time units)\n  N_f value = number of frequency bins (positive integer)\n  eta value = coupling constant between the shock system and the quantum thermal bath (positive unitless)\n  beta value = the quantum temperature is updated every beta time steps (positive integer)\n  T_init value = quantum temperature for the initial state (temperature units)\n  \n  \n  ",
    "examples": "# (liquid methane modeled with the REAX force field, real units)\n  fix 1 all qbmsst z 0.122 q 25 mu 0.9 tscale 0.01 damp 200 seed 35082 f_max 0.3 N_f 100 eta 1 beta 400 T_init 110\n  # (quartz modeled with the BKS force field, metal units)\n  fix 2 all qbmsst z 72 q 40 tscale 0.05 damp 1 seed 47508 f_max 120.0 N_f 100 eta 1.0 beta 500 T_init 300\n  \n  \n  Two example input scripts are given, including shocked\n  \\(\\alpha\\textrm{-quartz}\\) and shocked liquid methane.  The input\n  script first equilibrates an initial state with the quantum thermal\n  bath at the target temperature and then applies fix qbmsst to simulate\n  shock compression with quantum nuclear correction.  The following two\n  figures plot relevant quantities for shocked\n  \\(\\alpha\\textrm{-quartz}\\).\n  \n  Figure 1. Classical temperature\n  \\(T_{cl} = \\sum \\frac{m_iv_i^2}{3Nk_B}\\) vs. time for coupling the\n  \\(\\alpha\\textrm{-quartz}\\) initial state with the quantum thermal\n  bath at target quantum temperature \\(T^{qm} = 300 K\\). The NpH\n  ensemble is used for time integration while QTB provides the colored\n  random force. \\(T^{cl}\\) converges at the timescale of damp\n  which is set to be 1 ps.\n  \n  Figure 2. Quantum temperature and pressure vs. time for simulating\n  shocked \\(\\alpha\\textrm{-quartz}\\) with fix qbmsst. The shock\n  propagates along the z direction. Restart of the fix qbmsst command\n  is demonstrated in the example input script. Thermodynamic quantities\n  stay continuous before and after the restart.\n  ",
    "restrictions": "This fix style is part of the USER-QTB package.  It is only enabled if\n  LAMMPS was built with that package. See the Build package doc page for more info.\n  All cell dimensions must be periodic. This fix can not be used with a\n  triclinic cell.  The QBMSST fix has been tested only for the group-ID\n  all.\n  "
},
{
    "command": "fix qeq/comb",
    "description": "Perform charge equilibration (QeQ) in conjunction with the COMB\n  (Charge-Optimized Many-Body) potential as described in\n  (COMB_1) and (COMB_2).  It performs the charge\n  equilibration portion of the calculation using the so-called QEq\n  method, whereby the charge on each atom is adjusted to minimize the\n  energy of the system.  This fix can only be used with the COMB\n  potential; see the fix qeq/reax command for a QeQ\n  calculation that can be used with any potential.\n  Only charges on the atoms in the specified group are equilibrated.\n  The fix relies on the pair style (COMB in this case) to calculate the\n  per-atom electronegativity (effective force on the charges).  An\n  electronegativity equalization calculation (or QEq) is performed in an\n  iterative fashion, which in parallel requires communication at each\n  iteration for processors to exchange charge information about nearby\n  atoms with each other.  See Rappe_and_Goddard and\n  Rick_and_Stuart for details.\n  During a run, charge equilibration is performed every Nevery time\n  steps.  Charge equilibration is also always enforced on the first step\n  of each run.  The precision argument controls the tolerance for the\n  difference in electronegativity for all atoms during charge\n  equilibration.  Precision is a trade-off between the cost of\n  performing charge equilibration (more iterations) and accuracy.\n  If the file keyword is used, then information about each\n  equilibration calculation is written to the specified file.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The fix_modify respa option is supported by this\n  fix. This allows to set at which level of the r-RESPA\n  integrator the fix is performing charge equilibration. Default is\n  the outermost level.\n  This fix produces a per-atom vector which can be accessed by various\n  output commands.  The vector stores the gradient\n  of the charge on each atom.  The per-atom values be accessed on any\n  timestep.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  This fix can be invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID qeq/comb Nevery precision keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  qeq/comb = style name of this fix command\n  Nevery = perform charge equilibration every this many steps\n  precision = convergence criterion for charge equilibration\n  zero or more keyword/value pairs may be appended\n  keyword = file\n  file value = filename\n    filename = name of file to write QEQ equilibration info to\n  \n  \n  ",
    "examples": "fix 1 surface qeq/comb 10 0.0001\n  \n  \n  ",
    "restrictions": "This fix command currently only supports pair style *comb*.\n  "
},
{
    "command": "fix qeq/reax",
    "description": "Perform the charge equilibration (QEq) method as described in (Rappe and Goddard) and formulated in (Nakano).  It is\n  typically used in conjunction with the ReaxFF force field model as\n  implemented in the pair_style reax/c command, but\n  it can be used with any potential in LAMMPS, so long as it defines and\n  uses charges on each atom.  The fix qeq/comb\n  command should be used to perform charge equilibration with the COMB potential.  For more technical details about the\n  charge equilibration performed by fix qeq/reax, see the\n  (Aktulga) paper.\n  The QEq method minimizes the electrostatic energy of the system by\n  adjusting the partial charge on individual atoms based on interactions\n  with their neighbors.  It requires some parameters for each atom type.\n  If the params setting above is the word “reax/c”, then these are\n  extracted from the pair_style reax/c command and\n  the ReaxFF force field file it reads in.  If a file name is specified\n  for params, then the parameters are taken from the specified file\n  and the file must contain one line for each atom type.  The latter\n  form must be used when performing QeQ with a non-ReaxFF potential.\n  Each line should be formatted as follows:\n  itype chi eta gamma\n  \n  \n  where itype is the atom type from 1 to Ntypes, chi denotes the\n  electronegativity in eV, eta denotes the self-Coulomb\n  potential in eV, and gamma denotes the valence orbital\n  exponent.  Note that these 3 quantities are also in the ReaxFF\n  potential file, except that eta is defined here as twice the eta value\n  in the ReaxFF file. Note that unlike the rest of LAMMPS, the units\n  of this fix are hard-coded to be A, eV, and electronic charge.\n  The optional dual keyword allows to perform the optimization\n  of the S and T matrices in parallel. This is only supported for\n  the qeq/reax/omp style. Otherwise they are processed separately.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  No global scalar or vector or per-atom\n  quantities are stored by this fix for access by various output commands.  No parameter of this fix can be used\n  with the start/stop keywords of the run command.\n  This fix is invoked during energy minimization.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "fix ID group-ID qeq/reax Nevery cutlo cuthi tolerance params args\n  \n  \n  \n  ID, group-ID are documented in fix command\n  qeq/reax = style name of this fix command\n  Nevery = perform QEq every this many steps\n  cutlo,cuthi = lo and hi cutoff for Taper radius\n  tolerance = precision to which charges will be equilibrated\n  params = reax/c or a filename\n  args   = dual (optional)\n  \n  ",
    "examples": "fix 1 all qeq/reax 1 0.0 10.0 1.0e-6 reax/c\n  fix 1 all qeq/reax 1 0.0 10.0 1.0e-6 param.qeq\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-REAXC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  This fix does not correctly handle interactions\n  involving multiple periodic images of the same atom. Hence, it should not\n  be used for periodic cell dimensions less than 10 angstroms.\n  "
},
{
    "command": "fix qmmm",
    "description": "This fix provides functionality to enable a quantum\n  mechanics/molecular mechanics (QM/MM) coupling of LAMMPS to a quantum\n  mechanical code.  The current implementation only supports an ONIOM\n  style mechanical coupling to the Quantum ESPRESSO plane\n  wave DFT package.  Electrostatic coupling is in preparation and the\n  interface has been written in a manner that coupling to other QM codes\n  should be possible without changes to LAMMPS itself.\n  The interface code for this is in the lib/qmmm directory of the LAMMPS\n  distribution and is being made available at this early stage of\n  development in order to encourage contributions for interfaces to\n  other QM codes.  This will allow the LAMMPS side of the implementation\n  to be adapted if necessary before being finalized.\n  Details about how to use this fix are currently documented in the\n  description of the QM/MM interface code itself in lib/qmmm/README.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global scalar or vector or per-atom\n  quantities are stored by this fix for access by various output commands.  No parameter of this fix can be used\n  with the start/stop keywords of the run command.  This\n  fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID qmmm\n  \n  \n  \n  ID, group-ID are documented in fix command\n  qmmm = style name of this fix command\n  \n  ",
    "examples": "fix 1 qmol qmmm\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-QMMM package.  It is only enabled if\n  LAMMPS was built with that package. It also requires building a\n  library provided with LAMMPS.  See the Build package doc page for more info.\n  The fix is only functional when LAMMPS is built as a library and\n  linked with a compatible QM program and a QM/MM front end into a QM/MM\n  executable.  See the lib/qmmm/README file for details.\n  Related commands: none\n  Default: none\n  "
},
{
    "command": "fix qtb",
    "description": "This command performs the quantum thermal bath scheme proposed by\n  (Dammak) to include self-consistent quantum nuclear effects,\n  when used in conjunction with the fix nve or fix nph commands.\n  Classical molecular dynamics simulation does not include any quantum\n  nuclear effect. Quantum treatment of the vibrational modes will\n  introduce zero point energy into the system, alter the energy power\n  spectrum and bias the heat capacity from the classical limit. Missing\n  all the quantum nuclear effects, classical MD cannot model systems at\n  temperatures lower than their classical limits. This effect is\n  especially important for materials with a large population of hydrogen\n  atoms and thus higher classical limits.\n  The equation of motion implemented by this command follows a Langevin\n  form:\n  \n  \\[m_i a_i = f_i + R_i - m_i\\gamma v_i\\]\n  Here \\(m_i, a_i, f_i, R_i, \\gamma, \\textrm{and} v_i\\)\n  represent in this order mass, acceleration, force exerted by all other atoms, random\n  force, frictional coefficient (the inverse of damping parameter damp),\n  and velocity. The random force \\(R_i\\) is “colored” so\n  that any vibrational mode with frequency \\(\\omega\\) will have a\n  temperature-sensitive energy \\(\\theta(\\omega,T)\\) which\n  resembles the energy expectation for a quantum harmonic oscillator\n  with the same natural frequency:\n  \n  \\[\\theta(\\omega T) = \\frac{\\hbar}{2} + \\hbar\\omega \\left[\\exp(\\frac{\\hbar\\omega}{k_B T})-1 \\right]^{-1}\\]\n  To efficiently generate the random forces, we employ the method\n  of (Barrat), that circumvents the need to generate all\n  random forces for all times before the simulation. The memory\n  requirement of this approach is less demanding and independent\n  of the simulation duration. Since the total random force \\(R_{tot}\\)\n  does not necessarily vanish for a finite number of atoms,\n  \\(R_i\\) is replaced by \\(R_i - \\frac{R_{tot}}{N_{tot}}\\)\n  to avoid collective motion of the system.\n  The temp parameter sets the target quantum temperature. LAMMPS will\n  still have an output temperature in its thermo style. That is the\n  instantaneous classical temperature \\(T^{cl}\\) derived from\n  the atom velocities at thermal equilibrium. A non-zero\n  \\(T^{cl}\\) will be present even when the quantum\n  temperature approaches zero. This is associated with zero-point energy\n  at low temperatures.\n  \n  \\[T^{cl} = \\sum \\frac{m_i v_i^2}{3 N k_B}\\]\n  The damp parameter is specified in time units, and it equals the\n  inverse of the frictional coefficient \\(\\gamma\\). \\(\\gamma\\)\n  should be as small as possible but slightly larger than the timescale\n  of anharmonic coupling in the system which is about 10 ps to 100\n  ps. When \\(\\gamma\\) is too large, it gives an energy spectrum that\n  differs from the desired Bose-Einstein spectrum. When \\(\\gamma\\)\n  is too small, the quantum thermal bath coupling to the system will be\n  less significant than anharmonic effects, reducing to a classical\n  limit. We find that setting \\(\\gamma\\) between 5 THz and 1 THz\n  could be appropriate depending on the system.\n  The random number seed is a positive integer used to initiate a\n  Marsaglia random number generator. Each processor uses the input seed\n  to generate its own unique seed and its own stream of random\n  numbers. Thus the dynamics of the system will not be identical on two\n  runs on different numbers of processors.\n  The f_max parameter truncate the noise frequency domain so that\n  vibrational modes with frequencies higher than f_max will not be\n  modulated. If we denote \\(\\Delta t\\) as the time interval for the\n  MD integration, f_max is always reset by the code to make\n  \\(\\alpha = (int)(2\\) f_max \\(\\Delta t)^{-1}\\) a\n  positive integer and print out relative information. An appropriate\n  value for the cutoff frequency f_max would be around 2~3 \\(f_D\\),\n  where \\(f_D\\) is the Debye frequency.\n  The N_f parameter is the frequency grid size, the number of points\n  from 0 to f_max in the frequency domain that will be\n  sampled. 3*2N_f per-atom random numbers are required\n  in the random force generation and there could be as many atoms as in\n  the whole simulation that can migrate into every individual\n  processor. A larger N_f provides a more accurate sampling of the\n  spectrum while consumes more memory.  With fixed f_max and\n  \\(\\gamma\\), N_f should be big enough to converge the classical\n  temperature \\(T^{cl}\\) as a function of target quantum bath\n  temperature. Memory usage per processor could be from 10 to 100\n  Mbytes.\n  \n  Note\n  Unlike the fix nvt command which performs\n  Nose/Hoover thermostatting AND time integration, this fix does NOT\n  perform time integration. It only modifies forces to a colored\n  thermostat. Thus you must use a separate time integration fix, like\n  fix nve or fix nph to actually\n  update the velocities and positions of atoms (as shown in the\n  examples). Likewise, this fix should not normally be used with\n  other fixes or commands that also specify system temperatures ,\n  e.g. fix nvt and fix temp/rescale.\n  \n  \n  Restart, fix_modify, output, run start/stop, minimizie info:\n  No information about this fix is written to binary restart files.  Because the state of the random number generator is not\n  saved in restart files, this means you cannot do “exact” restarts with\n  this fix. However, in a statistical sense, a restarted simulation\n  should produce similar behaviors of the system.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID qtb keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  qtb = style name of this fix\n  zero or more keyword/value pairs may be appended\n  keyword = temp or damp or seed or f_max or N_f\n  temp value = target quantum temperature (temperature units)\n  damp value = damping parameter (time units) inverse of friction gamma\n  seed value = random number seed (positive integer)\n  f_max value = upper cutoff frequency of the vibration spectrum (1/time units)\n  N_f value = number of frequency bins (positive integer)\n  \n  \n  ",
    "examples": "# (liquid methane modeled with the REAX force field, real units)\n  fix 1 all nve\n  fix 1 all qtb temp 110 damp 200 seed 35082 f_max 0.3 N_f 100\n  # (quartz modeled with the BKS force field, metal units)\n  fix 2 all nph iso 1.01325 1.01325 1\n  fix 2 all qtb temp 300 damp 1 seed 47508 f_max 120.0 N_f 100\n  \n  \n  ",
    "restrictions": "This fix style is part of the USER-QTB package.  It is only enabled if\n  LAMMPS was built with that package. See the Build package doc page for more info.\n  "
},
{
    "command": "fix reax/c/bonds",
    "description": "Write out the bond information computed by the ReaxFF potential specified\n  by pair_style reax/c in the exact same format as the\n  original stand-alone ReaxFF code of Adri van Duin.  The bond information\n  is written to filename on timesteps that are multiples of Nevery,\n  including timestep 0.  For time-averaged chemical species analysis,\n  please see the fix reaxc/c/species command.\n  The specified group-ID is ignored by this fix.\n  The format of the output file should be reasonably self-explanatory.\n  The meaning of the column header abbreviations is as follows:\n  \n  id = atom id\n  type = atom type\n  nb = number of bonds\n  id_1 = atom id of first bond\n  id_nb = atom id of Nth bond\n  mol = molecule id\n  bo_1 = bond order of first bond\n  bo_nb = bond order of Nth bond\n  abo = atom bond order (sum of all bonds)\n  nlp = number of lone pairs\n  q = atomic charge\n  \n  If the filename ends with “.gz”, the output file is written in gzipped\n  format.  A gzipped dump file will be about 3x smaller than the text\n  version, but will also take longer to write.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed in Speed\n  of the manual.  The accelerated styles take the same arguments and\n  should produce the same results, except for round-off and precision\n  issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See Speed of the manual for\n  more instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "fix ID group-ID reaxc/bonds Nevery filename\n  \n  \n  \n  ID, group-ID are documented in fix command\n  reax/bonds = style name of this fix command\n  Nevery = output interval in timesteps\n  filename = name of output file\n  \n  ",
    "examples": "fix 1 all reax/c/bonds 100 bonds.reaxc\n  \n  \n  ",
    "restrictions": "The fix reax/c/bonds command requires that the pair_style reax/c is invoked.  This fix is part of the\n  USER-REAXC package.  It is only enabled if LAMMPS was built with that\n  package.  See the Build package doc page for more\n  info.\n  To write gzipped bond files, you must compile LAMMPS with the\n  -DLAMMPS_GZIP option.\n  "
},
{
    "command": "fix reax/c/species",
    "description": "Write out the chemical species information computed by the ReaxFF\n  potential specified by pair_style reax/c.\n  Bond-order values (either averaged or instantaneous, depending on\n  value of Nrepeat) are used to determine chemical bonds.  Every\n  Nfreq timesteps, chemical species information is written to\n  filename as a two line output.  The first line is a header\n  containing labels. The second line consists of the following:\n  timestep, total number of molecules, total number of distinct species,\n  number of molecules of each species.  In this context, “species” means\n  a unique molecule.  The chemical formula of each species is given in\n  the first line.\n  If the filename ends with “.gz”, the output file is written in gzipped\n  format.  A gzipped dump file will be about 3x smaller than the text version,\n  but will also take longer to write.\n  Optional keyword cutoff can be assigned to change the minimum\n  bond-order values used in identifying chemical bonds between pairs of\n  atoms.  Bond-order cutoffs should be carefully chosen, as bond-order\n  cutoffs that are too small may include too many bonds (which will\n  result in an error), while cutoffs that are too large will result in\n  fragmented molecules.  The default cutoff of 0.3 usually gives good\n  results.\n  The optional keyword element can be used to specify the chemical\n  symbol printed for each LAMMPS atom type. The number of symbols must\n  match the number of LAMMPS atom types and each symbol must consist of\n  1 or 2 alphanumeric characters. Normally, these symbols should be\n  chosen to match the chemical identity of each LAMMPS atom type, as\n  specified using the reax/c pair_coeff command and\n  the ReaxFF force field file.\n  The optional keyword position writes center-of-mass positions of\n  each identified molecules to file filepos every posfreq timesteps.\n  The first line contains information on timestep, total number of\n  molecules, total number of distinct species, and box dimensions.  The\n  second line is a header containing labels.  From the third line\n  downward, each molecule writes a line of output containing the\n  following information: molecule ID, number of atoms in this molecule,\n  chemical formula, total charge, and center-of-mass xyz positions of\n  this molecule.  The xyz positions are in fractional coordinates\n  relative to the box dimensions.\n  For the keyword position, the filepos is the name of the output\n  file.  It can contain the wildcard character “*”.  If the “*”\n  character appears in filepos, then one file per snapshot is written\n  at posfreq and the “*” character is replaced with the timestep\n  value.  For example, AuO.pos.* becomes AuO.pos.0, AuO.pos.1000, etc.\n  \n  The Nevery, Nrepeat, and Nfreq arguments specify on what\n  timesteps the bond-order values are sampled to get the average bond\n  order.  The species analysis is performed using the average bond-order\n  on timesteps that are a multiple of Nfreq.  The average is over\n  Nrepeat bond-order samples, computed in the preceding portion of the\n  simulation every Nevery timesteps.  Nfreq must be a multiple of\n  Nevery and Nevery must be non-zero even if Nrepeat is 1.\n  Also, the timesteps\n  contributing to the average bond-order cannot overlap,\n  i.e. Nrepeat*Nevery can not exceed Nfreq.\n  For example, if Nevery=2, Nrepeat=6, and Nfreq=100, then bond-order\n  values on timesteps 90,92,94,96,98,100 will be used to compute the\n  average bond-order for the species analysis output on timestep 100.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.\n  This fix computes both a global vector of length 2 and a per-atom\n  vector, either of which can be accessed by various output commands.  The values in the global vector are\n  “intensive”.\n  The 2 values in the global vector are as follows:\n  \n  1 = total number of molecules\n  2 = total number of distinct species\n  \n  The per-atom vector stores the molecule ID for each atom as identified\n  by the fix.  If an atom is not in a molecule, its ID will be 0.\n  For atoms in the same molecule, the molecule ID for all of them\n  will be the same and will be equal to the smallest atom ID of\n  any atom in the molecule.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed in Speed\n  of the manual.  The accelerated styles take the same arguments and\n  should produce the same results, except for round-off and precision\n  issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See Speed of the manual for\n  more instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "fix ID group-ID reax/c/species Nevery Nrepeat Nfreq filename keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  reax/c/species = style name of this command\n  Nevery = sample bond-order every this many timesteps\n  Nrepeat = # of bond-order samples used for calculating averages\n  Nfreq = calculate average bond-order every this many timesteps\n  filename = name of output file\n  zero or more keyword/value pairs may be appended\n  keyword = cutoff or element or position\n  cutoff value = I J Cutoff\n    I, J = atom types\n    Cutoff = Bond-order cutoff value for this pair of atom types\n  element value = Element1, Element2, ...\n  position value = posfreq filepos\n    posfreq = write position files every this many timestep\n    filepos = name of position output file\n  \n  \n  ",
    "examples": "fix 1 all reax/c/species 10 10 100 species.out\n  fix 1 all reax/c/species 1 2 20 species.out cutoff 1 1 0.40 cutoff 1 2 0.55\n  fix 1 all reax/c/species 1 100 100 species.out element Au O H position 1000 AuOH.pos\n  \n  \n  ",
    "restrictions": "The “fix reax/c/species” currently only works with pair_style reax/c and it requires that the pair_style reax/c be invoked.  This fix is part of the\n  USER-REAXC package.  It is only enabled if LAMMPS was built with that\n  package.  See the Build package doc page for more\n  info.\n  To write gzipped species files, you must compile LAMMPS with the\n  -DLAMMPS_GZIP option.\n  It should be possible to extend it to other reactive pair_styles (such as\n  rebo, airebo,\n  comb, and bop), but this has not yet been done.\n  "
},
{
    "command": "fix recenter",
    "description": "Constrain the center-of-mass position of a group of atoms by adjusting\n  the coordinates of the atoms every timestep.  This is simply a small\n  shift that does not alter the dynamics of the system or change the\n  relative coordinates of any pair of atoms in the group.  This can be\n  used to insure the entire collection of atoms (or a portion of them)\n  do not drift during the simulation due to random perturbations\n  (e.g. fix langevin thermostatting).\n  Distance units for the x,y,z values are determined by the setting of\n  the units keyword, as discussed below.  One or more x,y,z values can\n  also be specified as NULL, which means exclude that dimension from\n  this operation.  Or it can be specified as INIT which means to\n  constrain the center-of-mass to its initial value at the beginning of\n  the run.\n  The center-of-mass (COM) is computed for the group specified by the\n  fix.  If the current COM is different than the specified x,y,z, then a\n  group of atoms has their coordinates shifted by the difference.  By\n  default the shifted group is also the group specified by the fix.  A\n  different group can be shifted by using the shift keyword.  For\n  example, the COM could be computed on a protein to keep it in the\n  center of the simulation box.  But the entire system (protein + water)\n  could be shifted.\n  If the units keyword is set to box, then the distance units of\n  x,y,z are defined by the units command - e.g. Angstroms\n  for real units.  A lattice value means the distance units are in\n  lattice spacings.  The lattice command must have been\n  previously used to define the lattice spacing.  A fraction value\n  means a fractional distance between the lo/hi box boundaries, e.g. 0.5\n  = middle of the box.  The default is to use lattice units.\n  Note that the velocity command can be used to create\n  velocities with zero aggregate linear and/or angular momentum.\n  \n  Note\n  This fix performs its operations at the same point in the\n  timestep as other time integration fixes, such as fix nve, fix nvt, or fix npt.\n  Thus fix recenter should normally be the last such fix specified in\n  the input script, since the adjustments it makes to atom coordinates\n  should come after the changes made by time integration.  LAMMPS will\n  warn you if your fixes are not ordered this way.\n  \n  \n  Note\n  If you use this fix on a small group of atoms (e.g. a molecule\n  in solvent) without using the shift keyword to adjust the positions\n  of all atoms in the system, then the results can be unpredictable.\n  For example, if the molecule is pushed consistently in one direction\n  by a flowing solvent, its velocity will increase.  But its coordinates\n  will be re-centered, meaning it is moved back towards the force.  Thus\n  over time, the velocity and effective temperature of the molecule\n  could become very large, though it won’t actually be moving due to the\n  re-centering.  If you are thermostatting the entire system, then the\n  solvent would be cooled to compensate.  A better solution for this\n  simulation scenario is to use the fix spring command\n  to tether the molecule in place.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.\n  This fix computes a global scalar which can be accessed by various\n  output commands.  The scalar is the distance the\n  group is moved by fix recenter.\n  This fix also computes global 3-vector which can be accessed by\n  various output commands.  The 3 quantities in the\n  vector are xyz components of displacement applied to the group of\n  atoms by the fix.\n  The scalar and vector values calculated by this fix are “extensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID recenter x y z keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  recenter = style name of this fix command\n  x,y,z = constrain center-of-mass to these coords (distance units),         any coord can also be NULL or INIT (see below)\n  zero or more keyword/value pairs may be appended\n  keyword = shift or units\n  shift value = group-ID\n    group-ID = group of atoms whose coords are shifted\n  units value = box or lattice or fraction\n  \n  \n  ",
    "examples": "fix 1 all recenter 0.0 0.5 0.0\n  fix 1 all recenter INIT INIT NULL\n  fix 1 all recenter INIT 0.0 0.0 units box\n  \n  \n  ",
    "restrictions": "This fix should not be used with an x,y,z setting that causes a large\n  shift in the system on the 1st timestep, due to the requested COM\n  being very different from the initial COM.  This could cause atoms to\n  be lost, especially in parallel.  Instead, use the\n  displace_atoms command, which can be used to\n  move atoms a large distance.\n  "
},
{
    "command": "fix restrain",
    "description": "Restrain the motion of the specified sets of atoms by making them part\n  of a bond or angle or dihedral interaction whose strength can vary\n  over time during a simulation.  This is functionally similar to\n  creating a bond or angle or dihedral for the same atoms in a data\n  file, as specified by the read_data command, albeit\n  with a time-varying pre-factor coefficient, and except for exclusion\n  rules, as explained below.\n  For the purpose of force field parameter-fitting or mapping a molecular\n  potential energy surface, this fix reduces the hassle and risk\n  associated with modifying data files.  In other words, use this fix to\n  temporarily force a molecule to adopt a particular conformation.  To\n  create a permanent bond or angle or dihedral, you should modify the\n  data file.\n  \n  Note\n  Adding a bond/angle/dihedral with this command does not apply\n  the exclusion rules and weighting factors specified by the\n  special_bonds command to atoms in the restraint\n  that are now bonded (1-2,1-3,1-4 neighbors) as a result.  If they are\n  close enough to interact in a pair_style sense\n  (non-bonded interaction), then the bond/angle/dihedral restraint\n  interaction will simply be superposed on top of that interaction.\n  \n  The group-ID specified by this fix is ignored.\n  The second example above applies a restraint to hold the dihedral\n  angle formed by atoms 1, 2, 3, and 4 near 120 degrees using a constant\n  restraint coefficient.  The fourth example applies similar restraints\n  to multiple dihedral angles using a restraint coefficient that\n  increases from 0.0 to 2000.0 over the course of the run.\n  \n  Note\n  Adding a force to atoms implies a change in their potential\n  energy as they move due to the applied force field.  For dynamics via\n  the run command, this energy can be added to the system’s\n  potential energy for thermodynamic output (see below).  For energy\n  minimization via the minimize command, this energy\n  must be added to the system’s potential energy to formulate a\n  self-consistent minimization problem (see below).\n  \n  In order for a restraint to be effective, the restraint force must\n  typically be significantly larger than the forces associated with\n  conventional force field terms.  If the restraint is applied during a\n  dynamics run (as opposed to during an energy minimization), a large\n  restraint coefficient can significantly reduce the stable timestep\n  size, especially if the atoms are initially far from the preferred\n  conformation.  You may need to experiment to determine what value of \\(K\\)\n  works best for a given application.\n  For the case of finding a minimum energy structure for a single\n  molecule with particular restraints (e.g. for fitting force field\n  parameters or constructing a potential energy surface), commands such\n  as the following may be useful:\n  # minimize molecule energy with restraints\n  velocity all create 600.0 8675309 mom yes rot yes dist gaussian\n  fix NVE all nve\n  fix TFIX all langevin 600.0 0.0 100 24601\n  fix REST all restrain dihedral 2 1 3 8 0.0 5000.0 ${angle1} dihedral 3 1 2 9 0.0 5000.0 ${angle2}\n  fix_modify REST energy yes\n  run 10000\n  fix TFIX all langevin 0.0 0.0 100 24601\n  fix REST all restrain dihedral 2 1 3 8 5000.0 5000.0 ${angle1} dihedral 3 1 2 9 5000.0 5000.0 ${angle2}\n  fix_modify REST energy yes\n  run 10000\n  # sanity check for convergence\n  minimize 1e-6 1e-9 1000 100000\n  # report unrestrained energies\n  unfix REST\n  run 0\n  \n  \n  \n  The bond keyword applies a bond restraint to the specified atoms\n  using the same functional form used by the bond_style harmonic command.  The potential associated with\n  the restraint is\n  \n  \\[E = K (r - r_0)^2\\]\n  with the following coefficients:\n  \n  \\(K\\) (energy/distance^2)\n  \\(r_0\\) (distance)\n  \n  \\(K\\) and \\(r_0\\) are specified with the fix.  Note that the usual 1/2 factor\n  is included in \\(K\\).\n  \n  The angle keyword applies an angle restraint to the specified atoms\n  using the same functional form used by the angle_style harmonic command.  The potential associated with\n  the restraint is\n  \n  \\[E = K (\\theta - \\theta_0)^2\\]\n  with the following coefficients:\n  \n  \\(K\\) (energy/radian^2)\n  \\(\\theta_0\\) (degrees)\n  \n  \\(K\\) and \\(\\theta_0\\) are specified with the fix.  Note that the usual 1/2\n  factor is included in \\(K\\).\n  \n  The dihedral keyword applies a dihedral restraint to the specified\n  atoms using a simplified form of the function used by the\n  dihedral_style charmm command.  The potential\n  associated with the restraint is\n  \n  \\[E = K [ 1 + \\cos (n \\phi - d) ]\\]\n  with the following coefficients:\n  \n  \\(K\\) (energy)\n  \\(n\\) (multiplicity, >= 0)\n  \\(d\\) (degrees) = \\(\\phi_0 + 180\\)\n  \n  \\(K\\) and \\(\\phi_0\\) are specified with the fix.  Note that the value of the\n  dihedral multiplicity \\(n\\) is set by default to 1. You can use the\n  optional mult keyword to set it to a different positive integer.\n  Also note that the energy will be a minimum when the\n  current dihedral angle \\(\\phi\\) is equal to \\(\\phi_0\\).\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The fix_modify energy option is supported by this\n  fix to add the potential energy associated with this fix to the\n  system’s potential energy as part of thermodynamic output.\n  The fix_modify respa option is supported by this\n  fix. This allows to set at which level of the r-RESPA\n  integrator the fix is adding its forces. Default is the outermost level.\n  \n  Note\n  If you want the fictitious potential energy associated with the\n  added forces to be included in the total potential energy of the\n  system (the quantity being minimized), you MUST enable the\n  fix_modify energy option for this fix.\n  \n  This fix computes a global scalar and a global vector of length 3,\n  which can be accessed by various output commands.\n  The scalar is the total potential energy for all the restraints as\n  discussed above. The vector values are the sum of contributions to the\n  following individual categories:\n  \n  1 = bond energy\n  2 = angle energy\n  3 = dihedral energy\n  \n  The scalar and vector values calculated by this fix are “extensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  ",
    "syntax": "fix ID group-ID restrain keyword args ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  restrain = style name of this fix command\n  one or more keyword/arg pairs may be appended\n  keyword = bond or angle or dihedral\n  bond args = atom1 atom2 Kstart Kstop r0\n    atom1,atom2 = IDs of 2 atoms in bond\n    Kstart,Kstop = restraint coefficients at start/end of run (energy units)\n    r0 = equilibrium bond distance (distance units)\n  angle args = atom1 atom2 atom3 Kstart Kstop theta0\n    atom1,atom2,atom3 = IDs of 3 atoms in angle, atom2 = middle atom\n    Kstart,Kstop = restraint coefficients at start/end of run (energy units)\n    theta0 = equilibrium angle theta (degrees)\n  dihedral args = atom1 atom2 atom3 atom4 Kstart Kstop phi0 keyword/value\n    atom1,atom2,atom3,atom4 = IDs of 4 atoms in dihedral in linear order\n    Kstart,Kstop = restraint coefficients at start/end of run (energy units)\n    phi0 = equilibrium dihedral angle phi (degrees)\n    keyword/value = optional keyword value pairs. supported keyword/value pairs:\n      mult n = dihedral multiplicity n (integer >= 0, default = 1)\n  \n  \n  ",
    "examples": "fix holdem all restrain bond 45 48 2000.0 2000.0 2.75\n  fix holdem all restrain dihedral 1 2 3 4 2000.0 2000.0 120.0\n  fix holdem all restrain bond 45 48 2000.0 2000.0 2.75 dihedral 1 2 3 4 2000.0 2000.0 120.0\n  fix texas_holdem all restrain dihedral 1 2 3 4 0.0 2000.0 120.0 dihedral 1 2 3 5 0.0 2000.0 -120.0 dihedral 1 2 3 6 0.0 2000.0 0.0\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  Related commands: none\n  Default: none\n  "
},
{
    "command": "fix rhok",
    "description": "The fix applies a force to atoms given by the potential\n  \n  \\[\\begin{split}U  = &  \\frac{1}{2} K (|\\rho_{\\vec{k}}| - a)^2 \\\\\n  \\rho_{\\vec{k}}  = & \\sum_j^N \\exp(-i\\vec{k} \\cdot \\vec{r}_j )/\\sqrt{N} \\\\\n  \\vec{k}  = & (2\\pi n_x /L_x , 2\\pi n_y  /L_y , 2\\pi n_z/L_z )\\end{split}\\]\n  as described in (Pedersen).\n  This field, which biases configurations with long-range order, can be\n  used to study crystal-liquid interfaces and determine melting\n  temperatures (Pedersen).\n  An example of using the interface pinning method is located in the\n  examples/USER/misc/rhok directory.\n  ",
    "syntax": "fix ID group-ID restrain keyword args ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  restrain = style name of this fix command\n  one or more keyword/arg pairs may be appended\n  keyword = bond or angle or dihedral\n  bond args = atom1 atom2 Kstart Kstop r0\n    atom1,atom2 = IDs of 2 atoms in bond\n    Kstart,Kstop = restraint coefficients at start/end of run (energy units)\n    r0 = equilibrium bond distance (distance units)\n  angle args = atom1 atom2 atom3 Kstart Kstop theta0\n    atom1,atom2,atom3 = IDs of 3 atoms in angle, atom2 = middle atom\n    Kstart,Kstop = restraint coefficients at start/end of run (energy units)\n    theta0 = equilibrium angle theta (degrees)\n  dihedral args = atom1 atom2 atom3 atom4 Kstart Kstop phi0 keyword/value\n    atom1,atom2,atom3,atom4 = IDs of 4 atoms in dihedral in linear order\n    Kstart,Kstop = restraint coefficients at start/end of run (energy units)\n    phi0 = equilibrium dihedral angle phi (degrees)\n    keyword/value = optional keyword value pairs. supported keyword/value pairs:\n      mult n = dihedral multiplicity n (integer >= 0, default = 1)\n  \n  \n  ",
    "examples": "fix bias all rhok 16 0 0 4.0 16.0\n  fix 1 all npt temp 0.8 0.8 4.0 z 2.2 2.2 8.0\n  # output of 4 values from fix rhok: U_bias rho_k_RE  rho_k_IM  \\|rho_k\\|\n  thermo_style custom step temp pzz lz f_bias f_bias[1] f_bias[2] f_bias[3]\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "fix rigid",
    "description": "Treat one or more sets of atoms as independent rigid bodies.  This\n  means that each timestep the total force and torque on each rigid body\n  is computed as the sum of the forces and torques on its constituent\n  particles.  The coordinates, velocities, and orientations of the atoms\n  in each body are then updated so that the body moves and rotates as a\n  single entity.  This is implemented by creating internal data structures\n  for each rigid body and performing time integration on these data\n  structures.  Positions, velocities, and orientations of the constituent\n  particles are regenerated from the rigid body data structures in every\n  time step. This restricts which operations and fixes can be applied to\n  rigid bodies. See below for a detailed discussion.\n  Examples of large rigid bodies are a colloidal particle, or portions\n  of a biomolecule such as a protein.\n  Example of small rigid bodies are patchy nanoparticles, such as those\n  modeled in this paper by Sharon Glotzer’s group, clumps of\n  granular particles, lipid molecules consisting of one or more point\n  dipoles connected to other spheroids or ellipsoids, irregular\n  particles built from line segments (2d) or triangles (3d), and\n  coarse-grain models of nano or colloidal particles consisting of a\n  small number of constituent particles.  Note that the fix shake command can also be used to rigidify small\n  molecules of 2, 3, or 4 atoms, e.g. water molecules.  That fix treats\n  the constituent atoms as point masses.\n  These fixes also update the positions and velocities of the atoms in\n  each rigid body via time integration, in the NVE, NVT, NPT, or NPH\n  ensemble, as described below.\n  There are two main variants of this fix, fix rigid and fix\n  rigid/small.  The NVE/NVT/NPT/NHT versions belong to one of the two\n  variants, as their style names indicate.\n  \n  Note\n  Not all of the bodystyle options and keyword/value options are\n  available for both the rigid and rigid/small variants.  See\n  details below.\n  \n  The rigid styles are typically the best choice for a system with a\n  small number of large rigid bodies, each of which can extend across\n  the domain of many processors.  It operates by creating a single\n  global list of rigid bodies, which all processors contribute to.\n  MPI_Allreduce operations are performed each timestep to sum the\n  contributions from each processor to the force and torque on all the\n  bodies.  This operation will not scale well in parallel if large\n  numbers of rigid bodies are simulated.\n  The rigid/small styles are typically best for a system with a large\n  number of small rigid bodies.  Each body is assigned to the atom\n  closest to the geometrical center of the body.  The fix operates using\n  local lists of rigid bodies owned by each processor and information is\n  exchanged and summed via local communication between neighboring\n  processors when ghost atom info is accumulated.\n  \n  Note\n  To use the rigid/small styles the ghost atom cutoff must be\n  large enough to span the distance between the atom that owns the body\n  and every other atom in the body.  This distance value is printed out\n  when the rigid bodies are defined.  If the\n  pair_style cutoff plus neighbor skin does not span\n  this distance, then you should use the comm_modify cutoff command with a setting epsilon larger than\n  the distance.\n  \n  Which of the two variants is faster for a particular problem is hard\n  to predict.  The best way to decide is to perform a short test run.\n  Both variants should give identical numerical answers for short runs.\n  Long runs should give statistically similar results, but round-off\n  differences may accumulate to produce divergent trajectories.\n  \n  Note\n  You should not update the atoms in rigid bodies via other\n  time-integration fixes (e.g. fix nve, fix nvt, fix npt, fix move),\n  or you will have conflicting updates to positions and velocities\n  resulting in unphysical behavior in most cases. When performing a hybrid\n  simulation with some atoms in rigid bodies, and some not, a separate\n  time integration fix like fix nve or fix nvt should be used for the non-rigid particles.\n  \n  \n  Note\n  These fixes are overkill if you simply want to hold a collection\n  of atoms stationary or have them move with a constant velocity.  A\n  simpler way to hold atoms stationary is to not include those atoms in\n  your time integration fix.  E.g. use “fix 1 mobile nve” instead of\n  “fix 1 all nve”, where “mobile” is the group of atoms that you want to\n  move.  You can move atoms with a constant velocity by assigning them\n  an initial velocity (via the velocity command),\n  setting the force on them to 0.0 (via the fix setforce command), and integrating them as usual\n  (e.g. via the fix nve command).\n  \n  \n  Warning\n  The aggregate properties of each rigid body are\n  calculated at the start of a simulation run and are maintained in\n  internal data structures. The properties include the position and\n  velocity of the center-of-mass of the body, its moments of inertia, and\n  its angular momentum.  This is done using the properties of the\n  constituent atoms of the body at that point in time (or see the infile\n  keyword option).  Thereafter, changing these properties of individual\n  atoms in the body will have no effect on a rigid body’s dynamics, unless\n  they effect any computation of per-atom forces or torques. If the\n  keyword reinit is set to yes (the default), the rigid body data\n  structures will be recreated at the beginning of each run command;\n  if the keyword reinit is set to no, the rigid body data structures\n  will be built only at the very first run command and maintained for\n  as long as the rigid fix is defined. For example, you might think you\n  could displace the atoms in a body or add a large velocity to each atom\n  in a body to make it move in a desired direction before a 2nd run is\n  performed, using the set or\n  displace_atoms or velocity\n  commands.  But these commands will not affect the internal attributes\n  of the body unless reinit is set to yes. With reinit set to no\n  (or using the infile option, which implies reinit no) the position\n  and velocity of individual atoms in the body will be reset when time\n  integration starts again.\n  \n  \n  Each rigid body must have two or more atoms.  An atom can belong to at\n  most one rigid body.  Which atoms are in which bodies can be defined\n  via several options.\n  \n  Note\n  With the rigid/small styles, which require that bodystyle be\n  specified as molecule or custom, you can define a system that has\n  no rigid bodies initially.  This is useful when you are using the\n  mol keyword in conjunction with another fix that is adding rigid\n  bodies on-the-fly as molecules, such as fix deposit\n  or fix pour.\n  \n  For bodystyle single the entire fix group of atoms is treated as one\n  rigid body.  This option is only allowed for the rigid styles.\n  For bodystyle molecule, atoms are grouped into rigid bodies by their\n  respective molecule IDs: each set of atoms in the fix group with the\n  same molecule ID is treated as a different rigid body.  This option is\n  allowed for both the rigid and rigid/small styles.  Note that\n  atoms with a molecule ID = 0 will be treated as a single rigid body.\n  For a system with atomic solvent (typically this is atoms with\n  molecule ID = 0) surrounding rigid bodies, this may not be what you\n  want.  Thus you should be careful to use a fix group that only\n  includes atoms you want to be part of rigid bodies.\n  Bodystyle custom is similar to bodystyle molecule except that it\n  is more flexible in using other per-atom properties to define the sets\n  of atoms that form rigid bodies.  An integer vector defined by the\n  fix property/atom command can be used.  Or an\n  atom-style or atomfile-style variable can be used; the\n  floating-point value produced by the variable is rounded to an\n  integer.  As with bodystyle molecule, each set of atoms in the fix\n  groups with the same integer value is treated as a different rigid\n  body.  Since fix property/atom vectors and atom-style variables\n  produce values for all atoms, you should be careful to use a fix group\n  that only includes atoms you want to be part of rigid bodies.\n  \n  Note\n  To compute the initial center-of-mass position and other\n  properties of each rigid body, the image flags for each atom in the\n  body are used to “unwrap” the atom coordinates.  Thus you must insure\n  that these image flags are consistent so that the unwrapping creates a\n  valid rigid body (one where the atoms are close together),\n  particularly if the atoms in a single rigid body straddle a periodic\n  boundary.  This means the input data file or restart file must define\n  the image flags for each atom consistently or that you have used the\n  set command to specify them correctly.  If a dimension is\n  non-periodic then the image flag of each atom must be 0 in that\n  dimension, else an error is generated.\n  \n  The force and torque keywords discussed next are only allowed for\n  the rigid styles.\n  By default, each rigid body is acted on by other atoms which induce an\n  external force and torque on its center of mass, causing it to\n  translate and rotate.  Components of the external center-of-mass force\n  and torque can be turned off by the force and torque keywords.\n  This may be useful if you wish a body to rotate but not translate, or\n  vice versa, or if you wish it to rotate or translate continuously\n  unaffected by interactions with other particles.  Note that if you\n  expect a rigid body not to move or rotate by using these keywords, you\n  must insure its initial center-of-mass translational or angular\n  velocity is 0.0.  Otherwise the initial translational or angular\n  momentum the body has will persist.\n  An xflag, yflag, or zflag set to off means turn off the component of\n  force of torque in that dimension.  A setting of on means turn on\n  the component, which is the default.  Which rigid body(s) the settings\n  apply to is determined by the first argument of the force and\n  torque keywords.  It can be an integer M from 1 to Nbody, where\n  Nbody is the number of rigid bodies defined.  A wild-card asterisk can\n  be used in place of, or in conjunction with, the M argument to set the\n  flags for multiple rigid bodies.  This takes the form “*” or “*n” or\n  “n*” or “m*n”.  If N = the number of rigid bodies, then an asterisk\n  with no numeric values means all bodies from 1 to N.  A leading\n  asterisk means all bodies from 1 to n (inclusive).  A trailing\n  asterisk means all bodies from n to N (inclusive).  A middle asterisk\n  means all types from m to n (inclusive).  Note that you can use the\n  force or torque keywords as many times as you like.  If a\n  particular rigid body has its component flags set multiple times, the\n  settings from the final keyword are used.\n  \n  Note\n  For computational efficiency, you may wish to turn off pairwise\n  and bond interactions within each rigid body, as they no longer\n  contribute to the motion.  The neigh_modify exclude and delete_bonds\n  commands are used to do this.  If the rigid bodies have strongly\n  overlapping atoms, you may need to turn off these interactions to\n  avoid numerical problems due to large equal/opposite intra-body forces\n  swamping the contribution of small inter-body forces.\n  \n  For computational efficiency, you should typically define one fix\n  rigid or fix rigid/small command which includes all the desired rigid\n  bodies.  LAMMPS will allow multiple rigid fixes to be defined, but it\n  is more expensive.\n  \n  The constituent particles within a rigid body can be point particles\n  (the default in LAMMPS) or finite-size particles, such as spheres or\n  ellipsoids or line segments or triangles.  See the atom_style sphere and ellipsoid and line and tri commands for more\n  details on these kinds of particles.  Finite-size particles contribute\n  differently to the moment of inertia of a rigid body than do point\n  particles.  Finite-size particles can also experience torque (e.g. due\n  to frictional granular interactions) and have an\n  orientation.  These contributions are accounted for by these fixes.\n  Forces between particles within a body do not contribute to the\n  external force or torque on the body.  Thus for computational\n  efficiency, you may wish to turn off pairwise and bond interactions\n  between particles within each rigid body.  The neigh_modify exclude and delete_bonds\n  commands are used to do this.  For finite-size particles this also\n  means the particles can be highly overlapped when creating the rigid\n  body.\n  \n  The rigid, rigid/nve, rigid/small, and rigid/small/nve styles\n  perform constant NVE time integration.  They are referred to below as\n  the 4 NVE rigid styles.  The only difference is that the rigid and\n  rigid/small styles use an integration technique based on Richardson\n  iterations.  The rigid/nve and rigid/small/nve styles uses the\n  methods described in the paper by Miller, which are thought\n  to provide better energy conservation than an iterative approach.\n  The rigid/nvt and rigid/nvt/small styles performs constant NVT\n  integration using a Nose/Hoover thermostat with chains as described\n  originally in (Hoover) and (Martyna), which\n  thermostats both the translational and rotational degrees of freedom\n  of the rigid bodies.  They are referred to below as the 2 NVT rigid\n  styles.  The rigid-body algorithm used by rigid/nvt is described in\n  the paper by Kamberaj.\n  The rigid/npt, rigid/nph, rigid/npt/small, and rigid/nph/small\n  styles perform constant NPT or NPH integration using a Nose/Hoover\n  barostat with chains.  They are referred to below as the 4 NPT and NPH\n  rigid styles.  For the NPT case, the same Nose/Hoover thermostat is\n  also used as with rigid/nvt and rigid/nvt/small.\n  The barostat parameters are specified using one or more of the iso,\n  aniso, x, y, z and couple keywords.  These keywords give you\n  the ability to specify 3 diagonal components of the external stress\n  tensor, and to couple these components together so that the dimensions\n  they represent are varied together during a constant-pressure\n  simulation.  The effects of these keywords are similar to those\n  defined in fix npt/nph\n  \n  Note\n  Currently the rigid/npt, rigid/nph, rigid/npt/small, and\n  rigid/nph/small styles do not support triclinic (non-orthogonal)\n  boxes.\n  \n  The target pressures for each of the 6 components of the stress tensor\n  can be specified independently via the x, y, z keywords, which\n  correspond to the 3 simulation box dimensions.  For each component,\n  the external pressure or tensor component at each timestep is a ramped\n  value during the run from Pstart to Pstop. If a target pressure is\n  specified for a component, then the corresponding box dimension will\n  change during a simulation.  For example, if the y keyword is used,\n  the y-box length will change.  A box dimension will not change if that\n  component is not specified, although you have the option to change\n  that dimension via the fix deform command.\n  For all barostat keywords, the Pdamp parameter operates like the\n  Tdamp parameter, determining the time scale on which pressure is\n  relaxed.  For example, a value of 10.0 means to relax the pressure in\n  a timespan of (roughly) 10 time units (e.g. tau or fmsec or psec - see\n  the units command).\n  Regardless of what atoms are in the fix group (the only atoms which\n  are time integrated), a global pressure or stress tensor is computed\n  for all atoms.  Similarly, when the size of the simulation box is\n  changed, all atoms are re-scaled to new positions, unless the keyword\n  dilate is specified with a dilate-group-ID for a group that\n  represents a subset of the atoms.  This can be useful, for example, to\n  leave the coordinates of atoms in a solid substrate unchanged and\n  controlling the pressure of a surrounding fluid.  Another example is a\n  system consisting of rigid bodies and point particles where the\n  barostat is only coupled with the rigid bodies.  This option should be\n  used with care, since it can be unphysical to dilate some atoms and\n  not others, because it can introduce large, instantaneous\n  displacements between a pair of atoms (one dilated, one not) that are\n  far from the dilation origin.\n  The couple keyword allows two or three of the diagonal components of\n  the pressure tensor to be “coupled” together.  The value specified\n  with the keyword determines which are coupled.  For example, xz\n  means the Pxx and Pzz components of the stress tensor are coupled.\n  Xyz means all 3 diagonal components are coupled.  Coupling means two\n  things: the instantaneous stress will be computed as an average of the\n  corresponding diagonal components, and the coupled box dimensions will\n  be changed together in lockstep, meaning coupled dimensions will be\n  dilated or contracted by the same percentage every timestep.  The\n  Pstart, Pstop, Pdamp parameters for any coupled dimensions must\n  be identical.  Couple xyz can be used for a 2d simulation; the z\n  dimension is simply ignored.\n  The iso and aniso keywords are simply shortcuts that are\n  equivalent to specifying several other keywords together.\n  The keyword iso means couple all 3 diagonal components together when\n  pressure is computed (hydrostatic pressure), and dilate/contract the\n  dimensions together.  Using “iso Pstart Pstop Pdamp” is the same as\n  specifying these 4 keywords:\n  x Pstart Pstop Pdamp\n  y Pstart Pstop Pdamp\n  z Pstart Pstop Pdamp\n  couple xyz\n  \n  \n  The keyword aniso means x, y, and z dimensions are controlled\n  independently using the Pxx, Pyy, and Pzz components of the\n  stress tensor as the driving forces, and the specified scalar external\n  pressure.  Using “aniso Pstart Pstop Pdamp” is the same as specifying\n  these 4 keywords:\n  x Pstart Pstop Pdamp\n  y Pstart Pstop Pdamp\n  z Pstart Pstop Pdamp\n  couple none\n  \n  \n  \n  The keyword/value option pairs are used in the following ways.\n  The reinit keyword determines, whether the rigid body properties\n  are re-initialized between run commands. With the option yes (the\n  default) this is done, with the option no this is not done. Turning\n  off the re-initialization can be helpful to protect rigid bodies against\n  unphysical manipulations between runs or when properties cannot be\n  easily re-computed (e.g. when read from a file). When using the infile\n  keyword, the reinit option is automatically set to no.\n  The langevin and temp and tparam keywords perform thermostatting\n  of the rigid bodies, altering both their translational and rotational\n  degrees of freedom.  What is meant by “temperature” of a collection of\n  rigid bodies and how it can be monitored via the fix output is\n  discussed below.\n  The langevin keyword applies a Langevin thermostat to the constant\n  NVE time integration performed by any of the 4 NVE rigid styles:\n  rigid, rigid/nve, rigid/small, rigid/small/nve.  It cannot be\n  used with the 2 NVT rigid styles: rigid/nvt, rigid/small/nvt.  The\n  desired temperature at each timestep is a ramped value during the run\n  from Tstart to Tstop.  The Tdamp parameter is specified in time\n  units and determines how rapidly the temperature is relaxed.  For\n  example, a value of 100.0 means to relax the temperature in a timespan\n  of (roughly) 100 time units (tau or fmsec or psec - see the\n  units command).  The random # seed must be a positive\n  integer.\n  The way that Langevin thermostatting operates is explained on the fix langevin doc page.  If you wish to simply viscously\n  damp the rotational motion without thermostatting, you can set\n  Tstart and Tstop to 0.0, which means only the viscous drag term in\n  the Langevin thermostat will be applied.  See the discussion on the\n  fix viscous doc page for details.\n  \n  Note\n  When the langevin keyword is used with fix rigid versus fix\n  rigid/small, different dynamics will result for parallel runs.  This\n  is because of the way random numbers are used in the two cases.  The\n  dynamics for the two cases should be statistically similar, but will\n  not be identical, even for a single timestep.\n  \n  The temp and tparam keywords apply a Nose/Hoover thermostat to the\n  NVT time integration performed by the 2 NVT rigid styles.  They cannot\n  be used with the 4 NVE rigid styles.  The desired temperature at each\n  timestep is a ramped value during the run from Tstart to Tstop.\n  The Tdamp parameter is specified in time units and determines how\n  rapidly the temperature is relaxed.  For example, a value of 100.0\n  means to relax the temperature in a timespan of (roughly) 100 time\n  units (tau or fmsec or psec - see the units command).\n  Nose/Hoover chains are used in conjunction with this thermostat.  The\n  tparam keyword can optionally be used to change the chain settings\n  used.  Tchain is the number of thermostats in the Nose Hoover chain.\n  This value, along with Tdamp can be varied to dampen undesirable\n  oscillations in temperature that can occur in a simulation.  As a rule\n  of thumb, increasing the chain length should lead to smaller\n  oscillations. The keyword pchain specifies the number of\n  thermostats in the chain thermostatting the barostat degrees of\n  freedom.\n  \n  Note\n  There are alternate ways to thermostat a system of rigid bodies.\n  You can use fix langevin to treat the individual\n  particles in the rigid bodies as effectively immersed in an implicit\n  solvent, e.g. a Brownian dynamics model.  For hybrid systems with both\n  rigid bodies and solvent particles, you can thermostat only the\n  solvent particles that surround one or more rigid bodies by\n  appropriate choice of groups in the compute and fix commands for\n  temperature and thermostatting.  The solvent interactions with the\n  rigid bodies should then effectively thermostat the rigid body\n  temperature as well without use of the Langevin or Nose/Hoover options\n  associated with the fix rigid commands.\n  \n  \n  The mol keyword can only be used with the rigid/small styles.  It\n  must be used when other commands, such as fix deposit or fix pour, add rigid\n  bodies on-the-fly during a simulation.  You specify a template-ID\n  previously defined using the molecule command, which\n  reads a file that defines the molecule.  You must use the same\n  template-ID that the other fix which is adding rigid bodies uses.\n  The coordinates, atom types, atom diameters, center-of-mass, and\n  moments of inertia can be specified in the molecule file.  See the\n  molecule command for details.  The only settings\n  required to be in this file are the coordinates and types of atoms in\n  the molecule, in which case the molecule command calculates the other\n  quantities itself.\n  Note that these other fixes create new rigid bodies, in addition to\n  those defined initially by this fix via the bodystyle setting.\n  Also note that when using the mol keyword, extra restart information\n  about all rigid bodies is written out whenever a restart file is\n  written out.  See the NOTE in the next section for details.\n  \n  The infile keyword allows a file of rigid body attributes to be read\n  in from a file, rather then having LAMMPS compute them.  There are 5\n  such attributes: the total mass of the rigid body, its center-of-mass\n  position, its 6 moments of inertia, its center-of-mass velocity, and\n  the 3 image flags of the center-of-mass position.  For rigid bodies\n  consisting of point particles or non-overlapping finite-size\n  particles, LAMMPS can compute these values accurately.  However, for\n  rigid bodies consisting of finite-size particles which overlap each\n  other, LAMMPS will ignore the overlaps when computing these 4\n  attributes.  The amount of error this induces depends on the amount of\n  overlap.  To avoid this issue, the values can be pre-computed\n  (e.g. using Monte Carlo integration).\n  The format of the file is as follows.  Note that the file does not\n  have to list attributes for every rigid body integrated by fix rigid.\n  Only bodies which the file specifies will have their computed\n  attributes overridden.  The file can contain initial blank lines or\n  comment lines starting with “#” which are ignored.  The first\n  non-blank, non-comment line should list N = the number of lines to\n  follow.  The N successive lines contain the following information:\n  ID1 masstotal xcm ycm zcm ixx iyy izz ixy ixz iyz vxcm vycm vzcm lx ly lz ixcm iycm izcm\n  ID2 masstotal xcm ycm zcm ixx iyy izz ixy ixz iyz vxcm vycm vzcm lx ly lz ixcm iycm izcm\n  ...\n  IDN masstotal xcm ycm zcm ixx iyy izz ixy ixz iyz vxcm vycm vzcm lx ly lz ixcm iycm izcm\n  \n  \n  The rigid body IDs are all positive integers.  For the single\n  bodystyle, only an ID of 1 can be used.  For the group bodystyle,\n  IDs from 1 to Ng can be used where Ng is the number of specified\n  groups.  For the molecule bodystyle, use the molecule ID for the\n  atoms in a specific rigid body as the rigid body ID.\n  The masstotal and center-of-mass coordinates (xcm,ycm,zcm) are\n  self-explanatory.  The center-of-mass should be consistent with what\n  is calculated for the position of the rigid body with all its atoms\n  unwrapped by their respective image flags.  If this produces a\n  center-of-mass that is outside the simulation box, LAMMPS wraps it\n  back into the box.\n  The 6 moments of inertia (ixx,iyy,izz,ixy,ixz,iyz) should be the\n  values consistent with the current orientation of the rigid body\n  around its center of mass.  The values are with respect to the\n  simulation box XYZ axes, not with respect to the principal axes of the\n  rigid body itself.  LAMMPS performs the latter calculation internally.\n  The (vxcm,vycm,vzcm) values are the velocity of the center of mass.\n  The (lx,ly,lz) values are the angular momentum of the body.  The\n  (vxcm,vycm,vzcm) and (lx,ly,lz) values can simply be set to 0 if you\n  wish the body to have no initial motion.\n  The (ixcm,iycm,izcm) values are the image flags of the center of mass\n  of the body.  For periodic dimensions, they specify which image of the\n  simulation box the body is considered to be in.  An image of 0 means\n  it is inside the box as defined.  A value of 2 means add 2 box lengths\n  to get the true value.  A value of -1 means subtract 1 box length to\n  get the true value.  LAMMPS updates these flags as the rigid bodies\n  cross periodic boundaries during the simulation.\n  \n  Note\n  If you use the infile or mol keywords and write restart\n  files during a simulation, then each time a restart file is written,\n  the fix also write an auxiliary restart file with the name\n  rfile.rigid, where “rfile” is the name of the restart file,\n  e.g. tmp.restart.10000 and tmp.restart.10000.rigid.  This auxiliary\n  file is in the same format described above.  Thus it can be used in a\n  new input script that restarts the run and re-specifies a rigid fix\n  using an infile keyword and the appropriate filename.  Note that the\n  auxiliary file will contain one line for every rigid body, even if the\n  original file only listed a subset of the rigid bodies.\n  \n  \n  If you use a temperature compute with a group that\n  includes particles in rigid bodies, the degrees-of-freedom removed by\n  each rigid body are accounted for in the temperature (and pressure)\n  computation, but only if the temperature group includes all the\n  particles in a particular rigid body.\n  A 3d rigid body has 6 degrees of freedom (3 translational, 3\n  rotational), except for a collection of point particles lying on a\n  straight line, which has only 5, e.g a dimer.  A 2d rigid body has 3\n  degrees of freedom (2 translational, 1 rotational).\n  \n  Note\n  You may wish to explicitly subtract additional\n  degrees-of-freedom if you use the force and torque keywords to\n  eliminate certain motions of one or more rigid bodies.  LAMMPS does\n  not do this automatically.\n  \n  The rigid body contribution to the pressure of the system (virial) is\n  also accounted for by this fix.\n  \n  If your simulation is a hybrid model with a mixture of rigid bodies\n  and non-rigid particles (e.g. solvent) there are several ways these\n  rigid fixes can be used in tandem with fix nve, fix nvt, fix npt, and fix nph.\n  If you wish to perform NVE dynamics (no thermostatting or\n  barostatting), use one of 4 NVE rigid styles to integrate the rigid\n  bodies, and fix nve to integrate the non-rigid\n  particles.\n  If you wish to perform NVT dynamics (thermostatting, but no\n  barostatting), you can use one of the 2 NVT rigid styles for the rigid\n  bodies, and any thermostatting fix for the non-rigid particles (fix nvt, fix langevin, fix temp/berendsen).  You can also use one of the\n  4 NVE rigid styles for the rigid bodies and thermostat them using fix langevin on the group that contains all the\n  particles in the rigid bodies.  The net force added by fix langevin to each rigid body effectively thermostats\n  its translational center-of-mass motion.  Not sure how well it does at\n  thermostatting its rotational motion.\n  If you with to perform NPT or NPH dynamics (barostatting), you cannot\n  use both fix npt and the NPT or NPH rigid styles.  This\n  is because there can only be one fix which monitors the global\n  pressure and changes the simulation box dimensions.  So you have 3\n  choices:\n  \n  Use one of the 4 NPT or NPH styles for the rigid bodies.  Use the\n  dilate all option so that it will dilate the positions of the\n  non-rigid particles as well.  Use fix nvt (or any other\n  thermostat) for the non-rigid particles.\n  Use fix npt for the group of non-rigid particles.  Use\n  the dilate all option so that it will dilate the center-of-mass\n  positions of the rigid bodies as well.  Use one of the 4 NVE or 2 NVT\n  rigid styles for the rigid bodies.\n  Use fix press/berendsen to compute the\n  pressure and change the box dimensions.  Use one of the 4 NVE or 2 NVT\n  rigid styles for the rigid bodies.  Use fix nvt (or any\n  other thermostat) for the non-rigid particles.\n  \n  In all case, the rigid bodies and non-rigid particles both contribute\n  to the global pressure and the box is scaled the same by any of the\n  barostatting fixes.\n  You could even use the 2nd and 3rd options for a non-hybrid simulation\n  consisting of only rigid bodies, assuming you give fix npt an empty group, though it’s an odd thing to do.  The\n  barostatting fixes (fix npt and fix press/berensen) will monitor the pressure\n  and change the box dimensions, but not time integrate any particles.\n  The integration of the rigid bodies will be performed by fix\n  rigid/nvt.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about the 4 NVE rigid styles is written to binary restart files.  The exception is if the infile or\n  mol keyword is used, in which case an auxiliary file is written out\n  with rigid body information each time a restart file is written, as\n  explained above for the infile keyword.  For the 2 NVT rigid styles,\n  the state of the Nose/Hoover thermostat is written to binary restart files.  Ditto for the 4 NPT and NPH rigid styles, and\n  the state of the Nose/Hoover barostat.  See the\n  read_restart command for info on how to re-specify\n  a fix in an input script that reads a restart file, so that the\n  operation of the fix continues in an uninterrupted fashion.\n  The fix_modify energy option is supported by the 6\n  NVT, NPT, NPH rigid styles to add the energy change induced by the\n  thermostatting to the system’s potential energy as part of\n  thermodynamic output.\n  The fix_modify virial option is supported by this\n  fix to add the contribution due to keeping the objects rigid to the\n  system’s virial as part of thermodynamic output.\n  The default is virial yes\n  The fix_modify temp and press options are\n  supported by the 4 NPT and NPH rigid styles to change the computes\n  used to calculate the instantaneous pressure tensor.  Note that the 2\n  NVT rigid fixes do not use any external compute to compute\n  instantaneous temperature.\n  The fix_modify bodyforces option is supported by\n  all rigid styles to set whether per-body forces and torques are\n  computed early or late in a timestep, i.e. at the post-force stage or\n  at the final-integrate stage or the timestep, respectively.\n  The 2 NVE rigid fixes compute a global scalar which can be accessed by\n  various output commands.  The scalar value\n  calculated by these fixes is “intensive”.  The scalar is the current\n  temperature of the collection of rigid bodies.  This is averaged over\n  all rigid bodies and their translational and rotational degrees of\n  freedom.  The translational energy of a rigid body is 1/2 m v^2, where\n  m = total mass of the body and v = the velocity of its center of mass.\n  The rotational energy of a rigid body is 1/2 I w^2, where I = the\n  moment of inertia tensor of the body and w = its angular velocity.\n  Degrees of freedom constrained by the force and torque keywords\n  are removed from this calculation, but only for the rigid and\n  rigid/nve fixes.\n  The 6 NVT, NPT, NPH rigid fixes compute a global scalar which can be\n  accessed by various output commands.  The scalar\n  value calculated by these fixes is “extensive”.  The scalar is the\n  cumulative energy change due to the thermostatting and barostatting\n  the fix performs.\n  All of the rigid styles (not the rigid/small styles) compute a\n  global array of values which can be accessed by various output commands.  Similar information about the bodies\n  defined by the rigid/small styles can be accessed via the compute rigid/local command.\n  The number of rows in the array is equal to the number of rigid\n  bodies.  The number of columns is 15.  Thus for each rigid body, 15\n  values are stored: the xyz coords of the center of mass (COM), the xyz\n  components of the COM velocity, the xyz components of the force acting\n  on the COM, the xyz components of the torque acting on the COM, and\n  the xyz image flags of the COM.\n  The center of mass (COM) for each body is similar to unwrapped\n  coordinates written to a dump file.  It will always be inside (or\n  slightly outside) the simulation box.  The image flags have the same\n  meaning as image flags for atom positions (see the “dump” command).\n  This means you can calculate the unwrapped COM by applying the image\n  flags to the COM, the same as when unwrapped coordinates are written\n  to a dump file.\n  The force and torque values in the array are not affected by the\n  force and torque keywords in the fix rigid command; they reflect\n  values before any changes are made by those keywords.\n  The ordering of the rigid bodies (by row in the array) is as follows.\n  For the single keyword there is just one rigid body.  For the\n  molecule keyword, the bodies are ordered by ascending molecule ID.\n  For the group keyword, the list of group IDs determines the ordering\n  of bodies.\n  The array values calculated by these fixes are “intensive”, meaning\n  they are independent of the number of atoms in the simulation.\n  No parameter of these fixes can be used with the start/stop keywords\n  of the run command.  These fixes are not invoked during\n  energy minimization.\n  ",
    "syntax": "fix ID group-ID style bodystyle args keyword values ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  style = rigid or rigid/nve or rigid/nvt or rigid/npt or rigid/nph or rigid/small or rigid/nve/small or rigid/nvt/small or rigid/npt/small or rigid/nph/small\n  bodystyle = single or molecule or group\n  single args = none\n  molecule args = none\n  custom args = i_propname or v_varname\n    i_propname = an integer property defined via fix property/atom\n    v_varname  = an atom-style or atomfile-style variable\n  group args = N groupID1 groupID2 ...\n    N = # of groups\n    groupID1, groupID2, ... = list of N group IDs\n  \n  zero or more keyword/value pairs may be appended\n  keyword = langevin or reinit or temp or iso or aniso or x or y or z or couple or tparam or pchain or dilate or force or torque or infile\n  langevin values = Tstart Tstop Tperiod seed\n    Tstart,Tstop = desired temperature at start/stop of run (temperature units)\n    Tdamp = temperature damping parameter (time units)\n    seed = random number seed to use for white noise (positive integer)\n  reinit = yes or no\n  temp values = Tstart Tstop Tdamp\n    Tstart,Tstop = desired temperature at start/stop of run (temperature units)\n    Tdamp = temperature damping parameter (time units)\n  iso or aniso values = Pstart Pstop Pdamp\n    Pstart,Pstop = scalar external pressure at start/end of run (pressure units)\n    Pdamp = pressure damping parameter (time units)\n  x or y or z values = Pstart Pstop Pdamp\n    Pstart,Pstop = external stress tensor component at start/end of run (pressure units)\n    Pdamp = stress damping parameter (time units)\n  couple = none or xyz or xy or yz or xz\n  tparam values = Tchain Titer Torder\n    Tchain = length of Nose/Hoover thermostat chain\n    Titer = number of thermostat iterations performed\n    Torder = 3 or 5 = Yoshida-Suzuki integration parameters\n  pchain values = Pchain\n    Pchain = length of the Nose/Hoover thermostat chain coupled with the barostat\n  dilate value = dilate-group-ID\n    dilate-group-ID = only dilate atoms in this group due to barostat volume changes\n  force values = M xflag yflag zflag\n    M = which rigid body from 1-Nbody (see asterisk form below)\n    xflag,yflag,zflag = off/on if component of center-of-mass force is active\n  torque values = M xflag yflag zflag\n    M = which rigid body from 1-Nbody (see asterisk form below)\n    xflag,yflag,zflag = off/on if component of center-of-mass torque is active\n  infile filename\n    filename = file with per-body values of mass, center-of-mass, moments of inertia\n  mol value = template-ID\n    template-ID = ID of molecule template specified in a separate molecule command\n  \n  \n  ",
    "examples": "fix 1 clump rigid single reinit yes\n  fix 1 clump rigid/small molecule\n  fix 1 clump rigid single force 1 off off on langevin 1.0 1.0 1.0 428984\n  fix 1 polychains rigid/nvt molecule temp 1.0 1.0 5.0 reinit no\n  fix 1 polychains rigid molecule force 1*5 off off off force 6*10 off off on\n  fix 1 polychains rigid/small molecule langevin 1.0 1.0 1.0 428984\n  fix 2 fluid rigid group 3 clump1 clump2 clump3 torque * off off off\n  fix 1 rods rigid/npt molecule temp 300.0 300.0 100.0 iso 0.5 0.5 10.0\n  fix 1 particles rigid/npt molecule temp 1.0 1.0 5.0 x 0.5 0.5 1.0 z 0.5 0.5 1.0 couple xz\n  fix 1 water rigid/nph molecule iso 0.5 0.5 1.0\n  fix 1 particles rigid/npt/small molecule temp 1.0 1.0 1.0 iso 0.5 0.5 1.0\n  \n  variable bodyid atom 1.0*gmask(clump1)+2.0*gmask(clump2)+3.0*gmask(clump3)\n  fix 1 clump rigid custom v_bodyid\n  \n  variable bodyid atomfile bodies.txt\n  fix 1 clump rigid custom v_bodyid\n  \n  fix 0 all property/atom i_bodyid\n  read_restart data.rigid fix 0 NULL Bodies\n  fix 1 clump rigid/small custom i_bodyid\n  \n  \n  ",
    "restrictions": "These fixes are all part of the RIGID package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  Assigning a temperature via the velocity create\n  command to a system with rigid bodies may not have\n  the desired outcome for two reasons.  First, the velocity command can\n  be invoked before the rigid-body fix is invoked or initialized and the\n  number of adjusted degrees of freedom (DOFs) is known.  Thus it is not\n  possible to compute the target temperature correctly.  Second, the\n  assigned velocities may be partially canceled when constraints are\n  first enforced, leading to a different temperature than desired.  A\n  workaround for this is to perform a run 0 command, which\n  insures all DOFs are accounted for properly, and then rescale the\n  temperature to the desired value before performing a simulation.  For\n  example:\n  velocity all create 300.0 12345\n  run 0                             # temperature may not be 300K\n  velocity all scale 300.0          # now it should be\n  \n  \n  "
},
{
    "command": "fix rigid/meso",
    "description": "Treat one or more sets of mesoscopic SPH/SDPD particles as independent\n  rigid bodies.  This means that each timestep the total force and torque\n  on each rigid body is computed as the sum of the forces and torques on\n  its constituent particles.  The coordinates and velocities of the\n  particles in each body are then updated so that the body moves and\n  rotates as a single entity using the methods described in the paper by\n  (Miller). Density and internal energy of the particles will\n  also be updated. This is implemented by creating internal data structures\n  for each rigid body and performing time integration on these data\n  structures.  Positions and velocities of the constituent particles are\n  regenerated from the rigid body data structures in every time step. This\n  restricts which operations and fixes can be applied to rigid bodies. See\n  below for a detailed discussion.\n  The operation of this fix is exactly like that described by the\n  fix rigid/nve command, except that particles’ density,\n  internal energy and extrapolated velocity are also updated.\n  \n  Note\n  You should not update the particles in rigid bodies via other\n  time-integration fixes (e.g. fix meso,\n  fix meso/stationary), or you will have conflicting\n  updates to positions and velocities resulting in unphysical behavior in most\n  cases. When performing a hybrid simulation with some atoms in rigid bodies,\n  and some not, a separate time integration fix like fix meso\n  should be used for the non-rigid particles.\n  \n  \n  Note\n  These fixes are overkill if you simply want to hold a collection\n  of particles stationary or have them move with a constant velocity. To\n  hold particles stationary use fix meso/stationary instead. If you would like to\n  move particles with a constant velocity use fix meso/move.\n  \n  \n  Warning\n  The aggregate properties of each rigid body are\n  calculated at the start of a simulation run and are maintained in\n  internal data structures. The properties include the position and\n  velocity of the center-of-mass of the body, its moments of inertia, and\n  its angular momentum.  This is done using the properties of the\n  constituent particles of the body at that point in time (or see the infile\n  keyword option).  Thereafter, changing these properties of individual\n  particles in the body will have no effect on a rigid body’s dynamics, unless\n  they effect any computation of per-particle forces or torques. If the\n  keyword reinit is set to yes (the default), the rigid body data\n  structures will be recreated at the beginning of each run command;\n  if the keyword reinit is set to no, the rigid body data structures\n  will be built only at the very first run command and maintained for\n  as long as the rigid fix is defined. For example, you might think you\n  could displace the particles in a body or add a large velocity to each particle\n  in a body to make it move in a desired direction before a 2nd run is\n  performed, using the set or\n  displace_atoms or velocity\n  commands.  But these commands will not affect the internal attributes\n  of the body unless reinit is set to yes. With reinit set to no\n  (or using the infile option, which implies reinit no) the position\n  and velocity of individual particles in the body will be reset when time\n  integration starts again.\n  \n  \n  Each rigid body must have two or more particles.  A particle can belong\n  to at most one rigid body.  Which particles are in which bodies can be\n  defined via several options.\n  For bodystyle single the entire fix group of particles is treated as\n  one rigid body.\n  For bodystyle molecule, particles are grouped into rigid bodies by their\n  respective molecule IDs: each set of particles in the fix group with the\n  same molecule ID is treated as a different rigid body.  Note that particles\n  with a molecule ID = 0 will be treated as a single rigid body. For a\n  system with solvent (typically this is particles with molecule ID = 0)\n  surrounding rigid bodies, this may not be what you want.  Thus you\n  should be careful to use a fix group that only includes particles you\n  want to be part of rigid bodies.\n  Bodystyle custom is similar to bodystyle molecule except that it\n  is more flexible in using other per-atom properties to define the sets\n  of particles that form rigid bodies.  An integer vector defined by the\n  fix property/atom command can be used.  Or an\n  atom-style or atomfile-style variable can be used; the\n  floating-point value produced by the variable is rounded to an\n  integer.  As with bodystyle molecule, each set of particles in the fix\n  groups with the same integer value is treated as a different rigid\n  body.  Since fix property/atom vectors and atom-style variables\n  produce values for all particles, you should be careful to use a fix group\n  that only includes particles you want to be part of rigid bodies.\n  For bodystyle group, each of the listed groups is treated as a\n  separate rigid body.  Only particles that are also in the fix group are\n  included in each rigid body.\n  \n  Note\n  To compute the initial center-of-mass position and other\n  properties of each rigid body, the image flags for each particle in the\n  body are used to “unwrap” the particle coordinates.  Thus you must\n  insure that these image flags are consistent so that the unwrapping\n  creates a valid rigid body (one where the particles are close together)\n  , particularly if the particles in a single rigid body straddle a\n  periodic boundary.  This means the input data file or restart file must\n  define the image flags for each particle consistently or that you have\n  used the set command to specify them correctly.  If a\n  dimension is non-periodic then the image flag of each particle must be\n  0 in that dimension, else an error is generated.\n  \n  By default, each rigid body is acted on by other particles which induce\n  an external force and torque on its center of mass, causing it to\n  translate and rotate.  Components of the external center-of-mass force\n  and torque can be turned off by the force and torque keywords.\n  This may be useful if you wish a body to rotate but not translate, or\n  vice versa, or if you wish it to rotate or translate continuously\n  unaffected by interactions with other particles.  Note that if you\n  expect a rigid body not to move or rotate by using these keywords, you\n  must insure its initial center-of-mass translational or angular\n  velocity is 0.0. Otherwise the initial translational or angular\n  momentum, the body has, will persist.\n  An xflag, yflag, or zflag set to off means turn off the component of\n  force or torque in that dimension.  A setting of on means turn on\n  the component, which is the default.  Which rigid body(s) the settings\n  apply to is determined by the first argument of the force and\n  torque keywords.  It can be an integer M from 1 to Nbody, where\n  Nbody is the number of rigid bodies defined.  A wild-card asterisk can\n  be used in place of, or in conjunction with, the M argument to set the\n  flags for multiple rigid bodies.  This takes the form “*” or “*n” or\n  “n*” or “m*n”.  If N = the number of rigid bodies, then an asterisk\n  with no numeric values means all bodies from 1 to N.  A leading\n  asterisk means all bodies from 1 to n (inclusive).  A trailing\n  asterisk means all bodies from n to N (inclusive).  A middle asterisk\n  means all bodies from m to n (inclusive).  Note that you can use the\n  force or torque keywords as many times as you like.  If a\n  particular rigid body has its component flags set multiple times, the\n  settings from the final keyword are used.\n  For computational efficiency, you should typically define one fix\n  rigid/meso command which includes all the desired rigid bodies. LAMMPS\n  will allow multiple rigid/meso fixes to be defined, but it is more\n  expensive.\n  \n  The keyword/value option pairs are used in the following ways.\n  The reinit keyword determines, whether the rigid body properties\n  are re-initialized between run commands. With the option yes (the\n  default) this is done, with the option no this is not done. Turning\n  off the re-initialization can be helpful to protect rigid bodies against\n  unphysical manipulations between runs or when properties cannot be\n  easily re-computed (e.g. when read from a file). When using the infile\n  keyword, the reinit option is automatically set to no.\n  \n  The infile keyword allows a file of rigid body attributes to be read\n  in from a file, rather then having LAMMPS compute them.  There are 5\n  such attributes: the total mass of the rigid body, its center-of-mass\n  position, its 6 moments of inertia, its center-of-mass velocity, and\n  the 3 image flags of the center-of-mass position.  For rigid bodies\n  consisting of point particles or non-overlapping finite-size\n  particles, LAMMPS can compute these values accurately.  However, for\n  rigid bodies consisting of finite-size particles which overlap each\n  other, LAMMPS will ignore the overlaps when computing these 4\n  attributes.  The amount of error this induces depends on the amount of\n  overlap.  To avoid this issue, the values can be pre-computed\n  (e.g. using Monte Carlo integration).\n  The format of the file is as follows.  Note that the file does not\n  have to list attributes for every rigid body integrated by fix rigid.\n  Only bodies which the file specifies will have their computed\n  attributes overridden.  The file can contain initial blank lines or\n  comment lines starting with “#” which are ignored.  The first\n  non-blank, non-comment line should list N = the number of lines to\n  follow.  The N successive lines contain the following information:\n  ID1 masstotal xcm ycm zcm ixx iyy izz ixy ixz iyz vxcm vycm vzcm lx ly lz ixcm iycm izcm\n  ID2 masstotal xcm ycm zcm ixx iyy izz ixy ixz iyz vxcm vycm vzcm lx ly lz ixcm iycm izcm\n  ...\n  IDN masstotal xcm ycm zcm ixx iyy izz ixy ixz iyz vxcm vycm vzcm lx ly lz ixcm iycm izcm\n  \n  \n  The rigid body IDs are all positive integers.  For the single\n  bodystyle, only an ID of 1 can be used.  For the group bodystyle,\n  IDs from 1 to Ng can be used where Ng is the number of specified\n  groups.  For the molecule bodystyle, use the molecule ID for the\n  atoms in a specific rigid body as the rigid body ID.\n  The masstotal and center-of-mass coordinates (xcm,ycm,zcm) are\n  self-explanatory.  The center-of-mass should be consistent with what\n  is calculated for the position of the rigid body with all its atoms\n  unwrapped by their respective image flags.  If this produces a\n  center-of-mass that is outside the simulation box, LAMMPS wraps it\n  back into the box.\n  The 6 moments of inertia (ixx,iyy,izz,ixy,ixz,iyz) should be the\n  values consistent with the current orientation of the rigid body\n  around its center of mass.  The values are with respect to the\n  simulation box XYZ axes, not with respect to the principal axes of the\n  rigid body itself.  LAMMPS performs the latter calculation internally.\n  The (vxcm,vycm,vzcm) values are the velocity of the center of mass.\n  The (lx,ly,lz) values are the angular momentum of the body.  The\n  (vxcm,vycm,vzcm) and (lx,ly,lz) values can simply be set to 0 if you\n  wish the body to have no initial motion.\n  The (ixcm,iycm,izcm) values are the image flags of the center of mass\n  of the body.  For periodic dimensions, they specify which image of the\n  simulation box the body is considered to be in.  An image of 0 means\n  it is inside the box as defined.  A value of 2 means add 2 box lengths\n  to get the true value.  A value of -1 means subtract 1 box length to\n  get the true value.  LAMMPS updates these flags as the rigid bodies\n  cross periodic boundaries during the simulation.\n  \n  Note\n  If you use the infile keyword and write restart\n  files during a simulation, then each time a restart file is written,\n  the fix also write an auxiliary restart file with the name\n  rfile.rigid, where “rfile” is the name of the restart file,\n  e.g. tmp.restart.10000 and tmp.restart.10000.rigid.  This auxiliary\n  file is in the same format described above.  Thus it can be used in a\n  new input script that restarts the run and re-specifies a rigid fix\n  using an infile keyword and the appropriate filename.  Note that the\n  auxiliary file will contain one line for every rigid body, even if the\n  original file only listed a subset of the rigid bodies.\n  \n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information is written to binary restart files.\n  If the infile keyword is used, an auxiliary file is written out\n  with rigid body information each time a restart file is written, as\n  explained above for the infile keyword.\n  None of the fix_modify options are relevant to this\n  fix.\n  This fix computes a global array of values which can be accessed by\n  various output commands.\n  The number of rows in the array is equal to the number of rigid\n  bodies.  The number of columns is 28.  Thus for each rigid body, 28\n  values are stored: the xyz coords of the center of mass (COM), the xyz\n  components of the COM velocity, the xyz components of the force acting\n  on the COM, the components of the 4-vector quaternion representing the\n  orientation of the rigid body, the xyz components of the angular velocity\n  of the body around its COM, the xyz components of the torque acting on the\n  COM, the 3 principal components of the moment of inertia, the xyz components\n  of the angular momentum of the body around its COM, and the xyz image\n  flags of the COM.\n  The center of mass (COM) for each body is similar to unwrapped\n  coordinates written to a dump file.  It will always be inside (or\n  slightly outside) the simulation box.  The image flags have the same\n  meaning as image flags for particle positions (see the “dump” command).\n  This means you can calculate the unwrapped COM by applying the image\n  flags to the COM, the same as when unwrapped coordinates are written\n  to a dump file.\n  The force and torque values in the array are not affected by the\n  force and torque keywords in the fix rigid command; they reflect\n  values before any changes are made by those keywords.\n  The ordering of the rigid bodies (by row in the array) is as follows.\n  For the single keyword there is just one rigid body.  For the\n  molecule keyword, the bodies are ordered by ascending molecule ID.\n  For the group keyword, the list of group IDs determines the ordering\n  of bodies.\n  The array values calculated by this fix are “intensive”, meaning they\n  are independent of the number of particles in the simulation.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID rigid/meso bodystyle args keyword values ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  rigid/meso = style name of this fix command\n  bodystyle = single or molecule or group\n  single args = none\n  molecule args = none\n  custom args = i_propname or v_varname\n    i_propname = an integer property defined via fix property/atom\n    v_varname  = an atom-style or atomfile-style variable\n  group args = N groupID1 groupID2 ...\n    N = # of groups\n    groupID1, groupID2, ... = list of N group IDs\n  \n  zero or more keyword/value pairs may be appended\n  keyword = reinit or force or torque or infile\n  reinit = yes or no\n  force values = M xflag yflag zflag\n    M = which rigid body from 1-Nbody (see asterisk form below)\n    xflag,yflag,zflag = off/on if component of center-of-mass force is active\n  torque values = M xflag yflag zflag\n    M = which rigid body from 1-Nbody (see asterisk form below)\n    xflag,yflag,zflag = off/on if component of center-of-mass torque is active\n  infile filename\n    filename = file with per-body values of mass, center-of-mass, moments of inertia\n  \n  \n  ",
    "examples": "fix 1 ellipsoid rigid/meso single\n  fix 1 rods      rigid/meso molecule\n  fix 1 spheres   rigid/meso single force 1 off off on\n  fix 1 particles rigid/meso molecule force 1\\*5 off off off force 6\\*10 off off on\n  fix 2 spheres   rigid/meso group 3 sphere1 sphere2 sphere3 torque \\* off off off\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-SDPD package and also depends on the RIGID\n  package.  It is only enabled if LAMMPS was built with both packages. See\n  the Build package doc page for more info.\n  This fix requires that atoms store density and internal energy as\n  defined by the atom_style meso command.\n  All particles in the group must be mesoscopic SPH/SDPD particles.\n  "
},
{
    "command": "fix rx",
    "description": "Fix rx solves the reaction kinetic ODEs for a given reaction set that is\n  defined within the file associated with this command.\n  For a general reaction such that\n  \n  \\[\\nu_{A}A + \\nu_{B}B \\rightarrow \\nu_{C}C\\]\n  the reaction rate equation is defined to be of the form\n  \n  \\[r = k(T)[A]^{\\nu_{A}}[B]^{\\nu_{B}}\\]\n  In the current implementation, the exponents are defined to be equal\n  to the stoichiometric coefficients.  A given reaction set consisting\n  of n reaction equations will contain a total of m species.  A set\n  of m ordinary differential equations (ODEs) that describe the change\n  in concentration of a given species as a function of time are then\n  constructed based on the n reaction rate equations.\n  The ODE systems are solved over the full DPD timestep dt using either a 4th\n  order Runge-Kutta rk4 method with a fixed step-size h, specified\n  by the lammps_rk4 keyword, or a 4th order Runge-Kutta-Fehlberg (rkf45) method\n  with an adaptive step-size for h. The number of ODE steps per DPD timestep\n  for the rk4 method is optionally specified immediately after the rk4\n  keyword. The ODE step-size is set as dt/num_steps. Smaller\n  step-sizes tend to yield more accurate results but there is not\n  control on the error. For error control, use the rkf45 ODE solver.\n  The rkf45 method adjusts the step-size so that the local truncation error is held\n  within the specified absolute and relative tolerances. The initial step-size h0\n  can be specified by the user or estimated internally. It is recommended that the user\n  specify h0 since this will generally reduced the number of ODE integration steps\n  required. h0 is defined as dt / min_steps if min_steps >= 1. If min_steps == 0,\n  h0 is estimated such that an explicit Euler method would likely produce\n  an acceptable solution. This is generally overly conservative for the 4th-order\n  method and users are advised to specify h0 as some fraction of the DPD timestep.\n  For small DPD timesteps, only one step may be necessary depending upon the tolerances.\n  Note that more than min_steps ODE steps may be taken depending upon the ODE stiffness\n  but no more than max_steps will be taken. If max_steps is reached, an error warning\n  is printed and the simulation is stopped.\n  After each ODE step, the solution error e is tested and weighted using the absTol\n  and relTol values. The error vector is weighted as e / (relTol * |u| + absTol)\n  where u is the solution vector. If the norm of the error is <= 1, the solution is\n  accepted, h is increased by a proportional amount, and the next ODE step is begun.\n  Otherwise, h is shrunk and the ODE step is repeated.\n  Run-time diagnostics are available for the rkf45 ODE solver. The frequency\n  (in time-steps) that diagnostics are reported is controlled by the last (optional)\n  12th argument. A negative frequency means that diagnostics are reported once at the\n  end of each run. A positive value N means that the diagnostics are reported once\n  per N time-steps.\n  The diagnostics report the average # of integrator steps and RHS function evaluations\n  and run-time per ODE as well as the average/RMS/min/max per process. If the\n  reporting frequency is 1, the RMS/min/max per ODE are also reported. The per ODE\n  statistics can be used to adjust the tolerance and min/max step parameters. The\n  statistics per MPI process can be useful to examine any load imbalance caused by the\n  adaptive ODE solver. (Some DPD particles can take longer to solve than others. This\n  can lead to an imbalance across the MPI processes.)\n  \n  The filename specifies a file that contains the entire set of reaction\n  kinetic equations and corresponding Arrhenius parameters.  The format of\n  this file is described below.\n  There is no restriction on the total number or reaction equations that\n  are specified.  The species names are arbitrary string names that are\n  associated with the species concentrations.  Each species in a given\n  reaction must be preceded by it’s stoichiometric coefficient.  The\n  only delimiters that are recognized between the species are either a\n  + or = character.  The = character corresponds to an\n  irreversible reaction.  After specifying the reaction, the reaction\n  rate constant is determined through the temperature dependent\n  Arrhenius equation:\n  \n  \\[k = AT^{n}e^{\\frac{-E_{a}}{k_{B}T}}\\]\n  where A is the Arrhenius factor in time units or concentration/time\n  units, n is the unitless exponent of the temperature dependence, and\n  \\(E_a\\) is the activation energy in energy units.  The temperature\n  dependence can be removed by specifying the exponent as zero.\n  The internal temperature of the coarse-grained particles can be used\n  in constructing the reaction rate constants at every DPD timestep by\n  specifying the keyword none.  Alternatively, the keyword lucy can\n  be specified to compute a local-average particle internal temperature\n  for use in the reaction rate constant expressions.  The local-average\n  particle internal temperature is defined as:\n  \n  \\[\\theta_i^{-1} = \\frac{\\sum_{j=1}\\omega_{Lucy}\\left(r_{ij}\\right)\\theta_j^{-1}}{\\sum_{j=1}\\omega_{Lucy}\\left(r_{ij}\\right)}\\]\n  where the Lucy function is expressed as:\n  \n  \\[\\omega_{Lucy}\\left(r_{ij}\\right) = \\left( 1 + \\frac{3r_{ij}}{r_c} \\right) \\left( 1 - \\frac{r_{ij}}{r_c} \\right)^3\\]\n  The self-particle interaction is included in the above equation.\n  The stoichiometric coefficients for the reaction mechanism are stored\n  in either a sparse or dense matrix format. The dense matrix should only be\n  used for small reaction mechanisms. The sparse matrix should be used when there\n  are many reactions (e.g., more than 5). This allows the number of reactions and\n  species to grow while keeping the computational cost tractable. The matrix\n  format can be specified as using either the sparse or dense keywords.\n  If all stoichiometric coefficients for a reaction are small integers (whole\n  numbers <= 3), a fast exponential function is used. This can save significant\n  computational time so users are encouraged to use integer coefficients\n  where possible.\n  \n  The format of a tabulated file is as follows (without the\n  parenthesized comments):\n  # Rxn equations and parameters                                               (one or more comment or blank lines)\n  \n  1.0 hcn + 1.0 no2 = 1.0  no + 0.5 n2  + 0.5 h2 + 1.0 co   2.49E+01 0.0 1.34  (rxn equation, A, n, Ea)\n  1.0 hcn + 1.0  no = 1.0  co + 1.0 n2  + 0.5 h2            2.16E+00 0.0 1.52\n  ...\n  1.0  no + 1.0  co = 0.5  n2 + 1.0 co2                     1.66E+06 0.0 0.69\n  \n  \n  A section begins with a non-blank line whose 1st character is not a\n  “#”; blank lines or lines starting with “#” can be used as comments\n  between sections.\n  Following a blank line, the next N lines list the N reaction\n  equations.  Each species within the reaction equation is specified\n  through its stoichiometric coefficient and a species tag.  Reactant\n  species are specified on the left-hand side of the equation and\n  product species are specified on the right-hand side of the equation.\n  After specifying the reactant and product species, the final three\n  arguments of each line represent the Arrhenius parameter A, the\n  temperature exponent n, and the activation energy Ea.\n  Note that the species tags that are defined in the reaction equations\n  are used by the fix eos/table/rx command to\n  define the thermodynamic properties of each species.  Furthermore, the\n  number of species molecules (i.e., concentration) can be specified\n  either with the set command using the “d_” prefix or by\n  reading directly the concentrations from a data file.  For the latter\n  case, the read_data command with the fix keyword\n  should be specified, where the fix-ID will be the “fix rx`ID with a <SPECIES”>`_ suffix, e.g.\n  fix          foo all rx reaction.file …\n  read_data    data.dpd fix foo_SPECIES NULL Species\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "fix ID group-ID rx file localTemp matrix solver minSteps ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  rx = style name of this fix command\n  file = filename containing the reaction kinetic equations and Arrhenius parameters\n  localTemp = none,lucy = no local temperature averaging or local temperature defined through Lucy weighting function\n  matrix = sparse, dense format for the stoichiometric matrix\n  solver = lammps_rk4,rkf45 = rk4 is an explicit 4th order Runge-Kutta method; rkf45 is an adaptive 4th-order Runge-Kutta-Fehlberg method\n  minSteps = # of steps for rk4 solver or minimum # of steps for rkf45 (rk4 or rkf45)\n  maxSteps = maximum number of steps for the rkf45 solver (rkf45 only)\n  relTol = relative tolerance for the rkf45 solver (rkf45 only)\n  absTol = absolute tolerance for the rkf45 solver (rkf45 only)\n  diag   = Diagnostics frequency for the rkf45 solver (optional, rkf45 only)\n  \n  ",
    "examples": "fix 1 all rx kinetics.rx none dense lammps_rk4\n  fix 1 all rx kinetics.rx none sparse lammps_rk4 1\n  fix 1 all rx kinetics.rx lucy sparse lammps_rk4 10\n  fix 1 all rx kinetics.rx none dense rkf45 1 100 1e-6 1e-8\n  fix 1 all rx kinetics.rx none dense rkf45 1 100 1e-6 1e-8 -1\n  \n  \n  ",
    "restrictions": "This command is part of the USER-DPD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  This command also requires use of the atom_style dpd\n  command.\n  This command can only be used with a constant energy or constant\n  enthalpy DPD simulation.\n  "
},
{
    "command": "fix saed/vtk",
    "description": "Time average computed intensities from compute saed and\n  write output to a file in the 3rd generation vtk image data format for\n  visualization directly in parallelized visualization software packages\n  like ParaView and VisIt. Note that if no time averaging is done, this\n  command can be used as a convenient way to simply output diffraction\n  intensities at a single snapshot.\n  To produce output in the image data vtk format ghost data is added\n  outside the Kmax range assigned in the compute saed. The ghost data is\n  assigned a value of -1 and can be removed setting a minimum isovolume\n  of 0 within the visualization software. SAED images can be created by\n  visualizing a spherical slice of the data that is centered at\n  R_Ewald*[h k l]/norm([h k l]), where R_Ewald=1/lambda.\n  The group specified within this command is ignored. However, note that\n  specified values may represent calculations performed by saed computes\n  which store their own “group” definitions.\n  Fix saed/vtk is designed to work only with compute saed\n  values, e.g.\n  compute 3 top saed 0.0251 Al O\n  fix saed/vtk 1 1 1 c_3 file Al2O3_001.saed\n  \n  \n  \n  The Nevery, Nrepeat, and Nfreq arguments specify on what\n  timesteps the input values will be used in order to contribute to the\n  average.  The final averaged quantities are generated on timesteps\n  that are a multiple of Nfreq.  The average is over Nrepeat\n  quantities, computed in the preceding portion of the simulation every\n  Nevery timesteps.  Nfreq must be a multiple of Nevery and\n  Nevery must be non-zero even if Nrepeat is 1.\n  Also, the timesteps\n  contributing to the average value cannot overlap,\n  i.e. Nrepeat*Nevery can not exceed Nfreq.\n  For example, if Nevery=2, Nrepeat=6, and Nfreq=100, then values on\n  timesteps 90,92,94,96,98,100 will be used to compute the final average\n  on timestep 100.  Similarly for timesteps 190,192,194,196,198,200 on\n  timestep 200, etc.  If Nrepeat=1 and Nfreq = 100, then no time\n  averaging is done; values are simply generated on timesteps\n  100,200,etc.\n  \n  The output for fix ave/time/saed is a file written with the 3rd generation\n  vtk image data formatting.  The filename assigned by the file keyword is\n  appended with _N.vtk where N is an index (0,1,2…) to account for multiple\n  diffraction intensity outputs.\n  By default the header contains the following information (with example data):\n  # vtk DataFile Version 3.0 c_SAED\n  Image data set\n  ASCII\n  DATASET STRUCTURED_POINTS\n  DIMENSIONS 337 219 209\n  ASPECT_RATIO 0.00507953 0.00785161 0.00821458\n  ORIGIN -0.853361 -0.855826 -0.854316\n  POINT_DATA 15424827\n  SCALARS intensity float\n  LOOKUP_TABLE default\n  ...data\n  \n  \n  In this example, kspace is sampled across a 337 x 219 x 209 point mesh\n  where the mesh spacing is approximately 0.005, 0.007, and 0.008\n  inv(length) units in the k1, k2, and k3 directions, respectively.\n  The data is shifted by -0.85, -0.85, -0.85 inv(length) units so that\n  the origin will lie at 0, 0, 0.   Here, 15,424,827 kspace points are\n  sampled in total.\n  \n  Additional optional keywords also affect the operation of this fix.\n  The ave keyword determines how the values produced every Nfreq\n  steps are averaged with values produced on previous steps that were\n  multiples of Nfreq, before they are accessed by another output\n  command or written to a file.\n  If the ave setting is one, then the values produced on timesteps\n  that are multiples of Nfreq are independent of each other; they are\n  output as-is without further averaging.\n  If the ave setting is running, then the values produced on\n  timesteps that are multiples of Nfreq are summed and averaged in a\n  cumulative sense before being output.  Each output value is thus the\n  average of the value produced on that timestep with all preceding\n  values.  This running average begins when the fix is defined; it can\n  only be restarted by deleting the fix via the unfix\n  command, or by re-defining the fix by re-specifying it.\n  If the ave setting is window, then the values produced on\n  timesteps that are multiples of Nfreq are summed and averaged within\n  a moving “window” of time, so that the last M values are used to\n  produce the output.  E.g. if M = 3 and Nfreq = 1000, then the output\n  on step 10000 will be the average of the individual values on steps\n  8000,9000,10000.  Outputs on early steps will average over less than M\n  values if they are not available.\n  The start keyword specifies what timestep averaging will begin on.\n  The default is step 0.  Often input values can be 0.0 at time 0, so\n  setting start to a larger value can avoid including a 0.0 in a\n  running or windowed average.\n  The file keyword allows a filename to be specified.  Every Nfreq\n  steps, the vector of saed intensity data is written to a new file using\n  the 3rd generation vtk format.  The base of each file is assigned by\n  the file keyword and this string is appended with _N.vtk where N is\n  an index (0,1,2…) to account for situations with multiple diffraction\n  intensity outputs.\n  The overwrite keyword will continuously overwrite the output file\n  with the latest output, so that it only contains one timestep worth of\n  output.  This option can only be used with the ave running setting.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID saed/vtk Nevery Nrepeat Nfreak c_ID attribute args ... keyword args ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  saed/vtk = style name of this fix command\n  Nevery = use input values every this many timesteps\n  Nrepeat = # of times to use input values for calculating averages\n  Nfreq = calculate averages every this many timesteps\n  c_ID = saed compute ID\n  keyword = file or ave or start or file or overwrite:l\n    ave args = one or running or window M\n      one = output a new average value every Nfreq steps\n      running = output cumulative average of all previous Nfreq steps\n      window M = output average of M most recent Nfreq steps\n    start args = Nstart\n      Nstart = start averaging on this timestep\n    file arg = filename\n      filename = name of file to output time averages to\n    overwrite arg = none = overwrite output file with only latest output\n  \n  \n  ",
    "examples": "compute 1 all saed 0.0251 Al O Kmax 1.70 Zone 0 0 1 dR_Ewald 0.01 c 0.5 0.5 0.5\n  compute 2 all saed 0.0251 Ni Kmax 1.70 Zone 0 0 0 c 0.05 0.05 0.05 manual echo\n  \n  fix 1 all saed/vtk 1 1 1 c_1 file Al2O3_001.saed\n  fix 2 all saed/vtk 1 1 1 c_2 file Ni_000.saed\n  \n  \n  ",
    "restrictions": "The attributes for fix_saed_vtk must match the values assigned in the\n  associated compute_saed command.\n  "
},
{
    "command": "fix setforce",
    "description": "Set each component of force on each atom in the group to the specified\n  values fx,fy,fz.  This erases all previously computed forces on the\n  atom, though additional fixes could add new forces.  This command can\n  be used to freeze certain atoms in the simulation by zeroing their\n  force, either for running dynamics or performing an energy\n  minimization.  For dynamics, this assumes their initial velocity is\n  also zero.\n  Any of the fx,fy,fz values can be specified as NULL which means do not\n  alter the force component in that dimension.\n  Any of the 3 quantities defining the force components can be specified\n  as an equal-style or atom-style variable, namely fx,\n  fy, fz.  If the value is a variable, it should be specified as\n  v_name, where name is the variable name.  In this case, the variable\n  will be evaluated each timestep, and its value used to determine the\n  force component.\n  Equal-style variables can specify formulas with various mathematical\n  functions, and include thermo_style command\n  keywords for the simulation box parameters and timestep and elapsed\n  time.  Thus it is easy to specify a time-dependent force field.\n  Atom-style variables can specify the same formulas as equal-style\n  variables but can also include per-atom values, such as atom\n  coordinates.  Thus it is easy to specify a spatially-dependent force\n  field with optional time-dependence as well.\n  If the region keyword is used, the atom must also be in the\n  specified geometric region in order to have force added\n  to it.\n  \n  Style spin suffix sets the components of the magnetic precession\n  vectors instead of the mechanical forces. This also erases all\n  previously computed magnetic precession vectors on the atom, though\n  additional magnetic fixes could add new forces.\n  This command can be used to freeze the magnetic moment of certain\n  atoms in the simulation by zeroing their precession vector.\n  All options defined above remain valid, they just apply to the magnetic\n  precession vectors instead of the forces.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  The region keyword is also supported by Kokkos, but a Kokkos-enabled\n  region must be used. See the region region command for\n  more information.\n  These accelerated styles are part of the r Kokkos package.  They are\n  only enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The fix_modify respa option is supported by\n  this fix. This allows to set at which level of the r-RESPA\n  integrator the fix is setting the forces to the desired values; on all\n  other levels, the force is set to 0.0 for the atoms in the fix group,\n  so that setforce values are not counted multiple times. Default is to\n  to override forces at the outermost level.\n  This fix computes a global 3-vector of forces, which can be accessed\n  by various output commands.  This is the total\n  force on the group of atoms before the forces on individual atoms are\n  changed by the fix.  The vector values calculated by this fix are\n  “extensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  The forces due to this fix are imposed during an energy minimization,\n  invoked by the minimize command, but you cannot set\n  forces to any value besides zero when performing a minimization.  Use\n  the fix addforce command if you want to apply a\n  non-zero force to atoms during a minimization.\n  ",
    "syntax": "fix ID group-ID setforce fx fy fz keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  setforce = style name of this fix command\n  fx,fy,fz = force component values\n  any of fx,fy,fz can be a variable (see below)\n  zero or more keyword/value pairs may be appended to args\n  keyword = region\n  region value = region-ID\n    region-ID = ID of region atoms must be in to have added force\n  \n  \n  ",
    "examples": "fix freeze indenter setforce 0.0 0.0 0.0\n  fix 2 edge setforce NULL 0.0 0.0\n  fix 1 edge setforce/spin 0.0 0.0 0.0\n  fix 2 edge setforce NULL 0.0 v_oscillate\n  \n  \n  ",
    "restrictions": "The fix setforce/spin only makes sense when LAMMPS was built with the\n  SPIN package.\n  "
},
{
    "command": "fix shake",
    "description": "Apply bond and angle constraints to specified bonds and angles in the\n  simulation by either the SHAKE or RATTLE algorithms.  This typically\n  enables a longer timestep.\n  SHAKE vs RATTLE:\n  The SHAKE algorithm was invented for schemes such as standard Verlet\n  timestepping, where only the coordinates are integrated and the\n  velocities are approximated as finite differences to the trajectories\n  (Ryckaert et al. (1977)).  If the velocities are\n  integrated explicitly, as with velocity Verlet which is what LAMMPS\n  uses as an integration method, a second set of constraining forces is\n  required in order to eliminate velocity components along the bonds\n  (Andersen (1983)).\n  In order to formulate individual constraints for SHAKE and RATTLE,\n  focus on a single molecule whose bonds are constrained.  Let Ri and Vi\n  be the position and velocity of atom i at time n, for\n  i =1,…,N, where N is the number of sites of our reference\n  molecule. The distance vector between sites i and j is given by\n  \n  \\[\\mathbf r^{n+1}_{ij} = \\mathbf r^n_j - \\mathbf r^n_i\\]\n  The constraints can then be formulated as\n  \n  \\[\\begin{split}\\mathbf r^{n+1}_{ij} \\cdot \\mathbf r^{n+1}_{ij} &= d^2_{ij} \\quad \\text{and} \\\\\n  \\mathbf v^{n+1}_{ij} \\cdot \\mathbf r^{n+1}_{ij} &= 0\\end{split}\\]\n  The SHAKE algorithm satisfies the first condition, i.e. the sites at\n  time n+1 will have the desired separations Dij immediately after the\n  coordinates are integrated.  If we also enforce the second condition,\n  the velocity components along the bonds will vanish.  RATTLE satisfies\n  both conditions.  As implemented in LAMMPS, fix rattle uses fix shake\n  for satisfying the coordinate constraints. Therefore the settings and\n  optional keywords are the same for both fixes, and all the information\n  below about SHAKE is also relevant for RATTLE.\n  SHAKE:\n  Each timestep the specified bonds and angles are reset to their\n  equilibrium lengths and angular values via the SHAKE algorithm\n  (Ryckaert et al. (1977)).  This is done by applying an\n  additional constraint force so that the new positions preserve the\n  desired atom separations.  The equations for the additional force are\n  solved via an iterative method that typically converges to an accurate\n  solution in a few iterations.  The desired tolerance (e.g. 1.0e-4 = 1\n  part in 10000) and maximum # of iterations are specified as arguments.\n  Setting the N argument will print statistics to the screen and log\n  file about regarding the lengths of bonds and angles that are being\n  constrained.  Small delta values mean SHAKE is doing a good job.\n  In LAMMPS, only small clusters of atoms can be constrained.  This is\n  so the constraint calculation for a cluster can be performed by a\n  single processor, to enable good parallel performance.  A cluster is\n  defined as a central atom connected to others in the cluster by\n  constrained bonds.  LAMMPS allows for the following kinds of clusters\n  to be constrained: one central atom bonded to 1 or 2 or 3 atoms, or\n  one central atom bonded to 2 others and the angle between the 3 atoms\n  also constrained.  This means water molecules or CH2 or CH3 groups may\n  be constrained, but not all the C-C backbone bonds of a long polymer\n  chain.\n  The b constraint lists bond types that will be constrained.  The t\n  constraint lists atom types.  All bonds connected to an atom of the\n  specified type will be constrained.  The m constraint lists atom\n  masses.  All bonds connected to atoms of the specified masses will be\n  constrained (within a fudge factor of MASSDELTA specified in\n  fix_shake.cpp).  The a constraint lists angle types.  If both bonds\n  in the angle are constrained then the angle will also be constrained\n  if its type is in the list.\n  For all constraints, a particular bond is only constrained if both\n  atoms in the bond are in the group specified with the SHAKE fix.\n  The degrees-of-freedom removed by SHAKE bonds and angles are accounted\n  for in temperature and pressure computations.  Similarly, the SHAKE\n  contribution to the pressure of the system (virial) is also accounted\n  for.\n  \n  Note\n  This command works by using the current forces on atoms to\n  calculate an additional constraint force which when added will leave\n  the atoms in positions that satisfy the SHAKE constraints (e.g. bond\n  length) after the next time integration step.  If you define fixes\n  (e.g. fix efield) that add additional force to the\n  atoms after fix shake operates, then this fix will not take them into\n  account and the time integration will typically not satisfy the SHAKE\n  constraints.  The solution for this is to make sure that fix shake is\n  defined in your input script after any other fixes which add or change\n  forces (to atoms that fix shake operates on).\n  \n  \n  The mol keyword should be used when other commands, such as fix deposit or fix pour, add molecules\n  on-the-fly during a simulation, and you wish to constrain the new\n  molecules via SHAKE.  You specify a template-ID previously defined\n  using the molecule command, which reads a file that\n  defines the molecule.  You must use the same template-ID that the\n  command adding molecules uses.  The coordinates, atom types, special\n  bond restrictions, and SHAKE info can be specified in the molecule\n  file.  See the molecule command for details.  The only\n  settings required to be in this file (by this command) are the SHAKE\n  info of atoms in the molecule.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  RATTLE:\n  The velocity constraints lead to a linear system of equations which\n  can be solved analytically.  The implementation of the algorithm in\n  LAMMPS closely follows (Andersen (1983)).\n  \n  Note\n  The fix rattle command modifies forces and velocities and thus\n  should be defined after all other integration fixes in your input\n  script.  If you define other fixes that modify velocities or forces\n  after fix rattle operates, then fix rattle will not take them into\n  account and the overall time integration will typically not satisfy\n  the RATTLE constraints.  You can check whether the constraints work\n  correctly by setting the value of RATTLE_DEBUG in src/fix_rattle.cpp\n  to 1 and recompiling LAMMPS.\n  \n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  The fix_modify virial option is supported by this\n  fix to add the contribution due to keeping the constraints to the\n  system’s virial as part of thermodynamic output.\n  The default is virial yes\n  No information about these fixes is written to binary restart files.  None of the fix_modify options\n  are relevant to these fixes.  No global or per-atom quantities are\n  stored by these fixes for access by various output commands.  No parameter of these fixes can be used\n  with the start/stop keywords of the run command.  These\n  fixes are not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID style tol iter N constraint values ... keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  style = shake or rattle = style name of this fix command\n  tol = accuracy tolerance of SHAKE solution\n  iter = max # of iterations in each SHAKE solution\n  N = print SHAKE statistics every this many timesteps (0 = never)\n  one or more constraint/value pairs are appended\n  constraint = b or a or t or m\n  b values = one or more bond types\n  a values = one or more angle types\n  t values = one or more atom types\n  m value = one or more mass values\n  \n  zero or more keyword/value pairs may be appended\n  keyword = mol\n  mol value = template-ID\n    template-ID = ID of molecule template specified in a separate molecule command\n  \n  \n  ",
    "examples": "fix 1 sub shake 0.0001 20 10 b 4 19 a 3 5 2\n  fix 1 sub shake 0.0001 20 10 t 5 6 m 1.0 a 31\n  fix 1 sub shake 0.0001 20 10 t 5 6 m 1.0 a 31 mol myMol\n  fix 1 sub rattle 0.0001 20 10 t 5 6 m 1.0 a 31\n  fix 1 sub rattle 0.0001 20 10 t 5 6 m 1.0 a 31 mol myMol\n  \n  \n  ",
    "restrictions": "These fixes are part of the RIGID package.  They are only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  For computational efficiency, there can only be one shake or rattle\n  fix defined in a simulation.\n  If you use a tolerance that is too large or a max-iteration count that\n  is too small, the constraints will not be enforced very strongly,\n  which can lead to poor energy conservation.  You can test for this in\n  your system by running a constant NVE simulation with a particular set\n  of SHAKE parameters and monitoring the energy versus time.\n  SHAKE or RATTLE should not be used to constrain an angle at 180\n  degrees (e.g. linear CO2 molecule).  This causes numeric difficulties.\n  You can use fix rigid or fix rigid/small instead to\n  make a linear molecule rigid.\n  Related commands: none\n  Default: none\n  \n  (Ryckaert) J.-P. Ryckaert, G. Ciccotti and H. J. C. Berendsen,\n  J of Comp Phys, 23, 327-341 (1977).\n  (Andersen) H. Andersen, J of Comp Phys, 52, 24-34 (1983).\n  "
},
{
    "command": "fix shardlow",
    "description": "Specifies that the Shardlow splitting algorithm (SSA) is to be used to\n  integrate the DPD equations of motion.  The SSA splits the integration\n  into a stochastic and deterministic integration step.  The fix\n  shardlow performs the stochastic integration step and must be used\n  in conjunction with a deterministic integrator (e.g. fix nve or fix nph).  The stochastic\n  integration of the dissipative and random forces is performed prior to\n  the deterministic integration of the conservative force. Further\n  details regarding the method are provided in (Lisal) and\n  (Larentzos1).\n  The fix shardlow must be used with the pair_style dpd/fdt or pair_style dpd/fdt/energy command to properly initialize the\n  fluctuation-dissipation theorem parameter(s) sigma (and kappa, if\n  necessary).\n  Note that numerous variants of DPD can be specified by choosing an\n  appropriate combination of the integrator and pair_style dpd/fdt command.  DPD under isothermal conditions can\n  be specified by using fix shardlow, fix nve and pair_style\n  dpd/fdt.  DPD under isoenergetic conditions can be specified by\n  using fix shardlow, fix nve and pair_style dpd/fdt/energy.  DPD\n  under isobaric conditions can be specified by using fix shardlow, fix\n  nph and pair_style dpd/fdt.  DPD under isoenthalpic conditions can\n  be specified by using fix shardlow, fix nph and pair_style\n  dpd/fdt/energy.  Examples of each DPD variant are provided in the\n  examples/USER/dpd directory.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "fix ID group-ID shardlow\n  \n  \n  \n  ID, group-ID are documented in fix command\n  shardlow = style name of this fix command\n  \n  ",
    "examples": "fix 1 all shardlow\n  \n  \n  ",
    "restrictions": "This command is part of the USER-DPD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  This fix is currently limited to orthogonal simulation cell\n  geometries.\n  This fix must be used with an additional fix that specifies time\n  integration, e.g. fix nve or fix nph.\n  The Shardlow splitting algorithm requires the sizes of the sub-domain\n  lengths to be larger than twice the cutoff+skin.  Generally, the\n  domain decomposition is dependent on the number of processors\n  requested.\n  "
},
{
    "command": "fix smd",
    "description": "This fix implements several options of steered MD (SMD) as reviewed in\n  (Izrailev), which allows to induce conformational changes\n  in systems and to compute the potential of mean force (PMF) along the\n  assumed reaction coordinate (Park) based on Jarzynski’s\n  equality (Jarzynski).  This fix borrows a lot from fix spring and fix setforce.\n  You can apply a moving spring force to a group of atoms (tether\n  style) or between two groups of atoms (couple style).  The spring\n  can then be used in either constant velocity (cvel) mode or in\n  constant force (cfor) mode to induce transitions in your systems.\n  When running in tether style, you may need some way to fix some\n  other part of the system (e.g. via fix spring/self)\n  The tether style attaches a spring between a point at a distance of\n  R0 away from a fixed point x,y,z and the center of mass of the fix\n  group of atoms.  A restoring force of magnitude K (R - R0) Mi / M is\n  applied to each atom in the group where K is the spring constant, Mi\n  is the mass of the atom, and M is the total mass of all atoms in the\n  group.  Note that K thus represents the total force on the group of\n  atoms, not a per-atom force.\n  In cvel mode the distance R is incremented or decremented\n  monotonously according to the pulling (or pushing) velocity.\n  In cfor mode a constant force is added and the actual distance\n  in direction of the spring is recorded.\n  The couple style links two groups of atoms together.  The first\n  group is the fix group; the second is specified by group-ID2.  The\n  groups are coupled together by a spring that is at equilibrium when\n  the two groups are displaced by a vector in direction x,y,z with\n  respect to each other and at a distance R0 from that displacement.\n  Note that x,y,z only provides a direction and will be internally\n  normalized. But since it represents the absolute displacement of\n  group-ID2 relative to the fix group, (1,1,0) is a different spring\n  than (-1,-1,0).  For each vector component, the displacement can be\n  described with the auto parameter. In this case the direction is\n  re-computed in every step, which can be useful for steering a local\n  process where the whole object undergoes some other change.  When the\n  relative positions and distance between the two groups are not in\n  equilibrium, the same spring force described above is applied to atoms\n  in each of the two groups.\n  For both the tether and couple styles, any of the x,y,z values can\n  be specified as NULL which means do not include that dimension in the\n  distance calculation or force application.\n  For constant velocity pulling (cvel mode), the running integral\n  over the pulling force in direction of the spring is recorded and\n  can then later be used to compute the potential of mean force (PMF)\n  by averaging over multiple independent trajectories along the same\n  pulling path.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  The fix stores the direction of the spring, current pulling target\n  distance and the running PMF to binary restart files.\n  See the read_restart command for info on how to\n  re-specify a fix in an input script that reads a restart file, so that\n  the operation of the fix continues in an uninterrupted fashion.\n  The fix_modify virial option is supported by this\n  fix to add the contribution due to the added forces on atoms to the\n  system’s virial as part of thermodynamic output.\n  The default is virial no\n  The fix_modify respa option is supported by\n  this fix. This allows to set at which level of the r-RESPA\n  integrator the fix is adding its forces. Default is the outermost level.\n  This fix computes a vector list of 7 quantities, which can be accessed\n  by various output commands.  The quantities in the\n  vector are in this order: the x-, y-, and z-component of the pulling\n  force, the total force in direction of the pull, the equilibrium\n  distance of the spring, the distance between the two reference points,\n  and finally the accumulated PMF (the sum of pulling forces times\n  displacement).\n  The force is the total force on the group of atoms by the spring.  In\n  the case of the couple style, it is the force on the fix group\n  (group-ID) or the negative of the force on the 2nd group (group-ID2).\n  The vector values calculated by this fix are “extensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID smd type values keyword values\n  \n  \n  \n  ID, group-ID are documented in fix command\n  smd  = style name of this fix command\n  mode = cvel or cfor to select constant velocity or constant force SMD\n  cvel values = K vel\n    K = spring constant (force/distance units)\n    vel = velocity of pulling (distance/time units)\n  cfor values = force\n    force = pulling force (force units)\n  \n  keyword = tether or couple\n  tether values = x y z R0\n    x,y,z = point to which spring is tethered\n    R0 = distance of end of spring from tether point (distance units)\n  couple values = group-ID2 x y z R0\n    group-ID2 = 2nd group to couple to fix group with a spring\n    x,y,z = direction of spring, automatically computed with 'auto'\n    R0 = distance of end of spring (distance units)\n  \n  \n  ",
    "examples": "fix  pull    cterm smd cvel 20.0 -0.00005 tether NULL NULL 100.0 0.0\n  fix  pull    cterm smd cvel 20.0 -0.0001 tether 25.0 25 25.0 0.0\n  fix  stretch cterm smd cvel 20.0  0.0001 couple nterm auto auto auto 0.0\n  fix  pull    cterm smd cfor  5.0 tether 25.0 25.0 25.0 0.0\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "fix smd/adjust_dt",
    "description": "The fix calculates a new stable time increment for use with the SMD\n  time integrators.\n  The stable time increment is based on multiple conditions. For the SPH\n  pair styles, a CFL criterion (Courant, Friedrichs & Lewy, 1928) is\n  evaluated, which determines the speed of sound cannot propagate\n  further than a typical spacing between particles within a single time\n  step to ensure no information is lost. For the contact pair styles, a\n  linear analysis of the pair potential determines a stable maximum time\n  step.\n  This fix inquires the minimum stable time increment across all\n  particles contained in the group for which this fix is defined. An\n  additional safety factor s_fact is applied to the time increment.\n  See this PDF guide to use Smooth Mach\n  Dynamics in LAMMPS.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  Currently, no part of USER-SMD supports restarting nor minimization.\n  ",
    "syntax": "fix ID group-ID smd/adjust_dt arg\n  \n  \n  \n  ID, group-ID are documented in fix command\n  smd/adjust_dt = style name of this fix command\n  arg = s_fact\n  s_fact = safety factor\n  \n  \n  ",
    "examples": "fix 1 all smd/adjust_dt 0.1\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "fix smd/integrate_tlsph",
    "description": "The fix performs explicit time integration for particles which\n  interact according with the Total-Lagrangian SPH pair style.\n  See this PDF guide to using Smooth Mach\n  Dynamics in LAMMPS.\n  The limit_velocity keyword will control the velocity, scaling the\n  norm of the velocity vector to max_vel in case it exceeds this\n  velocity limit.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  Currently, no part of USER-SMD supports restarting nor\n  minimization. This fix has no outputs.\n  ",
    "syntax": "fix ID group-ID smd/integrate_tlsph keyword values\n  \n  \n  \n  ID, group-ID are documented in fix command\n  smd/integrate_tlsph = style name of this fix command\n  zero or more keyword/value pairs may be appended\n  keyword = limit_velocity\n  \n  limit_velocity value = max_vel\n    max_vel = maximum allowed velocity\n  ",
    "examples": "fix 1 all smd/integrate_tlsph\n  fix 1 all smd/integrate_tlsph limit_velocity 1000\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "fix smd/integrate_ulsph",
    "description": "The fix performs explicit time integration for particles which\n  interact with the updated Lagrangian SPH pair style.\n  See this PDF guide to using Smooth Mach\n  Dynamics in LAMMPS.\n  The adjust_radius keyword activates dynamic adjustment of the\n  per-particle SPH smoothing kernel radius such that the number of\n  neighbors per particles remains within the interval min_nn to\n  max_nn. The parameter adjust_radius_factor determines the amount\n  of adjustment per timestep. Typical values are adjust_radius_factor\n  =1.02, min_nn =15, and max_nn =20.\n  The limit_velocity keyword will control the velocity, scaling the norm of\n  the velocity vector to max_vel in case it exceeds this velocity limit.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  Currently, no part of USER-SMD supports restarting nor\n  minimization. This fix has no outputs.\n  ",
    "syntax": "fix ID group-ID smd/integrate_ulsph keyword\n  \n  \n  \n  ID, group-ID are documented in fix command\n  smd/integrate_ulsph = style name of this fix command\n  zero or more keyword/value pairs may be appended\n  keyword = adjust_radius or limit_velocity\n  \n  \n  adjust_radius values = adjust_radius_factor min_nn max_nnadjust_radius_factor = factor which scale the smooth/kernel radius\n  min_nn = minimum number of neighbors\n  max_nn = maximum number of neighbors\n  \n  limit_velocity values = max_velocitymax_velocity = maximum allowed velocity.\n  \n  \n  ",
    "examples": "fix 1 all smd/integrate_ulsph adjust_radius 1.02 25 50\n  fix 1 all smd/integrate_ulsph limit_velocity 1000\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  Related commands: none\n  Default: none\n  "
},
{
    "command": "fix smd/move_tri_surf",
    "description": "This fix applies only to rigid surfaces read from .STL files via fix\n  smd/wall_surface .  It updates position\n  and velocity for the particles in the group each timestep without\n  regard to forces on the particles.  The rigid surfaces can thus be\n  moved along simple trajectories during the simulation.\n  The *LINEAR style moves particles with the specified constant velocity\n  vector V = (Vx,Vy,Vz). This style also sets the velocity of each particle\n  to V = (Vx,Vy,Vz).\n  The *WIGGLE style moves particles in an oscillatory fashion.\n  Particles are moved along (vx, vy, vz) with constant velocity until a\n  displacement of max_travel is reached. Then, the velocity vector is\n  reversed. This process is repeated.\n  The *ROTATE style rotates particles around a rotation axis R =\n  (Rx,Ry,Rz) that goes through a point P = (Px,Py,Pz). The period of the\n  rotation is also specified. This style also sets the velocity of each\n  particle to (omega cross Rperp) where omega is its angular velocity\n  around the rotation axis and Rperp is a perpendicular vector from the\n  rotation axis to the particle.\n  See this PDF guide to using Smooth Mach\n  Dynamics in LAMMPS.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  Currently, no part of USER-SMD supports restarting nor\n  minimization. This fix has no outputs.\n  ",
    "syntax": "fix ID group-ID smd/move_tri_surf keyword\n  \n  \n  \n  ID, group-ID are documented in fix command\n  smd/move_tri_surf keyword = style name of this fix command\n  keyword = *LINEAR or *WIGGLE or *ROTATE\n  *LINEAR args = Vx Vy Vz\n     Vx,Vy,Vz = components of velocity vector (velocity units), any component can be specified as NULL\n  *WIGGLE args = Vx Vy Vz max_travel\n     vx,vy,vz = components of velocity vector (velocity units), any component can be specified as NULL\n     max_travel = wiggle amplitude\n  *ROTATE args = Px Py Pz Rx Ry Rz period\n     Px,Py,Pz = origin point of axis of rotation (distance units)\n     Rx,Ry,Rz = axis of rotation vector\n     period = period of rotation (time units)\n  \n  \n  ",
    "examples": "fix 1 tool smd/move_tri_surf *LINEAR 20 20 10\n  fix 2 tool smd/move_tri_surf *WIGGLE 20 20 10\n  fix 2 tool smd/move_tri_surf *ROTATE 0 0 0 5 2 1\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "fix smd/setvel",
    "description": "Set each component of velocity on each particle in the group to the specified\n  values vx,vy,vz, regardless of the forces acting on the particle.  This command can\n  be used to impose velocity boundary conditions.\n  Any of the vx,vy,vz values can be specified as NULL which means do not\n  alter the velocity component in that dimension.\n  This fix is indented to be used together with a time integration fix.\n  Any of the 3 quantities defining the velocity components can be specified\n  as an equal-style or atom-style variable, namely vx,\n  vy, vz.  If the value is a variable, it should be specified as\n  v_name, where name is the variable name.  In this case, the variable\n  will be evaluated each timestep, and its value used to determine the\n  force component.\n  Equal-style variables can specify formulas with various mathematical\n  functions, and include thermo_style command\n  keywords for the simulation box parameters and timestep and elapsed\n  time.  Thus it is easy to specify a time-dependent velocity field.\n  Atom-style variables can specify the same formulas as equal-style\n  variables but can also include per-atom values, such as atom\n  coordinates.  Thus it is easy to specify a spatially-dependent velocity\n  field with optional time-dependence as well.\n  If the region keyword is used, the particle must also be in the\n  specified geometric region in order to have its velocity set by this command.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  Currently, no part of USER-SMD supports restarting nor minimization\n  None of the fix_modify options\n  are relevant to this fix.\n  This fix computes a global 3-vector of forces, which can be accessed\n  by various output commands.  This is the total\n  force on the group of atoms.  The vector values calculated by this fix\n  are “extensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  ",
    "syntax": "fix ID group-ID smd/setvel vx vy vz keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  smd/setvel = style name of this fix command\n  vx,vy,vz = velocity component values\n  any of vx,vy,vz can be a variable (see below)\n  zero or more keyword/value pairs may be appended to args\n  keyword = region\n  region value = region-ID\n    region-ID = ID of region particles must be in to have their velocities set\n  \n  \n  ",
    "examples": "fix top_velocity top_group smd/setvel 1.0 0.0 0.0\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  Related commands: none\n  Default: none\n  "
},
{
    "command": "fix smd/wall_surface",
    "description": "This fix creates reads a triangulated surface from a file in .STL\n  format.  For each triangle, a new particle is created which stores the\n  barycenter of the triangle and the vertex positions.  The radius of\n  the new particle is that of the minimum circle which encompasses the\n  triangle vertices.\n  The triangulated surface can be used as a complex rigid wall via the\n  smd/tri_surface pair style.  It\n  is possible to move the triangulated surface via the\n  smd/move_tri_surf fix style.\n  Immediately after a .STL file has been read, the simulation needs to\n  be run for 0 timesteps in order to properly register the new particles\n  in the system. See the “funnel_flow” example in the USER-SMD examples\n  directory.\n  See this PDF guide to use Smooth Mach\n  Dynamics in LAMMPS.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  Currently, no part of USER-SMD supports restarting nor\n  minimization. This fix has no outputs.\n  ",
    "syntax": "fix ID group-ID smd/wall_surface arg type mol-ID\n  \n  \n  \n  ID, group-ID are documented in fix command\n  smd/wall_surface = style name of this fix command\n  arg = file\n  file = file name of a triangular mesh in stl format\n  \n  type = particle type to be given to the new particles created by this fix\n  mol-ID = molecule-ID to be given to the new particles created by this fix (must be >= 65535)\n  \n  ",
    "examples": "fix stl_surf all smd/wall_surface tool.stl 2 65535\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  The molecule ID given to the particles created by this fix have to be\n  equal to or larger than 65535.\n  Within each .STL file, only a single triangulated object must be\n  present, even though the STL format allows for the possibility of\n  multiple objects in one file.\n  "
},
{
    "command": "fix spring",
    "description": "Apply a spring force to a group of atoms or between two groups of\n  atoms.  This is useful for applying an umbrella force to a small\n  molecule or lightly tethering a large group of atoms (e.g. all the\n  solvent or a large molecule) to the center of the simulation box so\n  that it does not wander away over the course of a long simulation.  It\n  can also be used to hold the centers of mass of two groups of atoms at\n  a given distance or orientation with respect to each other.\n  The tether style attaches a spring between a fixed point x,y,z and\n  the center of mass of the fix group of atoms.  The equilibrium\n  position of the spring is R0.  At each timestep the distance R from\n  the center of mass of the group of atoms to the tethering point is\n  computed, taking account of wrap-around in a periodic simulation box.\n  A restoring force of magnitude K (R - R0) Mi / M is applied to each\n  atom in the group where K is the spring constant, Mi is the mass of\n  the atom, and M is the total mass of all atoms in the group.  Note\n  that K thus represents the spring constant for the total force on\n  the group of atoms, not for a spring applied to each atom.\n  The couple style links two groups of atoms together.  The first\n  group is the fix group; the second is specified by group-ID2.  The\n  groups are coupled together by a spring that is at equilibrium when\n  the two groups are displaced by a vector x,y,z with respect to each\n  other and at a distance R0 from that displacement.  Note that x,y,z\n  is the equilibrium displacement of group-ID2 relative to the fix\n  group.  Thus (1,1,0) is a different spring than (-1,-1,0).  When the\n  relative positions and distance between the two groups are not in\n  equilibrium, the same spring force described above is applied to atoms\n  in each of the two groups.\n  For both the tether and couple styles, any of the x,y,z values can\n  be specified as NULL which means do not include that dimension in the\n  distance calculation or force application.\n  The first example above pulls the ligand towards the point (0,0,0).\n  The second example holds the ligand near the surface of a sphere of\n  radius 5 around the point (0,0,0).  The third example holds the ligand\n  a distance 3 away from the z=2 plane (on either side).\n  The fourth example holds 2 bilayers a distance 10 apart in z.  For the\n  last two examples, imagine a pore (a slab of atoms with a cylindrical\n  hole cut out) oriented with the pore axis along z, and an ion moving\n  within the pore.  The fifth example holds the ion a distance of -20\n  below the z = 0 center plane of the pore (umbrella sampling).  The\n  last example holds the ion a distance 5 away from the pore axis\n  (assuming the center-of-mass of the pore in x,y is the pore axis).\n  \n  Note\n  The center of mass of a group of atoms is calculated in\n  “unwrapped” coordinates using atom image flags, which means that the\n  group can straddle a periodic boundary.  See the dump doc\n  page for a discussion of unwrapped coordinates.  It also means that a\n  spring connecting two groups or a group and the tether point can cross\n  a periodic boundary and its length be calculated correctly.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The fix_modify energy option is supported by this\n  fix to add the energy stored in the spring to the system’s potential\n  energy as part of thermodynamic output.\n  The fix_modify respa option is supported by this\n  fix. This allows to set at which level of the r-RESPA\n  integrator the fix is adding its forces. Default is the outermost level.\n  This fix computes a global scalar which can be accessed by various\n  output commands.  The scalar is the spring energy\n  = 0.5 * K * r^2.\n  This fix also computes global 4-vector which can be accessed by\n  various output commands.  The first 3 quantities\n  in the vector are xyz components of the total force added to the group\n  of atoms by the spring.  In the case of the couple style, it is the\n  force on the fix group (group-ID) or the negative of the force on the\n  2nd group (group-ID2).  The 4th quantity in the vector is the\n  magnitude of the force added by the spring, as a positive value if\n  (r-R0) > 0 and a negative value if (r-R0) < 0.  This sign convention\n  can be useful when using the spring force to compute a potential of\n  mean force (PMF).\n  The scalar and vector values calculated by this fix are “extensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  The forces due to this fix are imposed during an energy minimization,\n  invoked by the minimize command.\n  \n  Note\n  If you want the spring energy to be included in the total\n  potential energy of the system (the quantity being minimized), you\n  MUST enable the fix_modify energy option for this\n  fix.\n  \n  ",
    "syntax": "fix ID group-ID spring keyword values\n  \n  \n  \n  ID, group-ID are documented in fix command\n  spring = style name of this fix command\n  keyword = tether or couple\n  tether values = K x y z R0\n    K = spring constant (force/distance units)\n    x,y,z = point to which spring is tethered\n    R0 = equilibrium distance from tether point (distance units)\n  couple values = group-ID2 K x y z R0\n    group-ID2 = 2nd group to couple to fix group with a spring\n    K = spring constant (force/distance units)\n    x,y,z = direction of spring\n    R0 = equilibrium distance of spring (distance units)\n  \n  \n  ",
    "examples": "fix pull ligand spring tether 50.0 0.0 0.0 0.0 0.0\n  fix pull ligand spring tether 50.0 0.0 0.0 0.0 5.0\n  fix pull ligand spring tether 50.0 NULL NULL 2.0 3.0\n  fix 5 bilayer1 spring couple bilayer2 100.0 NULL NULL 10.0 0.0\n  fix longitudinal pore spring couple ion 100.0 NULL NULL -20.0 0.0\n  fix radial pore spring couple ion 100.0 0.0 0.0 NULL 5.0\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix spring/chunk",
    "description": "Apply a spring force to the center-of-mass (COM) of chunks of atoms as\n  defined by the compute chunk/atom command.\n  Chunks can be molecules or spatial bins or other groupings of atoms.\n  This is a way of tethering each chunk to its initial COM coordinates.\n  The chunkID is the ID of a compute chunk/atom command defined in the\n  input script.  It is used to define the chunks.  The comID is the ID\n  of a compute com/chunk command defined in the input script.  It is\n  used to compute the COMs of each chunk.\n  At the beginning of the first run or\n  minimize command after this fix is defined, the\n  initial COM of each chunk is calculated and stored as R0m, where M is\n  the chunk number.  Thereafter, at every timestep (or minimization\n  iteration), the current COM of each chunk is calculated as Rm.  A\n  restoring force of magnitude K (Rm - R0m) Mi / Mm is applied to each\n  atom in each chunk where K is the specified spring constant, Mi is\n  the mass of the atom, and Mm is the total mass of all atoms in the\n  chunk.  Note that K thus represents the spring constant for the\n  total force on each chunk of atoms, not for a spring applied to each\n  atom.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The fix_modify energy option is supported by this\n  fix to add the energy stored in all the springs to the system’s potential\n  energy as part of thermodynamic output.\n  The fix_modify respa option is supported by this\n  fix. This allows to set at which level of the r-RESPA\n  integrator the fix is adding its forces. Default is the outermost level.\n  This fix computes a global scalar which can be accessed by various\n  output commands.  The scalar is the energy of all\n  the springs, i.e. 0.5 * K * r^2 per-spring.\n  The scalar value calculated by this fix is “extensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  The forces due to this fix are imposed during an energy minimization,\n  invoked by the minimize command.\n  \n  Note\n  If you want the spring energies to be included in the total\n  potential energy of the system (the quantity being minimized), you\n  MUST enable the fix_modify energy option for this\n  fix.\n  \n  ",
    "syntax": "fix ID group-ID spring/chunk K chunkID comID\n  \n  \n  \n  ID, group-ID are documented in fix command\n  spring/chunk = style name of this fix command\n  K = spring constant for each chunk (force/distance units)\n  chunkID = ID of compute chunk/atom command\n  comID = ID of compute com/chunk command\n  \n  ",
    "examples": "fix restrain all spring/chunk 100 chunkID comID\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix spring/rg",
    "description": "Apply a harmonic restraining force to atoms in the group to affect\n  their central moment about the center of mass (radius of gyration).\n  This fix is useful to encourage a protein or polymer to fold/unfold\n  and also when sampling along the radius of gyration as a reaction\n  coordinate (i.e. for protein folding).\n  The radius of gyration is defined as RG in the first formula.  The\n  energy of the constraint and associated force on each atom is given by\n  the second and third formulas, when the group is at a different RG\n  than the target value RG0.\n  \n  \\[\\begin{split}{R_G}^2 & = \\frac{1}{M}\\sum_{i}^{N}{m_{i}\\left( x_{i} -\n  \\frac{1}{M}\\sum_{j}^{N}{m_{j}x_{j}} \\right)^{2}} \\\\\n  E & = K\\left( R_G - R_{G0} \\right)^{2} \\\\\n  F_{i} & = 2K\\frac{m_{i}}{M}\\left( 1-\\frac{R_{G0}}{R_G}\n  \\right)\\left( x_{i} - \\frac{1}{M}\\sum_{j}^{N}{m_{j}x_{j}} \\right)\\end{split}\\]\n  The (\\(x_i\\) - center-of-mass) term is computed taking into account\n  periodic boundary conditions, \\(m_i\\) is the mass of the atom, and\n  M is the mass of the entire group.  Note that K is thus a force constant\n  for the aggregate force on the group of atoms, not a per-atom force.\n  If \\(R_{G0}\\) is specified as NULL, then the RG of the group is computed at\n  the time the fix is specified, and that value is used as the target.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  The fix_modify respa option is supported by this\n  fix. This allows to set at which level of the r-RESPA\n  integrator the fix is adding its forces. Default is the outermost level.\n  ",
    "syntax": "fix ID group-ID spring/rg K RG0\n  \n  \n  \n  ID, group-ID are documented in fix command\n  spring/rg = style name of this fix command\n  K = harmonic force constant (force/distance units)\n  RG0 = target radius of gyration to constrain to (distance units)\n  \n  if RG0 = NULL, use the current RG as the target value\n  \n  \n  ",
    "examples": "fix 1 protein spring/rg 5.0 10.0\n  fix 2 micelle spring/rg 5.0 NULL\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix spring/self",
    "description": "Apply a spring force independently to each atom in the group to tether\n  it to its initial position.  The initial position for each atom is its\n  location at the time the fix command was issued.  At each timestep,\n  the magnitude of the force on each atom is -Kr, where r is the\n  displacement of the atom from its current position to its initial\n  position.  The distance r correctly takes into account any crossings\n  of periodic boundary by the atom since it was in its initial\n  position.\n  With the (optional) dir flag, one can select in which direction the\n  spring force is applied. By default, the restraint is applied in all\n  directions, but it can be limited to the xy-, xz-, yz-plane and the\n  x-, y-, or z-direction, thus restraining the atoms to a line or a\n  plane, respectively.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  This fix writes the original coordinates of tethered atoms to binary restart files, so that the spring effect will be the\n  same in a restarted simulation.  See the\n  read_restart command for info on how to re-specify\n  a fix in an input script that reads a restart file, so that the\n  operation of the fix continues in an uninterrupted fashion.\n  The fix_modify energy option is supported by this\n  fix to add the energy stored in the per-atom springs to the system’s\n  potential energy as part of thermodynamic output.\n  The fix_modify respa option is supported by\n  this fix. This allows to set at which level of the r-RESPA\n  integrator the fix is adding its forces. Default is the outermost level.\n  This fix computes a global scalar which can be accessed by various\n  output commands.  The scalar is an energy which is\n  the sum of the spring energy for each atom, where the per-atom energy\n  is 0.5 * K * r^2.  The scalar value calculated by this fix is\n  “extensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  The forces due to this fix are imposed during an energy minimization,\n  invoked by the minimize command.\n  \n  Note\n  If you want the per-atom spring energy to be included in the\n  total potential energy of the system (the quantity being minimized),\n  you MUST enable the fix_modify energy option for\n  this fix.\n  \n  ",
    "syntax": "fix ID group-ID spring/self K dir\n  \n  \n  \n  ID, group-ID are documented in fix command\n  spring/self = style name of this fix command\n  K = spring constant (force/distance units)\n  dir = xyz, xy, xz, yz, x, y, or z (optional, default: xyz)\n  \n  ",
    "examples": "fix tether boundary-atoms spring/self 10.0\n  fix zrest  move spring/self 10.0 z\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix srd",
    "description": "Treat a group of particles as stochastic rotation dynamics (SRD)\n  particles that serve as a background solvent when interacting with big\n  (colloidal) particles in groupbig-ID.  The SRD formalism is described\n  in (Hecht).  The key idea behind using SRD particles as a\n  cheap coarse-grained solvent is that SRD particles do not interact\n  with each other, but only with the solute particles, which in LAMMPS\n  can be spheroids, ellipsoids, or line segments, or triangles, or rigid\n  bodies containing multiple spheroids or ellipsoids or line segments\n  or triangles.  The collision and rotation properties of the model\n  imbue the SRD particles with fluid-like properties, including an\n  effective viscosity.  Thus simulations with large solute particles can\n  be run more quickly, to measure solute properties like diffusivity\n  and viscosity in a background fluid.  The usual LAMMPS fixes for such\n  simulations, such as fix deform, fix viscosity, and fix nvt/sllod,\n  can be used in conjunction with the SRD model.\n  For more details on how the SRD model is implemented in LAMMPS, this paper describes the implementation and usage of pure SRD\n  fluids.  This paper, which is nearly complete, describes\n  the implementation and usage of mixture systems (solute particles in\n  an SRD fluid).  See the examples/srd directory for sample input\n  scripts using SRD particles in both settings.\n  This fix does two things:\n  \n  \n  It advects the SRD particles, performing collisions between SRD\n  and big particles or walls every timestep, imparting force and torque\n  to the big particles.  Collisions also change the position and\n  velocity of SRD particles.\n  It resets the velocity distribution of SRD particles via random\n  rotations every N timesteps.\n  \n  \n  SRD particles have a mass, temperature, characteristic timestep\n  \\(dt_{SRD}\\), and mean free path between collisions\n  (\\(\\lambda\\)).  The fundamental equation relating these 4 quantities\n  is\n  \n  \\[\\lambda = dt_{SRD} \\sqrt{\\frac{k_B T_{SRD}}{m}}\\]\n  The mass m of SRD particles is set by the mass command\n  elsewhere in the input script.  The SRD timestep \\(dt_{SRD}\\) is N\n  times the step dt defined by the timestep command.\n  Big particles move in the normal way via a time integration fix with a short timestep dt.  SRD particles advect with a large\n  timestep \\(dt_{SRD} \\ge dt\\).\n  If the lamda keyword is not specified, the SRD temperature\n  \\(T_{SRD}\\) is used in the above formula to compute \\(\\lambda\\).\n  If the lamda keyword is specified, then the Tsrd setting is ignored\n  and the above equation is used to compute the SRD temperature.\n  The characteristic length scale for the SRD fluid is set by hgrid\n  which is used to bin SRD particles for purposes of resetting their\n  velocities.  Normally hgrid is set to be 1/4 of the big particle\n  diameter or smaller, to adequately resolve fluid properties around the\n  big particles.\n  \\(\\lambda\\) cannot be smaller than 0.6 * hgrid, else an error is\n  generated (unless the shift keyword is used, see below).  The\n  velocities of SRD particles are bounded by Vmax, which is set so that an\n  SRD particle will not advect further than \\(D_{max} = 4 \\lambda\\) in\n  \\(dt_{SRD}\\).  This means that roughly speaking, \\(D_{max}\\)\n  should not be larger than a big particle diameter, else SRDs may pass\n  through big particles without colliding.  A warning is generated if this\n  is the case.\n  Collisions between SRD particles and big particles or walls are\n  modeled as a lightweight SRD point particle hitting a heavy big\n  particle of given diameter or a wall at a point on its surface and\n  bouncing off with a new velocity.  The collision changes the momentum\n  of the SRD particle.  It imparts a force and torque to the big\n  particle.  It imparts a force to a wall.  Static or moving SRD walls\n  are setup via the fix wall/srd command.  For the\n  remainder of this doc page, a collision of an SRD particle with a wall\n  can be viewed as a collision with a big particle of infinite radius\n  and mass.\n  The collision keyword sets the style of collisions.  The slip\n  style means that the tangential component of the SRD particle momentum\n  is preserved.  Thus a force is imparted to a big particle, but no\n  torque.  The normal component of the new SRD velocity is sampled from\n  a Gaussian distribution at temperature Tsrd.\n  For the noslip style, both the normal and tangential components of\n  the new SRD velocity are sampled from a Gaussian distribution at\n  temperature Tsrd.  Additionally, a new tangential direction for the\n  SRD velocity is chosen randomly.  This collision style imparts torque\n  to a big particle.  Thus a time integrator fix that rotates\n  the big particles appropriately should be used.\n  \n  The overlap keyword should be set to yes if two (or more) big\n  particles can ever overlap.  This depends on the pair potential\n  interaction used for big-big interactions, or could be the case if\n  multiple big particles are held together as rigid bodies via the\n  fix rigid command.  If the overlap keyword is no\n  and big particles do in fact overlap, then SRD/big collisions can\n  generate an error if an SRD ends up inside two (or more) big particles\n  at once.  How this error is treated is determined by the inside\n  keyword.  Running with overlap set to no allows for faster collision\n  checking, so it should only be set to yes if needed.\n  The inside keyword determines how a collision is treated if the\n  computation determines that the timestep started with the SRD particle\n  already inside a big particle.  If the setting is error then this\n  generates an error message and LAMMPS stops.  If the setting is warn\n  then this generates a warning message and the code continues.  If the\n  setting is ignore then no message is generated.  One of the output\n  quantities logged by the fix (see below) tallies the number of such\n  events, so it can be monitored.  Note that once an SRD particle is\n  inside a big particle, it may remain there for several steps until it\n  drifts outside the big particle.\n  The exact keyword determines how accurately collisions are computed.\n  A setting of yes computes the time and position of each collision as\n  SRD and big particles move together.  A setting of no estimates the\n  position of each collision based on the end-of-timestep positions of\n  the SRD and big particle.  If overlap is set to yes, the setting of\n  the exact keyword is ignored since time-accurate collisions are\n  needed.\n  The radius keyword scales the effective size of big particles.  If\n  big particles will overlap as they undergo dynamics, then this keyword\n  can be used to scale down their effective collision radius by an\n  amount rfactor, so that SRD particle will only collide with one big\n  particle at a time.  For example, in a Lennard-Jones system at a\n  temperature of 1.0 (in reduced LJ units), the minimum separation\n  between two big particles is as small as about 0.88 sigma.  Thus an\n  rfactor value of 0.85 should prevent dual collisions.\n  The bounce keyword can be used to limit the maximum number of\n  collisions an SRD particle undergoes in a single timestep as it\n  bounces between nearby big particles.  Note that if the limit is\n  reached, the SRD can be left inside a big particle.  A setting of 0 is\n  the same as no limit.\n  \n  There are 2 kinds of bins created and maintained when running an SRD\n  simulation.  The first are “SRD bins” which are used to bin SRD\n  particles and reset their velocities, as discussed above.  The second\n  are “search bins” which are used to identify SRD/big particle\n  collisions.\n  The search keyword can be used to choose a search bin size for\n  identifying SRD/big particle collisions.  The default is to use the\n  hgrid parameter for SRD bins as the search bin size.  Choosing a\n  smaller or large value may be more efficient, depending on the\n  problem.  But, in a statistical sense, it should not change the\n  simulation results.\n  The cubic keyword can be used to generate an error or warning when\n  the bin size chosen by LAMMPS creates SRD bins that are non-cubic or\n  different than the requested value of hgrid by a specified\n  tolerance.  Note that using non-cubic SRD bins can lead to\n  undetermined behavior when rotating the velocities of SRD particles,\n  hence LAMMPS tries to protect you from this problem.\n  LAMMPS attempts to set the SRD bin size to exactly hgrid.  However,\n  there must be an integer number of bins in each dimension of the\n  simulation box.  Thus the actual bin size will depend on the size and\n  shape of the overall simulation box.  The actual bin size is printed\n  as part of the SRD output when a simulation begins.\n  If the actual bin size in non-cubic by an amount exceeding the\n  tolerance, an error or warning is printed, depending on the style of\n  the cubic keyword.  Likewise, if the actual bin size differs from\n  the requested hgrid value by an amount exceeding the tolerance, then\n  an error or warning is printed.  The tolerance is a fractional\n  difference.  E.g. a tolerance setting of 0.01 on the shape means that\n  if the ratio of any 2 bin dimensions exceeds (1 +/- tolerance) then an\n  error or warning is generated.  Similarly, if the ratio of any bin\n  dimension with hgrid exceeds (1 +/- tolerance), then an error or\n  warning is generated.\n  \n  Note\n  The fix srd command can be used with simulations the size and/or\n  shape of the simulation box changes.  This can be due to non-periodic\n  boundary conditions or the use of fixes such as the fix deform or fix wall/srd commands\n  to impose a shear on an SRD fluid or an interaction with an external\n  wall.  If the box size changes then the size of SRD bins must be\n  recalculated every reneighboring.  This is not necessary if only the\n  box shape changes.  This re-binning is always done so as to fit an\n  integer number of bins in the current box dimension, whether it be a\n  fixed, shrink-wrapped, or periodic boundary, as set by the\n  boundary command.  If the box size or shape changes,\n  then the size of the search bins must be recalculated every\n  reneighboring.  Note that changing the SRD bin size may alter the\n  properties of the SRD fluid, such as its viscosity.\n  \n  The shift keyword determines whether the coordinates of SRD particles\n  are randomly shifted when binned for purposes of rotating their\n  velocities.  When no shifting is performed, SRD particles are binned and\n  the velocity distribution of the set of SRD particles in each bin is\n  adjusted via a rotation operator.  This is a statistically valid\n  operation if SRD particles move sufficiently far between successive\n  rotations.  This is determined by their mean-free path \\(\\lambda\\).\n  If \\(\\lambda\\) is less than 0.6 of the SRD bin size, then shifting\n  is required.  A shift means that all of the SRD particles are shifted by\n  a vector whose coordinates are chosen randomly in the range [-1/2 bin\n  size, 1/2 bin size].  Note that all particles are shifted by the same\n  vector.  The specified random number shiftseed is used to generate\n  these vectors.  This operation sufficiently randomizes which SRD\n  particles are in the same bin, even if \\(lambda\\) is small.\n  If the shift flag is set to no, then no shifting is performed, but\n  bin data will be communicated if bins overlap processor boundaries.  An\n  error will be generated if \\(\\lambda < 0.6\\) of the SRD bin size.\n  If the shift flag is set to possible, then shifting is performed\n  only if \\(\\lambda < 0.6\\) of the SRD bin size.  A warning is\n  generated to let you know this is occurring.  If the shift flag is set\n  to yes then shifting is performed regardless of the magnitude of\n  \\(\\lambda\\).  Note that the shiftseed is not used if the shift\n  flag is set to no, but must still be specified.\n  Note that shifting of SRD coordinates requires extra communication,\n  hence it should not normally be enabled unless required.\n  The tstat keyword will thermostat the SRD particles to the specified\n  Tsrd.  This is done every N timesteps, during the velocity rotation\n  operation, by rescaling the thermal velocity of particles in each SRD\n  bin to the desired temperature.  If there is a streaming velocity\n  associated with the system, e.g. due to use of the fix deform command to perform a simulation undergoing\n  shear, then that is also accounted for.  The mean velocity of each bin\n  of SRD particles is set to the position-dependent streaming velocity,\n  based on the coordinates of the center of the SRD bin.  Note that\n  collisions of SRD particles with big particles or walls has a\n  thermostatting effect on the colliding particles, so it may not be\n  necessary to thermostat the SRD particles on a bin by bin basis in\n  that case.  Also note that for streaming simulations, if no\n  thermostatting is performed (the default), then it may take a long\n  time for the SRD fluid to come to equilibrium with a velocity profile\n  that matches the simulation box deformation.\n  The rescale keyword enables rescaling of an SRD particle’s velocity\n  if it would travel more than 4 mean-free paths in an SRD timestep.  If\n  an SRD particle exceeds this velocity it is possible it will be lost\n  when migrating to other processors or that collisions with big\n  particles will be missed, either of which will generate errors.  Thus\n  the safest mode is to run with rescaling enabled.  However rescaling\n  removes kinetic energy from the system (the particle’s velocity is\n  reduced).  The latter will not typically be a problem if\n  thermostatting is enabled via the tstat keyword or if SRD collisions\n  with big particles or walls effectively thermostat the system.  If you\n  wish to turn off rescaling (on is the default), e.g. for a pure SRD\n  system with no thermostatting so that the temperature does not decline\n  over time, the rescale keyword can be used.  The no value turns\n  rescaling off during collisions and the per-bin velocity rotation\n  operation.  The collide and rotate values turn it on for\n  one of the operations and off for the other.\n  \n  \n  Note\n  This fix is normally used for simulations with a huge number of\n  SRD particles relative to the number of big particles, e.g. 100 to 1.\n  In this scenario, computations that involve only big particles\n  (neighbor list creation, communication, time integration) can slow\n  down dramatically due to the large number of background SRD particles.\n  \n  Three other input script commands will largely overcome this effect,\n  speeding up an SRD simulation by a significant amount.  These are the\n  atom_modify first, neigh_modify include, and comm_modify group\n  commands.  Each takes a group-ID as an argument, which in this case\n  should be the group-ID of the big solute particles.\n  Additionally, when a pair_style for big/big particle\n  interactions is specified, the pair_coeff command\n  should be used to turn off big/SRD interactions, e.g. by setting their\n  epsilon or cutoff length to 0.0.\n  The “delete_atoms overlap” command may be useful in setting up an SRD\n  simulation to insure there are no initial overlaps between big and SRD\n  particles.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.\n  This fix tabulates several SRD statistics which are stored in a vector\n  of length 12, which can be accessed by various output commands.  The vector values calculated by this fix\n  are “intensive”, meaning they do not scale with the size of the\n  simulation.  Technically, the first 8 do scale with the size of the\n  simulation, but treating them as intensive means they are not scaled\n  when printed as part of thermodynamic output.\n  These are the 12 quantities.  All are values for the current timestep,\n  except for quantity 5 and the last three, each of which are\n  cumulative quantities since the beginning of the run.\n  \n  \n  # of SRD/big collision checks performed\n  \n  \n  \n  # of SRDs which had a collision\n  \n  \n  \n  # of SRD/big collisions (including multiple bounces)\n  \n  \n  \n  # of SRD particles inside a big particle\n  \n  \n  \n  # of SRD particles whose velocity was rescaled to be < Vmax\n  \n  \n  \n  # of bins for collision searching\n  \n  \n  \n  # of bins for SRD velocity rotation\n  \n  \n  \n  # of bins in which SRD temperature was computed\n  \n  \n  \n  SRD temperature\n  \n  \n  \n  # of SRD particles which have undergone max # of bounces\n  \n  \n  \n  max # of bounces any SRD particle has had in a single step\n  \n  \n  \n  # of reneighborings due to SRD particles moving too far\n  \n  \n  \n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID srd N groupbig-ID Tsrd hgrid seed keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  srd = style name of this fix command\n  N = reset SRD particle velocities every this many timesteps\n  groupbig-ID = ID of group of large particles that SRDs interact with\n  Tsrd = temperature of SRD particles (temperature units)\n  hgrid = grid spacing for SRD grouping (distance units)\n  seed = random # seed (positive integer)\n  zero or more keyword/value pairs may be appended\n  keyword = lamda or collision or overlap or inside or exact or radius or bounce or search or cubic or shift or tstat or rescale\n  lamda value = mean free path of SRD particles (distance units)\n  collision value = noslip or slip = collision model\n  overlap value = yes or no = whether big particles may overlap\n  inside value = error or warn or ignore = how SRD particles which end up inside a big particle are treated\n  exact value = yes or no\n  radius value = rfactor = scale collision radius by this factor\n  bounce value = Nbounce = max # of collisions an SRD particle can undergo in one timestep\n  search value = sgrid = grid spacing for collision partner searching (distance units)\n  cubic values = style tolerance\n    style = error or warn\n    tolerance = fractional difference allowed (0 <= tol <= 1)\n  shift values = flag shiftseed\n    flag = yes or no or possible = SRD bin shifting for better statistics\n      yes = perform bin shifting each time SRD velocities are rescaled\n      no = no shifting\n      possible = shift depending on mean free path and bin size\n    shiftseed = random # seed (positive integer)\n  tstat value = yes or no = thermostat SRD particles or not\n  rescale value = yes or no or rotate or collide = rescaling of SRD velocities\n    yes = rescale during velocity rotation and collisions\n    no = no rescaling\n    rotate = rescale during velocity rotation, but not collisions\n    collide = rescale during collisions, but not velocity rotation\n  \n  \n  ",
    "examples": "fix 1 srd srd 10 big 1.0 0.25 482984\n  fix 1 srd srd 10 big 0.5 0.25 482984 collision slip search 0.5\n  \n  \n  ",
    "restrictions": "This command can only be used if LAMMPS was built with the SRD\n  package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "fix store/force",
    "description": "Store the forces on atoms in the group at the point during each\n  timestep when the fix is invoked, as described below.  This is useful\n  for storing forces before constraints or other boundary conditions are\n  computed which modify the forces, so that unmodified forces can be\n  written to a dump file or accessed by other output commands that use per-atom quantities.\n  This fix is invoked at the point in the velocity-Verlet timestepping\n  immediately after pair, bond,\n  angle, dihedral,\n  improper, and long-range\n  forces have been calculated.  It is the point in the timestep when\n  various fixes that compute constraint forces are calculated and\n  potentially modify the force on each atom.  Examples of such fixes are\n  fix shake, fix wall, and fix indent.\n  \n  Note\n  The order in which various fixes are applied which operate at\n  the same point during the timestep, is the same as the order they are\n  specified in the input script.  Thus normally, if you want to store\n  per-atom forces due to force field interactions, before constraints\n  are applied, you should list this fix first within that set of fixes,\n  i.e. before other fixes that apply constraints.  However, if you wish\n  to include certain constraints (e.g. fix shake) in the stored force,\n  then it could be specified after some fixes and before others.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.\n  This fix produces a per-atom array which can be accessed by various\n  output commands.  The number of columns for each\n  atom is 3, and the columns store the x,y,z forces on each atom.  The\n  per-atom values be accessed on any timestep.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID store/force\n  \n  \n  \n  ID, group-ID are documented in fix command\n  store/force = style name of this fix command\n  \n  ",
    "examples": "fix 1 all store/force\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix store/state",
    "description": "Define a fix that stores attributes for each atom in the group at the\n  time the fix is defined.  If N is 0, then the values are never\n  updated, so this is a way of archiving an atom attribute at a given\n  time for future use in a calculation or output.  See the discussion of\n  output commands that take fixes as inputs.\n  If N is not zero, then the attributes will be updated every N\n  steps.\n  \n  Note\n  Actually, only atom attributes specified by keywords like xu\n  or vy or radius are initially stored immediately at the point in\n  your input script when the fix is defined.  Attributes specified by a\n  compute, fix, or variable are not initially stored until the first run\n  following the fix definition begins.  This is because calculating\n  those attributes may require quantities that are not defined in\n  between runs.\n  \n  The list of possible attributes is the same as that used by the dump custom command, which describes their meaning.\n  If the com keyword is set to yes then the xu, yu, and zu\n  inputs store the position of each atom relative to the center-of-mass\n  of the group of atoms, instead of storing the absolute position.\n  The requested values are stored in a per-atom vector or array as\n  discussed below.  Zeroes are stored for atoms not in the specified\n  group.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  This fix writes the per-atom values it stores to binary restart files, so that the values can be restored when a\n  simulation is restarted.  See the read_restart\n  command for info on how to re-specify a fix in an input script that\n  reads a restart file, so that the operation of the fix continues in an\n  uninterrupted fashion.\n  None of the fix_modify options are relevant to this\n  fix.\n  If a single input is specified, this fix produces a per-atom vector.\n  If multiple inputs are specified, a per-atom array is produced where\n  the number of columns for each atom is the number of inputs.  These\n  can be accessed by various output commands.  The\n  per-atom values be accessed on any timestep.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID store/state N input1 input2 ... keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  store/state = style name of this fix command\n  N = store atom attributes every N steps, N = 0 for initial store only\n  input = one or more atom attributes\n  possible attributes = id, mol, type, mass,\n                        x, y, z, xs, ys, zs, xu, yu, zu, xsu, ysu, zsu, ix, iy, iz,\n                        vx, vy, vz, fx, fy, fz,\n                        q, mux, muy, muz, mu,\n                        radius, diameter, omegax, omegay, omegaz,\n                        angmomx, angmomy, angmomz, tqx, tqy, tqz,\n                        c_ID, c_ID[N], f_ID, f_ID[N], v_name,\n                        d_name, i_name\n  \n  \n  id = atom ID\n  mol = molecule ID\n  type = atom type\n  mass = atom mass\n  x,y,z = unscaled atom coordinates\n  xs,ys,zs = scaled atom coordinates\n  xu,yu,zu = unwrapped atom coordinates\n  xsu,ysu,zsu = scaled unwrapped atom coordinates\n  ix,iy,iz = box image that the atom is in\n  vx,vy,vz = atom velocities\n  fx,fy,fz = forces on atoms\n  q = atom charge\n  mux,muy,muz = orientation of dipolar atom\n  mu = magnitued of dipole moment of atom\n  radius,diameter = radius.diameter of spherical particle\n  omegax,omegay,omegaz = angular velocity of spherical particle\n  angmomx,angmomy,angmomz = angular momentum of aspherical particle\n  tqx,tqy,tqz = torque on finite-size particles\n  c_ID = per-atom vector calculated by a compute with ID\n  c_ID[I] = Ith column of per-atom array calculated by a compute with ID\n  f_ID = per-atom vector calculated by a fix with ID\n  f_ID[I] = Ith column of per-atom array calculated by a fix with ID\n  v_name = per-atom vector calculated by an atom-style variable with name\n  d_name = per-atom floating point vector name, managed by fix property/atom\n  i_name = per-atom integer vector name, managed by fix property/atom\n  \n  \n  \n  zero or more keyword/value pairs may be appended\n  keyword = com\n  com value = yes or no\n  \n  \n  ",
    "examples": "fix 1 all store/state 0 x y z\n  fix 1 all store/state 0 xu yu zu com yes\n  fix 2 all store/state 1000 vx vy vz\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix temp/berendsen",
    "description": "Reset the temperature of a group of atoms by using a Berendsen\n  thermostat (Berendsen), which rescales their velocities\n  every timestep.\n  The thermostat is applied to only the translational degrees of freedom\n  for the particles, which is an important consideration for finite-size\n  particles which have rotational degrees of freedom are being\n  thermostatted with this fix.  The translational degrees of freedom can\n  also have a bias velocity removed from them before thermostatting\n  takes place; see the description below.\n  The desired temperature at each timestep is a ramped value during the\n  run from Tstart to Tstop.  The Tdamp parameter is specified in\n  time units and determines how rapidly the temperature is relaxed.  For\n  example, a value of 100.0 means to relax the temperature in a timespan\n  of (roughly) 100 time units (tau or fmsec or psec - see the\n  units command).\n  Tstart can be specified as an equal-style variable.\n  In this case, the Tstop setting is ignored.  If the value is a\n  variable, it should be specified as v_name, where name is the variable\n  name.  In this case, the variable will be evaluated each timestep, and\n  its value used to determine the target temperature.\n  \n  Note\n  This thermostat will generate an error if the current\n  temperature is zero at the end of a timestep.  It cannot rescale a\n  zero temperature.\n  \n  Equal-style variables can specify formulas with various mathematical\n  functions, and include thermo_style command\n  keywords for the simulation box parameters and timestep and elapsed\n  time.  Thus it is easy to specify a time-dependent temperature.\n  \n  Note\n  Unlike the fix nvt command which performs\n  Nose/Hoover thermostatting AND time integration, this fix does NOT\n  perform time integration.  It only modifies velocities to effect\n  thermostatting.  Thus you must use a separate time integration fix,\n  like fix nve to actually update the positions of atoms\n  using the modified velocities.  Likewise, this fix should not normally\n  be used on atoms that also have their temperature controlled by\n  another fix - e.g. by fix nvt or fix langevin commands.\n  \n  See the Howto thermostat doc page for a\n  discussion of different ways to compute temperature and perform\n  thermostatting.\n  This fix computes a temperature each timestep.  To do this, the fix\n  creates its own compute of style “temp”, as if this command had been\n  issued:\n  compute fix-ID_temp group-ID temp\n  \n  \n  See the compute temp command for details.  Note\n  that the ID of the new compute is the fix-ID + underscore + “temp”,\n  and the group for the new compute is the same as the fix group.\n  Note that this is NOT the compute used by thermodynamic output (see\n  the thermo_style command) with ID = thermo_temp.\n  This means you can change the attributes of this fix’s temperature\n  (e.g. its degrees-of-freedom) via the\n  compute_modify command or print this temperature\n  during thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\n  It also means that changing attributes of thermo_temp will have no\n  effect on this fix.\n  Like other fixes that perform thermostatting, this fix can be used\n  with compute commands that calculate a temperature\n  after removing a “bias” from the atom velocities.  E.g. removing the\n  center-of-mass velocity from a group of atoms or only calculating\n  temperature on the x-component of velocity or only calculating\n  temperature for atoms in a geometric region.  This is not done by\n  default, but only if the fix_modify command is used\n  to assign a temperature compute to this fix that includes such a bias\n  term.  See the doc pages for individual compute commands to determine which ones include a bias.  In\n  this case, the thermostat works in the following manner: the current\n  temperature is calculated taking the bias into account, bias is\n  removed from each atom, thermostatting is performed on the remaining\n  thermal degrees of freedom, and the bias is added back in.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The fix_modify temp option is supported by this\n  fix.  You can use it to assign a temperature compute\n  you have defined to this fix which will be used in its thermostatting\n  procedure, as described above.  For consistency, the group used by\n  this fix and by the compute should be the same.\n  The fix_modify energy option is supported by this\n  fix to add the energy change implied by a velocity rescaling to the\n  system’s potential energy as part of thermodynamic output.\n  This fix computes a global scalar which can be accessed by various\n  output commands.  The scalar is the cumulative\n  energy change due to this fix.  The scalar value calculated by this\n  fix is “extensive”.\n  This fix can ramp its target temperature over multiple runs, using the\n  start and stop keywords of the run command.  See the\n  run command for details of how to do this.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID temp/berendsen Tstart Tstop Tdamp\n  \n  \n  \n  ID, group-ID are documented in fix command\n  temp/berendsen = style name of this fix command\n  Tstart,Tstop = desired temperature at start/end of run\n  Tstart can be a variable (see below)\n  \n  \n  \n  Tdamp = temperature damping parameter (time units)\n  \n  ",
    "examples": "fix 1 all temp/berendsen 300.0 300.0 100.0\n  \n  \n  ",
    "restrictions": "This fix can be used with dynamic groups as defined by the\n  group command.  Likewise it can be used with groups to\n  which atoms are added or deleted over time, e.g. a deposition\n  simulation.  However, the conservation properties of the thermostat\n  and barostat are defined for systems with a static set of atoms.  You\n  may observe odd behavior if the atoms in a group vary dramatically\n  over time or the atom count becomes very small.\n  "
},
{
    "command": "fix temp/csvr",
    "description": "Adjust the temperature with a canonical sampling thermostat that uses\n  global velocity rescaling with Hamiltonian dynamics (temp/csvr)\n  (Bussi1), or Langevin dynamics (temp/csld)\n  (Bussi2).  In the case of temp/csvr the thermostat is\n  similar to the empirical Berendsen thermostat in\n  temp/berendsen, but chooses the actual\n  scaling factor from a suitably chosen (gaussian) distribution rather\n  than having it determined from the time constant directly. In the case\n  of temp/csld the velocities are updated to a linear combination of\n  the current velocities with a gaussian distribution of velocities at\n  the desired temperature.  Both thermostats are applied every timestep.\n  The thermostat is applied to only the translational degrees of freedom\n  for the particles, which is an important consideration for finite-size\n  particles which have rotational degrees of freedom are being\n  thermostatted with these fixes.  The translational degrees of freedom\n  can also have a bias velocity removed from them before thermostatting\n  takes place; see the description below.\n  The desired temperature at each timestep is a ramped value during the\n  run from Tstart to Tstop.  The Tdamp parameter is specified in\n  time units and determines how rapidly the temperature is relaxed.  For\n  example, a value of 100.0 means to relax the temperature in a timespan\n  of (roughly) 100 time units (tau or fmsec or psec - see the\n  units command).\n  Tstart can be specified as an equal-style variable.\n  In this case, the Tstop setting is ignored.  If the value is a\n  variable, it should be specified as v_name, where name is the variable\n  name.  In this case, the variable will be evaluated each timestep, and\n  its value used to determine the target temperature.\n  Equal-style variables can specify formulas with various mathematical\n  functions, and include thermo_style command\n  keywords for the simulation box parameters and timestep and elapsed\n  time.  Thus it is easy to specify a time-dependent temperature.\n  \n  Note\n  Unlike the fix nvt command which performs\n  Nose/Hoover thermostatting AND time integration, these fixes do NOT\n  perform time integration. They only modify velocities to effect\n  thermostatting.  Thus you must use a separate time integration fix,\n  like fix nve to actually update the positions of atoms\n  using the modified velocities.  Likewise, these fixes should not\n  normally be used on atoms that also have their temperature controlled\n  by another fix - e.g. by fix nvt or fix langevin commands.\n  \n  See the Howto thermostat doc page for a\n  discussion of different ways to compute temperature and perform\n  thermostatting.\n  These fixes compute a temperature each timestep.  To do this, the fix\n  creates its own compute of style “temp”, as if this command had been\n  issued:\n  compute fix-ID_temp group-ID temp\n  \n  \n  See the compute temp command for details.  Note\n  that the ID of the new compute is the fix-ID + underscore + “temp”,\n  and the group for the new compute is the same as the fix group.\n  Note that this is NOT the compute used by thermodynamic output (see\n  the thermo_style command) with ID = thermo_temp.\n  This means you can change the attributes of this fix’s temperature\n  (e.g. its degrees-of-freedom) via the\n  compute_modify command or print this temperature\n  during thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\n  It also means that changing attributes of thermo_temp will have no\n  effect on this fix.\n  Like other fixes that perform thermostatting, these fixes can be used\n  with compute commands that calculate a temperature\n  after removing a “bias” from the atom velocities.  E.g. removing the\n  center-of-mass velocity from a group of atoms or only calculating\n  temperature on the x-component of velocity or only calculating\n  temperature for atoms in a geometric region.  This is not done by\n  default, but only if the fix_modify command is used\n  to assign a temperature compute to this fix that includes such a bias\n  term.  See the doc pages for individual compute commands to determine which ones include a bias.  In\n  this case, the thermostat works in the following manner: the current\n  temperature is calculated taking the bias into account, bias is\n  removed from each atom, thermostatting is performed on the remaining\n  thermal degrees of freedom, and the bias is added back in.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about these fixes are written to binary restart files.\n  The fix_modify temp option is supported by these\n  fixes.  You can use it to assign a temperature compute\n  you have defined to these fixes which will be used in its thermostatting\n  procedure, as described above.  For consistency, the group used by\n  these fixes and by the compute should be the same.\n  These fixes can ramp its target temperature over multiple runs, using\n  the start and stop keywords of the run command.  See the\n  run command for details of how to do this.\n  These fixes are not invoked during energy minimization.\n  These fixes compute a global scalar which can be accessed by various\n  output commands.  The scalar is the cumulative\n  energy change due to the fix.  The scalar value calculated by this fix\n  is “extensive”.\n  ",
    "syntax": "fix ID group-ID temp/csvr Tstart Tstop Tdamp seed\n  fix ID group-ID temp/csld Tstart Tstop Tdamp seed\n  \n  \n  \n  ID, group-ID are documented in fix command\n  temp/csvr or temp/csld = style name of this fix command\n  Tstart,Tstop = desired temperature at start/end of run\n  Tstart can be a variable (see below)\n  \n  \n  \n  Tdamp = temperature damping parameter (time units)\n  seed = random number seed to use for white noise (positive integer)\n  \n  ",
    "examples": "fix 1 all temp/csvr 300.0 300.0 100.0 54324\n  fix 1 all temp/csld 100.0 300.0 10.0 123321\n  \n  \n  ",
    "restrictions": "These fixes are not compatible with fix shake.\n  The fix can be used with dynamic groups as defined by the\n  group command.  Likewise it can be used with groups to\n  which atoms are added or deleted over time, e.g. a deposition\n  simulation.  However, the conservation properties of the thermostat\n  and barostat are defined for systems with a static set of atoms.  You\n  may observe odd behavior if the atoms in a group vary dramatically\n  over time or the atom count becomes very small.\n  "
},
{
    "command": "fix temp/rescale",
    "description": "Reset the temperature of a group of atoms by explicitly rescaling\n  their velocities.\n  The rescaling is applied to only the translational degrees of freedom\n  for the particles, which is an important consideration if finite-size\n  particles which have rotational degrees of freedom are being\n  thermostatted with this fix.  The translational degrees of freedom can\n  also have a bias velocity removed from them before thermostatting\n  takes place; see the description below.\n  Rescaling is performed every N timesteps.  The target temperature is a\n  ramped value between the Tstart and Tstop temperatures at the\n  beginning and end of the run.\n  \n  Note\n  This thermostat will generate an error if the current\n  temperature is zero at the end of a timestep it is invoked on.  It\n  cannot rescale a zero temperature.\n  \n  Tstart can be specified as an equal-style variable.\n  In this case, the Tstop setting is ignored.  If the value is a\n  variable, it should be specified as v_name, where name is the variable\n  name.  In this case, the variable will be evaluated each timestep, and\n  its value used to determine the target temperature.\n  Equal-style variables can specify formulas with various mathematical\n  functions, and include thermo_style command\n  keywords for the simulation box parameters and timestep and elapsed\n  time.  Thus it is easy to specify a time-dependent temperature.\n  Rescaling is only performed if the difference between the current and\n  desired temperatures is greater than the window value.  The amount\n  of rescaling that is applied is a fraction (from 0.0 to 1.0) of the\n  difference between the actual and desired temperature.  E.g. if\n  fraction = 1.0, the temperature is reset to exactly the desired\n  value.\n  \n  Note\n  Unlike the fix nvt command which performs\n  Nose/Hoover thermostatting AND time integration, this fix does NOT\n  perform time integration.  It only modifies velocities to effect\n  thermostatting.  Thus you must use a separate time integration fix,\n  like fix nve to actually update the positions of atoms\n  using the modified velocities.  Likewise, this fix should not normally\n  be used on atoms that also have their temperature controlled by\n  another fix - e.g. by fix nvt or fix langevin commands.\n  \n  See the Howto thermostat doc page for a\n  discussion of different ways to compute temperature and perform\n  thermostatting.\n  This fix computes a temperature each timestep.  To do this, the fix\n  creates its own compute of style “temp”, as if one of this command had\n  been issued:\n  compute fix-ID_temp group-ID temp\n  \n  \n  See the compute temp for details.  Note that the\n  ID of the new compute is the fix-ID + underscore + “temp”, and the\n  group for the new compute is the same as the fix group.\n  Note that this is NOT the compute used by thermodynamic output (see\n  the thermo_style command) with ID = thermo_temp.\n  This means you can change the attributes of this fix’s temperature\n  (e.g. its degrees-of-freedom) via the\n  compute_modify command or print this temperature\n  during thermodynamic output via the thermo_style custom command using the appropriate compute-ID.\n  It also means that changing attributes of thermo_temp will have no\n  effect on this fix.\n  Like other fixes that perform thermostatting, this fix can be used\n  with compute commands that calculate a temperature\n  after removing a “bias” from the atom velocities.  E.g. removing the\n  center-of-mass velocity from a group of atoms or only calculating\n  temperature on the x-component of velocity or only calculating\n  temperature for atoms in a geometric region.  This is not done by\n  default, but only if the fix_modify command is used\n  to assign a temperature compute to this fix that includes such a bias\n  term.  See the doc pages for individual compute commands to determine which ones include a bias.  In\n  this case, the thermostat works in the following manner: the current\n  temperature is calculated taking the bias into account, bias is\n  removed from each atom, thermostatting is performed on the remaining\n  thermal degrees of freedom, and the bias is added back in.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The fix_modify temp option is supported by this\n  fix.  You can use it to assign a temperature compute\n  you have defined to this fix which will be used in its thermostatting\n  procedure, as described above.  For consistency, the group used by\n  this fix and by the compute should be the same.\n  The fix_modify energy option is supported by this\n  fix to add the energy change implied by a velocity rescaling to the\n  system’s potential energy as part of thermodynamic output.\n  This fix computes a global scalar which can be accessed by various\n  output commands.  The scalar is the cumulative\n  energy change due to this fix.  The scalar value calculated by this\n  fix is “extensive”.\n  This fix can ramp its target temperature over multiple runs, using the\n  start and stop keywords of the run command.  See the\n  run command for details of how to do this.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID temp/rescale N Tstart Tstop window fraction\n  \n  \n  \n  ID, group-ID are documented in fix command\n  temp/rescale = style name of this fix command\n  N = perform rescaling every N steps\n  Tstart,Tstop = desired temperature at start/end of run (temperature units)\n  Tstart can be a variable (see below)\n  \n  \n  \n  window = only rescale if temperature is outside this window (temperature units)\n  fraction = rescale to target temperature by this fraction\n  \n  ",
    "examples": "fix 3 flow temp/rescale 100 1.0 1.1 0.02 0.5\n  fix 3 boundary temp/rescale 1 1.0 1.5 0.05 1.0\n  fix 3 boundary temp/rescale 1 1.0 1.5 0.05 1.0\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix temp/rescale/eff",
    "description": "Reset the temperature of a group of nuclei and electrons in the\n  electron force field model by explicitly rescaling\n  their velocities.\n  The operation of this fix is exactly like that described by the fix temp/rescale command, except that the rescaling\n  is also applied to the radial electron velocity for electron\n  particles.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The fix_modify temp option is supported by this\n  fix.  You can use it to assign a temperature compute\n  you have defined to this fix which will be used in its thermostatting\n  procedure, as described above.  For consistency, the group used by\n  this fix and by the compute should be the same.\n  The fix_modify energy option is supported by this\n  fix to add the energy change implied by a velocity rescaling to the\n  system’s potential energy as part of thermodynamic output.\n  This fix computes a global scalar which can be accessed by various\n  output commands.  The scalar is the cumulative\n  energy change due to this fix.  The scalar value calculated by this\n  fix is “extensive”.\n  This fix can ramp its target temperature over multiple runs, using the\n  start and stop keywords of the run command.  See the\n  run command for details of how to do this.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID temp/rescale/eff N Tstart Tstop window fraction\n  \n  \n  \n  ID, group-ID are documented in fix command\n  temp/rescale/eff = style name of this fix command\n  N = perform rescaling every N steps\n  Tstart,Tstop = desired temperature at start/end of run (temperature units)\n  window = only rescale if temperature is outside this window (temperature units)\n  fraction = rescale to target temperature by this fraction\n  \n  ",
    "examples": "fix 3 flow temp/rescale/eff 10 1.0 100.0 0.02 1.0\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-EFF package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "fix tfmc",
    "description": "Perform uniform-acceptance force-bias Monte Carlo (fbMC) simulations,\n  using the time-stamped force-bias Monte Carlo (tfMC) algorithm\n  described in (Mees) and (Bal).\n  One successful use case of force-bias Monte Carlo methods is that they\n  can be used to extend the time scale of atomistic simulations, in\n  particular when long time scale relaxation effects must be considered;\n  some interesting examples are given in the review by (Neyts).\n  An example of a typical use case would be the modelling of chemical\n  vapor deposition (CVD) processes on a surface, in which impacts by\n  gas-phase species can be performed using MD, but subsequent relaxation\n  of the surface is too slow to be done using MD only. Using tfMC can\n  allow for a much faster relaxation of the surface, so that higher\n  fluxes can be used, effectively extending the time scale of the\n  simulation. (Such an alternating simulation approach could be set up\n  using a loop.)\n  The initial version of tfMC algorithm in (Mees) contained an\n  estimation of the effective time scale of such a simulation, but it\n  was later shown that the speed-up one can gain from a tfMC simulation\n  is system- and process-dependent, ranging from none to several orders\n  of magnitude. In general, solid-state processes such as\n  (re)crystallization or growth can be accelerated by up to two or three\n  orders of magnitude, whereas diffusion in the liquid phase is not\n  accelerated at all. The observed pseudodynamics when using the tfMC\n  method is not the actual dynamics one would obtain using MD, but the\n  relative importance of processes can match the actual relative\n  dynamics of the system quite well, provided Delta is chosen with\n  care. Thus, the system’s equilibrium is reached faster than in MD,\n  along a path that is generally roughly similar to a typical MD\n  simulation (but not necessarily so). See (Bal) for details.\n  Each step, all atoms in the selected group are displaced using the\n  stochastic tfMC algorithm, which is designed to sample the canonical\n  (NVT) ensemble at the temperature Temp. Although tfMC is a Monte\n  Carlo algorithm and thus strictly speaking does not perform time\n  integration, it is similar in the sense that it uses the forces on all\n  atoms in order to update their positions. Therefore, it is implemented\n  as a time integration fix, and no other fixes of this type (such as\n  fix nve) should be used at the same time. Because\n  velocities do not play a role in this kind of Monte Carlo simulations,\n  instantaneous temperatures as calculated by temperature computes or thermodynamic output have no meaning: the only relevant\n  temperature is the sampling temperature Temp.  Similarly, performing\n  tfMC simulations does not require setting a timestep\n  and the simulated time as calculated by LAMMPS is\n  meaningless.\n  The critical parameter determining the success of a tfMC simulation is\n  Delta, the maximal displacement length of the lightest element in\n  the system: the larger it is, the longer the effective time scale of\n  the simulation will be (there is an approximately quadratic\n  dependence). However, Delta must also be chosen sufficiently small\n  in order to comply with detailed balance; in general values between 5\n  and 10 % of the nearest neighbor distance are found to be a good\n  choice. For a more extensive discussion with specific examples, please\n  refer to (Bal), which also describes how the code calculates\n  element-specific maximal displacements from Delta, based on the\n  fourth root of their mass.\n  Because of the uncorrelated movements of the atoms, the center-of-mass\n  of the fix group will not necessarily be stationary, just like its\n  orientation. When the com keyword is used, all atom positions will\n  be shifted (after every tfMC iteration) in order to fix the position\n  of the center-of-mass along the included directions, by setting the\n  corresponding flag to 1. The rot keyword does the same for the\n  rotational component of the tfMC displacements after every iteration.\n  \n  Note\n  the com and rot keywords should not be used if an external\n  force is acting on the specified fix group, along the included\n  directions. This can be either a true external force (e.g.  through\n  fix wall) or forces due to the interaction with atoms\n  not included in the fix group. This is because in such cases,\n  translations or rotations of the fix group could be induced by these\n  external forces, and removing them will lead to a violation of\n  detailed balance.\n  \n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  None of the fix_modify options are relevant to this\n  fix.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID tfmc Delta Temp seed keyword value\n  \n  \n  \n  ID, group-ID are documented in fix command\n  tfmc = style name of this fix command\n  Delta = maximal displacement length (distance units)\n  Temp = imposed temperature of the system\n  seed = random number seed (positive integer)\n  zero or more keyword/arg pairs may be appended\n  keyword = com or rot\n  com args = xflag yflag zflag\n    xflag,yflag,zflag = 0/1 to exclude/include each dimension\n  rot args = none\n  \n  \n  ",
    "examples": "fix 1 all tfmc 0.1 1000.0 159345\n  fix 1 all tfmc 0.05 600.0 658943 com 1 1 0\n  fix 1 all tfmc 0.1 750.0 387068 com 1 1 1 rot\n  \n  \n  ",
    "restrictions": "This fix is part of the MC package.  It is only enabled if LAMMPS was\n  built with that package.  See the Build package\n  doc page for more info.\n  This fix is not compatible with fix shake.\n  "
},
{
    "command": "fix thermal/conductivity",
    "description": "Use the Muller-Plathe algorithm described in this paper to exchange kinetic energy between two particles\n  in different regions of the simulation box every N steps.  This\n  induces a temperature gradient in the system.  As described below this\n  enables the thermal conductivity of a material to be calculated.  This\n  algorithm is sometimes called a reverse non-equilibrium MD (reverse\n  NEMD) approach to computing thermal conductivity.  This is because the\n  usual NEMD approach is to impose a temperature gradient on the system\n  and measure the response as the resulting heat flux.  In the\n  Muller-Plathe method, the heat flux is imposed, and the temperature\n  gradient is the system’s response.\n  See the compute heat/flux command for details\n  on how to compute thermal conductivity in an alternate way, via the\n  Green-Kubo formalism.\n  The simulation box is divided into Nbin layers in the edim\n  direction, where the layer 1 is at the low end of that dimension and\n  the layer Nbin is at the high end.  Every N steps, Nswap pairs of\n  atoms are chosen in the following manner.  Only atoms in the fix group\n  are considered.  The hottest Nswap atoms in layer 1 are selected.\n  Similarly, the coldest Nswap atoms in the “middle” layer (see below)\n  are selected.  The two sets of Nswap atoms are paired up and their\n  velocities are exchanged.  This effectively swaps their kinetic\n  energies, assuming their masses are the same.  If the masses are\n  different, an exchange of velocities relative to center of mass motion\n  of the 2 atoms is performed, to conserve kinetic energy.  Over time,\n  this induces a temperature gradient in the system which can be\n  measured using commands such as the following, which writes the\n  temperature profile (assuming z = edim) to the file tmp.profile:\n  compute   ke all ke/atom\n  variable  temp atom c_ke/1.5\n  compute   layers all chunk/atom bin/1d z lower 0.05 units reduced\n  fix       3 all ave/chunk 10 100 1000 layers v_temp file tmp.profile\n  \n  \n  Note that by default, Nswap = 1, though this can be changed by the\n  optional swap keyword.  Setting this parameter appropriately, in\n  conjunction with the swap rate N, allows the heat flux to be adjusted\n  across a wide range of values, and the kinetic energy to be exchanged\n  in large chunks or more smoothly.\n  The “middle” layer for velocity swapping is defined as the Nbin/2 +\n  1 layer.  Thus if Nbin = 20, the two swapping layers are 1 and 11.\n  This should lead to a symmetric temperature profile since the two\n  layers are separated by the same distance in both directions in a\n  periodic sense.  This is why Nbin is restricted to being an even\n  number.\n  As described below, the total kinetic energy transferred by these\n  swaps is computed by the fix and can be output.  Dividing this\n  quantity by time and the cross-sectional area of the simulation box\n  yields a heat flux.  The ratio of heat flux to the slope of the\n  temperature profile is proportional to the thermal conductivity of the\n  fluid, in appropriate units.  See the Muller-Plathe paper for details.\n  \n  Note\n  If your system is periodic in the direction of the heat flux,\n  then the flux is going in 2 directions.  This means the effective heat\n  flux in one direction is reduced by a factor of 2.  You will see this\n  in the equations for thermal conductivity (kappa) in the Muller-Plathe\n  paper.  LAMMPS is simply tallying kinetic energy which does not\n  account for whether or not your system is periodic; you must use the\n  value appropriately to yield a kappa for your system.\n  \n  \n  Note\n  After equilibration, if the temperature gradient you observe is\n  not linear, then you are likely swapping energy too frequently and are\n  not in a regime of linear response.  In this case you cannot\n  accurately infer a thermal conductivity and should try increasing the\n  Nevery parameter.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.\n  This fix computes a global scalar which can be accessed by various\n  output commands.  The scalar is the cumulative\n  kinetic energy transferred between the bottom and middle of the\n  simulation box (in the edim direction) is stored as a scalar\n  quantity by this fix.  This quantity is zeroed when the fix is defined\n  and accumulates thereafter, once every N steps.  The units of the\n  quantity are energy; see the units command for details.\n  The scalar value calculated by this fix is “intensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID thermal/conductivity N edim Nbin keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  thermal/conductivity = style name of this fix command\n  N = perform kinetic energy exchange every N steps\n  edim = x or y or z = direction of kinetic energy transfer\n  Nbin = # of layers in edim direction (must be even number)\n  zero or more keyword/value pairs may be appended\n  keyword = swap\n  swap value = Nswap = number of swaps to perform every N steps\n  \n  \n  ",
    "examples": "fix 1 all thermal/conductivity 100 z 20\n  fix 1 all thermal/conductivity 50 z 20 swap 2\n  \n  \n  ",
    "restrictions": "This fix is part of the MISC package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  Swaps conserve both momentum and kinetic energy, even if the masses of\n  the swapped atoms are not equal.  Thus you should not need to\n  thermostat the system.  If you do use a thermostat, you may want to\n  apply it only to the non-swapped dimensions (other than vdim).\n  LAMMPS does not check, but you should not use this fix to swap the\n  kinetic energy of atoms that are in constrained molecules, e.g. via\n  fix shake or fix rigid.  This is\n  because application of the constraints will alter the amount of\n  transferred momentum.  You should, however, be able to use flexible\n  molecules.  See the Zhang paper for a discussion and results\n  of this idea.\n  When running a simulation with large, massive particles or molecules\n  in a background solvent, you may want to only exchange kinetic energy\n  between solvent particles.\n  "
},
{
    "command": "fix ti/spring",
    "description": "This fix allows you to compute the free energy of crystalline solids\n  by performing a nonequilibrium thermodynamic integration between the\n  solid of interest and an Einstein crystal. A detailed explanation of\n  how to use this command and choose its parameters for optimal\n  performance and accuracy is given in the paper by\n  Freitas. The paper also presents a short summary of the\n  theory of nonequilibrium thermodynamic integration.\n  The thermodynamic integration procedure is performed by rescaling the\n  force on each atom. Given an atomic configuration the force (F) on\n  each atom is given by\n  \n  \\[F = \\left( 1-\\lambda \\right) F_{\\text{solid}} + \\lambda F_{\\text{harm}}\\]\n  where F_solid is the force that acts on an atom due to an interatomic\n  potential (e.g. EAM potential), F_harm is the force due to the\n  Einstein crystal harmonic spring, and lambda is the coupling parameter\n  of the thermodynamic integration. An Einstein crystal is a solid where\n  each atom is attached to its equilibrium position by a harmonic spring\n  with spring constant k. With this fix a spring force is applied\n  independently to each atom in the group defined by the fix to tether\n  it to its initial position. The initial position of each atom is its\n  position at the time the fix command was issued.\n  The fix acts as follows: during the first t_eq steps after the fix\n  is defined the value of lambda is zero. This is the period to\n  equilibrate the system in the lambda = 0 state. After this the value\n  of lambda changes dynamically during the simulation from 0 to 1\n  according to the function defined using the keyword function\n  (described below), this switching from lambda from 0 to 1 is done in\n  t_s steps. Then comes the second equilibration period of t_eq to\n  equilibrate the system in the lambda = 1 state. After that, the\n  switching back to the lambda = 0 state is made using t_s timesteps\n  and following the same switching function. After this period the value\n  of lambda is kept equal to zero and the fix has no other effect on the\n  dynamics of the system.\n  The processes described above is known as nonequilibrium thermodynamic\n  integration and is has been shown (Freitas) to present a\n  much superior efficiency when compared to standard equilibrium\n  methods. The reason why the switching it is made in both directions\n  (potential to Einstein crystal and back) is to eliminate the\n  dissipated heat due to the nonequilibrium process. Further details\n  about nonequilibrium thermodynamic integration and its implementation\n  in LAMMPS is available in Freitas.\n  The function keyword allows the use of two different lambda\n  paths. Option 1 results in a constant rate of change of lambda with\n  time:\n  \n  \\[\\lambda(\\tau) = \\tau\\]\n  where tau is the scaled time variable t/t_s. The option 2 performs\n  the lambda switching at a rate defined by the following switching\n  function\n  \n  \\[\\lambda(\\tau) = \\tau^5 \\left( 70 \\tau^4 - 315 \\tau^3 + 540 \\tau^2 - 420 \\tau + 126 \\right)\\]\n  This function has zero slope as lambda approaches its extreme values\n  (0 and 1), according to de Koning this results in\n  smaller fluctuations on the integral to be computed on the\n  thermodynamic integration. The use of option 2 is recommended since\n  it results in better accuracy and less dissipation without any\n  increase in computational resources cost.\n  \n  Note\n  As described in Freitas, it is important to keep the\n  center-of-mass fixed during the thermodynamic integration. A nonzero\n  total velocity will result in divergences during the integration due\n  to the fact that the atoms are ‘attached’ to their equilibrium\n  positions by the Einstein crystal. Check the option zero of fix langevin and velocity. The use of\n  the Nose-Hoover thermostat (fix nvt) is NOT\n  recommended due to its well documented issues with the canonical\n  sampling of harmonic degrees of freedom (notice that the chain\n  option will NOT solve this problem). The Langevin thermostat (fix langevin) correctly thermostats the system and we\n  advise its usage with ti/spring command.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  This fix writes the original coordinates of tethered atoms to binary restart files, so that the spring effect will be the\n  same in a restarted simulation. See the read restart command for info on how to re-specify a fix\n  in an input script that reads a restart file, so that the operation of\n  the fix continues in an uninterrupted fashion.\n  The fix modify energy option is supported by this\n  fix to add the energy stored in the per-atom springs to the system’s\n  potential energy as part of thermodynamic output.\n  This fix computes a global scalar and a global vector quantities which\n  can be accessed by various output commands. The\n  scalar is an energy which is the sum of the spring energy for each\n  atom, where the per-atom energy is 0.5 * k * r^2. The vector has 2\n  positions, the first one is the coupling parameter lambda and the\n  second one is the time derivative of lambda. The scalar and vector\n  values calculated by this fix are “extensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  The forces due to this fix are imposed during an energy minimization,\n  invoked by the minimize command.\n  \n  Note\n  If you want the per-atom spring energy to be included in the\n  total potential energy of the system (the quantity being minimized),\n  you MUST enable the fix modify energy option for\n  this fix.\n  \n  ",
    "syntax": "fix ID group-ID ti/spring k t_s t_eq keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  ti/spring = style name of this fix command\n  k = spring constant (force/distance units)\n  t_eq = number of steps for the equilibration procedure\n  t_s = number of steps for the switching procedure\n  zero or more keyword/value pairs may be appended to args\n  keyword = function\n  function value = function-ID\n    function-ID = ID of the switching function (1 or 2)\n  \n  \n  Example:\n  fix 1 all ti/spring 50.0 2000 1000 function 2\n  \n  \n  ",
    "examples": "fix 1 all thermal/conductivity 100 z 20\n  fix 1 all thermal/conductivity 50 z 20 swap 2\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-MISC package. It is only enabled if\n  LAMMPS was built with that package. See the Build package doc page for more info.\n  "
},
{
    "command": "fix tmd",
    "description": "Perform targeted molecular dynamics (TMD) on a group of atoms.  A\n  holonomic constraint is used to force the atoms to move towards (or\n  away from) the target configuration.  The parameter “rho” is\n  monotonically decreased (or increased) from its initial value to\n  rho_final at the end of the run.\n  Rho has distance units and is a measure of the root-mean-squared\n  distance (RMSD) between the current configuration of the atoms in the\n  group and the target coordinates listed in file1.  Thus a value of\n  rho_final = 0.0 means move the atoms all the way to the final\n  structure during the course of the run.\n  The target file1 can be ASCII text or a gzipped text file (detected by\n  a .gz suffix).  The format of the target file1 is as follows:\n  0.0 25.0 xlo xhi\n  0.0 25.0 ylo yhi\n  0.0 25.0 zlo zhi\n  125     24.97311   1.69005     23.46956 0 0 -1\n  126     1.94691    2.79640     1.92799  1 0 0\n  127     0.15906    3.46099     0.79121  1 0 0\n  ...\n  \n  \n  The first 3 lines may or may not be needed, depending on the format of\n  the atoms to follow.  If image flags are included with the atoms, the\n  1st 3 lo/hi lines must appear in the file.  If image flags are not\n  included, the 1st 3 lines should not appear.  The 3 lines contain the\n  simulation box dimensions for the atom coordinates, in the same format\n  as in a LAMMPS data file (see the read_data command).\n  The remaining lines each contain an atom ID and its target x,y,z\n  coordinates.  The atom lines (all or none of them) can optionally be\n  followed by 3 integer values: nx,ny,nz.  For periodic dimensions, they\n  specify which image of the box the atom is considered to be in, i.e. a\n  value of N (positive or negative) means add N times the box length to\n  the coordinate to get the true value.\n  The atom lines can be listed in any order, but every atom in the group\n  must be listed in the file.  Atoms not in the fix group may also be\n  listed; they will be ignored.\n  TMD statistics are written to file2 every N timesteps, unless N is\n  specified as 0, which means no statistics.\n  The atoms in the fix tmd group should be integrated (via a fix nve,\n  nvt, npt) along with other atoms in the system.\n  Restarts can be used with a fix tmd command.  For example, imagine a\n  10000 timestep run with a rho_initial = 11 and a rho_final = 1.  If a\n  restart file was written after 2000 time steps, then the configuration\n  in the file would have a rho value of 9.  A new 8000 time step run\n  could be performed with the same rho_final = 1 to complete the\n  conformational change at the same transition rate.  Note that for\n  restarted runs, the name of the TMD statistics file should be changed\n  to prevent it being overwritten.\n  For more information about TMD, see (Schlitter1) and\n  (Schlitter2).\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  This fix can ramp its rho parameter over multiple runs, using the\n  start and stop keywords of the run command.  See the\n  run command for details of how to do this.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID tmd rho_final file1 N file2\n  \n  \n  \n  ID, group-ID are documented in fix command\n  tmd = style name of this fix command\n  rho_final = desired value of rho at the end of the run (distance units)\n  file1 = filename to read target structure from\n  N = dump TMD statistics every this many timesteps, 0 = no dump\n  file2 = filename to write TMD statistics to (only needed if N > 0)\n  \n  ",
    "examples": "fix 1 all nve\n  fix 2 tmdatoms tmd 1.0 target_file 100 tmd_dump_file\n  \n  \n  ",
    "restrictions": "All TMD fixes must be listed in the input script after all integrator\n  fixes (nve, nvt, npt) are applied.  This ensures that atoms are moved\n  before their positions are corrected to comply with the constraint.\n  Atoms that have a TMD fix applied should not be part of a group to\n  which a SHAKE fix is applied.  This is because LAMMPS assumes there\n  are not multiple competing holonomic constraints applied to the same\n  atoms.\n  To read gzipped target files, you must compile LAMMPS with the\n  -DLAMMPS_GZIP option.  See the Build settings\n  doc page for details.\n  Related commands: none\n  Default: none\n  \n  (Schlitter1) Schlitter, Swegat, Mulders, “Distance-type reaction\n  coordinates for modelling activated processes”, J Molecular Modeling,\n  7, 171-177 (2001).\n  (Schlitter2) Schlitter and Klahn, “The free energy of a reaction\n  coordinate at multiple constraints: a concise formulation”, Molecular\n  Physics, 101, 3439-3443 (2003).\n  "
},
{
    "command": "fix ttm",
    "description": "Use a two-temperature model (TTM) to represent heat transfer through\n  and between electronic and atomic subsystems.  LAMMPS models the\n  atomic subsystem as usual with a molecular dynamics model and the\n  classical force field specified by the user, but the electronic\n  subsystem is modeled as a continuum, or a background “gas”, on a\n  regular grid.  Energy can be transferred spatially within the grid\n  representing the electrons.  Energy can also be transferred between\n  the electronic and the atomic subsystems.  The algorithm underlying\n  this fix was derived by D. M.  Duffy and A. M. Rutherford and is\n  discussed in two J Physics: Condensed Matter papers: (Duffy)\n  and (Rutherford).  They used this algorithm in cascade\n  simulations where a primary knock-on atom (PKA) was initialized with a\n  high velocity to simulate a radiation event.\n  The description in this sub-section applies to both fix ttm and fix\n  ttm/mod.  Fix ttm/mod adds options to account for external heat\n  sources (e.g. at a surface) and for specifying parameters that allow\n  the electronic heat capacity to depend strongly on electronic\n  temperature.  It is more expensive computationally than fix ttm\n  because it treats the thermal diffusion equation as non-linear.  More\n  details on fix ttm/mod are given below.\n  Heat transfer between the electronic and atomic subsystems is carried\n  out via an inhomogeneous Langevin thermostat.  This thermostat differs\n  from the regular Langevin thermostat (fix langevin) in three important ways.  First, the\n  Langevin thermostat is applied uniformly to all atoms in the\n  user-specified group for a single target temperature, whereas the TTM\n  fix applies Langevin thermostatting locally to atoms within the\n  volumes represented by the user-specified grid points with a target\n  temperature specific to that grid point.  Second, the Langevin\n  thermostat couples the temperature of the atoms to an infinite heat\n  reservoir, whereas the heat reservoir for fix TTM is finite and\n  represents the local electrons.  Third, the TTM fix allows users to\n  specify not just one friction coefficient, but rather two independent\n  friction coefficients: one for the electron-ion interactions\n  (gamma_p), and one for electron stopping (gamma_s).\n  When the friction coefficient due to electron stopping, gamma_s, is\n  non-zero, electron stopping effects are included for atoms moving\n  faster than the electron stopping critical velocity, v_0.  For\n  further details about this algorithm, see (Duffy) and\n  (Rutherford).\n  Energy transport within the electronic subsystem is solved according\n  to the heat diffusion equation with added source terms for heat\n  transfer between the subsystems:\n  \n  \\[C_e \\rho_e \\frac{\\partial T_e}{\\partial t} =\n  \\bigtriangledown (\\kappa_e \\bigtriangledown T_e) -\n  g_p (T_e - T_a) + g_s T_a'\\]\n  where C_e is the specific heat, rho_e is the density, kappa_e is the\n  thermal conductivity, T is temperature, the “e” and “a” subscripts\n  represent electronic and atomic subsystems respectively, g_p is the\n  coupling constant for the electron-ion interaction, and g_s is the\n  electron stopping coupling parameter.  C_e, rho_e, and kappa_e are\n  specified as parameters to the fix.  The other quantities are derived.\n  The form of the heat diffusion equation used here is almost the same\n  as that in equation 6 of (Duffy), with the exception that the\n  electronic density is explicitly represented, rather than being part\n  of the specific heat parameter.\n  Currently, fix ttm assumes that none of the user-supplied parameters\n  will vary with temperature. Note that (Duffy) used a tanh()\n  functional form for the temperature dependence of the electronic\n  specific heat, but ignored temperature dependencies of any of the\n  other parameters.  See more discussion below for fix ttm/mod.\n  These fixes require use of periodic boundary conditions and a 3D\n  simulation.  Periodic boundary conditions are also used in the heat\n  equation solve for the electronic subsystem.  This varies from the\n  approach of (Rutherford) where the atomic subsystem was\n  embedded within a larger continuum representation of the electronic\n  subsystem.\n  The initial electronic temperature input file, T_infile, is a text\n  file LAMMPS reads in with no header and with four numeric columns\n  (ix,iy,iz,Temp) and with a number of rows equal to the number of\n  user-specified grid points (Nx by Ny by Nz).  The ix,iy,iz are node\n  indices from 0 to nxnodes-1, etc.  For example, the initial electronic\n  temperatures on a 1 by 2 by 3 grid could be specified in a T_infile\n  as follows:\n  0 0 0 1.0\n  0 0 1 1.0\n  0 0 2 1.0\n  0 1 0 2.0\n  0 1 1 2.0\n  0 1 2 2.0\n  \n  \n  where the electronic temperatures along the y=0 plane have been set to\n  1.0, and the electronic temperatures along the y=1 plane have been set\n  to 2.0.  The order of lines in this file is no important.  If all the\n  nodal values are not specified, LAMMPS will generate an error.\n  The temperature output file, T_oufile, is created and written by\n  this fix.  Temperatures for both the electronic and atomic subsystems\n  at every node and every N timesteps are output.  If N is specified as\n  zero, no output is generated, and no output filename is needed.  The\n  format of the output is as follows.  One long line is written every\n  output timestep.  The timestep itself is given in the first column.\n  The next Nx*Ny*Nz columns contain the temperatures for the atomic\n  subsystem, and the final Nx*Ny*Nz columns contain the temperatures for\n  the electronic subsystem.  The ordering of the Nx*Ny*Nz columns is\n  with the z index varying fastest, y the next fastest, and x the\n  slowest.\n  These fixes do not change the coordinates of their atoms; they only\n  scales their velocities.  Thus a time integration fix (e.g. fix nve) should still be used to time integrate the affected\n  atoms.  The fixes should not normally be used on atoms that have their\n  temperature controlled by another fix - e.g. fix nvt or\n  fix langevin.\n  \n  Note\n  The current implementations of these fixes create a copy of the\n  electron grid that overlays the entire simulation domain, for each\n  processor.  Values on the grid are summed across all processors.  Thus\n  you should insure that this grid is not too large, else your\n  simulation could incur high memory and communication costs.\n  \n  \n  Additional details for fix ttm/mod\n  Fix ttm/mod uses the heat diffusion equation with possible external\n  heat sources (e.g. laser heating in ablation simulations):\n  \n  \\[C_e \\rho_e \\frac{\\partial T_e}{\\partial t} =\n  \\bigtriangledown (\\kappa_e \\bigtriangledown T_e) -\n  g_p (T_e - T_a) + g_s T_a' + \\theta (x-x_{surface})I_0 \\exp(-x/l_{skin})\\]\n  where theta is the Heaviside step function, I_0 is the (absorbed)\n  laser pulse intensity for ablation simulations, l_skin is the depth\n  of skin-layer, and all other designations have the same meaning as in\n  the former equation. The duration of the pulse is set by the parameter\n  tau in the init_file.\n  Fix ttm/mod also allows users to specify the dependencies of C_e and\n  kappa_e on the electronic temperature. The specific heat is expressed\n  as\n  \n  \\[C_e = C_0 + (a_0 + a_1 X + a_2 X^2 + a_3 X^3 + a_4 X^4) \\exp (-(AX)^2)\\]\n  where X = T_e/1000, and the thermal conductivity is defined as\n  kappa_e = D_e*rho_e*C_e, where D_e is the thermal diffusion\n  coefficient.\n  Electronic pressure effects are included in the TTM model to account\n  for the blast force acting on ions because of electronic pressure\n  gradient (see (Chen), (Norman)).  The total force\n  acting on an ion is:\n  \n  \\[{\\vec F}_i = - \\partial U / \\partial {\\vec r}_i + {\\vec F}_{langevin} - \\nabla P_e/n_{ion}\\]\n  where F_langevin is a force from Langevin thermostat simulating\n  electron-phonon coupling, and nabla P_e/n_ion is the electron blast\n  force.\n  The electronic pressure is taken to be P_e = B*rho_e*C_e*T_e\n  The current fix ttm/mod implementation allows TTM simulations with a\n  vacuum. The vacuum region is defined as the grid cells with zero\n  electronic temperature. The numerical scheme does not allow energy\n  exchange with such cells. Since the material can expand to previously\n  unoccupied region in some simulations, the vacuum border can be\n  allowed to move. It is controlled by the surface_movement parameter\n  in the init_file. If it is set to 1, then “vacuum” cells can be\n  changed to “electron-filled” cells with the temperature T_e_min if\n  atoms move into them (currently only implemented for the case of\n  1-dimensional motion of flat surface normal to the X axis). The\n  initial borders of vacuum can be set in the init_file via lsurface\n  and rsurface parameters. In this case, electronic pressure gradient\n  is calculated as\n  \n  \\[\\nabla_x P_e = \\left[\\frac{C_e{}T_e(x)\\lambda}{(x+\\lambda)^2} + \\frac{x}{x+\\lambda}\\frac{(C_e{}T_e)_{x+\\Delta x}-(C_e{}T_e)_{x}}{\\Delta x} \\right]\\]\n  where lambda is the electron mean free path (see (Norman),\n  (Pisarev))\n  The fix ttm/mod parameter file init_file has the following syntax/\n  Every line with the odd number is considered as a comment and\n  ignored. The lines with the even numbers are treated as follows:\n  a_0, energy/(temperature*electron) units\n  a_1, energy/(temperature^2*electron) units\n  a_2, energy/(temperature^3*electron) units\n  a_3, energy/(temperature^4*electron) units\n  a_4, energy/(temperature^5*electron) units\n  C_0, energy/(temperature*electron) units\n  A, 1/temperature units\n  rho_e, electrons/volume units\n  D_e, length^2/time units\n  gamma_p, mass/time units\n  gamma_s, mass/time units\n  v_0, length/time units\n  I_0, energy/(time*length^2) units\n  lsurface, electron grid units (positive integer)\n  rsurface, electron grid units (positive integer)\n  l_skin, length units\n  tau, time units\n  B, dimensionless\n  lambda, length units\n  n_ion, ions/volume units\n  surface_movement: 0 to disable tracking of surface motion, 1 to enable\n  T_e_min, temperature units\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  These fixes write the state of the electronic subsystem and the energy\n  exchange between the subsystems to binary restart files.  See the read_restart command\n  for info on how to re-specify a fix in an input script that reads a\n  restart file, so that the operation of the fix continues in an\n  uninterrupted fashion.\n  Because the state of the random number generator is not saved in the\n  restart files, this means you cannot do “exact” restarts with this\n  fix, where the simulation continues on the same as if no restart had\n  taken place.  However, in a statistical sense, a restarted simulation\n  should produce the same behavior.\n  None of the fix_modify options are relevant to these\n  fixes.\n  Both fixes compute 2 output quantities stored in a vector of length 2,\n  which can be accessed by various output commands.\n  The first quantity is the total energy of the electronic\n  subsystem. The second quantity is the energy transferred from the\n  electronic to the atomic subsystem on that timestep. Note that the\n  velocity verlet integrator applies the fix ttm forces to the atomic\n  subsystem as two half-step velocity updates: one on the current\n  timestep and one on the subsequent timestep.  Consequently, the change\n  in the atomic subsystem energy is lagged by half a timestep relative\n  to the change in the electronic subsystem energy. As a result of this,\n  users may notice slight fluctuations in the sum of the atomic and\n  electronic subsystem energies reported at the end of the timestep.\n  The vector values calculated are “extensive”.\n  No parameter of the fixes can be used with the start/stop keywords\n  of the run command.  The fixes are not invoked during\n  energy minimization.\n  ",
    "syntax": "fix ID group-ID ttm seed C_e rho_e kappa_e gamma_p gamma_s v_0 Nx Ny Nz T_infile N T_outfile\n  fix ID group-ID ttm/mod seed init_file Nx Ny Nz T_infile N T_outfile\n  \n  \n  \n  ID, group-ID are documented in fix command\n  style = ttm or ttm_mod\n  seed = random number seed to use for white noise (positive integer)\n  remaining arguments for fix ttm:\n  C_e  = electronic specific heat (energy/(electron*temperature) units)\n  rho_e = electronic density (electrons/volume units)\n  kappa_e = electronic thermal conductivity (energy/(time*distance*temperature) units)\n  gamma_p = friction coefficient due to electron-ion interactions (mass/time units)\n  gamma_s = friction coefficient due to electronic stopping (mass/time units)\n  v_0 = electronic stopping critical velocity (velocity units)\n  Nx = number of thermal solve grid points in the x-direction (positive integer)\n  Ny = number of thermal solve grid points in the y-direction (positive integer)\n  Nz = number of thermal solve grid points in the z-direction (positive integer)\n  T_infile = filename to read initial electronic temperature from\n  N = dump TTM temperatures every this many timesteps, 0 = no dump\n  T_outfile = filename to write TTM temperatures to (only needed if N > 0)\n  \n  remaining arguments for fix ttm/mod:\n  init_file = file with the parameters to TTM\n  Nx = number of thermal solve grid points in the x-direction (positive integer)\n  Ny = number of thermal solve grid points in the y-direction (positive integer)\n  Nz = number of thermal solve grid points in the z-direction (positive integer)\n  T_infile = filename to read initial electronic temperature from\n  N = dump TTM temperatures every this many timesteps, 0 = no dump\n  T_outfile = filename to write TTM temperatures to (only needed if N > 0)\n  \n  \n  \n  \n  ",
    "examples": "fix 2 all ttm 699489 1.0 1.0 10 0.1 0.0 2.0 1 12 1 initialTs 1000 T.out\n  fix 2 all ttm 123456 1.0 1.0 1.0 1.0 1.0 5.0 5 5 5 Te.in 1 Te.out\n  fix 2 all ttm/mod 34277 parameters.txt 5 5 5 T_init 10 T_out\n  \n  \n  ",
    "restrictions": "Fix ttm is part of the MISC package. It is only enabled if LAMMPS\n  was built with that package.  Fix ttm/mod is part of the USER-MISC\n  package. It is only enabled if LAMMPS was built with that package.\n  See the Build package doc page for more info.\n  These fixes can only be used for 3d simulations and orthogonal\n  simulation boxes.  You must also use periodic\n  boundary conditions.\n  "
},
{
    "command": "fix tune/kspace",
    "description": "This fix tests each kspace style (Ewald, PPPM, and MSM), and\n  automatically selects the fastest style to use for the remainder\n  of the run. If the fastest style is Ewald or PPPM, the fix also\n  adjusts the Coulombic cutoff towards optimal speed. Future versions\n  of this fix will automatically select other kspace parameters\n  to use for maximum simulation speed. The kspace parameters may\n  include the style, cutoff, grid points in each direction, order,\n  Ewald parameter, MSM parallelization cut-point, MPI tasks to use, etc.\n  The rationale for this fix is to provide the user with\n  as-fast-as-possible simulations that include long-range electrostatics\n  (kspace) while meeting the user-prescribed accuracy requirement. A\n  simple heuristic could never capture the optimal combination of\n  parameters for every possible run-time scenario. But by performing\n  short tests of various kspace parameter sets, this fix allows\n  parameters to be tailored specifically to the user’s machine, MPI\n  ranks, use of threading or accelerators, the simulated system, and the\n  simulation details. In addition, it is possible that parameters could\n  be evolved with the simulation on-the-fly, which is useful for systems\n  that are dynamically evolving (e.g. changes in box size/shape or\n  number of particles).\n  When this fix is invoked, LAMMPS will perform short timed tests of\n  various parameter sets to determine the optimal parameters. Tests are\n  performed on-the-fly, with a new test initialized every N steps. N should\n  be chosen large enough so that adequate CPU time lapses between tests,\n  thereby providing statistically significant timings. But N should not be\n  chosen to be so large that an unfortunate parameter set test takes an\n  inordinate amount of wall time to complete. An N of 100 for most problems\n  seems reasonable. Once an optimal parameter set is found, that set is\n  used for the remainder of the run.\n  This fix uses heuristics to guide it’s selection of parameter sets to test,\n  but the actual timed results will be used to decide which set to use in the\n  simulation.\n  It is not necessary to discard trajectories produced using sub-optimal\n  parameter sets, or a mix of various parameter sets, since the user-prescribed\n  accuracy will have been maintained throughout. However, some users may prefer\n  to use this fix only to discover the optimal parameter set for a given setup\n  that can then be used on subsequent production runs.\n  This fix starts with kspace parameters that are set by the user with the\n  kspace_style and kspace_modify\n  commands. The prescribed accuracy will be maintained by this fix throughout\n  the simulation.\n  None of the fix_modify options are relevant to this\n  fix.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID tune/kspace N\n  \n  \n  \n  ID, group-ID are documented in fix command\n  tune/kspace = style name of this fix command\n  N = invoke this fix every N steps\n  \n  ",
    "examples": "fix 2 all tune/kspace 100\n  \n  \n  ",
    "restrictions": "This fix is part of the KSPACE package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  Do not set “neigh_modify once yes” or else this fix will never be\n  called.  Reneighboring is required.\n  This fix is not compatible with a hybrid pair style, long-range dispersion,\n  TIP4P water support, or long-range point dipole support.\n  "
},
{
    "command": "fix vector",
    "description": "Use one or more global values as inputs every few timesteps, and\n  simply store them.  For a single specified value, the values are\n  stored as a global vector of growing length.  For multiple specified\n  values, they are stored as rows in a global array, whose number of\n  rows is growing.  The resulting vector or array can be used by other\n  output commands.\n  One way to to use this command is to accumulate a vector that is\n  time-integrated using the variable trap() function.\n  For example the velocity auto-correlation function (VACF) can be\n  time-integrated, to yield a diffusion coefficient, as follows:\n  compute         2 all vacf\n  fix             5 all vector 1 c_2[4]\n  variable        diff equal dt*trap(f_5)\n  thermo_style    custom step v_diff\n  \n  \n  The group specified with this command is ignored.  However, note that\n  specified values may represent calculations performed by computes and\n  fixes which store their own “group” definitions.\n  Each listed value can be the result of a compute or\n  fix or the evaluation of an equal-style or vector-style\n  variable.  In each case, the compute, fix, or variable\n  must produce a global quantity, not a per-atom or local quantity.  And\n  the global quantity must be a scalar, not a vector or array.\n  Computes that produce global quantities are those which\n  do not have the word atom in their style name.  Only a few\n  fixes produce global quantities.  See the doc pages for\n  individual fixes for info on which ones produce such values.\n  Variables of style equal or vector are the only\n  ones that can be used with this fix.  Variables of style atom cannot\n  be used, since they produce per-atom values.\n  The Nevery argument specifies on what timesteps the input values\n  will be used in order to be stored.  Only timesteps that are a\n  multiple of Nevery, including timestep 0, will contribute values.\n  Note that if you perform multiple runs, using the “pre no” option of\n  the run command to avoid initialization on subsequent runs,\n  then you need to use the stop keyword with the first run\n  command with a timestep value that encompasses all the runs.  This is\n  so that the vector or array stored by this fix can be allocated to a\n  sufficient size.\n  \n  If a value begins with “c_”, a compute ID must follow which has been\n  previously defined in the input script.  If no bracketed term is\n  appended, the global scalar calculated by the compute is used.  If a\n  bracketed term is appended, the Ith element of the global vector\n  calculated by the compute is used.\n  Note that there is a compute reduce command\n  which can sum per-atom quantities into a global scalar or vector which\n  can thus be accessed by fix vector.  Or it can be a compute defined\n  not in your input script, but by thermodynamic output or other fixes such as fix nvt\n  or fix temp/rescale.  See the doc pages for\n  these commands which give the IDs of these computes.  Users can also\n  write code for their own compute styles and add them to LAMMPS.\n  If a value begins with “f_”, a fix ID must follow which has been\n  previously defined in the input script.  If no bracketed term is\n  appended, the global scalar calculated by the fix is used.  If a\n  bracketed term is appended, the Ith element of the global vector\n  calculated by the fix is used.\n  Note that some fixes only produce their values on certain timesteps,\n  which must be compatible with Nevery, else an error will result.\n  Users can also write code for their own fix styles and add them to LAMMPS.\n  If a value begins with “v_”, a variable name must follow which has\n  been previously defined in the input script.  An equal-style or\n  vector-style variable can be referenced; the latter requires a\n  bracketed term to specify the Ith element of the vector calculated by\n  the variable.  See the variable command for details.\n  Note that variables of style equal and vector define a formula\n  which can reference individual atom properties or thermodynamic\n  keywords, or they can invoke other computes, fixes, or variables when\n  they are evaluated, so this is a very general means of specifying\n  quantities to be stored by fix vector.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.\n  This fix produces a global vector or global array which can be\n  accessed by various output commands.  The values\n  can only be accessed on timesteps that are multiples of Nevery.\n  A vector is produced if only a single input value is specified.\n  An array is produced if multiple input values are specified.\n  The length of the vector or the number of rows in the array grows\n  by 1 every Nevery timesteps.\n  If the fix produces a vector, then the entire vector will be either\n  “intensive” or “extensive”, depending on whether the values stored in\n  the vector are “intensive” or “extensive”.  If the fix produces an\n  array, then all elements in the array must be the same, either\n  “intensive” or “extensive”.  If a compute or fix provides the value\n  stored, then the compute or fix determines whether the value is\n  intensive or extensive; see the doc page for that compute or fix for\n  further info.  Values produced by a variable are treated as intensive.\n  This fix can allocate storage for stored values accumulated over\n  multiple runs, using the start and stop keywords of the\n  run command.  See the run command for details of\n  how to do this.  If using the run pre no command option,\n  this is required to allow the fix to allocate sufficient storage for\n  stored values.\n  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID vector Nevery value1 value2 ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  vector = style name of this fix command\n  Nevery = use input values every this many timesteps\n  one or more input values can be listed\n  value = c_ID, c_ID[N], f_ID, f_ID[N], v_name\n  c_ID = global scalar calculated by a compute with ID\n  c_ID[I] = Ith component of global vector calculated by a compute with ID\n  f_ID = global scalar calculated by a fix with ID\n  f_ID[I] = Ith component of global vector calculated by a fix with ID\n  v_name = value calculated by an equal-style variable with name\n  v_name[I] = Ith component of vector-style variable with name\n  \n  \n  \n  \n  ",
    "examples": "fix 1 all vector 100 c_myTemp\n  fix 1 all vector 5 c_myTemp v_integral\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix viscosity",
    "description": "Use the Muller-Plathe algorithm described in this paper to exchange momenta between two particles in\n  different regions of the simulation box every N steps.  This induces a\n  shear velocity profile in the system.  As described below this enables\n  a viscosity of the fluid to be calculated.  This algorithm is\n  sometimes called a reverse non-equilibrium MD (reverse NEMD) approach\n  to computing viscosity.  This is because the usual NEMD approach is to\n  impose a shear velocity profile on the system and measure the response\n  via an off-diagonal component of the stress tensor, which is\n  proportional to the momentum flux.  In the Muller-Plathe method, the\n  momentum flux is imposed, and the shear velocity profile is the\n  system’s response.\n  The simulation box is divided into Nbin layers in the pdim\n  direction, where the layer 1 is at the low end of that dimension and\n  the layer Nbin is at the high end.  Every N steps, Nswap pairs of\n  atoms are chosen in the following manner.  Only atoms in the fix group\n  are considered.  Nswap atoms in layer 1 with positive velocity\n  components in the vdim direction closest to the target value V are\n  selected.  Similarly, Nswap atoms in the “middle” layer (see below) with\n  negative velocity components in the vdim direction closest to the\n  negative of the target value V are selected.  The two sets of Nswap\n  atoms are paired up and their vdim momenta components are swapped\n  within each pair.  This resets their velocities, typically in opposite\n  directions.  Over time, this induces a shear velocity profile in the\n  system which can be measured using commands such as the following,\n  which writes the profile to the file tmp.profile:\n  compute layers all chunk/atom bin/1d z lower 0.05 units reduced\n  fix f1 all ave/chunk 100 10 1000 layers vx file tmp.profile\n  \n  \n  Note that by default, Nswap = 1 and vtarget = INF, though this can be\n  changed by the optional swap and vtarget keywords.  When vtarget =\n  INF, one or more atoms with the most positive and negative velocity\n  components are selected.  Setting these parameters appropriately, in\n  conjunction with the swap rate N, allows the momentum flux rate to be\n  adjusted across a wide range of values, and the momenta to be\n  exchanged in large chunks or more smoothly.\n  The “middle” layer for momenta swapping is defined as the Nbin/2 + 1\n  layer.  Thus if Nbin = 20, the two swapping layers are 1 and 11.\n  This should lead to a symmetric velocity profile since the two layers\n  are separated by the same distance in both directions in a periodic\n  sense.  This is why Nbin is restricted to being an even number.\n  As described below, the total momentum transferred by these velocity\n  swaps is computed by the fix and can be output.  Dividing this\n  quantity by time and the cross-sectional area of the simulation box\n  yields a momentum flux.  The ratio of momentum flux to the slope of\n  the shear velocity profile is proportional to the viscosity of the\n  fluid, in appropriate units.  See the Muller-Plathe paper for details.\n  \n  Note\n  If your system is periodic in the direction of the momentum\n  flux, then the flux is going in 2 directions.  This means the\n  effective momentum flux in one direction is reduced by a factor of 2.\n  You will see this in the equations for viscosity in the Muller-Plathe\n  paper.  LAMMPS is simply tallying momentum which does not account for\n  whether or not your system is periodic; you must use the value\n  appropriately to yield a viscosity for your system.\n  \n  \n  Note\n  After equilibration, if the velocity profile you observe is not\n  linear, then you are likely swapping momentum too frequently and are\n  not in a regime of linear response.  In this case you cannot\n  accurately infer a viscosity and should try increasing the Nevery\n  parameter.\n  \n  An alternative method for calculating a viscosity is to run a NEMD\n  simulation, as described on the Howto nemd doc page.\n  NEMD simulations deform the simulation box via the fix deform command.  Thus they cannot be run on a charged\n  system using a PPPM solver since PPPM does not\n  currently support non-orthogonal boxes.  Using fix viscosity keeps the\n  box orthogonal; thus it does not suffer from this limitation.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.\n  This fix computes a global scalar which can be accessed by various\n  output commands.  The scalar is the cumulative\n  momentum transferred between the bottom and middle of the simulation\n  box (in the pdim direction) is stored as a scalar quantity by this\n  fix.  This quantity is zeroed when the fix is defined and accumulates\n  thereafter, once every N steps.  The units of the quantity are\n  momentum = mass*velocity.  The scalar value calculated by this fix is\n  “intensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID viscosity N vdim pdim Nbin keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  viscosity = style name of this fix command\n  N = perform momentum exchange every N steps\n  vdim = x or y or z = which momentum component to exchange\n  pdim = x or y or z = direction of momentum transfer\n  Nbin = # of layers in pdim direction (must be even number)\n  zero or more keyword/value pairs may be appended\n  keyword = swap or target\n  swap value = Nswap = number of swaps to perform every N steps\n  vtarget value = V or INF = target velocity of swap partners (velocity units)\n  \n  \n  ",
    "examples": "fix 1 all viscosity 100 x z 20\n  fix 1 all viscosity 50 x z 20 swap 2 vtarget 1.5\n  \n  \n  ",
    "restrictions": "This fix is part of the MISC package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  Swaps conserve both momentum and kinetic energy, even if the masses of\n  the swapped atoms are not equal.  Thus you should not need to\n  thermostat the system.  If you do use a thermostat, you may want to\n  apply it only to the non-swapped dimensions (other than vdim).\n  LAMMPS does not check, but you should not use this fix to swap\n  velocities of atoms that are in constrained molecules, e.g. via fix shake or fix rigid.  This is because\n  application of the constraints will alter the amount of transferred\n  momentum.  You should, however, be able to use flexible molecules.\n  See the Maginn paper for an example of using this algorithm\n  in a computation of alcohol molecule properties.\n  When running a simulation with large, massive particles or molecules\n  in a background solvent, you may want to only exchange momenta between\n  solvent particles.\n  "
},
{
    "command": "fix viscous",
    "description": "Add a viscous damping force to atoms in the group that is proportional\n  to the velocity of the atom.  The added force can be thought of as a\n  frictional interaction with implicit solvent, i.e. the no-slip Stokes\n  drag on a spherical particle.  In granular simulations this can be\n  useful for draining the kinetic energy from the system in a controlled\n  fashion.  If used without additional thermostatting (to add kinetic\n  energy to the system), it has the effect of slowly (or rapidly)\n  freezing the system; hence it can also be used as a simple energy\n  minimization technique.\n  The damping force \\(F_i\\) is given by \\(F_i = - \\gamma v_i\\).\n  The larger the coefficient, the faster the kinetic energy is reduced.\n  If the optional keyword scale is used, \\(\\gamma\\) can scaled up or\n  down by the specified factor for atoms of that type.  It can be used\n  multiple times to adjust \\(\\gamma\\) for several atom types.\n  \n  Note\n  You should specify gamma in force/velocity units.  This is not\n  the same as mass/time units, at least for some of the LAMMPS\n  units options like “real” or “metal” that are not\n  self-consistent.\n  \n  In a Brownian dynamics context, \\(\\gamma = \\frac{k_B T}{D}\\), where\n  \\(k_B =\\) Boltzmann’s constant, T = temperature, and D = particle\n  diffusion coefficient.  D can be written as \\(\\frac{k_B T}{3 \\pi\n  \\eta d}\\), where \\(\\eta =\\) dynamic viscosity of the frictional fluid\n  and d = diameter of particle.  This means \\(\\gamma = 3 \\pi \\eta d\\),\n  and thus is proportional to the viscosity of the fluid and the particle\n  diameter.\n  In the current implementation, rather than have the user specify a\n  viscosity, \\(\\gamma\\) is specified directly in force/velocity units.\n  If needed, \\(\\gamma\\) can be adjusted for atoms of different sizes\n  (i.e. \\(\\sigma\\)) by using the scale keyword.\n  Note that Brownian dynamics models also typically include a randomized\n  force term to thermostat the system at a chosen temperature.  The\n  fix langevin command does this.  It has the same\n  viscous damping term as fix viscous and adds a random force to each\n  atom.  The random force term is proportional to the square root of the\n  chosen thermostatting temperature.  Thus if you use fix langevin with a\n  target \\(T = 0\\), its random force term is zero, and you are\n  essentially performing the same operation as fix viscous.  Also note\n  that the gamma of fix viscous is related to the damping parameter of\n  fix langevin, however the former is specified in\n  units of force/velocity and the latter in units of time, so that it can\n  more easily be used as a thermostat.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options are\n  relevant to this fix.  No global or per-atom quantities are stored by\n  this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  The fix_modify respa option is supported by this\n  fix. This allows to set at which level of the r-RESPA\n  integrator the fix is modifying forces. Default is the outermost level.\n  The forces due to this fix are imposed during an energy minimization,\n  invoked by the minimize command.  This fix should only\n  be used with damped dynamics minimizers that allow for\n  non-conservative forces.  See the min_style command\n  for details.\n  ",
    "syntax": "fix ID group-ID viscous gamma keyword values ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  viscous = style name of this fix command\n  gamma = damping coefficient (force/velocity units)\n  zero or more keyword/value pairs may be appended\n  keyword = scale\n    scale values = type ratio\n      type = atom type (1-N)\n      ratio = factor to scale the damping coefficient by\n  \n  \n  ",
    "examples": "fix 1 flow viscous 0.1\n  fix 1 damp viscous 0.5 scale 3 2.5\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix wall/lj93",
    "description": "Bound the simulation domain on one or more of its faces with a flat\n  wall that interacts with the atoms in the group by generating a force\n  on the atom in a direction perpendicular to the wall.  The energy of\n  wall-particle interactions depends on the style.\n  For style wall/lj93, the energy E is given by the 9/3 potential:\n  \n  \\[E = \\epsilon \\left[ \\frac{2}{15} \\left(\\frac{\\sigma}{r}\\right)^{9} -\n                        \\left(\\frac{\\sigma}{r}\\right)^3 \\right]\n                        \\qquad r < r_c\\]\n  For style wall/lj126, the energy E is given by the 12/6 potential:\n  \n  \\[E = 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -\n                        \\left(\\frac{\\sigma}{r}\\right)^6 \\right]\n                        \\qquad r < r_c\\]\n  For style wall/lj1043, the energy E is given by the 10/4/3 potential:\n  \n  \\[E = 2 \\pi \\epsilon \\left[ \\frac{2}{5} \\left(\\frac{\\sigma}{r}\\right)^{10} -\n                        \\left(\\frac{\\sigma}{r}\\right)^4 -\n                        \\frac{\\sqrt(2)\\sigma^3}{3\\left(r+\\left(0.61/\\sqrt(2)\\right)\\sigma\\right)^3}\\right]\n                        \\qquad r < r_c\\]\n  For style wall/colloid, the energy E is given by an integrated form\n  of the pair_style colloid potential:\n  \n  \\[\\begin{split}E = & \\epsilon \\left[ \\frac{\\sigma^{6}}{7560}\n  \\left(\\frac{6R-D}{D^{7}} + \\frac{D+8R}{(D+2R)^{7}} \\right) \\right. \\\\\n   & \\left. - \\frac{1}{6} \\left(\\frac{2R(D+R) + D(D+2R)\n   \\left[ \\ln D - \\ln (D+2R) \\right]}{D(D+2R)} \\right) \\right] \\qquad r < r_c\\end{split}\\]\n  For style wall/harmonic, the energy E is given by a harmonic spring\n  potential:\n  \n  \\[E = \\epsilon \\quad (r - r_c)^2 \\qquad r < r_c\\]\n  For style wall/morse, the energy E is given by a Morse potential:\n  \n  \\[E = D_0 \\left[ e^{- 2 \\alpha (r - r_0)} - 2 e^{- \\alpha (r - r_0)} \\right]\n      \\qquad r < r_c\\]\n  In all cases, r is the distance from the particle to the wall at\n  position coord, and \\(r_c\\) is the cutoff distance at which the\n  particle and wall no longer interact.  The energy of the wall\n  potential is shifted so that the wall-particle interaction energy is\n  0.0 at the cutoff distance.\n  Up to 6 walls or faces can be specified in a single command: xlo,\n  xhi, ylo, yhi, zlo, zhi.  A lo face interacts with\n  particles near the lower side of the simulation box in that dimension.\n  A hi face interacts with particles near the upper side of the\n  simulation box in that dimension.\n  The position of each wall can be specified in one of 3 ways: as the\n  EDGE of the simulation box, as a constant value, or as a variable.  If\n  EDGE is used, then the corresponding boundary of the current\n  simulation box is used.  If a numeric constant is specified then the\n  wall is placed at that position in the appropriate dimension (x, y, or\n  z).  In both the EDGE and constant cases, the wall will never move.\n  If the wall position is a variable, it should be specified as v_name,\n  where name is an equal-style variable name.  In this\n  case the variable is evaluated each timestep and the result becomes\n  the current position of the reflecting wall.  Equal-style variables\n  can specify formulas with various mathematical functions, and include\n  thermo_style command keywords for the simulation\n  box parameters and timestep and elapsed time.  Thus it is easy to\n  specify a time-dependent wall position.  See examples below.\n  For the wall/lj93 and wall/lj126 and wall/lj1043 styles,\n  \\(\\epsilon\\) and \\(\\sigma\\) are the usual Lennard-Jones parameters, which\n  determine the strength and size of the particle as it interacts with\n  the wall.  Epsilon has energy units.  Note that this \\(\\epsilon\\) and\n  \\(\\sigma\\) may be different than any \\(\\epsilon\\) or \\(\\sigma\\) values defined\n  for a pair style that computes particle-particle interactions.\n  The wall/lj93 interaction is derived by integrating over a 3d\n  half-lattice of Lennard-Jones 12/6 particles.  The wall/lj126\n  interaction is effectively a harder, more repulsive wall interaction.\n  The wall/lj1043 interaction is yet a different form of wall\n  interaction, described in Magda et al in (Magda).\n  For the wall/colloid style, R is the radius of the colloid particle,\n  D is the distance from the surface of the colloid particle to the wall\n  (r-R), and \\(\\sigma\\) is the size of a constituent LJ particle\n  inside the colloid particle and wall.  Note that the cutoff distance Rc\n  in this case is the distance from the colloid particle center to the\n  wall.  The prefactor \\(\\epsilon\\) can be thought of as an effective\n  Hamaker constant with energy units for the strength of the colloid-wall\n  interaction.  More specifically, the \\(\\epsilon\\) pre-factor is\n  \\(4\\pi^2 \\rho_{wall} \\rho_{colloid} \\epsilon \\sigma^6\\), where\n  \\(\\epsilon\\) and \\(\\sigma\\) are the LJ parameters for the\n  constituent LJ particles. \\(\\rho_{wall}\\) and \\(\\rho_{colloid}\\)\n  are the number density of the constituent particles, in the wall and\n  colloid respectively, in units of 1/volume.\n  The wall/colloid interaction is derived by integrating over\n  constituent LJ particles of size \\(\\sigma\\) within the colloid particle\n  and a 3d half-lattice of Lennard-Jones 12/6 particles of size \\(\\sigma\\)\n  in the wall.  As mentioned in the preceding paragraph, the density of\n  particles in the wall and colloid can be different, as specified by\n  the \\(\\epsilon\\) pre-factor.\n  For the wall/harmonic style, \\(\\epsilon\\) is effectively the spring\n  constant K, and has units (energy/distance^2).  The input parameter\n  \\(\\sigma\\) is ignored.  The minimum energy position of the harmonic\n  spring is at the cutoff.  This is a repulsive-only spring since the\n  interaction is truncated at the cutoff\n  For the wall/morse style, the three parameters are in this order:\n  \\(D_0\\) the depth of the potential, \\(\\alpha\\) the width parameter, and\n  \\(r_0\\) the location of the minimum.  \\(D_0\\) has energy units, \\(\\alpha\\)\n  inverse distance units, and \\(r_0\\) distance units.\n  For any wall, the \\(\\epsilon\\) and/or \\(\\sigma\\) and/or \\(\\alpha\\) parameter can\n  be specified\n  as an equal-style variable, in which case it should be\n  specified as v_name, where name is the variable name.  As with a\n  variable wall position, the variable is evaluated each timestep and\n  the result becomes the current epsilon or sigma of the wall.\n  Equal-style variables can specify formulas with various mathematical\n  functions, and include thermo_style command\n  keywords for the simulation box parameters and timestep and elapsed\n  time.  Thus it is easy to specify a time-dependent wall interaction.\n  \n  Note\n  For all of the styles, you must insure that r is always > 0 for\n  all particles in the group, or LAMMPS will generate an error.  This\n  means you cannot start your simulation with particles at the wall\n  position coord (r = 0) or with particles on the wrong side of the\n  wall (r < 0).  For the wall/lj93 and wall/lj126 styles, the energy\n  of the wall/particle interaction (and hence the force on the particle)\n  blows up as r -> 0.  The wall/colloid style is even more\n  restrictive, since the energy blows up as D = r-R -> 0.  This means\n  the finite-size particles of radius R must be a distance larger than R\n  from the wall position coord.  The harmonic style is a softer\n  potential and does not blow up as r -> 0, but you must use a large\n  enough \\(\\epsilon\\) that particles always reamin on the correct side of\n  the wall (r > 0).\n  \n  The units keyword determines the meaning of the distance units used\n  to define a wall position, but only when a numeric constant or\n  variable is used.  It is not relevant when EDGE is used to specify a\n  face position.  In the variable case, the variable is assumed to\n  produce a value compatible with the units setting you specify.\n  A box value selects standard distance units as defined by the\n  units command, e.g. Angstroms for units = real or metal.\n  A lattice value means the distance units are in lattice spacings.\n  The lattice command must have been previously used to\n  define the lattice spacings.\n  The fld keyword can be used with a yes setting to invoke the wall\n  constraint before pairwise interactions are computed.  This allows an\n  implicit FLD model using pair_style lubricateU\n  to include the wall force in its calculations.  If the setting is\n  no, wall forces are imposed after pairwise interactions, in the\n  usual manner.\n  The pbc keyword can be used with a yes setting to allow walls to\n  be specified in a periodic dimension.  See the\n  boundary command for options on simulation box\n  boundaries.  The default for pbc is no, which means the system\n  must be non-periodic when using a wall.  But you may wish to use a\n  periodic box.  E.g. to allow some particles to interact with the wall\n  via the fix group-ID, and others to pass through it and wrap around a\n  periodic box.  In this case you should insure that the wall if\n  sufficiently far enough away from the box boundary.  If you do not,\n  then particles may interact with both the wall and with periodic\n  images on the other side of the box, which is probably not what you\n  want.\n  \n  Here are examples of variable definitions that move the wall position\n  in a time-dependent fashion using equal-style\n  variables.  The wall interaction parameters (epsilon,\n  sigma) could be varied with additional variable definitions.\n  variable ramp equal ramp(0,10)\n  fix 1 all wall xlo v_ramp 1.0 1.0 2.5\n  \n  variable linear equal vdisplace(0,20)\n  fix 1 all wall xlo v_linear 1.0 1.0 2.5\n  \n  variable wiggle equal swiggle(0.0,5.0,3.0)\n  fix 1 all wall xlo v_wiggle 1.0 1.0 2.5\n  \n  variable wiggle equal cwiggle(0.0,5.0,3.0)\n  fix 1 all wall xlo v_wiggle 1.0 1.0 2.5\n  \n  \n  The ramp(lo,hi) function adjusts the wall position linearly from lo to\n  hi over the course of a run.  The vdisplace(c0,velocity) function does\n  something similar using the equation position = c0 + velocity*delta,\n  where delta is the elapsed time.\n  The swiggle(c0,A,period) function causes the wall position to\n  oscillate sinusoidally according to this equation, where omega = 2 PI\n  / period:\n  position = c0 + A sin(omega*delta)\n  The cwiggle(c0,A,period) function causes the wall position to\n  oscillate sinusoidally according to this equation, which will have an\n  initial wall velocity of 0.0, and thus may impose a gentler\n  perturbation on the particles:\n  position = c0 + A (1 - cos(omega*delta))\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The fix_modify energy option is supported by this\n  fix to add the energy of interaction between atoms and each wall to\n  the system’s potential energy as part of thermodynamic output.\n  The fix_modify virial option is supported by this\n  fix to add the contribution due to the interaction between\n  atoms and each wall to the system’s virial as part of thermodynamic output. The default is virial no\n  The fix_modify respa option is supported by this\n  fix. This allows to set at which level of the r-RESPA\n  integrator the fix is adding its forces. Default is the outermost level.\n  This fix computes a global scalar energy and a global vector of\n  forces, which can be accessed by various output commands.  Note that the scalar energy is the sum\n  of interactions with all defined walls.  If you want the energy on a\n  per-wall basis, you need to use multiple fix wall commands.  The\n  length of the vector is equal to the number of walls defined by the\n  fix.  Each vector value is the normal force on a specific wall.  Note\n  that an outward force on a wall will be a negative value for lo\n  walls and a positive value for hi walls.  The scalar and vector\n  values calculated by this fix are “extensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  The forces due to this fix are imposed during an energy minimization,\n  invoked by the minimize command.\n  \n  Note\n  If you want the atom/wall interaction energy to be included in\n  the total potential energy of the system (the quantity being\n  minimized), you MUST enable the fix_modify energy\n  option for this fix.\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "fix ID group-ID style face args ... keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  style = wall/lj93 or wall/lj126 or wall/lj1043 or wall/colloid or wall/harmonic or wall/morse\n  one or more face/arg pairs may be appended\n  face = xlo or xhi or ylo or yhi or zlo or zhi\n  args for styles lj93 or lj126 or lj1043 or colloid or harmonic\n  args = coord epsilon sigma cutoff\n  coord = position of wall = EDGE or constant or variable\n    EDGE = current lo or hi edge of simulation box\n    constant = number like 0.0 or -30.0 (distance units)\n    variable = equal-style variable like v_x or v_wiggle\n  epsilon = strength factor for wall-particle interaction (energy or energy/distance^2 units)\n    epsilon can be a variable (see below)\n  sigma = size factor for wall-particle interaction (distance units)\n    sigma can be a variable (see below)\n  cutoff = distance from wall at which wall-particle interaction is cut off (distance units)\n  \n  args for style morse\n  args = coord D_0 alpha r_0 cutoff\n  coord = position of wall = EDGE or constant or variable\n    EDGE = current lo or hi edge of simulation box\n    constant = number like 0.0 or -30.0 (distance units)\n    variable = equal-style variable like v_x or v_wiggle\n  D_0 = depth of the potential (energy units)\n    D_0 can be a variable (see below)\n  alpha = width factor for wall-particle interaction (1/distance units)\n    alpha can be a variable (see below)\n  r_0 = distance of the potential minimum from the face of region (distance units)\n    r_0 can be a variable (see below)\n  cutoff = distance from wall at which wall-particle interaction is cut off (distance units)\n  \n  zero or more keyword/value pairs may be appended\n  keyword = units or fld\n  units value = lattice or box\n    lattice = the wall position is defined in lattice units\n    box = the wall position is defined in simulation box units\n  fld value = yes or no\n    yes = invoke the wall constraint to be compatible with implicit FLD\n    no = invoke the wall constraint in the normal way\n  pbc value = yes or no\n    yes = allow periodic boundary in a wall dimension\n    no = require non-perioidic boundaries in any wall dimension\n  \n  \n  ",
    "examples": "fix wallhi all wall/lj93 xlo -1.0 1.0 1.0 2.5 units box\n  fix wallhi all wall/lj93 xhi EDGE 1.0 1.0 2.5\n  fix wallhi all wall/morse xhi EDGE 1.0 1.0 1.0 2.5 units box\n  fix wallhi all wall/lj126 v_wiggle 23.2 1.0 1.0 2.5\n  fix zwalls all wall/colloid zlo 0.0 1.0 1.0 0.858 zhi 40.0 1.0 1.0 0.858\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix wall/body/polygon",
    "description": "This fix is for use with 2d models of body particles of style\n  rounded/polygon.  It bounds the simulation domain with wall(s).  All\n  particles in the group interact with the wall when they are close\n  enough to touch it.  The nature of the interaction between the wall\n  and the polygon particles is the same as that between the polygon\n  particles themselves, which is similar to a Hookean potential.  See\n  the Howto body doc page for more details on using\n  body particles.\n  The parameters k_n, c_n, c_t have the same meaning and units as\n  those specified with the pair_style body/rounded/polygon command.\n  The wallstyle can be planar or cylindrical.  The 2 planar options\n  specify a pair of walls in a dimension.  Wall positions are given by\n  lo and hi.  Either of the values can be specified as NULL if a\n  single wall is desired.  For a zcylinder wallstyle, the cylinder’s\n  axis is at x = y = 0.0, and the radius of the cylinder is specified.\n  Optionally, the wall can be moving, if the wiggle keyword is\n  appended.\n  For the wiggle keyword, the wall oscillates sinusoidally, similar to\n  the oscillations of particles which can be specified by the fix move command.  This is useful in packing simulations of\n  particles.  The arguments to the wiggle keyword specify a dimension\n  for the motion, as well as it’s amplitude and period.  Note that\n  if the dimension is in the plane of the wall, this is effectively a\n  shearing motion.  If the dimension is perpendicular to the wall, it is\n  more of a shaking motion.  A zcylinder wall can only be wiggled in\n  the z dimension.\n  Each timestep, the position of a wiggled wall in the appropriate dim\n  is set according to this equation:\n  position = coord + A - A cos (omega * delta)\n  where coord is the specified initial position of the wall, A is\n  the amplitude, omega is 2 PI / period, and delta is the time\n  elapsed since the fix was specified.  The velocity of the wall is set\n  to the derivative of this expression.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  None of the fix_modify options are relevant to this\n  fix.  No global or per-atom quantities are stored by this fix for\n  access by various output commands.  No parameter\n  of this fix can be used with the start/stop keywords of the\n  run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID wall/body/polygon k_n c_n c_t wallstyle args keyword values ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  wall/body/polygon = style name of this fix command\n  k_n = normal repulsion strength (force/distance or pressure units)\n  c_n = normal damping coefficient (force/distance or pressure units)\n  c_t = tangential damping coefficient (force/distance or pressure units)\n  wallstyle = xplane or yplane or zplane or zcylinder\n  args = list of arguments for a particular style\n  xplane or yplane args = lo hi\n    lo,hi = position of lower and upper plane (distance units), either can be NULL)\n  zcylinder args = radius\n    radius = cylinder radius (distance units)\n  \n  zero or more keyword/value pairs may be appended to args\n  keyword = wiggle\n  wiggle values = dim amplitude period\n    dim = x or y or z\n    amplitude = size of oscillation (distance units)\n    period = time of oscillation (time units)\n  \n  \n  ",
    "examples": "fix 1 all wall/body/polygon 1000.0 20.0 5.0 xplane -10.0 10.0\n  \n  \n  ",
    "restrictions": "This fix is part of the BODY package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  Any dimension (xy) that has a wall must be non-periodic.\n  "
},
{
    "command": "fix wall/body/polyhedron",
    "description": "This fix is for use with 3d models of body particles of style\n  rounded/polyhedron.  It bounds the simulation domain with wall(s).\n  All particles in the group interact with the wall when they are close\n  enough to touch it.  The nature of the interaction between the wall\n  and the polygon particles is the same as that between the polygon\n  particles themselves, which is similar to a Hookean potential.  See\n  the Howto body doc page for more details on using\n  body particles.\n  The parameters k_n, c_n, c_t have the same meaning and units as\n  those specified with the pair_style body/rounded/polyhedron command.\n  The wallstyle can be planar or cylindrical.  The 3 planar options\n  specify a pair of walls in a dimension.  Wall positions are given by\n  lo and hi.  Either of the values can be specified as NULL if a\n  single wall is desired.  For a zcylinder wallstyle, the cylinder’s\n  axis is at x = y = 0.0, and the radius of the cylinder is specified.\n  Optionally, the wall can be moving, if the wiggle keyword is appended.\n  For the wiggle keyword, the wall oscillates sinusoidally, similar to\n  the oscillations of particles which can be specified by the fix move command.  This is useful in packing simulations of\n  particles.  The arguments to the wiggle keyword specify a dimension\n  for the motion, as well as it’s amplitude and period.  Note that\n  if the dimension is in the plane of the wall, this is effectively a\n  shearing motion.  If the dimension is perpendicular to the wall, it is\n  more of a shaking motion.  A zcylinder wall can only be wiggled in\n  the z dimension.\n  Each timestep, the position of a wiggled wall in the appropriate dim\n  is set according to this equation:\n  position = coord + A - A cos (omega * delta)\n  where coord is the specified initial position of the wall, A is\n  the amplitude, omega is 2 PI / period, and delta is the time\n  elapsed since the fix was specified.  The velocity of the wall is set\n  to the derivative of this expression.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  None of the fix_modify options are relevant to this\n  fix.  No global or per-atom quantities are stored by this fix for\n  access by various output commands.  No parameter\n  of this fix can be used with the start/stop keywords of the\n  run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID wall/body/polyhedron k_n c_n c_t wallstyle args keyword values ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  wall/body/polyhedron = style name of this fix command\n  k_n = normal repulsion strength (force/distance units or pressure units - see discussion below)\n  c_n = normal damping coefficient (force/distance units or pressure units - see discussion below)\n  c_t = tangential damping coefficient (force/distance units or pressure units - see discussion below)\n  wallstyle = xplane or yplane or zplane or zcylinder\n  args = list of arguments for a particular style\n  xplane or yplane args = lo hi\n    lo,hi = position of lower and upper plane (distance units), either can be NULL)\n  zcylinder args = radius\n    radius = cylinder radius (distance units)\n  \n  zero or more keyword/value pairs may be appended to args\n  keyword = wiggle\n  wiggle values = dim amplitude period\n    dim = x or y or z\n    amplitude = size of oscillation (distance units)\n    period = time of oscillation (time units)\n  \n  \n  ",
    "examples": "fix 1 all wall/body/polyhedron 1000.0 20.0 5.0 xplane -10.0 10.0\n  \n  \n  ",
    "restrictions": "This fix is part of the BODY package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  Any dimension (xyz) that has a wall must be non-periodic.\n  "
},
{
    "command": "fix wall/ees",
    "description": "Fix wall/ees bounds the simulation domain on one or more of its\n  faces with a flat wall that interacts with the ellipsoidal atoms in the\n  group by generating a force on the atom in a direction perpendicular to\n  the wall and a torque parallel with the wall.  The energy of\n  wall-particle interactions E is given by:\n  \n  \\[E = \\epsilon \\left[ \\frac{2  \\sigma_{LJ}^{12} \\left(7 r^5+14 r^3 \\sigma_{n}^2+3 r \\sigma_{n}^4\\right) }{945 \\left(r^2-\\sigma_{n}^2\\right)^7} -\\frac{ \\sigma_{LJ}^6 \\left(2 r \\sigma_{n}^3+\\sigma_{n}^2 \\left(r^2-\\sigma_{n}^2\\right)\\log{ \\left[\\frac{r-\\sigma_{n}}{r+\\sigma_{n}}\\right]}\\right) }{12 \\sigma_{n}^5 \\left(r^2-\\sigma_{n}^2\\right)} \\right]\\qquad \\sigma_n < r < r_c\\]\n  Introduced by Babadi and Ejtehadi in (Babadi). Here,\n  r is the distance from the particle to the wall at position coord,\n  and Rc is the cutoff distance at which the particle and wall no\n  longer interact. Also, \\(\\sigma_n\\) is the distance between center of\n  ellipsoid and the nearest point of its surface to the wall as shown below.\n  \n  Details of using this command and specifications are the same as\n  fix/wall command. You can also find an example in USER/ees/ under\n  examples/ directory.\n  The prefactor \\(\\epsilon\\) can be thought of as an\n  effective Hamaker constant with energy units for the strength of the\n  ellipsoid-wall interaction.  More specifically, the \\(\\epsilon\\)\n  pre-factor is\n  \n  \\[8 \\pi^2 \\quad \\rho_{wall} \\quad \\rho_{ellipsoid} \\quad \\epsilon \\quad \\sigma_a \\quad \\sigma_b \\quad \\sigma_c\\]\n  where \\(\\epsilon\\) is the LJ energy parameter for the constituent LJ\n  particles and \\(\\sigma_a\\), \\(\\sigma_b\\), and \\(\\sigma_c\\)\n  are the radii of the ellipsoidal particles. \\(\\rho_{wall}\\) and\n  \\(\\rho_{ellipsoid}\\) are the number density of the constituent\n  particles, in the wall and ellipsoid respectively, in units of 1/volume.\n  \n  Note\n  You must insure that r is always bigger than \\(\\sigma_n\\) for\n  all particles in the group, or LAMMPS will generate an error.  This\n  means you cannot start your simulation with particles touching the wall\n  position coord (\\(r = \\sigma_n\\)) or with particles penetrating\n  the wall (\\(0 =< r < \\sigma_n\\)) or with particles on the wrong\n  side of the wall (\\(r < 0\\)).\n  \n  Fix wall/region/ees treats the surface of the geometric region defined\n  by the region-ID as a bounding wall which interacts with nearby\n  ellipsoidal particles according to the EES potential introduced above.\n  Other details of this command are the same as for the fix wall/region command.  One may also find an example\n  of using this fix in the examples/USER/misc/ees/ directory.\n  ",
    "syntax": "fix ID group-ID style args\n  \n  \n  \n  ID, group-ID are documented in fix command\n  style = wall/ees or wall/region/ees\n  args for style wall/ees: one or more face parameters groups may be appended\n  face = xlo or xhi or ylo or yhi or zlo or zhi\n  parameters = coord epsilon sigma cutoff\n    coord = position of wall = EDGE or constant or variable\n      EDGE = current lo or hi edge of simulation box\n      constant = number like 0.0 or -30.0 (distance units)\n      variable = equal-style variable like v_x or v_wiggle\n    epsilon = strength factor for wall-particle interaction (energy or energy/distance^2 units)\n      epsilon can be a variable (see below)\n    sigma = size factor for wall-particle interaction (distance units)\n      sigma can be a variable (see below)\n    cutoff = distance from wall at which wall-particle interaction is cut off (distance units)\n  args for style wall/region/ees: region-ID epsilon sigma cutoff\n    region-ID = region whose boundary will act as wall\n    epsilon = strength factor for wall-particle interaction (energy or energy/distance^2 units)\n    sigma = size factor for wall-particle interaction (distance units)\n    cutoff = distance from wall at which wall-particle interaction is cut off (distance units)\n  \n  \n  ",
    "examples": "fix wallhi all wall/ees xlo -1.0 1.0 1.0 2.5 units box\n  fix wallhi all wall/ees xhi EDGE 1.0 1.0 2.5\n  fix wallhi all wall/ees v_wiggle 23.2 1.0 1.0 2.5\n  fix zwalls all wall/ees zlo 0.0 1.0 1.0 0.858 zhi 40.0 1.0 1.0 0.858\n  \n  fix ees_cube all wall/region/ees myCube 1.0 1.0 2.5\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  This fix requires that atoms be ellipsoids as defined by the\n  atom_style ellipsoid command.\n  "
},
{
    "command": "fix wall/gran",
    "description": "Bound the simulation domain of a granular system with a frictional\n  wall.  All particles in the group interact with the wall when they are\n  close enough to touch it.\n  The nature of the wall/particle interactions are determined by the\n  fstyle setting.  It can be any of the styles defined by the\n  pair_style gran/* or the more general\n  pair_style granular commands.  Currently the\n  options are hooke, hooke/history, or hertz/history for the\n  former, and granular with all the possible options of the associated\n  pair_coeff command for the latter.  The equation for the force\n  between the wall and particles touching it is the same as the\n  corresponding equation on the pair_style gran/* and\n  pair_style granular doc pages, in the limit of\n  one of the two particles going to infinite radius and mass (flat wall).\n  Specifically, delta = radius - r = overlap of particle with wall, m_eff\n  = mass of particle, and the effective radius of contact = RiRj/Ri+Rj is\n  set to the radius of the particle.\n  The parameters Kn, Kt, gamma_n, gamma_t, xmu and dampflag\n  have the same meaning and units as those specified with the\n  pair_style gran/* commands.  This means a NULL can be\n  used for either Kt or gamma_t as described on that page.  If a\n  NULL is used for Kt, then a default value is used where Kt = 2/7\n  Kn.  If a NULL is used for gamma_t, then a default value is used\n  where gamma_t = 1/2 gamma_n.\n  All the model choices for cohesion, tangential friction, rolling\n  friction and twisting friction supported by the pair_style granular through its pair_coeff command are also\n  supported for walls. These are discussed in greater detail on the doc\n  page for pair_style granular.\n  Note that you can choose a different force styles and/or different\n  values for the wall/particle coefficients than for particle/particle\n  interactions.  E.g. if you wish to model the wall as a different\n  material.\n  \n  Note\n  As discussed on the doc page for pair_style gran/*,\n  versions of LAMMPS before 9Jan09 used a\n  different equation for Hertzian interactions.  This means Hertizian\n  wall/particle interactions have also changed.  They now include a\n  sqrt(radius) term which was not present before.  Also the previous\n  versions used Kn and Kt from the pairwise interaction and hardwired\n  dampflag to 1, rather than letting them be specified directly.  This\n  means you can set the values of the wall/particle coefficients\n  appropriately in the current code to reproduce the results of a\n  previous Hertzian monodisperse calculation.  For example, for the\n  common case of a monodisperse system with particles of diameter 1, Kn,\n  Kt, gamma_n, and gamma_s should be set sqrt(2.0) larger than they were\n  previously.\n  \n  The effective mass m_eff in the formulas listed on the pair_style granular doc page is the mass of the particle for\n  particle/wall interactions (mass of wall is infinite).  If the\n  particle is part of a rigid body, its mass is replaced by the mass of\n  the rigid body in those formulas.  This is determined by searching for\n  a fix rigid command (or its variants).\n  The wallstyle can be planar or cylindrical.  The 3 planar options\n  specify a pair of walls in a dimension.  Wall positions are given by\n  lo and hi.  Either of the values can be specified as NULL if a\n  single wall is desired.  For a zcylinder wallstyle, the cylinder’s\n  axis is at x = y = 0.0, and the radius of the cylinder is specified.\n  Optionally, the wall can be moving, if the wiggle or shear\n  keywords are appended.  Both keywords cannot be used together.\n  For the wiggle keyword, the wall oscillates sinusoidally, similar to\n  the oscillations of particles which can be specified by the fix move command.  This is useful in packing simulations of\n  granular particles.  The arguments to the wiggle keyword specify a\n  dimension for the motion, as well as it’s amplitude and period.\n  Note that if the dimension is in the plane of the wall, this is\n  effectively a shearing motion.  If the dimension is perpendicular to\n  the wall, it is more of a shaking motion.  A zcylinder wall can only\n  be wiggled in the z dimension.\n  Each timestep, the position of a wiggled wall in the appropriate dim\n  is set according to this equation:\n  position = coord + A - A cos (omega * delta)\n  where coord is the specified initial position of the wall, A is\n  the amplitude, omega is 2 PI / period, and delta is the time\n  elapsed since the fix was specified.  The velocity of the wall is set\n  to the derivative of this expression.\n  For the shear keyword, the wall moves continuously in the specified\n  dimension with velocity vshear.  The dimension must be tangential to\n  walls with a planar wallstyle, e.g. in the y or z directions for\n  an xplane wall.  For zcylinder walls, a dimension of z means the\n  cylinder is moving in the z-direction along it’s axis.  A dimension of\n  x or y means the cylinder is spinning around the z-axis, either in\n  the clockwise direction for vshear > 0 or counter-clockwise for\n  vshear < 0.  In this case, vshear is the tangential velocity of\n  the wall at whatever radius has been defined.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  This fix writes the shear friction state of atoms interacting with the\n  wall to binary restart files, so that a simulation can\n  continue correctly if granular potentials with shear “history” effects\n  are being used.  See the read_restart command for\n  info on how to re-specify a fix in an input script that reads a\n  restart file, so that the operation of the fix continues in an\n  uninterrupted fashion.\n  None of the fix_modify options are relevant to this\n  fix.  No global or per-atom quantities are stored by this fix for\n  access by various output commands.  No parameter\n  of this fix can be used with the start/stop keywords of the\n  run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID wall/gran fstyle fstyle_params wallstyle args keyword values ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  wall/gran = style name of this fix command\n  fstyle = style of force interactions between particles and wall\n  possible choices: hooke, hooke/history, hertz/history, granular\n  \n  \n  \n  fstyle_params = parameters associated with force interaction style\n  For hooke, hooke/history, and hertz/history, fstyle_params are:\n        Kn = elastic constant for normal particle repulsion (force/distance units or pressure units - see discussion below)\n        Kt = elastic constant for tangential contact (force/distance units or pressure units - see discussion below)\n        gamma_n = damping coefficient for collisions in normal direction (1/time units or 1/time-distance units - see discussion below)\n        gamma_t = damping coefficient for collisions in tangential direction (1/time units or 1/time-distance units - see discussion below)\n        xmu = static yield criterion (unitless value between 0.0 and 1.0e4)\n        dampflag = 0 or 1 if tangential damping force is excluded or included\n  For granular, fstyle_params are set using the same syntax as for the pair_coeff command of pair_style granular\n  \n  wallstyle = xplane or yplane or zplane or zcylinder\n  args = list of arguments for a particular style\n  xplane or yplane or zplane args = lo hi\n    lo,hi = position of lower and upper plane (distance units), either can be NULL)\n  zcylinder args = radius\n    radius = cylinder radius (distance units)\n  \n  zero or more keyword/value pairs may be appended to args\n  keyword = wiggle or shear\n  wiggle values = dim amplitude period\n    dim = x or y or z\n    amplitude = size of oscillation (distance units)\n    period = time of oscillation (time units)\n  shear values = dim vshear\n    dim = x or y or z\n    vshear = magnitude of shear velocity (velocity units)\n  \n  \n  ",
    "examples": "fix 1 all wall/gran hooke  200000.0 NULL 50.0 NULL 0.5 0 xplane -10.0 10.0\n  fix 1 all wall/gran hooke/history 200000.0 NULL 50.0 NULL 0.5 0 zplane 0.0 NULL\n  fix 2 all wall/gran hooke 100000.0 20000.0 50.0 30.0 0.5 1 zcylinder 15.0 wiggle z 3.0 2.0\n  fix 3 all wall/gran/region granular hooke 1000.0 50.0 tangential linear_nohistory 1.0 0.4 damping velocity region myBox\n  fix 4 all wall/gran/region granular jkr 1e5 1500.0 0.3 10.0 tangential mindlin NULL 1.0 0.5 rolling sds 500.0 200.0 0.5 twisting marshall region myCone\n  fix 5 all wall/gran/region granular dmt 1e5 0.2 0.3 10.0 tangential mindlin NULL 1.0 0.5 rolling sds 500.0 200.0 0.5 twisting marshall damping tsuji region myCone\n  \n  \n  ",
    "restrictions": "This fix is part of the GRANULAR package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  Any dimension (xyz) that has a granular wall must be non-periodic.\n  "
},
{
    "command": "fix wall/gran/region",
    "description": "Treat the surface of the geometric region defined by the region-ID\n  as a bounding frictional wall which interacts with nearby finite-size\n  granular particles when they are close enough to touch the wall.  See\n  the fix wall/region and fix wall/gran commands for related kinds of walls for\n  non-granular particles and simpler wall geometries, respectively.\n  Here are snapshots of example models using this command.\n  Corresponding input scripts can be found in examples/granregion.\n  Click on the images to see a bigger picture.  Movies of these\n  simulations are here on the Movies page of the LAMMPS\n  web site.\n  \n  \n  \n  The distance between a particle and the region boundary is the\n  distance to the nearest point on the region surface.  The force the\n  wall exerts on the particle is along the direction between that point\n  and the particle center, which is the direction normal to the surface\n  at that point.  Note that if the region surface is comprised of\n  multiple “faces”, then each face can exert a force on the particle if\n  it is close enough.  E.g. for region_style block, a\n  particle in the interior, near a corner of the block, could feel wall\n  forces from 1, 2, or 3 faces of the block.\n  Regions are defined using the region command.  Note that\n  the region volume can be interior or exterior to the bounding surface,\n  which will determine in which direction the surface interacts with\n  particles, i.e. the direction of the surface normal. The exception to\n  this is if one or more open options are specified for the region\n  command, in which case particles interact with both the interior and\n  exterior surfaces of regions.\n  Regions can either be primitive shapes (block, sphere, cylinder, etc)\n  or combinations of primitive shapes specified via the union or\n  intersect region styles.  These latter styles can be used to\n  construct particle containers with complex shapes.\n  Regions can also move dynamically via the region command\n  keywords (move) and rotate, or change their shape by use of variables\n  as inputs to the region command.  If such a region is used\n  with this fix, then the region surface will move in time in the\n  corresponding manner.\n  \n  Note\n  As discussed on the region command doc page,\n  regions in LAMMPS do not get wrapped across periodic boundaries.  It\n  is up to you to ensure that the region location with respect to\n  periodic or non-periodic boundaries is specified appropriately via the\n  region and boundary commands when using\n  a region as a wall that bounds particle motion.\n  \n  \n  Note\n  For primitive regions with sharp corners and/or edges (e.g. a\n  block or cylinder), wall/particle forces are computed accurately for\n  both interior and exterior regions.  For union and intersect\n  regions, additional sharp corners and edges may be present due to the\n  intersection of the surfaces of 2 or more primitive volumes.  These\n  corners and edges can be of two types: concave or convex.  Concave\n  points/edges are like the corners of a cube as seen by particles in\n  the interior of a cube.  Wall/particle forces around these features\n  are computed correctly.  Convex points/edges are like the corners of a\n  cube as seen by particles exterior to the cube, i.e. the points jut\n  into the volume where particles are present.  LAMMPS does NOT compute\n  the location of these convex points directly, and hence wall/particle\n  forces in the cutoff volume around these points suffer from\n  inaccuracies.  The basic problem is that the outward normal of the\n  surface is not continuous at these points.  This can cause particles\n  to feel no force (they don’t “see” the wall) when in one location,\n  then move a distance epsilon, and suddenly feel a large force because\n  they now “see” the wall.  In a worst-case scenario, this can blow\n  particles out of the simulation box.  Thus, as a general rule you\n  should not use the fix wall/gran/region command with union or\n  interesect regions that have convex points or edges resulting from\n  the union/intersection (convex points/edges in the union/intersection\n  due to a single sub-region are still OK).\n  \n  \n  Note\n  Similarly, you should not define union or intersert regions\n  for use with this command that share an overlapping common face that\n  is part of the overall outer boundary (interior boundary is OK), even\n  if the face is smooth.  E.g. two regions of style block in a union\n  region, where the two blocks overlap on one or more of their faces.\n  This is because LAMMPS discards points that are part of multiple\n  sub-regions when calculating wall/particle interactions, to avoid\n  double-counting the interaction.  Having two coincident faces could\n  cause the face to become invisible to the particles.  The solution is\n  to make the two faces differ by epsilon in their position.\n  \n  The nature of the wall/particle interactions are determined by the\n  fstyle setting.  It can be any of the styles defined by the\n  pair_style gran/* or the more general\n  pair_style granular commands.  Currently the\n  options are hooke, hooke/history, or hertz/history for the\n  former, and granular with all the possible options of the associated\n  pair_coeff command for the latter.  The equation for the force\n  between the wall and particles touching it is the same as the\n  corresponding equation on the pair_style gran/* and\n  pair_style granular doc pages, but the effective\n  radius is calculated using the radius of the particle and the radius of\n  curvature of the wall at the contact point.\n  Specifically, delta = radius - r = overlap of particle with wall,\n  m_eff = mass of particle, and RiRj/Ri+Rj is the effective radius, with\n  Rj replaced by the radius of curvature of the wall at the contact\n  point.  The radius of curvature can be negative for a concave wall\n  section, e.g. the interior of cylinder.  For a flat wall, delta =\n  radius - r = overlap of particle with wall, m_eff = mass of particle,\n  and the effective radius of contact is just the radius of the\n  particle.\n  The parameters Kn, Kt, gamma_n, gamma_t, xmu and dampflag\n  have the same meaning and units as those specified with the\n  pair_style gran/* commands.  This means a NULL can be\n  used for either Kt or gamma_t as described on that page.  If a\n  NULL is used for Kt, then a default value is used where Kt = 2/7\n  Kn.  If a NULL is used for gamma_t, then a default value is used\n  where gamma_t = 1/2 gamma_n.\n  All the model choices for cohesion, tangential friction, rolling\n  friction and twisting friction supported by the pair_style granular through its pair_coeff command are also\n  supported for walls. These are discussed in greater detail on the doc\n  page for pair_style granular.\n  Note that you can choose a different force styles and/or different\n  values for the 6 wall/particle coefficients than for particle/particle\n  interactions.  E.g. if you wish to model the wall as a different\n  material.\n  Restart, fix_modify, output, run start/stop, minimize info:\n  Similar to fix wall/gran command, this fix writes\n  the shear friction state of atoms interacting with the wall to binary restart files, so that a simulation can continue\n  correctly if granular potentials with shear “history” effects are\n  being used.  This fix also includes info about a moving region in the\n  restart file.  See the read_restart command for\n  info on how to re-specify a fix in an input script that reads a\n  restart file, so that the operation of the fix continues in an\n  uninterrupted fashion.\n  \n  Note\n  Information about region definitions is NOT included in restart\n  files, as discussed on the read_restart doc page.\n  So you must re-define your region and if it is a moving region, define\n  its motion attributes in a way that is consistent with the simulation\n  that wrote the restart file.  In particular, if you want to change the\n  region motion attributes (e.g. its velocity), then you should ensure\n  the position/orientation of the region at the initial restart timestep\n  is the same as it was on the timestep the restart file was written.\n  If this is not possible, you may need to ignore info in the restart\n  file by defining a new fix wall/gran/region command in your restart\n  script, e.g. with a different fix ID.  Or if you want to keep the\n  shear history info but discard the region motion information, you can\n  use the same fix ID for fix wall/gran/region, but assign it a region\n  with a different region ID.\n  \n  None of the fix_modify options are relevant to this\n  fix.  No global or per-atom quantities are stored by this fix for\n  access by various output commands.  No parameter\n  of this fix can be used with the start/stop keywords of the\n  run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID wall/gran/region fstyle fstyle_params wallstyle regionID\n  \n  \n  \n  ID, group-ID are documented in fix command\n  wall/region = style name of this fix command\n  fstyle = style of force interactions between particles and wall\n  possible choices: hooke, hooke/history, hertz/history, granular\n  \n  \n  \n  fstyle_params = parameters associated with force interaction style\n  For hooke, hooke/history, and hertz/history, fstyle_params are:\n        Kn = elastic constant for normal particle repulsion (force/distance units or pressure units - see discussion below)\n        Kt = elastic constant for tangential contact (force/distance units or pressure units - see discussion below)\n        gamma_n = damping coefficient for collisions in normal direction (1/time units or 1/time-distance units - see discussion below)\n        gamma_t = damping coefficient for collisions in tangential direction (1/time units or 1/time-distance units - see discussion below)\n        xmu = static yield criterion (unitless value between 0.0 and 1.0e4)\n        dampflag = 0 or 1 if tangential damping force is excluded or included\n  For granular, fstyle_params are set using the same syntax as for the pair_coeff command of pair_style granular\n  \n  wallstyle = region (see fix wall/gran for options for other kinds of walls)\n  region-ID = region whose boundary will act as wall\n  \n  ",
    "examples": "fix wall all wall/gran/region hooke/history 1000.0 200.0 200.0 100.0 0.5 1 region myCone\n  fix 3 all wall/gran/region granular hooke 1000.0 50.0 tangential linear_nohistory 1.0 0.4 damping velocity region myBox\n  fix 4 all wall/gran/region granular jkr 1e5 1500.0 0.3 10.0 tangential mindlin NULL 1.0 0.5 rolling sds 500.0 200.0 0.5 twisting marshall region myCone\n  fix 5 all wall/gran/region granular dmt 1e5 0.2 0.3 10.0 tangential mindlin NULL 1.0 0.5 rolling sds 500.0 200.0 0.5 twisting marshall damping tsuji region myCone\n  \n  \n  ",
    "restrictions": "This fix is part of the GRANULAR package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "fix wall/piston",
    "description": "Bound the simulation with a moving wall which reflect particles in the\n  specified group and drive the system with an effective infinite-mass\n  piston capable of driving shock waves.\n  A momentum mirror technique is used, which means that if an atom (or\n  the wall) moves such that an atom is outside the wall on a timestep by\n  a distance delta (e.g. due to fix nve), then it is put\n  back inside the face by the same delta, and the velocity relative to\n  the moving wall is flipped in z.  For instance, a stationary particle\n  hit with a piston wall with velocity vz, will end the timestep with a\n  velocity of 2*vz.\n  Currently the face keyword can only be zlo.  This creates a piston\n  moving in the positive z direction.  Particles with z coordinate less\n  than the wall position are reflected to a z coordinate greater than\n  the wall position.  If the piston velocity is vpz and the particle\n  velocity before reflection is vzi, the particle velocity after\n  reflection is -vzi + 2*vpz.\n  The initial position of the wall can be specified by the pos keyword.\n  The final velocity of the wall can be specified by the vel keyword\n  The ramp keyword will cause the wall/piston to adjust the velocity\n  linearly from zero velocity to vel over the course of the run. If\n  the ramp keyword is omitted then the wall/piston moves at a constant\n  velocity defined by vel.\n  The temp keyword will cause the region immediately in front of the\n  wall/piston to be thermostatted with a Langevin thermostat.  This\n  region moves with the piston.  The damping and kicking are measured in\n  the reference frame of the piston.  So, a temperature of zero would\n  mean all particles were moving at exactly the speed of the\n  wall/piston.\n  The units keyword determines the meaning of the distance units used\n  to define a wall position, but only when a numeric constant is used.\n  A box value selects standard distance units as defined by the\n  units command, e.g. Angstroms for units = real or metal.\n  A lattice value means the distance units are in lattice spacings.\n  The lattice command must have been previously used to\n  define the lattice spacings.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.  No global or per-atom quantities are stored\n  by this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID wall/piston face ... keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  wall/piston = style name of this fix command\n  face = zlo\n  zero or more keyword/value pairs may be appended\n  keyword = pos or vel or ramp or units\n  pos args = z\n    z = z coordinate at which the piston begins (distance units)\n  vel args = vz\n    vz = final velocity of the piston (velocity units)\n  ramp = use a linear velocity ramp from 0 to vz\n  temp args = target damp seed extent\n    target = target velocity for region immediately ahead of the piston\n    damp = damping parameter (time units)\n    seed = random number seed for langevin kicks\n    extent = extent of thermostatted region (distance units)\n  units value = lattice or box\n    lattice = the wall position is defined in lattice units\n    box = the wall position is defined in simulation box units\n  \n  \n  ",
    "examples": "fix xwalls all wall/piston zlo\n  fix walls all wall/piston zlo pos 1.0 vel 10.0 units box\n  fix top all wall/piston zlo vel 10.0 ramp\n  \n  \n  ",
    "restrictions": "This fix style is part of the SHOCK package.  It is only enabled if\n  LAMMPS was built with that package. See the Build package doc page for more info.\n  The face that has the wall/piston must be boundary type ‘s’\n  (shrink-wrapped). The opposing face can be\n  any boundary type other than periodic.\n  A wall/piston should not be used with rigid bodies such as those\n  defined by a “fix rigid” command.  This is because the wall/piston\n  displaces atoms directly rather than exerting a force on them.\n  "
},
{
    "command": "fix wall/reflect",
    "description": "Bound the simulation with one or more walls which reflect particles\n  in the specified group when they attempt to move through them.\n  Reflection means that if an atom moves outside the wall on a timestep\n  by a distance delta (e.g. due to fix nve), then it is\n  put back inside the face by the same delta, and the sign of the\n  corresponding component of its velocity is flipped.\n  When used in conjunction with fix nve and\n  run_style verlet, the resultant time-integration\n  algorithm is equivalent to the primitive splitting algorithm (PSA)\n  described by Bond.  Because each reflection event\n  divides the corresponding timestep asymmetrically, energy conservation\n  is only satisfied to O(dt), rather than to O(dt^2) as it would be for\n  velocity-Verlet integration without reflective walls.\n  Up to 6 walls or faces can be specified in a single command: xlo,\n  xhi, ylo, yhi, zlo, zhi.  A lo face reflects particles\n  that move to a coordinate less than the wall position, back in the\n  hi direction.  A hi face reflects particles that move to a\n  coordinate higher than the wall position, back in the lo direction.\n  The position of each wall can be specified in one of 3 ways: as the\n  EDGE of the simulation box, as a constant value, or as a variable.  If\n  EDGE is used, then the corresponding boundary of the current\n  simulation box is used.  If a numeric constant is specified then the\n  wall is placed at that position in the appropriate dimension (x, y, or\n  z).  In both the EDGE and constant cases, the wall will never move.\n  If the wall position is a variable, it should be specified as v_name,\n  where name is an equal-style variable name.  In this\n  case the variable is evaluated each timestep and the result becomes\n  the current position of the reflecting wall.  Equal-style variables\n  can specify formulas with various mathematical functions, and include\n  thermo_style command keywords for the simulation\n  box parameters and timestep and elapsed time.  Thus it is easy to\n  specify a time-dependent wall position.\n  The units keyword determines the meaning of the distance units used\n  to define a wall position, but only when a numeric constant or\n  variable is used.  It is not relevant when EDGE is used to specify a\n  face position.  In the variable case, the variable is assumed to\n  produce a value compatible with the units setting you specify.\n  A box value selects standard distance units as defined by the\n  units command, e.g. Angstroms for units = real or metal.\n  A lattice value means the distance units are in lattice spacings.\n  The lattice command must have been previously used to\n  define the lattice spacings.\n  \n  Here are examples of variable definitions that move the wall position\n  in a time-dependent fashion using equal-style\n  variables.\n  variable ramp equal ramp(0,10)\n  fix 1 all wall/reflect xlo v_ramp\n  \n  variable linear equal vdisplace(0,20)\n  fix 1 all wall/reflect xlo v_linear\n  \n  variable wiggle equal swiggle(0.0,5.0,3.0)\n  fix 1 all wall/reflect xlo v_wiggle\n  \n  variable wiggle equal cwiggle(0.0,5.0,3.0)\n  fix 1 all wall/reflect xlo v_wiggle\n  \n  \n  The ramp(lo,hi) function adjusts the wall position linearly from lo to\n  hi over the course of a run.  The vdisplace(c0,velocity) function does\n  something similar using the equation position = c0 + velocity*delta,\n  where delta is the elapsed time.\n  The swiggle(c0,A,period) function causes the wall position to\n  oscillate sinusoidally according to this equation, where omega = 2 PI\n  / period:\n  position = c0 + A sin(omega*delta)\n  The cwiggle(c0,A,period) function causes the wall position to\n  oscillate sinusoidally according to this equation, which will have an\n  initial wall velocity of 0.0, and thus may impose a gentler\n  perturbation on the particles:\n  position = c0 + A (1 - cos(omega*delta))\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages\n  doc page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix\n  command-line switch when you invoke LAMMPS, or you can\n  use the suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options are\n  relevant to this fix.  No global or per-atom quantities are stored by\n  this fix for access by various output commands.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during\n  energy minimization.\n  ",
    "syntax": "fix ID group-ID wall/reflect face arg ... keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  wall/reflect = style name of this fix command\n  one or more face/arg pairs may be appended\n  face = xlo or xhi or ylo or yhi or zlo or zhi\n  arg = EDGE or constant or variable\n    EDGE = current lo edge of simulation box\n    constant = number like 0.0 or 30.0 (distance units)\n    variable = equal-style variable like v_x or v_wiggle\n  \n  zero or more keyword/value pairs may be appended\n  keyword = units\n  units value = lattice or box\n    lattice = the wall position is defined in lattice units\n    box = the wall position is defined in simulation box units\n  \n  \n  ",
    "examples": "fix xwalls all wall/reflect xlo EDGE xhi EDGE\n  fix walls all wall/reflect xlo 0.0 ylo 10.0 units box\n  fix top all wall/reflect zhi v_pressdown\n  \n  \n  ",
    "restrictions": "Any dimension (xyz) that has a reflecting wall must be non-periodic.\n  A reflecting wall should not be used with rigid bodies such as those\n  defined by a “fix rigid” command.  This is because the wall/reflect\n  displaces atoms directly rather than exerts a force on them.  For\n  rigid bodies, use a soft wall instead, such as fix wall/lj93.  LAMMPS will flag the use of a rigid fix with fix\n  wall/reflect with a warning, but will not generate an error.\n  "
},
{
    "command": "fix wall/reflect/stochastic",
    "description": "Bound the simulation with one or more walls which reflect particles\n  in the specified group when they attempt to move through them.\n  Reflection means that if an atom moves outside the wall on a timestep\n  (e.g. due to the fix nve command), then it is put back\n  inside the wall with a changed velocity.\n  This fix models treats the wall as a moving solid boundary with a\n  finite temperature, which can exchange energy with particles that\n  collide with it.  This is different than the simpler fix wall/reflect command which models mirror\n  reflection.  For this fix, the post collision velocity of each\n  particle is treated stochastically.  The randomness can come from many\n  sources: thermal motion of the wall atoms, surface roughness, etc.\n  Three stochastic reflection models are currently implemented.\n  For rstyle diffusive, particles are reflected diffusively. Their\n  velocity distribution corresponds to an equilibrium distribution of\n  particles at the wall temperature.  No accommodation coefficients\n  are specified.\n  For rstyle maxwell, particle reflection is Maxwellian which means\n  partially diffusive and partially specular (Maxwell).  A\n  single accommodation coeff is specified which must be between 0.0 and\n  1.0 inclusive.  It determines the fraction of the collision which is\n  diffusive versus specular.  An accommodation coefficient of 1.0 is fully\n  diffusive; a coefficient of 0.0 is fully specular.\n  For rstyle cll, particle collisions are computed by the\n  Cercignani/Lampis model.  See CL and To for details.\n  Three accommodations coefficient are specified.  Each must be between\n  0.0 and 1.0 inclusive.  Two are velocity accommodation coefficients;\n  one is a normal kinetic energy accommodation.  The normal coeff is the\n  one corresponding to the normal of the wall itself.  For example if\n  the wall is ylo or yhi, accomx and accomz are the tangential\n  velocity accommodation coefficients, and accomy is the normal\n  kinetic energy accommodation coefficient.\n  The optional units keyword determines the distance units used to\n  define a wall position.  A box value selects standard distance units\n  as defined by the units command, e.g. Angstroms for units\n  = real or metal.  A lattice value means the distance units are in\n  lattice spacings. The lattice command must have been\n  previously used to define the lattice spacings.\n  ",
    "syntax": "fix ID group-ID wall/reflect/stochastic rstyle seed face args ... keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  wall/reflect/stochastic = style name of this fix command\n  rstyle = diffusive or maxwell or ccl\n  seed = random seed for stochasticity (positive integer)\n  one or more face/args pairs may be appended\n  face = xlo or xhi or ylo or yhi or zlo or zhi\n  args = pos temp velx vely velz accomx accomy accomz\n    pos = EDGE or constant\n      EDGE = current lo or hi edge of simulation box\n      constant = number like 0.0 or 30.0 (distance units)\n    temp = wall temperature (temperature units)\n    velx,vely,velz = wall velocity in x,y,z directions (velocity units)\n    accomx,accomy,accomz = accommodation coeffs in x,y,z directions (unitless)\n      not specified for rstyle = diffusive\n      single accom coeff specified for rstyle maxwell\n      all 3 coeffs specified for rstyle cll\n  \n  \n  \n  zero or more keyword/value pairs may be appended\n  keyword = units\n  units value = lattice or box\n    lattice = the wall position is defined in lattice units\n    box = the wall position is defined in simulation box units\n  \n  \n  ",
    "examples": "fix zwalls all wall/reflect/stochastic diffusive 23424 zlo EDGE 300 0.1 0.1 0 zhi EDGE 200 0.1 0.1 0\n  fix ywalls all wall/reflect/stochastic maxwell 345533 ylo 5.0 300 0.1 0.0 0.0 0.8 yhi 10.0 300 0.1 0.0 0.0 0.8\n  fix xwalls all wall/reflect/stochastic cercignanilampis 2308 xlo 0.0 300 0.0 0.1 0.9 0.8 0.7 xhi EDGE 300 0.0 0.1 0 0.9 0.8 0.7 units box\n  \n  \n  ",
    "restrictions": "This fix has the same limitations as the fix wall/reflect command.  Any dimension (xyz) that\n  has a wall must be non-periodic.  It should not be used with rigid\n  bodies such as those defined by the fix rigid\n  command.  The wall velocity must lie on the same plane as the wall\n  itself.\n  This fix is part of the USER-MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "fix wall/region",
    "description": "Treat the surface of the geometric region defined by the region-ID\n  as a bounding wall which interacts with nearby particles according to\n  the specified style.\n  The distance between a particle and the surface is the distance to the\n  nearest point on the surface and the force the wall exerts on the\n  particle is along the direction between that point and the particle,\n  which is the direction normal to the surface at that point.  Note that\n  if the region surface is comprised of multiple “faces”, then each face\n  can exert a force on the particle if it is close enough.  E.g. for\n  region_style block, a particle in the interior, near a\n  corner of the block, could feel wall forces from 1, 2, or 3 faces of\n  the block.\n  Regions are defined using the region command.  Note that\n  the region volume can be interior or exterior to the bounding surface,\n  which will determine in which direction the surface interacts with\n  particles, i.e. the direction of the surface normal.  The surface of\n  the region only exerts forces on particles “inside” the region; if a\n  particle is “outside” the region it will generate an error, because it\n  has moved through the wall.\n  Regions can either be primitive shapes (block, sphere, cylinder, etc)\n  or combinations of primitive shapes specified via the union or\n  intersect region styles.  These latter styles can be used to\n  construct particle containers with complex shapes.  Regions can also\n  change over time via the region command keywords (move)\n  and rotate.  If such a region is used with this fix, then the of\n  region surface will move over time in the corresponding manner.\n  \n  Note\n  As discussed on the region command doc page,\n  regions in LAMMPS do not get wrapped across periodic boundaries.  It\n  is up to you to insure that periodic or non-periodic boundaries are\n  specified appropriately via the boundary command when\n  using a region as a wall that bounds particle motion.  This also means\n  that if you embed a region in your simulation box and want it to\n  repulse particles from its surface (using the “side out” option in the\n  region command), that its repulsive force will not be\n  felt across a periodic boundary.\n  \n  \n  Note\n  For primitive regions with sharp corners and/or edges (e.g. a\n  block or cylinder), wall/particle forces are computed accurately for\n  both interior and exterior regions.  For union and intersect\n  regions, additional sharp corners and edges may be present due to the\n  intersection of the surfaces of 2 or more primitive volumes.  These\n  corners and edges can be of two types: concave or convex.  Concave\n  points/edges are like the corners of a cube as seen by particles in\n  the interior of a cube.  Wall/particle forces around these features\n  are computed correctly.  Convex points/edges are like the corners of a\n  cube as seen by particles exterior to the cube, i.e. the points jut\n  into the volume where particles are present.  LAMMPS does NOT compute\n  the location of these convex points directly, and hence wall/particle\n  forces in the cutoff volume around these points suffer from\n  inaccuracies.  The basic problem is that the outward normal of the\n  surface is not continuous at these points.  This can cause particles\n  to feel no force (they don’t “see” the wall) when in one location,\n  then move a distance epsilon, and suddenly feel a large force because\n  they now “see” the wall.  In a worst-case scenario, this can blow\n  particles out of the simulation box.  Thus, as a general rule you\n  should not use the fix wall/gran/region command with union or\n  interesect regions that have convex points or edges resulting from\n  the union/intersection (convex points/edges in the union/intersection\n  due to a single sub-region are still OK).\n  \n  \n  Note\n  Similarly, you should not define union or intersert regions\n  for use with this command that share an overlapping common face that\n  is part of the overall outer boundary (interior boundary is OK), even\n  if the face is smooth.  E.g. two regions of style block in a union\n  region, where the two blocks overlap on one or more of their faces.\n  This is because LAMMPS discards points that are part of multiple\n  sub-regions when calculating wall/particle interactions, to avoid\n  double-counting the interaction.  Having two coincident faces could\n  cause the face to become invisible to the particles.  The solution is\n  to make the two faces differ by epsilon in their position.\n  \n  The energy of wall-particle interactions depends on the specified\n  style.\n  For style lj93, the energy E is given by the 9/3 potential:\n  \n  \\[E = \\epsilon \\left[ \\frac{2}{15} \\left(\\frac{\\sigma}{r}\\right)^{9} -\n                        \\left(\\frac{\\sigma}{r}\\right)^3 \\right]\n                        \\qquad r < r_c\\]\n  For style lj126, the energy E is given by the 12/6 potential:\n  \n  \\[E = 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -\n                        \\left(\\frac{\\sigma}{r}\\right)^6 \\right]\n                        \\qquad r < r_c\\]\n  For style wall/lj1043, the energy E is given by the 10/4/3 potential:\n  \n  \\[E = 2 \\pi \\epsilon \\left[ \\frac{2}{5} \\left(\\frac{\\sigma}{r}\\right)^{10} -\n                        \\left(\\frac{\\sigma}{r}\\right)^4 -\n                        \\frac{\\sqrt(2)\\sigma^3}{3\\left(r+\\left(0.61/\\sqrt(2)\\right)\\sigma\\right)^3}\\right]\n                        \\qquad r < r_c\\]\n  For style colloid, the energy E is given by an integrated form of\n  the pair_style colloid potential:\n  \n  \\[\\begin{split}E = & \\epsilon \\left[ \\frac{\\sigma^{6}}{7560}\n  \\left(\\frac{6R-D}{D^{7}} + \\frac{D+8R}{(D+2R)^{7}} \\right) \\right. \\\\\n   & \\left. - \\frac{1}{6} \\left(\\frac{2R(D+R) + D(D+2R)\n   \\left[ \\ln D - \\ln (D+2R) \\right]}{D(D+2R)} \\right) \\right] \\qquad r < r_c\\end{split}\\]\n  For style wall/harmonic, the energy E is given by a harmonic spring\n  potential (the distance parameter is ignored):\n  \n  \\[E = \\epsilon \\quad (r - r_c)^2 \\qquad r < r_c\\]\n  For style wall/morse, the energy E is given by the Morse potential:\n  \n  \\[E = D_0 \\left[ e^{- 2 \\alpha (r - r_0)} - 2 e^{- \\alpha (r - r_0)} \\right]\n      \\qquad r < r_c\\]\n  Unlike other styles, this requires three parameters (\\(D_0\\),\n  \\(\\alpha\\), and \\(r_0\\) in this order) instead of two like\n  for the other wall styles.\n  In all cases, r is the distance from the particle to the region\n  surface, and Rc is the cutoff distance at which the particle and\n  surface no longer interact.  The cutoff is always the last argument.\n  The energy of the wall potential is shifted so that the wall-particle\n  interaction energy is 0.0 at the cutoff distance.\n  For a full description of these wall styles, see fix_style\n  wall\n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.\n  The fix_modify energy option is supported by this\n  fix to add the energy of interaction between atoms and the wall to the\n  system’s potential energy as part of thermodynamic output.\n  The fix_modify virial option is supported by this\n  fix to add the contribution due to the interaction between\n  atoms and each wall to the system’s virial as part of thermodynamic output. The default is virial no\n  The fix_modify respa option is supported by this\n  fix. This allows to set at which level of the r-RESPA\n  integrator the fix is adding its forces. Default is the outermost level.\n  This fix computes a global scalar energy and a global 3-length vector\n  of forces, which can be accessed by various output commands.  The scalar energy is the sum of energy\n  interactions for all particles interacting with the wall represented\n  by the region surface.  The 3 vector quantities are the x,y,z\n  components of the total force acting on the wall due to the particles.\n  The scalar and vector values calculated by this fix are “extensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.\n  The forces due to this fix are imposed during an energy minimization,\n  invoked by the minimize command.\n  \n  Note\n  If you want the atom/wall interaction energy to be included in\n  the total potential energy of the system (the quantity being\n  minimized), you MUST enable the fix_modify energy\n  option for this fix.\n  \n  ",
    "syntax": "fix ID group-ID wall/region region-ID style args ... cutoff\n  \n  \n  \n  ID, group-ID are documented in fix command\n  wall/region = style name of this fix command\n  region-ID = region whose boundary will act as wall\n  style = lj93 or lj126 or lj1043 or colloid or harmonic or morse\n  args for styles lj93 or lj126 or lj1043 or colloid or harmonic =\n  epsilon = strength factor for wall-particle interaction (energy or energy/distance^2 units)\n  sigma = size factor for wall-particle interaction (distance units)\n  \n  args for style morse =\n  D_0 = depth of the potential (energy units)\n  alpha = width parameter (1/distance units)\n  r_0 = distance of the potential minimum from wall position (distance units)\n  \n  \n  \n  cutoff = distance from wall at which wall-particle interaction is cut off (distance units)\n  \n  ",
    "examples": "fix wall all wall/region mySphere lj93 1.0 1.0 2.5\n  fix wall all wall/region mySphere harmonic 1.0 0.0 2.5\n  fix wall all wall/region box_top morse 1.0 1.0 1.5 3.0\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix wall/srd",
    "description": "Bound the simulation with one or more walls which interact with\n  stochastic reaction dynamics (SRD) particles as slip (smooth) or\n  no-slip (rough) flat surfaces.  The wall interaction is actually\n  invoked via the fix srd command, only on the group of\n  SRD particles it defines, so the group setting for the fix wall/srd\n  command is ignored.\n  A particle/wall collision occurs if an SRD particle moves outside the\n  wall on a timestep.  This alters the position and velocity of the SRD\n  particle and imparts a force to the wall.\n  The collision and Tsrd settings specified via the fix srd command affect the SRD/wall collisions.  A slip\n  setting for the collision keyword means that the tangential\n  component of the SRD particle momentum is preserved.  Thus only a\n  normal force is imparted to the wall.  The normal component of the new\n  SRD velocity is sampled from a Gaussian distribution at temperature\n  Tsrd.\n  For a noslip setting of the collision keyword, both the normal and\n  tangential components of the new SRD velocity are sampled from a\n  Gaussian distribution at temperature Tsrd.  Additionally, a new\n  tangential direction for the SRD velocity is chosen randomly.  This\n  collision style imparts both a normal and tangential force to the\n  wall.\n  Up to 6 walls or faces can be specified in a single command: xlo,\n  xhi, ylo, yhi, zlo, zhi.  A lo face reflects particles\n  that move to a coordinate less than the wall position, back in the\n  hi direction.  A hi face reflects particles that move to a\n  coordinate higher than the wall position, back in the lo direction.\n  The position of each wall can be specified in one of 3 ways: as the\n  EDGE of the simulation box, as a constant value, or as a variable.  If\n  EDGE is used, then the corresponding boundary of the current\n  simulation box is used.  If a numeric constant is specified then the\n  wall is placed at that position in the appropriate dimension (x, y, or\n  z).  In both the EDGE and constant cases, the wall will never move.\n  If the wall position is a variable, it should be specified as v_name,\n  where name is an equal-style variable name.  In this\n  case the variable is evaluated each timestep and the result becomes\n  the current position of the reflecting wall.  Equal-style variables\n  can specify formulas with various mathematical functions, and include\n  thermo_style command keywords for the simulation\n  box parameters and timestep and elapsed time.  Thus it is easy to\n  specify a time-dependent wall position.\n  \n  Note\n  Because the trajectory of the SRD particle is tracked as it\n  collides with the wall, you must insure that r = distance of the\n  particle from the wall, is always > 0 for SRD particles, or LAMMPS\n  will generate an error.  This means you cannot start your simulation\n  with SRD particles at the wall position coord (r = 0) or with\n  particles on the wrong side of the wall (r < 0).\n  \n  \n  Note\n  If you have 2 or more walls that come together at an edge or\n  corner (e.g. walls in the x and y dimensions), then be sure to set the\n  overlap keyword to yes in the fix srd command,\n  since the walls effectively overlap when SRD particles collide with\n  them.  LAMMPS will issue a warning if you do not do this.\n  \n  \n  Note\n  The walls of this fix only interact with SRD particles, as\n  defined by the fix srd command.  If you are simulating\n  a mixture containing other kinds of particles, then you should\n  typically use another wall command to act on the other\n  particles.  Since SRD particles will be colliding both with the walls\n  and the other particles, it is important to insure that the other\n  particle’s finite extent does not overlap an SRD wall.  If you do not\n  do this, you may generate errors when SRD particles end up “inside”\n  another particle or a wall at the beginning of a collision step.\n  \n  The units keyword determines the meaning of the distance units used\n  to define a wall position, but only when a numeric constant is used.\n  It is not relevant when EDGE or a variable is used to specify a face\n  position.\n  A box value selects standard distance units as defined by the\n  units command, e.g. Angstroms for units = real or metal.\n  A lattice value means the distance units are in lattice spacings.\n  The lattice command must have been previously used to\n  define the lattice spacings.\n  \n  Here are examples of variable definitions that move the wall position\n  in a time-dependent fashion using equal-style\n  variables.\n  variable ramp equal ramp(0,10)\n  fix 1 all wall/srd xlo v_ramp\n  \n  variable linear equal vdisplace(0,20)\n  fix 1 all wall/srd xlo v_linear\n  \n  variable wiggle equal swiggle(0.0,5.0,3.0)\n  fix 1 all wall/srd xlo v_wiggle\n  \n  variable wiggle equal cwiggle(0.0,5.0,3.0)\n  fix 1 all wall/srd xlo v_wiggle\n  \n  \n  The ramp(lo,hi) function adjusts the wall position linearly from lo\n  to hi over the course of a run.  The vdisplace(c0,velocity) function\n  does something similar using the equation position = c0 +\n  velocity*delta, where delta is the elapsed time.\n  The swiggle(c0,A,period) function causes the wall position to\n  oscillate sinusoidally according to this equation, where omega = 2 PI\n  / period:\n  position = c0 + A sin(omega*delta)\n  The cwiggle(c0,A,period) function causes the wall position to\n  oscillate sinusoidally according to this equation, which will have an\n  initial wall velocity of 0.0, and thus may impose a gentler\n  perturbation on the particles:\n  position = c0 + A (1 - cos(omega*delta))\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about this fix is written to binary restart files.  None of the fix_modify options\n  are relevant to this fix.\n  This fix computes a global array of values which can be accessed by\n  various output commands.  The number of rows in\n  the array is equal to the number of walls defined by the fix.  The\n  number of columns is 3, for the x,y,z components of force on each\n  wall.\n  Note that an outward normal force on a wall will be a negative value\n  for lo walls and a positive value for hi walls.  The array values\n  calculated by this fix are “extensive”.\n  No parameter of this fix can be used with the start/stop keywords of\n  the run command.  This fix is not invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID wall/srd face arg ... keyword value ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  wall/srd = style name of this fix command\n  one or more face/arg pairs may be appended\n  face = xlo or xhi or ylo or yhi or zlo or zhi\n  xlo,ylo,zlo arg = EDGE or constant or variable\n    EDGE = current lo edge of simulation box\n    constant = number like 0.0 or -30.0 (distance units)\n    variable = equal-style variable like v_x or v_wiggle\n  xhi,yhi,zhi arg = EDGE or constant or variable\n    EDGE = current hi edge of simulation box\n    constant = number like 50.0 or 100.3 (distance units)\n    variable = equal-style variable like v_x or v_wiggle\n  \n  zero or more keyword/value pairs may be appended\n  keyword = units\n  units value = lattice or box\n    lattice = the wall position is defined in lattice units\n    box = the wall position is defined in simulation box units\n  \n  \n  ",
    "examples": "fix xwalls all wall/srd xlo EDGE xhi EDGE\n  fix walls all wall/srd xlo 0.0 ylo 10.0 units box\n  fix top all wall/srd zhi v_pressdown\n  \n  \n  ",
    "restrictions": "Any dimension (xyz) that has an SRD wall must be non-periodic.\n  "
},
{
    "command": "compute temp/ramp",
    "description": "Define a computation that calculates the temperature of a group of\n  atoms, after subtracting out an ramped velocity profile before\n  computing the kinetic energy.  A compute of this style can be used by\n  any command that computes a temperature,\n  e.g. thermo_modify, fix temp/rescale, fix npt, etc.\n  The meaning of the arguments for this command which define the\n  velocity ramp are the same as for the velocity ramp\n  command which was presumably used to impose the velocity.\n  After the ramp velocity has been subtracted from the specified\n  dimension for each atom, the temperature is calculated by the formula\n  KE = dim/2 N k T, where KE = total kinetic energy of the group of\n  atoms (sum of 1/2 m v^2), dim = 2 or 3 = dimensionality of the\n  simulation, N = number of atoms in the group, k = Boltzmann constant,\n  and T = temperature.\n  The units keyword determines the meaning of the distance units used\n  for coordinates (c1,c2) and velocities (vlo,vhi).  A box value\n  selects standard distance units as defined by the units\n  command, e.g. Angstroms for units = real or metal.  A lattice value\n  means the distance units are in lattice spacings; e.g. velocity =\n  lattice spacings / tau.  The lattice command must have\n  been previously used to define the lattice spacing.\n  A kinetic energy tensor, stored as a 6-element vector, is also\n  calculated by this compute for use in the computation of a pressure\n  tensor.  The formula for the components of the tensor is the same as\n  the above formula, except that v^2 is replaced by vx*vy for the xy\n  component, etc.  The 6 components of the vector are ordered xx, yy,\n  zz, xy, xz, yz.\n  The number of atoms contributing to the temperature is assumed to be\n  constant for the duration of the run; use the dynamic option of the\n  compute_modify command if this is not the case.\n  The removal of the ramped velocity component by this fix is\n  essentially computing the temperature after a “bias” has been removed\n  from the velocity of the atoms.  If this compute is used with a fix\n  command that performs thermostatting then this bias will be subtracted\n  from each atom, thermostatting of the remaining thermal velocity will\n  be performed, and the bias will be added back in.  Thermostatting\n  fixes that work in this way include fix nvt, fix temp/rescale, fix temp/berendsen, and fix langevin.\n  This compute subtracts out degrees-of-freedom due to fixes that\n  constrain molecular motion, such as fix shake and\n  fix rigid.  This means the temperature of groups of\n  atoms that include these constraints will be computed correctly.  If\n  needed, the subtracted degrees-of-freedom can be altered using the\n  extra option of the compute_modify command.\n  See the Howto thermostat doc page for a\n  discussion of different ways to compute temperature and perform\n  thermostatting.\n  Output info:\n  This compute calculates a global scalar (the temperature) and a global\n  vector of length 6 (KE tensor), which can be accessed by indices 1-6.\n  These values can be used by any command that uses global scalar or\n  vector values from a compute as input.  See the Howto output doc page for an overview of LAMMPS output\n  options.\n  The scalar value calculated by this compute is “intensive”.  The\n  vector values are “extensive”.\n  The scalar value will be in temperature units.  The\n  vector values will be in energy units.\n  ",
    "syntax": "compute ID group-ID temp/ramp vdim vlo vhi dim clo chi keyword value ...\n  \n  \n  \n  ID, group-ID are documented in compute command\n  temp/ramp = style name of this compute command\n  vdim = vx or vy or vz\n  vlo,vhi = subtract velocities between vlo and vhi (velocity units)\n  dim = x or y or z\n  clo,chi = lower and upper bound of domain to subtract from (distance units)\n  zero or more keyword/value pairs may be appended\n  keyword = units\n  \n  units value = lattice or box\n  ",
    "examples": "compute 2nd middle temp/ramp vx 0 8 y 2 12 units lattice\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix qeq/point",
    "description": "Perform the charge equilibration (QEq) method as described in (Rappe and Goddard) and formulated in (Nakano) (also known\n  as the matrix inversion method) and in (Rick and Stuart) (also\n  known as the extended Lagrangian method) based on the\n  electronegativity equilization principle.\n  These fixes can be used with any pair style in\n  LAMMPS, so long as per-atom charges are defined.  The most typical\n  use-case is in conjunction with a pair style that\n  performs charge equilibration periodically (e.g. every timestep), such\n  as the ReaxFF or Streitz-Mintmire potential.\n  But these fixes can also be used with\n  potentials that normally assume per-atom charges are fixed, e.g. a\n  Buckingham or LJ/Coulombic potential.\n  Because the charge equilibration calculation is effectively\n  independent of the pair style, these fixes can also be used to perform\n  a one-time assignment of charges to atoms.  For example, you could\n  define the QEq fix, perform a zero-timestep run via the run\n  command without any pair style defined which would set per-atom\n  charges (based on the current atom configuration), then remove the fix\n  via the unfix command before performing further dynamics.\n  \n  Note\n  Computing and using charge values different from published\n  values defined for a fixed-charge potential like Buckingham or CHARMM\n  or AMBER, can have a strong effect on energies and forces, and\n  produces a different model than the published versions.\n  \n  \n  Note\n  The fix qeq/comb command must still be used\n  to perform charge equilibration with the COMB potential.  The fix qeq/reax\n  command can be used to perform charge equilibration with the ReaxFF force field, although fix qeq/shielded yields the\n  same results as fix qeq/reax if Nevery, cutoff, and tolerance\n  are the same.  Eventually the fix qeq/reax command will be deprecated.\n  \n  The QEq method minimizes the electrostatic energy of the system (or\n  equalizes the derivative of energy with respect to charge of all the\n  atoms) by adjusting the partial charge on individual atoms based on\n  interactions with their neighbors within cutoff.  It requires a few\n  parameters, in metal units, for each atom type which provided in a\n  file specified by qfile.  The file has the following format\n  1 chi eta gamma zeta qcore\n  2 chi eta gamma zeta qcore\n  ...\n  Ntype chi eta gamma zeta qcore\n  \n  \n  There have to be parameters given for every atom type. Wildcard entries\n  are possible using the same syntax as elsewhere in LAMMPS\n  (i.e., n*m, n*, *m, *). Later entries will overwrite previous ones.\n  Empty lines or any text following the pound sign (#) are ignored.\n  Each line starts with the atom type followed by five parameters.\n  Only a subset of the parameters is used by each QEq style as described\n  below, thus the others can be set to 0.0 if desired, but all five\n  entries per line are required.\n  \n  chi = electronegativity in energy units\n  eta = self-Coulomb potential in energy units\n  gamma = shielded Coulomb constant defined by ReaxFF force field in distance units\n  zeta = Slater type orbital exponent defined by the Streitz-Mintmire potential in reverse distance units\n  qcore = charge of the nucleus defined by the Streitz-Mintmire potential potential in charge units\n  \n  The qeq/point style describes partial charges on atoms as point\n  charges.  Interaction between a pair of charged particles is 1/r,\n  which is the simplest description of the interaction between charges.\n  Only the chi and eta parameters from the qfile file are used.\n  Note that Coulomb catastrophe can occur if repulsion between the pair\n  of charged particles is too weak.  This style solves partial charges\n  on atoms via the matrix inversion method.  A tolerance of 1.0e-6 is\n  usually a good number.\n  The qeq/shielded style describes partial charges on atoms also as\n  point charges, but uses a shielded Coulomb potential to describe the\n  interaction between a pair of charged particles.  Interaction through\n  the shielded Coulomb is given by equation (13) of the ReaxFF force field paper.  The shielding accounts for charge overlap\n  between charged particles at small separation.  This style is the same\n  as fix qeq/reax, and can be used with pair_style reax/c.  Only the chi, eta, and gamma\n  parameters from the qfile file are used. When using the string\n  reax/c as filename, these parameters are extracted directly from\n  an active reax/c pair style.  This style solves partial\n  charges on atoms via the matrix inversion method.  A tolerance of\n  1.0e-6 is usually a good number.\n  The qeq/slater style describes partial charges on atoms as spherical\n  charge densities centered around atoms via the Slater 1s orbital, so\n  that the interaction between a pair of charged particles is the\n  product of two Slater 1s orbitals.  The expression for the Slater\n  1s orbital is given under equation (6) of the\n  Streitz-Mintmire paper.  Only the chi, eta, zeta, and\n  qcore parameters from the qfile file are used. When using the string\n  coul/streitz as filename, these parameters are extracted directly from\n  an active coul/streitz pair style.  This style solves\n  partial charges on atoms via the matrix inversion method.  A tolerance\n  of 1.0e-6 is usually a good number.  Keyword alpha can be used to\n  change the Slater type orbital exponent.\n  The qeq/dynamic style describes partial charges on atoms as point\n  charges that interact through 1/r, but the extended Lagrangian method\n  is used to solve partial charges on atoms.  Only the chi and eta\n  parameters from the qfile file are used.  Note that Coulomb\n  catastrophe can occur if repulsion between the pair of charged\n  particles is too weak.  A tolerance of 1.0e-3 is usually a good\n  number.  Keyword qdamp can be used to change the damping factor, while\n  keyword qstep can be used to change the time step size.\n  The *qeq/fire* style describes the same charge model and charge\n  solver as the qeq/dynamic style, but employs a FIRE minimization\n  algorithm to solve for equilibrium charges.\n  Keyword qdamp can be used to change the damping factor, while\n  keyword qstep can be used to change the time step size.\n  Note that qeq/point, qeq/shielded, and qeq/slater describe\n  different charge models, whereas the matrix inversion method and the\n  extended Lagrangian method (qeq/dynamic and qeq/fire) are\n  different solvers.\n  Note that qeq/point, qeq/dynamic and qeq/fire styles all describe\n  charges as point charges that interact through 1/r relationship, but\n  solve partial charges on atoms using different solvers.  These three\n  styles should yield comparable results if\n  the QEq parameters and Nevery, cutoff, and tolerance are the\n  same.  Style qeq/point is typically faster, qeq/dynamic scales\n  better on larger sizes, and qeq/fire is faster than qeq/dynamic.\n  \n  Note\n  To avoid the evaluation of the derivative of charge with respect\n  to position, which is typically ill-defined, the system should have a\n  zero net charge.\n  \n  \n  Note\n  Developing QEq parameters (chi, eta, gamma, zeta, and qcore) is\n  non-trivial.  Charges on atoms are not guaranteed to equilibrate with\n  arbitrary choices of these parameters.  We do not develop these QEq\n  parameters.  See the examples/qeq directory for some examples.\n  \n  Restart, fix_modify, output, run start/stop, minimize info:\n  No information about these fixes is written to binary restart files.  No global scalar or vector or per-atom\n  quantities are stored by these fixes for access by various output commands.  No parameter of these fixes can be used\n  with the start/stop keywords of the run command.\n  Thexe fixes are invoked during energy minimization.\n  ",
    "syntax": "fix ID group-ID style Nevery cutoff tolerance maxiter qfile keyword ...\n  \n  \n  \n  ID, group-ID are documented in fix command\n  style = qeq/point or qeq/shielded or qeq/slater or qeq/dynamic or qeq/fire\n  Nevery = perform charge equilibration every this many steps\n  cutoff = global cutoff for charge-charge interactions (distance unit)\n  tolerance = precision to which charges will be equilibrated\n  maxiter = maximum iterations to perform charge equilibration\n  qfile = a filename with QEq parameters or coul/streitz or reax/c\n  zero or more keyword/value pairs may be appended\n  keyword = alpha or qdamp or qstep\n  alpha value = Slater type orbital exponent (qeq/slater only)\n  qdamp value = damping factor for damped dynamics charge solver (qeq/dynamic and qeq/fire only)\n  qstep value = time step size for damped dynamics charge solver (qeq/dynamic and qeq/fire only)\n  \n  \n  ",
    "examples": "fix 1 all qeq/point 1 10 1.0e-6 200 param.qeq1\n  fix 1 qeq qeq/shielded 1 8 1.0e-6 100 param.qeq2\n  fix 1 all qeq/slater 5 10 1.0e-6 100 params alpha 0.2\n  fix 1 qeq qeq/dynamic 1 12 1.0e-3 100 my_qeq\n  fix 1 all qeq/fire 1 10 1.0e-3 100 my_qeq qdamp 0.2 qstep 0.1\n  \n  \n  ",
    "restrictions": "These fixes are part of the QEQ package.  They are only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style adp",
    "description": "Style adp computes pairwise interactions for metals and metal alloys\n  using the angular dependent potential (ADP) of (Mishin),\n  which is a generalization of the embedded atom method (EAM) potential.  The LAMMPS implementation is discussed in\n  (Singh).  The total energy Ei of an atom I is given by\n  \n  \\[\\begin{split}E_i            & = F_\\alpha \\left( \\sum_{j\\neq i} \\rho_\\beta (r_{ij}) \\right) + \\frac{1}{2} \\sum_{j\\neq i}\\phi_{\\alpha\\beta}(r_{ij})+ \\frac{1}{2} \\sum_s (\\mu_i^s)^2 + \\frac{1}{2} \\sum_{s,t} (\\lambda_i^{st})^2 - \\frac{1}{6} \\nu_i^2 \\\\\n  \\mu_i^s        & = \\sum_{j\\neq i}u_{\\alpha\\beta}(r_{ij})r_{ij}^s\\\\\n  \\lambda_i^{st} & = \\sum_{j\\neq i}w_{\\alpha\\beta}(r_{ij})r_{ij}^sr_{ij}^t\\\\\n  \\nu_i          & = \\sum_s\\lambda_i^{ss}\\end{split}\\]\n  where \\(F\\) is the embedding energy which is a function of the atomic\n  electron density \\(\\rho\\), \\(\\phi\\) is a pair potential interaction,\n  \\(\\alpha\\) and \\(\\beta\\) are the element types of atoms \\(I\\) and\n  \\(J\\), and \\(s\\) and \\(t = 1,2,3\\) and refer to the cartesian\n  coordinates.  The \\(\\mu\\) and \\(\\lambda\\) terms represent the dipole\n  and quadruple distortions of the local atomic environment which extend the\n  original EAM framework by introducing angular forces.\n  Note that unlike for other potentials, cutoffs for ADP potentials are\n  not set in the pair_style or pair_coeff command; they are specified in\n  the ADP potential files themselves.  Likewise, the ADP potential files\n  list atomic masses; thus you do not need to use the mass\n  command to specify them.\n  ADP potentials are available from:\n  \n  The NIST WWW site at http://www.ctcms.nist.gov/potentials.\n  Note that ADP potentials obtained from NIST must be converted\n  into the extended DYNAMO setfl format discussed below.\n  The OpenKIM Project at\n  https://openkim.org/browse/models/by-type\n  provides ADP potentials that can be used directly in LAMMPS with the\n  kim_commands interface.\n  \n  \n  Only a single pair_coeff command is used with the adp style which\n  specifies an extended DYNAMO setfl file, which contains information\n  for \\(M\\) elements.  These are mapped to LAMMPS atom types by specifying \\(N\\)\n  additional arguments after the filename in the pair_coeff command,\n  where \\(N\\) is the number of LAMMPS atom types:\n  \n  filename\n  \\(N\\) element names = mapping of extended setfl elements to atom types\n  \n  See the pair_coeff doc page for alternate ways to\n  specify the path for the potential file.\n  As an example, the potentials/AlCu.adp file, included in the\n  potentials directory of the LAMMPS distribution, is an extended setfl\n  file which has tabulated ADP values for w elements and their alloy\n  interactions: Cu and Al.  If your LAMMPS simulation has 4 atoms types\n  and you want the 1st 3 to be Al, and the 4th to be Cu, you would use\n  the following pair_coeff command:\n  pair_coeff * * AlCu.adp Al Al Al Cu\n  \n  \n  The 1st 2 arguments must be * * so as to span all LAMMPS atom types.\n  The first three Al arguments map LAMMPS atom types 1,2,3 to the Al\n  element in the extended setfl file.  The final Cu argument maps\n  LAMMPS atom type 4 to the Al element in the extended setfl file.\n  Note that there is no requirement that your simulation use all the\n  elements specified by the extended setfl file.\n  If a mapping value is specified as NULL, the mapping is not performed.\n  This can be used when an adp potential is used as part of the\n  hybrid pair style.  The NULL values are placeholders for atom types\n  that will be used with other potentials.\n  Adp files in the potentials directory of the LAMMPS distribution\n  have an “.adp” suffix.  A DYNAMO setfl file extended for ADP is\n  formatted as follows.  Basically it is the standard setfl format\n  with additional tabulated functions u and w added to the file after\n  the tabulated pair potentials.  See the pair_eam\n  command for further details on the setfl format.\n  \n  lines 1,2,3 = comments (ignored)\n  line 4: \\(N_{\\text{elements}}\\) Element1 Element2 … ElementN\n  line 5: \\(N_{\\rho}\\), \\(d_{\\rho}\\), \\(N_r\\), \\(d_r\\), cutoff\n  \n  Following the 5 header lines are \\(N_{\\text{elements}}\\) sections, one for each\n  element, each with the following format:\n  \n  line 1 = atomic number, mass, lattice constant, lattice type (e.g. FCC)\n  embedding function \\(F(\\rho)\\) (\\(N_{\\rho}\\) values)\n  density function \\(\\rho(r)\\) (\\(N_r\\) values)\n  \n  Following the \\(N_{\\text{elements}}\\) sections, \\(N_r\\) values for each pair potential\n  \\(\\phi(r)\\) array are listed for all \\(i,j\\) element pairs in the same format\n  as other arrays.  Since these interactions are symmetric (\\(i,j = j,i\\))\n  only \\(\\phi\\) arrays with \\(i \\geq j\\) are listed, in the following order:\n  \n  \\[i,j = (1,1), (2,1), (2,2), (3,1), (3,2), (3,3), (4,1), ..., (N_{\\text{elements}},N_{\\text{elements}}).\\]\n  The tabulated values for each \\(\\phi\\) function are listed as\n  \\(r*\\phi\\) (in units of eV-Angstroms), since they are for atom pairs, the\n  same as for other EAM files.\n  After the \\(\\phi(r)\\) arrays, each of the \\(u(r)\\) arrays are listed in the\n  same order with the same assumptions of symmetry.  Directly following\n  the \\(u(r)\\), the \\(w(r)\\) arrays are listed.  Note that \\(\\phi(r)\\) is the only\n  array tabulated with a scaling by \\(r\\).\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, where types I and J correspond to\n  two different element types, no special mixing rules are needed, since\n  the ADP potential files specify alloy interactions explicitly.\n  This pair style does not support the pair_modify\n  shift, table, and tail options.\n  This pair style does not write its information to binary restart files, since it is stored in tabulated potential files.\n  Thus, you need to re-specify the pair_style and pair_coeff commands in\n  an input script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style adp\n  \n  \n  ",
    "examples": "pair_style adp\n  pair_coeff * * Ta.adp Ta\n  pair_coeff * * ../potentials/AlCu.adp Al Al Cu\n  \n  \n  ",
    "restrictions": "This pair style is part of the MANYBODY package.  It is only enabled\n  if LAMMPS was built with that package.\n  "
},
{
    "command": "pair_style agni",
    "description": "Style agni style computes the many-body vectorial force components for\n  an atom as\n  \n  \\[\\begin{split}F_i^u                  & = \\sum_t^{N_t}\\alpha_t \\cdot \\exp\\left[-\\frac{\\left(d_{i,t}^u\\right)^2}{2l^2}\\right] \\\\\n  d_{i,t}^u              & = \\left|\\left| V_i^u(\\eta) - V_t^u(\\eta) \\right|\\right| \\\\\n  V_i^u(\\eta)            & = \\sum_{j \\neq i}\\frac{r^u_{ij}}{r_{ij}} \\cdot e^{-\\left(\\frac{r_{ij}}{\\eta} \\right)^2} \\cdot f_d\\left(r_{ij}\\right) \\\\\n  f_d\\left(r_{ij}\\right) & = \\frac{1}{2} \\left[\\cos\\left(\\frac{\\pi r_{ij}}{R_c}\\right) + 1 \\right]\\end{split}\\]\n  \\(u\\) labels the individual components, i.e. \\(x\\), \\(y\\) or \\(z\\), and \\(V\\) is the\n  corresponding atomic fingerprint. \\(d\\) is the Euclidean distance between\n  any two atomic fingerprints. A total of \\(N_t\\) reference atomic\n  environments are considered to construct the force field file. \\(\\alpha_t\\)\n  and \\(l\\) are the weight coefficients and length scale parameter of the\n  non-linear regression model.\n  The method implements the recently proposed machine learning access to\n  atomic forces as discussed extensively in the following publications -\n  (Botu1) and (Botu2). The premise\n  of the method is to map the atomic environment numerically into a\n  fingerprint, and use machine learning methods to create a mapping to the\n  vectorial atomic forces.\n  Only a single pair_coeff command is used with the agni style which\n  specifies an AGNI potential file containing the parameters of the\n  force field for the needed elements. These are mapped to LAMMPS atom\n  types by specifying \\(N\\) additional arguments after the filename in the\n  pair_coeff command, where \\(N\\) is the number of LAMMPS atom types:\n  \n  filename\n  \\(N\\) element names = mapping of AGNI elements to atom types\n  \n  See the pair_coeff doc page for alternate ways\n  to specify the path for the force field file.\n  An AGNI force field is fully specified by the filename which contains the\n  parameters of the force field, i.e., the reference training environments\n  used to construct the machine learning force field. Example force field\n  and input files are provided in the examples/USER/misc/agni directory.\n  \n  Styles with omp suffix is functionally the same as the corresponding\n  style without the suffix. They have been optimized to run faster,\n  depending on your available hardware, as discussed on the Speed packages doc page.  The accelerated style takes\n  the same arguments and should produce the same results, except for\n  round-off and precision issues.\n  The accelerated style is part of the USER-OMP.  They are only enabled\n  if LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated style explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This pair style does not support the pair_modify\n  shift, table, and tail options.\n  This pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\n  need to re-specify the pair_style and pair_coeff commands in an input\n  script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style agni\n  \n  \n  ",
    "examples": "pair_style      agni\n  pair_coeff      * * Al.agni Al\n  \n  \n  ",
    "restrictions": "Currently, only elemental systems are implemented. Also, the method\n  only provides access to the forces and not energies or stresses.\n  The lack of potential energy data makes this pair style incompatible with\n  several of the minimizer algorthms like cg or sd.\n  It should work with damped dynamics based minimizers like fire or\n  quickmin.  However, one can access the energy via thermodynamic\n  integration of the forces as discussed in\n  (Botu3).  This pair style is part of the\n  USER-MISC package. It is only enabled if LAMMPS was built with that\n  package. See the Build package doc page for more\n  info.\n  The AGNI force field files provided with LAMMPS (see the\n  potentials directory) are parameterized for metal units.\n  You can use the AGNI potential with any LAMMPS units, but you would need\n  to create your own AGNI potential file with coefficients listed in the\n  appropriate units if your simulation does not use “metal” units.\n  "
},
{
    "command": "pair_style airebo",
    "description": "The airebo pair style computes the Adaptive Intermolecular Reactive\n  Empirical Bond Order (AIREBO) Potential of (Stuart) for a\n  system of carbon and/or hydrogen atoms.  Note that this is the initial\n  formulation of AIREBO from 2000, not the later formulation.\n  The airebo/morse pair style computes the AIREBO-M potential, which\n  is equivalent to AIREBO, but replaces the LJ term with a Morse potential.\n  The Morse potentials are parameterized by high-quality quantum chemistry\n  (MP2) calculations and do not diverge as quickly as particle density\n  increases. This allows AIREBO-M to retain accuracy to much higher pressures\n  than AIREBO (up to 40 GPa for Polyethylene). Details for this potential\n  and its parameterization are given in (O’Conner).\n  The rebo pair style computes the Reactive Empirical Bond Order (REBO)\n  Potential of (Brenner). Note that this is the so-called\n  2nd generation REBO from 2002, not the original REBO from 1990.\n  As discussed below, 2nd generation REBO is closely related to the\n  initial AIREBO; it is just a subset of the potential energy terms\n  with a few slightly different parameters\n  The AIREBO potential consists of three terms:\n  \n  \\[\\begin{split}E & = \\frac{1}{2} \\sum_i \\sum_{j \\neq i}\n  \\left[ E^{\\text{REBO}}_{ij} + E^{\\text{LJ}}_{ij} +\n   \\sum_{k \\neq i,j} \\sum_{l \\neq i,j,k} E^{\\text{TORSION}}_{kijl} \\right] \\\\\\end{split}\\]\n  By default, all three terms are included.  For the airebo style, if\n  the first two optional flag arguments to the pair_style command are\n  included, the LJ and torsional terms can be turned off.  Note that\n  both or neither of the flags must be included.  If both of the LJ an\n  torsional terms are turned off, it becomes the 2nd-generation REBO\n  potential, with a small caveat on the spline fitting procedure\n  mentioned below.  This can be specified directly as pair_style rebo\n  with no additional arguments.\n  The detailed formulas for this potential are given in\n  (Stuart); here we provide only a brief description.\n  The \\(E^{\\text{REBO}}\\) term has the same functional form as the hydrocarbon REBO\n  potential developed in (Brenner).  The coefficients for\n  \\(E^{\\text{REBO}}\\) in AIREBO are essentially the same as Brenner’s potential, but\n  a few fitted spline values are slightly different.  For most cases the\n  \\(E^{\\text{REBO}}\\) term in AIREBO will produce the same energies, forces and\n  statistical averages as the original REBO potential from which it was\n  derived.  The \\(E^{\\text{REBO}}\\) term in the AIREBO potential gives the model its\n  reactive capabilities and only describes short-ranged C-C, C-H and H-H\n  interactions (\\(r < 2\\) Angstroms). These interactions have strong\n  coordination-dependence through a bond order parameter, which adjusts\n  the attraction between the I,J atoms based on the position of other\n  nearby atoms and thus has 3- and 4-body dependence.\n  The \\(E^{\\text{LJ}}\\) term adds longer-ranged interactions (\\(2 < r < \\text{cutoff}\\)) using a\n  form similar to the standard Lennard Jones potential.\n  The \\(E^{\\text{LJ}}\\) term in AIREBO contains a series of switching functions so\n  that the short-ranged LJ repulsion (\\(1/r^{12}\\)) does not interfere with\n  the energetics captured by the \\(E^{\\text{REBO}}\\) term.  The extent of the \\(E^{\\text{LJ}}\\)\n  interactions is determined by the cutoff argument to the pair_style\n  command which is a scale factor.  For each type pair (C-C, C-H, H-H)\n  the cutoff is obtained by multiplying the scale factor by the sigma\n  value defined in the potential file for that type pair.  In the\n  standard AIREBO potential, \\(\\sigma_{CC} = 3.4\\) Angstroms, so with a scale\n  factor of 3.0 (the argument in pair_style), the resulting \\(E^{\\text{LJ}}\\) cutoff\n  would be 10.2 Angstroms.\n  By default, the longer-ranged interaction is smoothly switched off\n  between 2.16 and 3.0 \\(\\sigma\\). By specifying cutoff_min in addition\n  to cutoff, the switching can be configured to take place between\n  cutoff_min and cutoff. cutoff_min can only be specified if all\n  optional arguments are given.\n  The \\(E^{\\text{TORSION}}\\) term is an explicit 4-body potential that describes\n  various dihedral angle preferences in hydrocarbon configurations.\n  \n  Only a single pair_coeff command is used with the airebo, airebo\n  or rebo style which specifies an AIREBO, REBO, or AIREBO-M potential\n  file with parameters for C and H.  Note that as of LAMMPS version\n  15 May 2019 the rebo style in LAMMPS uses its own potential\n  file (CH.rebo).  These are mapped to LAMMPS atom types by specifying\n  N additional arguments after the filename in the pair_coeff command,\n  where N is the number of LAMMPS atom types:\n  \n  filename\n  \\(N\\) element names = mapping of AIREBO elements to atom types\n  \n  See the pair_coeff doc page for alternate ways\n  to specify the path for the potential file.\n  As an example, if your LAMMPS simulation has 4 atom types and you want\n  the 1st 3 to be C, and the 4th to be H, you would use the following\n  pair_coeff command:\n  pair_coeff * * CH.airebo C C C H\n  \n  \n  The 1st 2 arguments must be * * so as to span all LAMMPS atom types.\n  The first three C arguments map LAMMPS atom types 1,2,3 to the C\n  element in the AIREBO file.  The final H argument maps LAMMPS atom\n  type 4 to the H element in the SW file.  If a mapping value is\n  specified as NULL, the mapping is not performed.  This can be used\n  when a airebo potential is used as part of the hybrid pair style.\n  The NULL values are placeholders for atom types that will be used with\n  other potentials.\n  The parameters/coefficients for the AIREBO potentials are listed in\n  the CH.airebo file to agree with the original (Stuart)\n  paper.  Thus the parameters are specific to this potential and the way\n  it was fit, so modifying the file should be done cautiously.\n  Similarly the parameters/coefficients for the AIREBO-M potentials are\n  listed in the CH.airebo-m file to agree with the (O’Connor)\n  paper. Thus the parameters are specific to this potential and the way\n  it was fit, so modifying the file should be done cautiously. The\n  AIREBO-M Morse potentials were parameterized using a cutoff of\n  3.0 (\\(\\sigma\\)). Modifying this cutoff may impact simulation accuracy.\n  This pair style tallies a breakdown of the total AIREBO potential\n  energy into sub-categories, which can be accessed via the compute pair command as a vector of values of length 3.\n  The 3 values correspond to the following sub-categories:\n  \n  \\(E_{\\text{REBO}}\\) = REBO energy\n  \\(E_{\\text{LJ}}\\) = Lennard-Jones energy\n  \\(E_{\\text{TORSION}}\\) = Torsion energy\n  \n  To print these quantities to the log file (with descriptive column\n  headings) the following commands could be included in an input script:\n  compute 0 all pair airebo\n  variable REBO     equal c_0[1]\n  variable LJ       equal c_0[2]\n  variable TORSION  equal c_0[3]\n  thermo_style custom step temp epair v_REBO v_LJ v_TORSION\n  \n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  These pair styles do not support the pair_modify\n  mix, shift, table, and tail options.\n  These pair styles do not write their information to binary restart files, since it is stored in potential files.  Thus, you\n  need to re-specify the pair_style and pair_coeff commands in an input\n  script that reads a restart file.\n  These pair styles can only be used via the pair keyword of the\n  run_style respa command.  They do not support the\n  inner , middle, outer keywords.\n  ",
    "syntax": "pair_style style cutoff LJ_flag TORSION_flag cutoff_min\n  \n  \n  \n  style = airebo or airebo/morse or rebo\n  cutoff = LJ or Morse cutoff (\\(\\sigma\\) scale factor) (AIREBO and AIREBO-M only)\n  LJ_flag = 0/1 to turn off/on the LJ or Morse term (AIREBO and AIREBO-M only, optional)\n  TORSION_flag = 0/1 to turn off/on the torsion term (AIREBO and AIREBO-M only, optional)\n  cutoff_min = Start of the transition region of cutoff (\\(\\sigma\\) scale factor) (AIREBO and AIREBO-M only, optional)\n  \n  ",
    "examples": "pair_style airebo 3.0\n  pair_style airebo 2.5 1 0\n  pair_coeff * * ../potentials/CH.airebo H C\n  \n  pair_style airebo/morse 3.0\n  pair_coeff * * ../potentials/CH.airebo-m H C\n  \n  pair_style rebo\n  pair_coeff * * ../potentials/CH.rebo H C\n  \n  \n  ",
    "restrictions": "These pair styles are part of the MANYBODY package.  They are only\n  enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\n  These pair potentials require the newton setting to be\n  “on” for pair interactions.\n  The CH.airebo and CH.airebo-m potential files provided with LAMMPS\n  (see the potentials directory) are parameterized for metal units.\n  You can use the AIREBO, AIREBO-M or REBO potential with any LAMMPS units,\n  but you would need to create your own AIREBO or AIREBO-M potential file\n  with coefficients listed in the appropriate units, if your simulation\n  does not use “metal” units.\n  "
},
{
    "command": "pair_style atm",
    "description": "The atm style computes a 3-body Axilrod-Teller-Muto\n  potential for the energy E of a system of atoms as\n  \n  \\[\\begin{split}E & = \\nu\\frac{1+3\\cos\\gamma_1\\cos\\gamma_2\\cos\\gamma_3}{r_{12}^3r_{23}^3r_{31}^3} \\\\\\end{split}\\]\n  where \\(\\nu\\) is the three-body interaction strength.  The distances\n  between pairs of atoms \\(r_{12}\\), \\(r_{23}\\), \\(r_{31}\\) and the angles \\(\\gamma_1\\), \\(\\gamma_2\\),\n  \\(\\gamma_3\\) are as shown in this diagram:\n  \n  Note that for the interaction between a triplet of atoms \\(I,J,K\\), there\n  is no “central” atom.  The interaction is symmetric with respect to\n  permutation of the three atoms. Thus the \\(\\nu\\) value is\n  the same for all those permutations of the atom types of \\(I,J,K\\)\n  and needs to be specified only once, as discussed below.\n  The atm potential is typically used in combination with a two-body\n  potential using the pair_style hybrid/overlay\n  command as in the example above.\n  The potential for a triplet of atom is calculated only if all 3 distances\n  \\(r_{12}\\), \\(r_{23}\\), \\(r_{31}\\) between the 3 atoms satisfy\n  \\(r_{IJ} < \\text{cutoff}\\).  In addition, the product of the 3 distances\n  \\(r_{12} r_{23} r_{31}\\) < cutoff_triple \\(^3\\) is required, which\n  excludes from calculation the triplets with small contribution to the\n  interaction.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the restart files read by the\n  read_restart commands:\n  \n  \\(K\\) = atom type of the third atom (1 to \\(N_{\\text{types}}\\))\n  \\(\\nu\\) = prefactor (energy/distance^9 units)\n  \n  \\(K\\) can be specified in one of two ways.  An explicit numeric value can\n  be used, as in the 2nd example above.  \\(J \\leq K\\) is required.  LAMMPS\n  sets the coefficients for the other 5 symmetric interactions to the same\n  values.  E.g. if \\(I = 1\\), \\(J = 2\\), \\(K = 3\\), then these 6\n  values are set to the specified \\(\\nu\\): \\(\\nu_{123}\\),\n  \\(\\nu_{132}\\), \\(\\nu_{213}\\), \\(\\nu_{231}\\), \\(\\nu_{312}\\),\n  \\(\\nu_{321}\\).  This enforces the symmetry discussed above.\n  A wildcard asterisk can be used for K to set the coefficients for\n  multiple triplets of atom types.  This takes the form “*” or “*n” or\n  “n*” or “m*n”.  If \\(N\\) equals the number of atom types, then an asterisk with\n  no numeric values means all types from 1 to \\(N\\).  A leading asterisk\n  means all types from 1 to \\(n\\) (inclusive).  A trailing asterisk means\n  all types from \\(n\\) to \\(N\\) (inclusive).  A middle asterisk means all types\n  from \\(m\\) to \\(n\\) (inclusive).  Note that only type triplets with \\(J \\leq K\\) are\n  considered; if asterisks imply type triplets where \\(K < J\\), they are\n  ignored.\n  Note that a pair_coeff command can override a previous setting for the\n  same \\(I,J,K\\) triplet.  For example, these commands set \\(\\nu\\) for all \\(I,J.K\\)\n  triplets, then overwrite nu for just the \\(I,J,K = 2,3,4\\) triplet:\n  pair_coeff * * * 0.25\n  pair_coeff 2 3 4 0.1\n  \n  \n  Note that for a simulation with a single atom type, only a single\n  entry is required, e.g.\n  pair_coeff 1 1 1 0.25\n  \n  \n  For a simulation with two atom types, four pair_coeff commands will\n  specify all possible nu values:\n  pair_coeff 1 1 1 nu1\n  pair_coeff 1 1 2 nu2\n  pair_coeff 1 2 2 nu3\n  pair_coeff 2 2 2 nu4\n  \n  \n  For a simulation with three atom types, ten pair_coeff commands will\n  specify all possible nu values:\n  pair_coeff 1 1 1 nu1\n  pair_coeff 1 1 2 nu2\n  pair_coeff 1 1 3 nu3\n  pair_coeff 1 2 2 nu4\n  pair_coeff 1 2 3 nu5\n  pair_coeff 1 3 3 nu6\n  pair_coeff 2 2 2 nu7\n  pair_coeff 2 2 3 nu8\n  pair_coeff 2 3 3 nu9\n  pair_coeff 3 3 3 nu10\n  \n  \n  By default the \\(\\nu\\) value for all triplets is set to 0.0.  Thus it is\n  not required to provide pair_coeff commands that enumerate triplet\n  interactions for all \\(K\\) types.  If some \\(I,J,K\\) combination is not\n  specified, then there will be no 3-body ATM interactions for that\n  combination and all its permutations.  However, as with all pair\n  styles, it is required to specify a pair_coeff command for all \\(I,J\\)\n  combinations, else an error will result.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This pair styles do not support the pair_modify\n  mix, shift, table, and tail options.\n  This pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need to be specified\n  in an input script that reads a restart file.  However, if the atm potential\n  is used in combination with other potentials using the pair_style\n  hybrid/overlay command then pair_coeff commands need to be\n  re-specified in the restart input script.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner , middle , outer keywords.\n  ",
    "syntax": "pair_style atm cutoff cutoff_triple\n  \n  \n  \n  cutoff = cutoff for each pair in 3-body interaction (distance units)\n  cutoff_triple = additional cutoff applied to product of 3 pairwise distances (distance units)\n  \n  ",
    "examples": "pair_style atm 4.5 2.5\n  pair_coeff * * * 0.072\n  \n  pair_style hybrid/overlay lj/cut 6.5 atm 4.5 2.5\n  pair_coeff * * lj/cut 1.0 1.0\n  pair_coeff 1 1 atm 1 0.064\n  pair_coeff 1 1 atm 2 0.080\n  pair_coeff 1 2 atm 2 0.100\n  pair_coeff 2 2 atm 2 0.125\n  \n  \n  ",
    "restrictions": "This pair style is part of the MANYBODY package.  It is only enabled\n  if LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style awpmd/cut",
    "description": "This pair style contains an implementation of the Antisymmetrized Wave\n  Packet Molecular Dynamics (AWPMD) method.  Need citation here.  Need\n  basic formulas here.  Could be links to other documents.\n  Rc is the cutoff.\n  The pair_style command allows for several optional keywords\n  to be specified.\n  The hartree, dproduct, and uhf keywords specify the form of the\n  initial trial wave function for the system.  If the hartree keyword\n  is used, then a Hartree multielectron trial wave function is used.  If\n  the dproduct keyword is used, then a trial function which is a\n  product of two determinants for each spin type is used.  If the uhf\n  keyword is used, then an unrestricted Hartree-Fock trial wave function\n  is used.\n  The free, pbc, and fix keywords specify a width constraint on\n  the electron wave packets.  If the free keyword is specified, then there is no\n  constraint.  If the pbc keyword is used and Plen is specified as\n  -1, then the maximum width is half the shortest box length.  If Plen\n  is a positive value, then the value is the maximum width.  If the\n  fix keyword is used and Flen is specified as -1, then electrons\n  have a constant width that is read from the data file.  If Flen is a\n  positive value, then the constant width for all electrons is set to\n  Flen.\n  The harm keyword allow oscillations in the width of the\n  electron wave packets.  More details are needed.\n  The ermscale keyword specifies a unitless scaling factor\n  between the electron masses and the width variable mass.  More\n  details needed.\n  If the flex_press keyword is used, then a contribution from the\n  electrons is added to the total virial and pressure of the system.\n  This potential is designed to be used with atom_style wavepacket definitions, in order to handle the\n  description of systems with interacting nuclei and explicit electrons.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands, or by mixing as described below:\n  \n  cutoff (distance units)\n  \n  For awpmd/cut, the cutoff coefficient is optional.  If it is not\n  used (as in some of the examples above), the default global value\n  specified in the pair_style command is used.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  The pair_modify mix, shift, table, and tail options\n  are not relevant for this pair style.\n  This pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style awpmd/cut Rc keyword value ...\n  \n  \n  \n  Rc = global cutoff, -1 means cutoff of half the shortest box length\n  zero or more keyword/value pairs may be appended\n  keyword = hartree or dproduct or uhf or free or pbc or fix or harm or ermscale or flex_press\n  hartree value = none\n  dproduct value = none\n  uhf value = none\n  free value = none\n  pbc value = Plen\n    Plen = periodic width of electron = -1 or positive value (distance units)\n  fix value = Flen\n    Flen = fixed width of electron = -1 or positive value (distance units)\n  harm value = width\n    width = harmonic width constraint\n  ermscale value = factor\n    factor = scaling between electron mass and width variable mass\n  flex_press value = none\n  \n  \n  ",
    "examples": "pair_style awpmd/cut -1\n  pair_style awpmd/cut 40.0 uhf free\n  pair_coeff * *\n  pair_coeff 2 2 20.0\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "pair_style beck",
    "description": "Style beck computes interactions based on the potential by\n  (Beck), originally designed for simulation of Helium.  It\n  includes truncation at a cutoff distance Rc.\n  \n  \\[\\begin{split}E(r) &= A \\exp\\left[-\\alpha r - \\beta r^6\\right] - \\frac{B}{\\left(r^2+a^2\\right)^3} \\left(1+\\frac{2.709+3a^2}{r^2+a^2}\\right) \\qquad r < R_c \\\\\\end{split}\\]\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands.\n  \n  \\(A\\) (energy units)\n  \\(B\\) (energy-distance^6 units)\n  \\(a\\) (distance units)\n  \\(\\alpha\\) (1/distance units)\n  \\(\\beta\\)  (1/distance^6 units)\n  cutoff (distance units)\n  \n  The last coefficient is optional.  If not specified, the global cutoff\n  \\(R_c\\) is used.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, coefficients must be specified.\n  No default mixing rules are used.\n  This pair style does not support the pair_modify shift\n  option for the energy of the pair interaction.\n  The pair_modify table option is not relevant\n  for this pair style.\n  This pair style does not support the pair_modify\n  tail option for adding long-range tail corrections.\n  This pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style beck Rc\n  \n  \n  \n  Rc = cutoff for interactions (distance units)\n  \n  ",
    "examples": "pair_style beck 8.0\n  pair_coeff * * 399.671876712 0.0000867636112694 0.675 4.390 0.0003746\n  pair_coeff 1 1 399.671876712 0.0000867636112694 0.675 4.390 0.0003746 6.0\n  \n  \n  ",
    "restrictions": "none\n  "
},
{
    "command": "pair_style body/nparticle",
    "description": "Style body/nparticle is for use with body particles and calculates\n  pairwise body/body interactions as well as interactions between body\n  and point-particles.  See the Howto body doc page\n  for more details on using body particles.\n  This pair style is designed for use with the “nparticle” body style,\n  which is specified as an argument to the “atom-style body” command.\n  See the Howto body doc page for more details about\n  the body styles LAMMPS supports.  The “nparticle” style treats a body\n  particle as a rigid body composed of N sub-particles.\n  The coordinates of a body particle are its center-of-mass (COM).  If\n  the COMs of a pair of body particles are within the cutoff (global or\n  type-specific, as specified above), then all interactions between\n  pairs of sub-particles in the two body particles are computed.\n  E.g. if the first body particle has 3 sub-particles, and the second\n  has 10, then 30 interactions are computed and summed to yield the\n  total force and torque on each body particle.\n  \n  Note\n  In the example just described, all 30 interactions are computed\n  even if the distance between a particular pair of sub-particles is\n  greater than the cutoff.  Likewise, no interaction between two body\n  particles is computed if the two COMs are further apart than the\n  cutoff, even if the distance between some pairs of their sub-particles\n  is within the cutoff.  Thus care should be used in defining the cutoff\n  distances for body particles, depending on their shape and size.\n  \n  Similar rules apply for a body particle interacting with a point\n  particle.  The distance between the two particles is calculated using\n  the COM of the body particle and the position of the point particle.\n  If the distance is within the cutoff and the body particle has N\n  sub-particles, then N interactions with the point particle are\n  computed and summed.  If the distance is not within the cutoff, no\n  interactions between the body and point particle are computed.\n  The interaction between two sub-particles, or a sub-particle and point\n  particle, or between two point particles is computed as a Lennard-Jones\n  interaction, using the standard formula\n  \n  \\[\\begin{split}E & = 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -\n                      \\left(\\frac{\\sigma}{r}\\right)^6 \\right]\n                      \\qquad r < R_c \\\\\\end{split}\\]\n  where \\(R_c\\) is the cutoff.  As explained above, an interaction involving\n  one or two body sub-particles may be computed even for \\(r > R_c\\).\n  For style body, the following coefficients must be defined for each\n  pair of atoms types via the pair_coeff command as in\n  the examples above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands:\n  \n  \\(\\epsilon\\) (energy units)\n  \\(\\sigma\\) (distance units)\n  cutoff (distance units)\n  \n  The last coefficient is optional.  If not specified, the global cutoff\n  is used.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the epsilon and sigma coefficients\n  and cutoff distance for all of this pair style can be mixed.  The\n  default mix value is geometric.  See the pair_modify command for\n  details.\n  This pair style does not support the pair_modify\n  shift, table, and tail options.\n  This pair style does not write its information to binary restart files.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style body/nparticle cutoff\n  \n  \n  cutoff = global cutoff for interactions (distance units)\n  ",
    "examples": "pair_style body/nparticle 3.0\n  pair_coeff * * 1.0 1.0\n  pair_coeff 1 1 1.0 1.5 2.5\n  \n  \n  ",
    "restrictions": "This style is part of the BODY package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  Defining particles to be bodies so they participate in body/body or\n  body/particle interactions requires the use of the atom_style body command.\n  "
},
{
    "command": "pair_style body/rounded/polygon",
    "description": "Style body/rounded/polygon is for use with 2d models of body\n  particles of style rounded/polygon.  It calculates pairwise\n  body/body interactions which can include body particles modeled as\n  1-vertex circular disks with a specified diameter.  See the\n  Howto body doc page for more details on using body\n  rounded/polygon particles.\n  This pairwise interaction between rounded polygons is described in\n  Fraige, where a polygon does not have sharp corners,\n  but is rounded at its vertices by circles centered on each vertex with\n  a specified diameter.  The edges of the polygon are defined between\n  pairs of adjacent vertices.  The circle diameter for each polygon is\n  specified in the data file read by the read data\n  command.  This is a 2d discrete element model (DEM) which allows for\n  multiple contact points.\n  Note that when two particles interact, the effective surface of each\n  polygon particle is displaced outward from each of its vertices and\n  edges by half its circle diameter (as in the diagram below of a gray\n  and yellow square particle).  The interaction forces and energies\n  between two particles are defined with respect to the separation of\n  their respective rounded surfaces, not by the separation of the\n  vertices and edges themselves.\n  This means that the specified cutoff in the pair_style command is the\n  cutoff distance, \\(r_c\\), for the surface separation, \\(\\delta_n\\) (see figure\n  below).  This is the distance at which two particles no longer\n  interact.  If \\(r_c\\) is specified as 0.0, then it is a contact-only\n  interaction.  I.e. the two particles must overlap in order to exert a\n  repulsive force on each other.  If \\(r_c > 0.0\\), then the force between\n  two particles will be attractive for surface separations from 0 to\n  \\(r_c\\), and repulsive once the particles overlap.\n  Note that unlike for other pair styles, the specified cutoff is not\n  the distance between the centers of two particles at which they stop\n  interacting.  This center-to-center distance depends on the shape and\n  size of the two particles and their relative orientation.  LAMMPS\n  takes that into account when computing the surface separation distance\n  and applying the \\(r_c\\) cutoff.\n  The forces between vertex-vertex, vertex-edge, and edge-edge overlaps\n  are given by:\n  \n  \\[\\begin{split}F_n &= \\begin{cases}\n          k_n \\delta_n - c_n v_n     &  \\delta_n \\le 0 \\\\\n         -k_{na} \\delta_n - c_n v_n  &  0 < \\delta_n \\le r_c \\\\\n         0                           & \\delta_n > r_c \\\\\n         \\end{cases} \\\\\n  F_t &= \\begin{cases}\n         \\mu k_n \\delta_n - c_t v_t & \\delta_n \\le 0 \\\\\n         0                          & \\delta_n > 0\n         \\end{cases}\\end{split}\\]\n  \n  Note that \\(F_n\\) and \\(F_t\\) are functions of the surface separation\n  \\(\\delta_n = d - (R_i + R_j)\\).  In this model, when\n  \\((R_i + R_j) < d < (R_i + R_j) + r_c\\), that is, \\(0 < \\delta_n < r_c\\),\n  the cohesive region of the two surfaces overlap and the two surfaces are\n  attractive to each other.\n  In Fraige, the tangential friction force between two\n  particles that are in contact is modeled differently prior to gross\n  sliding (i.e. static friction) and during gross-sliding (kinetic\n  friction).  The latter takes place when the tangential deformation\n  exceeds the Coulomb frictional limit.  In the current implementation,\n  however, we do not take into account frictional history, i.e. we do\n  not keep track of how many time steps the two particles have been in\n  contact nor calculate the tangential deformation.  Instead, we assume\n  that gross sliding takes place as soon as two particles are in\n  contact.\n  The following coefficients must be defined for each pair of atom types\n  via the pair_coeff command as in the examples above,\n  or in the data file read by the read_data command:\n  \n  \\(k_n\\) (energy/distance^2 units)\n  \\(k_{na}\\) (energy/distance^2 units)\n  \n  Effectively, \\(k_n\\) and \\(k_{na}\\) are the slopes of the red lines in the plot\n  above for force versus surface separation, for \\(\\delta_n < 0\\) and\n  \\(0 < \\delta_n < r_c\\) respectively.\n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This pair style does not support the pair_modify\n  mix, shift, table, and tail options.\n  This pair style does not write its information to binary restart files.  Thus, you need to re-specify the pair_style and\n  pair_coeff commands in an input script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style body/rounded/polygon c_n c_t mu delta_ua cutoff\n  \n  \n  c_n = normal damping coefficient\n  c_t = tangential damping coefficient\n  mu = normal friction coefficient during gross sliding\n  delta_ua = multiple contact scaling factor\n  cutoff = global separation cutoff for interactions (distance units), see below for definition\n  \n  \n  ",
    "examples": "pair_style body/rounded/polygon 20.0 5.0 0.0 1.0 0.5\n  pair_coeff * * 100.0 1.0\n  pair_coeff 1 1 100.0 1.0\n  \n  \n  ",
    "restrictions": "These pair styles are part of the BODY package.  They are only enabled\n  if LAMMPS was built with that package.  See the Build package doc page for more info.\n  This pair style requires the newton setting to be “on”\n  for pair interactions.\n  "
},
{
    "command": "pair_style body/rounded/polyhedron",
    "description": "Style body/rounded/polygon is for use with 3d models of body\n  particles of style rounded/polyhedron.  It calculates pairwise\n  body/body interactions which can include body particles modeled as\n  1-vertex spheres with a specified diameter.  See the\n  Howto body doc page for more details on using body\n  rounded/polyhedron particles.\n  This pairwise interaction between the rounded polyhedra is described\n  in Wang, where a polyhedron does not have sharp corners\n  and edges, but is rounded at its vertices and edges by spheres\n  centered on each vertex with a specified diameter.  The edges if the\n  polyhedron are defined between pairs of adjacent vertices.  Its faces\n  are defined by a loop of edges.  The sphere diameter for each polygon\n  is specified in the data file read by the read data\n  command.  This is a discrete element model (DEM) which allows for\n  multiple contact points.\n  Note that when two particles interact, the effective surface of each\n  polyhedron particle is displaced outward from each of its vertices,\n  edges, and faces by half its sphere diameter.  The interaction forces\n  and energies between two particles are defined with respect to the\n  separation of their respective rounded surfaces, not by the separation\n  of the vertices, edges, and faces themselves.\n  This means that the specified cutoff in the pair_style command is the\n  cutoff distance, \\(r_c\\), for the surface separation, \\(\\delta_n\\) (see figure\n  below).  This is the distance at which two particles no longer\n  interact.  If \\(r_c\\) is specified as 0.0, then it is a contact-only\n  interaction.  I.e. the two particles must overlap in order to exert a\n  repulsive force on each other.  If \\(r_c > 0.0\\), then the force between\n  two particles will be attractive for surface separations from 0 to\n  \\(r_c\\), and repulsive once the particles overlap.\n  Note that unlike for other pair styles, the specified cutoff is not\n  the distance between the centers of two particles at which they stop\n  interacting.  This center-to-center distance depends on the shape and\n  size of the two particles and their relative orientation.  LAMMPS\n  takes that into account when computing the surface separation distance\n  and applying the \\(r_c\\) cutoff.\n  The forces between vertex-vertex, vertex-edge, vertex-face, edge-edge,\n  and edge-face overlaps are given by:\n  \n  \\[\\begin{split}F_n &= \\begin{cases}\n         k_n \\delta_n - c_n v_n,    & \\delta_n \\le 0 \\\\\n        -k_{na} \\delta_n - c_n v_n  & 0 < \\delta_n \\le r_c \\\\\n         0                          & \\delta_n > r_c \\\\\n         \\end{cases} \\\\\n  F_t &= \\begin{cases}\n         \\mu k_n \\delta_n - c_t v_t & \\delta_n \\le 0 \\\\\n         0                          & \\delta_n > 0\n         \\end{cases}\\end{split}\\]\n  \n  In Wang, the tangential friction force between two\n  particles that are in contact is modeled differently prior to gross\n  sliding (i.e. static friction) and during gross-sliding (kinetic\n  friction).  The latter takes place when the tangential deformation\n  exceeds the Coulomb frictional limit.  In the current implementation,\n  however, we do not take into account frictional history, i.e. we do\n  not keep track of how many time steps the two particles have been in\n  contact nor calculate the tangential deformation.  Instead, we assume\n  that gross sliding takes place as soon as two particles are in\n  contact.\n  The following coefficients must be defined for each pair of atom types\n  via the pair_coeff command as in the examples above,\n  or in the data file read by the read_data command:\n  \n  \\(k_n\\) (energy/distance^2 units)\n  \\(k_{na}\\) (energy/distance^2 units)\n  \n  Effectively, \\(k_n\\) and \\(k_{na}\\) are the slopes of the red lines in the plot\n  above for force versus surface separation, for \\(\\delta_n\\) < 0 and\n  \\(0 < \\delta_n < r_c\\) respectively.\n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This pair style does not support the pair_modify\n  mix, shift, table, and tail options.\n  This pair style does not write its information to binary restart files.\n  Thus, you need to re-specify the pair_style and pair_coeff\n  commands in an input script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style body/rounded/polyhedron c_n c_t mu delta_ua cutoff\n  \n  \n  c_n = normal damping coefficient\n  c_t = tangential damping coefficient\n  mu = normal friction coefficient during gross sliding\n  delta_ua = multiple contact scaling factor\n  cutoff = global separation cutoff for interactions (distance units), see below for definition\n  \n  \n  ",
    "examples": "pair_style body/rounded/polyhedron 20.0 5.0 0.0 1.0 0.5\n  pair_coeff * * 100.0 1.0\n  pair_coeff 1 1 100.0 1.0\n  \n  \n  ",
    "restrictions": "These pair styles are part of the BODY package.  They are only enabled\n  if LAMMPS was built with that package.  See the Build package doc page for more info.\n  This pair style requires the newton setting to be “on”\n  for pair interactions.\n  "
},
{
    "command": "pair_style bop",
    "description": "The bop pair style computes Bond-Order Potentials (BOP) based on\n  quantum mechanical theory incorporating both \\(\\sigma\\) and \\(\\pi\\) bonding.\n  By analytically deriving the BOP from quantum mechanical theory its\n  transferability to different phases can approach that of quantum\n  mechanical methods.  This potential is similar to the original BOP\n  developed by Pettifor (Pettifor_1,\n  Pettifor_2, Pettifor_3) and later updated\n  by Murdick, Zhou, and Ward (Murdick, Ward).\n  Currently, BOP potential files for these systems are provided with\n  LAMMPS: AlCu, CCu, CdTe, CdTeSe, CdZnTe, CuH, GaAs.  A system with\n  only a subset of these elements, including a single element (e.g. C or\n  Cu or Al or Ga or Zn or CdZn), can also be modeled by using the\n  appropriate alloy file and assigning all atom types to the\n  single element or subset of elements via the pair_coeff command, as\n  discussed below.\n  The BOP potential consists of three terms:\n  \n  \\[E = \\frac{1}{2} \\sum_{i=1}^{N} \\sum_{j=i_1}^{i_N} \\phi_{ij} \\left( r_{ij} \\right) - \\sum_{i=1}^{N} \\sum_{j=i_1}^{i_N} \\beta_{\\sigma,ij} \\left( r_{ij} \\right) \\cdot \\Theta_{\\sigma,ij} - \\sum_{i=1}^{N} \\sum_{j=i_1}^{i_N} \\beta_{\\pi,ij} \\left( r_{ij} \\right) \\cdot \\Theta_{\\pi,ij} + U_{prom}\\]\n  where \\(\\phi_{ij}(r_{ij})\\) is a short-range two-body function\n  representing the repulsion between a pair of ion cores,\n  \\(\\beta_{\\sigma,ij}(r_{ij})\\) and \\(\\beta_{\\sigma,ij}(r_{ij})\\)\n  are respectively sigma and \\(\\pi\\) bond integrals, \\(\\Theta_{\\sigma,ij}\\)\n  and \\(\\Theta_{\\pi,ij}\\) are \\(\\sigma\\) and \\(\\pi\\)\n  bond-orders, and U_prom is the promotion energy for sp-valent systems.\n  The detailed formulas for this potential are given in Ward\n  (Ward); here we provide only a brief description.\n  The repulsive energy \\(\\phi_{ij}(r_{ij})\\) and the bond integrals\n  \\(\\beta_{\\sigma,ij}(r_{ij})\\) and \\(\\beta_{\\phi,ij}(r_{ij})\\) are functions of the\n  interatomic distance \\(r_{ij}\\) between atom i and j.  Each of these\n  potentials has a smooth cutoff at a radius of \\(r_{cut,ij}\\).  These\n  smooth cutoffs ensure stable behavior at situations with high sampling\n  near the cutoff such as melts and surfaces.\n  The bond-orders can be viewed as environment-dependent local variables\n  that are ij bond specific.  The maximum value of the \\(\\sigma\\)\n  bond-order (\\(\\Theta_{\\sigma}\\) is 1, while that of the \\(\\pi\\)\n  bond-order (\\(\\Theta_{\\pi}\\)) is 2, attributing to a maximum value\n  of the total bond-order (\\(\\Theta_{\\sigma}+\\Theta_{\\pi}\\)) of 3.\n  The \\(\\sigma\\) and \\(\\pi\\) bond-orders reflect the ubiquitous\n  single-, double-, and triple- bond behavior of chemistry. Their\n  analytical expressions can be derived from tight- binding theory by\n  recursively expanding an inter-site Green’s function as a continued\n  fraction. To accurately represent the bonding with a computationally\n  efficient potential formulation suitable for MD simulations, the derived\n  BOP only takes (and retains) the first two levels of the recursive\n  representations for both the \\(\\sigma\\) and the \\(\\pi\\) bond-orders. Bond-order\n  terms can be understood in terms of molecular orbital hopping paths\n  based upon the Cyrot-Lackmann theorem (Pettifor_1).\n  The \\(\\sigma\\) bond-order with a half-full valence shell is used to\n  interpolate the bond-order expression that incorporated explicit valance\n  band filling.  This \\(\\pi\\) bond-order expression also contains also contains\n  a three-member ring term that allows implementation of an asymmetric\n  density of states, which helps to either stabilize or destabilize\n  close-packed structures.  The \\(\\pi\\) bond-order includes hopping paths of\n  length 4.  This enables the incorporation of dihedral angles effects.\n  \n  Note\n  Note that unlike for other potentials, cutoffs for BOP\n  potentials are not set in the pair_style or pair_coeff command; they\n  are specified in the BOP potential files themselves.  Likewise, the\n  BOP potential files list atomic masses; thus you do not need to use\n  the mass command to specify them.  Note that for BOP\n  potentials with hydrogen, you will likely want to set the mass of H\n  atoms to be 10x or 20x larger to avoid having to use a tiny timestep.\n  You can do this by using the mass command after using the\n  pair_coeff command to read the BOP potential\n  file.\n  \n  One option can be specified as a keyword with the pair_style command.\n  The save keyword gives you the option to calculate in advance and\n  store a set of distances, angles, and derivatives of angles.  The\n  default is to not do this, but to calculate them on-the-fly each time\n  they are needed.  The former may be faster, but takes more memory.\n  The latter requires less memory, but may be slower.  It is best to\n  test this option to optimize the speed of BOP for your particular\n  system configuration.\n  \n  Only a single pair_coeff command is used with the bop style which\n  specifies a BOP potential file, with parameters for all needed\n  elements.  These are mapped to LAMMPS atom types by specifying\n  N additional arguments after the filename in the pair_coeff command,\n  where N is the number of LAMMPS atom types:\n  \n  filename\n  N element names = mapping of BOP elements to atom types\n  \n  As an example, imagine the CdTe.bop file has BOP values for Cd\n  and Te.  If your LAMMPS simulation has 4 atoms types and you want the\n  1st 3 to be Cd, and the 4th to be Te, you would use the following\n  pair_coeff command:\n  pair_coeff * * CdTe Cd Cd Cd Te\n  \n  \n  The 1st 2 arguments must be * * so as to span all LAMMPS atom types.\n  The first three Cd arguments map LAMMPS atom types 1,2,3 to the Cd\n  element in the BOP file.  The final Te argument maps LAMMPS atom type\n  4 to the Te element in the BOP file.\n  BOP files in the potentials directory of the LAMMPS distribution\n  have a “.bop” suffix.  The potentials are in tabulated form containing\n  pre-tabulated pair functions for phi_ij(r_ij), beta_(sigma,ij)(r_ij),\n  and beta_pi,ij)(r_ij).\n  The parameters/coefficients format for the different kinds of BOP\n  files are given below with variables matching the formulation of Ward\n  (Ward) and Zhou (Zhou). Each header line containing a\n  “:” is preceded by a blank line.\n  \n  No angular table file format:\n  The parameters/coefficients format for the BOP potentials input file\n  containing pre-tabulated functions of g is given below with variables\n  matching the formulation of Ward (Ward).  This format also\n  assumes the angular functions have the formulation of (Ward).\n  \n  Line 1: # elements N\n  \n  The first line is followed by N lines containing the atomic\n  number, mass, and element symbol of each element.\n  Following the definition of the elements several global variables for\n  the tabulated functions are given.\n  \n  Line 1: nr, nBOt (nr is the number of divisions the radius is broken\n  into for function tables and MUST be a factor of 5; nBOt is the number\n  of divisions for the tabulated values of THETA_(S,ij)\n  Line 2: delta_1-delta_7 (if all are not used in the particular\n  formulation, set unused values to 0.0)\n  \n  Following this N lines for e_1-e_N containing p_pi.\n  \n  Line 3: p_pi (for e_1)\n  Line 4: p_pi (for e_2 and continues to e_N)\n  \n  The next section contains several pair constants for the number of\n  interaction types e_i-e_j, with i=1->N, j=i->N\n  \n  Line 1: r_cut (for e_1-e_1 interactions)\n  Line 2: c_sigma, a_sigma, c_pi, a_pi\n  Line 3: delta_sigma, delta_pi\n  Line 4: f_sigma, k_sigma, delta_3 (This delta_3 is similar to that of\n  the previous section but is interaction type dependent)\n  \n  The next section contains a line for each three body interaction type\n  e_j-e_i-e_k with i=0->N, j=0->N, k=j->N\n  \n  Line 1: g_(sigma0), g_(sigma1), g_(sigma2) (These are coefficients for\n  g_(sigma,jik)(THETA_ijk) for e_1-e_1-e_1 interaction. Ward\n  contains the full expressions for the constants as functions of\n  b_(sigma,ijk), p_(sigma,ijk), u_(sigma,ijk))\n  Line 2: g_(sigma0), g_(sigma1), g_(sigma2) (for e_1-e_1-e_2)\n  \n  The next section contains a block for each interaction type for the\n  phi_ij(r_ij).  Each block has nr entries with 5 entries per line.\n  \n  Line 1: phi(r1), phi(r2), phi(r3), phi(r4), phi(r5) (for the e_1-e_1\n  interaction type)\n  Line 2: phi(r6), phi(r7), phi(r8), phi(r9), phi(r10) (this continues\n  until nr)\n  …\n  Line nr/5_1: phi(r1), phi(r2), phi(r3), phi(r4), phi(r5), (for the\n  e_1-e_1 interaction type)\n  \n  The next section contains a block for each interaction type for the\n  beta_(sigma,ij)(r_ij).  Each block has nr entries with 5 entries per\n  line.\n  \n  Line 1: beta_sigma(r1), beta_sigma(r2), beta_sigma(r3), beta_sigma(r4),\n  beta_sigma(r5) (for the e_1-e_1 interaction type)\n  Line 2: beta_sigma(r6), beta_sigma(r7), beta_sigma(r8), beta_sigma(r9),\n  beta_sigma(r10) (this continues until nr)\n  …\n  Line nr/5+1: beta_sigma(r1), beta_sigma(r2), beta_sigma(r3),\n  beta_sigma(r4), beta_sigma(r5) (for the e_1-e_2 interaction type)\n  \n  The next section contains a block for each interaction type for\n  beta_(pi,ij)(r_ij).  Each block has nr entries with 5 entries per line.\n  \n  Line 1: beta_pi(r1), beta_pi(r2), beta_pi(r3), beta_pi(r4), beta_pi(r5)\n  (for the e_1-e_1 interaction type)\n  Line 2: beta_pi(r6), beta_pi(r7), beta_pi(r8), beta_pi(r9),\n  beta_pi(r10) (this continues until nr)\n  …\n  Line nr/5+1: beta_pi(r1), beta_pi(r2), beta_pi(r3), beta_pi(r4),\n  beta_pi(r5) (for the e_1-e_2 interaction type)\n  \n  The next section contains a block for each interaction type for the\n  THETA_(S,ij)((THETA_(sigma,ij))^(1/2), f_(sigma,ij)).  Each block has\n  nBOt entries with 5 entries per line.\n  \n  Line 1: THETA_(S,ij)(r1), THETA_(S,ij)(r2), THETA_(S,ij)(r3),\n  THETA_(S,ij)(r4), THETA_(S,ij)(r5) (for the e_1-e_2 interaction type)\n  Line 2: THETA_(S,ij)(r6), THETA_(S,ij)(r7), THETA_(S,ij)(r8),\n  THETA_(S,ij)(r9), THETA_(S,ij)(r10) (this continues until nBOt)\n  …\n  Line nBOt/5+1: THETA_(S,ij)(r1), THETA_(S,ij)(r2), THETA_(S,ij)(r3),\n  THETA_(S,ij)(r4), THETA_(S,ij)(r5) (for the e_1-e_2 interaction type)\n  \n  The next section contains a block of N lines for e_1-e_N\n  \n  Line 1: delta^mu (for e_1)\n  Line 2: delta^mu (for e_2 and repeats to e_N)\n  \n  The last section contains more constants for e_i-e_j interactions with\n  i=0->N, j=i->N\n  \n  Line 1: (A_ij)^(mu*nu) (for e1-e1)\n  Line 2: (A_ij)^(mu*nu) (for e1-e2 and repeats as above)\n  \n  \n  Angular spline table file format:\n  The parameters/coefficients format for the BOP potentials input file\n  containing pre-tabulated functions of g is given below with variables\n  matching the formulation of Ward (Ward).  This format also\n  assumes the angular functions have the formulation of (Zhou).\n  \n  Line 1: # elements N\n  \n  The first line is followed by N lines containing the atomic\n  number, mass, and element symbol of each element.\n  Following the definition of the elements several global variables for\n  the tabulated functions are given.\n  \n  Line 1: nr, ntheta, nBOt (nr is the number of divisions the radius is broken\n  into for function tables and MUST be a factor of 5; ntheta is the power of the\n  power of the spline used to fit the angular function; nBOt is the number\n  of divisions for the tabulated values of THETA_(S,ij)\n  Line 2: delta_1-delta_7 (if all are not used in the particular\n  formulation, set unused values to 0.0)\n  \n  Following this N lines for e_1-e_N containing p_pi.\n  \n  Line 3: p_pi (for e_1)\n  Line 4: p_pi (for e_2 and continues to e_N)\n  \n  The next section contains several pair constants for the number of\n  interaction types e_i-e_j, with i=1->N, j=i->N\n  \n  Line 1: r_cut (for e_1-e_1 interactions)\n  Line 2: c_sigma, a_sigma, c_pi, a_pi\n  Line 3: delta_sigma, delta_pi\n  Line 4: f_sigma, k_sigma, delta_3 (This delta_3 is similar to that of\n  the previous section but is interaction type dependent)\n  \n  The next section contains a line for each three body interaction type\n  e_j-e_i-e_k with i=0->N, j=0->N, k=j->N\n  \n  Line 1: g0, g1, g2… (These are coefficients for the angular spline\n  of the g_(sigma,jik)(THETA_ijk) for e_1-e_1-e_1 interaction.  The\n  function can contain up to 10 term thus 10 constants.  The first line\n  can contain up to five constants.  If the spline has more than five\n  terms the second line will contain the remaining constants The\n  following lines will then contain the constants for the remaining g0,\n  g1, g2… (for e_1-e_1-e_2) and the other three body\n  interactions\n  \n  The rest of the table has the same structure as the previous section\n  (see above).\n  \n  Angular no-spline table file format:\n  The parameters/coefficients format for the BOP potentials input file\n  containing pre-tabulated functions of g is given below with variables\n  matching the formulation of Ward (Ward).  This format also\n  assumes the angular functions have the formulation of (Zhou).\n  \n  Line 1: # elements N\n  \n  The first two lines are followed by N lines containing the atomic\n  number, mass, and element symbol of each element.\n  Following the definition of the elements several global variables for\n  the tabulated functions are given.\n  \n  Line 1: nr, ntheta, nBOt (nr is the number of divisions the radius is broken\n  into for function tables and MUST be a factor of 5; ntheta is the number of\n  divisions for the tabulated values of the g angular function; nBOt is the number\n  of divisions for the tabulated values of THETA_(S,ij)\n  Line 2: delta_1-delta_7 (if all are not used in the particular\n  formulation, set unused values to 0.0)\n  \n  Following this N lines for e_1-e_N containing p_pi.\n  \n  Line 3: p_pi (for e_1)\n  Line 4: p_pi (for e_2 and continues to e_N)\n  \n  The next section contains several pair constants for the number of\n  interaction types e_i-e_j, with i=1->N, j=i->N\n  \n  Line 1: r_cut (for e_1-e_1 interactions)\n  Line 2: c_sigma, a_sigma, c_pi, a_pi\n  Line 3: delta_sigma, delta_pi\n  Line 4: f_sigma, k_sigma, delta_3 (This delta_3 is similar to that of\n  the previous section but is interaction type dependent)\n  \n  The next section contains a line for each three body interaction type\n  e_j-e_i-e_k with i=0->N, j=0->N, k=j->N\n  \n  Line 1: g(theta1), g(theta2), g(theta3), g(theta4), g(theta5) (for the e_1-e_1-e_1\n  interaction type)\n  Line 2: g(theta6), g(theta7), g(theta8), g(theta9), g(theta10) (this continues\n  until ntheta)\n  …\n  Line ntheta/5+1: g(theta1), g(theta2), g(theta3), g(theta4), g(theta5), (for the\n  e_1-e_1-e_2 interaction type)\n  \n  The rest of the table has the same structure as the previous section (see above).\n  \n  Mixing, shift, table tail correction, restart:\n  This pair style does not support the pair_modify\n  mix, shift, table, and tail options.\n  This pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\n  need to re-specify the pair_style and pair_coeff commands in an input\n  script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style bop keyword ...\n  \n  \n  \n  zero or more keywords may be appended\n  keyword = save\n  \n  save = pre-compute and save some values\n  \n  \n  ",
    "examples": "pair_style bop\n  pair_coeff * * ../potentials/CdTe_bop Cd Te\n  pair_style bop save\n  pair_coeff * * ../potentials/CdTe.bop.table Cd Te Te\n  comm_modify cutoff 14.70\n  \n  \n  ",
    "restrictions": "These pair styles are part of the MANYBODY package.  They are only\n  enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\n  These pair potentials require the newtion setting to be\n  “on” for pair interactions.\n  The CdTe.bop and GaAs.bop potential files provided with LAMMPS (see the\n  potentials directory) are parameterized for metal units.\n  You can use the BOP potential with any LAMMPS units, but you would need\n  to create your own BOP potential file with coefficients listed in the\n  appropriate units if your simulation does not use “metal” units.\n  "
},
{
    "command": "pair_style born",
    "description": "The born style computes the Born-Mayer-Huggins or Tosi/Fumi\n  potential described in (Fumi and Tosi), given by\n  \n  \\[E = A \\exp \\left(\\frac{\\sigma - r}{\\rho} \\right) -\n  \\frac{C}{r^6} + \\frac{D}{r^8} \\qquad r < r_c\\]\n  where \\(\\sigma\\) is an interaction-dependent length parameter,\n  \\(\\rho\\) is an ionic-pair dependent length parameter, and\n  \\(r_c\\) is the cutoff.\n  The styles with coul/long or coul/msm add a Coulombic term as\n  described for the lj/cut pair styles.  An additional\n  damping factor is applied to the Coulombic term so it can be used in\n  conjunction with the kspace_style command and its\n  ewald or pppm of msm option.  The Coulombic cutoff specified for\n  this style means that pairwise interactions within this distance are\n  computed directly; interactions outside that distance are computed in\n  reciprocal space.\n  If one cutoff is specified for the born/coul/long and\n  born/coul/msm style, it is used for both the A,C,D and Coulombic\n  terms.  If two cutoffs are specified, the first is used as the cutoff\n  for the A,C,D terms, and the second is the cutoff for the Coulombic\n  term.\n  The born/coul/wolf style adds a Coulombic term as described for the\n  Wolf potential in the coul/wolf pair style.\n  The born/coul/dsf style computes the Coulomb contribution with the\n  damped shifted force model as in the coul/dsf style.\n  Note that these potentials are related to the Buckingham potential.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands, or by mixing as described below:\n  \n  A (energy units)\n  \\(\\rho\\) (distance units)\n  \\(\\sigma\\) (distance units)\n  C (energy units * distance units^6)\n  D (energy units * distance units^8)\n  cutoff (distance units)\n  \n  The second coefficient, rho, must be greater than zero.\n  The last coefficient is optional.  If not specified, the global A,C,D\n  cutoff specified in the pair_style command is used.\n  For born/coul/long, born/coul/wolf and born/coul/dsf no\n  Coulombic cutoff can be specified for an individual I,J type pair.\n  All type pairs use the same global Coulombic cutoff specified in the\n  pair_style command.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  These pair styles do not support mixing.  Thus, coefficients for all\n  I,J pairs must be specified explicitly.\n  These styles support the pair_modify shift option\n  for the energy of the exp(), 1/r^6, and 1/r^8 portion of the pair\n  interaction.\n  The born/coul/long pair style supports the\n  pair_modify table option to tabulate the\n  short-range portion of the long-range Coulombic interaction.\n  These styles support the pair_modify tail option for adding long-range\n  tail corrections to energy and pressure.\n  Thess styles writes thei information to binary restart\n  files, so pair_style and pair_coeff commands do not need to be\n  specified in an input script that reads a restart file.\n  These styles can only be used via the pair keyword of the run_style respa command.  They do not support the inner,\n  middle, outer keywords.\n  ",
    "syntax": "pair_style style args\n  \n  \n  \n  style = born or born/coul/long or born/coul/msm or born/coul/wolf\n  args = list of arguments for a particular style\n  \n  born args = cutoff\n    cutoff = global cutoff for non-Coulombic interactions (distance units)\n  born/coul/long args = cutoff (cutoff2)\n    cutoff = global cutoff for non-Coulombic (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  born/coul/msm args = cutoff (cutoff2)\n    cutoff = global cutoff for non-Coulombic (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  born/coul/wolf args = alpha cutoff (cutoff2)\n    alpha = damping parameter (inverse distance units)\n    cutoff = global cutoff for non-Coulombic (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  born/coul/dsf args = alpha cutoff (cutoff2)\n    alpha = damping parameter (inverse distance units)\n    cutoff = global cutoff for non-Coulombic (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (distance units)\n  ",
    "examples": "pair_style born 10.0\n  pair_coeff * * 6.08 0.317 2.340 24.18 11.51\n  pair_coeff 1 1 6.08 0.317 2.340 24.18 11.51\n  \n  pair_style born/coul/long 10.0\n  pair_style born/coul/long 10.0 8.\n  pair_coeff * * 6.08 0.317 2.340 24.18 11.51\n  pair_coeff 1 1 6.08 0.317 2.340 24.18 11.51\n  \n  pair_style born/coul/msm 10.0\n  pair_style born/coul/msm 10.0 8.0\n  pair_coeff * * 6.08 0.317 2.340 24.18 11.51\n  pair_coeff 1 1 6.08 0.317 2.340 24.18 11.51\n  \n  pair_style born/coul/wolf 0.25 10.0\n  pair_style born/coul/wolf 0.25 10.0 9.0\n  pair_coeff * * 6.08 0.317 2.340 24.18 11.51\n  pair_coeff 1 1 6.08 0.317 2.340 24.18 11.51\n  \n  pair_style born/coul/dsf 0.1 10.0 12.0\n  pair_coeff * *   0.0 1.00 0.00 0.00 0.00\n  pair_coeff 1 1 480.0 0.25 0.00 1.05 0.50\n  \n  \n  ",
    "restrictions": "The born/coul/long style is part of the KSPACE package.  It is only\n  enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style brownian",
    "description": "Styles brownian and brownian/poly compute Brownian forces and\n  torques on finite-size spherical particles.  The former requires\n  monodisperse spherical particles; the latter allows for polydisperse\n  spherical particles.\n  These pair styles are designed to be used with either the pair_style lubricate or pair_style lubricateU commands to provide thermostatting\n  when dissipative lubrication forces are acting.  Thus the parameters\n  mu, flaglog, flagfld, cutinner, and cutoff should be\n  specified consistent with the settings in the lubrication pair styles.\n  For details, refer to either of the lubrication pair styles.\n  The t_target setting is used to specify the target temperature of\n  the system.  The random number seed is used to generate random\n  numbers for the thermostatting procedure.\n  The flagHI and flagVF settings are optional.  Neither should be\n  used, or both must be defined.\n  \n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands, or by mixing as described below:\n  \n  cutinner (distance units)\n  cutoff (distance units)\n  \n  The two coefficients are optional.  If neither is specified, the two\n  cutoffs specified in the pair_style command are used.  Otherwise both\n  must be specified.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed in this section of\n  the manual.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See this section of the manual for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the two cutoff distances for this\n  pair style can be mixed.  The default mix value is geometric.  See\n  the “pair_modify” command for details.\n  This pair style does not support the pair_modify\n  shift option for the energy of the pair interaction.\n  The pair_modify table option is not relevant\n  for this pair style.\n  This pair style does not support the pair_modify\n  tail option for adding long-range tail corrections to energy and\n  pressure.\n  This pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style style mu flaglog flagfld cutinner cutoff t_target seed flagHI flagVF\n  \n  \n  \n  style = brownian or brownian/poly\n  mu = dynamic viscosity (dynamic viscosity units)\n  flaglog = 0/1 log terms in the lubrication approximation on/off\n  flagfld = 0/1 to include/exclude Fast Lubrication Dynamics effects\n  cutinner = inner cutoff distance (distance units)\n  cutoff = outer cutoff for interactions (distance units)\n  t_target = target temp of the system (temperature units)\n  seed = seed for the random number generator (positive integer)\n  flagHI (optional) = 0/1 to include/exclude 1/r hydrodynamic interactions\n  flagVF (optional) = 0/1 to include/exclude volume fraction corrections in the long-range isotropic terms\n  \n  ",
    "examples": "pair_style brownian 1.5 1 1 2.01 2.5 2.0 5878567 (assuming radius = 1)\n  pair_coeff 1 1 2.05 2.8\n  pair_coeff * *\n  \n  \n  ",
    "restrictions": "These styles are part of the COLLOID package.  They are only enabled\n  if LAMMPS was built with that package.  See the Build package doc page for more info.\n  Only spherical monodisperse particles are allowed for pair_style\n  brownian.\n  Only spherical particles are allowed for pair_style brownian/poly.\n  "
},
{
    "command": "pair_style buck",
    "description": "The buck style computes a Buckingham potential (exp/6 instead of\n  Lennard-Jones 12/6) given by\n  \n  \\[E = A e^{-r / \\rho} - \\frac{C}{r^6} \\qquad r < r_c\\]\n  where \\(\\rho\\) is an ionic-pair dependent length parameter, and\n  \\(r_c\\) is the cutoff on both terms.\n  The styles with coul/cut or coul/long or coul/msm add a\n  Coulombic term as described for the lj/cut pair styles.\n  For buck/coul/long and buc/coul/msm, an additional damping factor\n  is applied to the Coulombic term so it can be used in conjunction with\n  the kspace_style command and its ewald or pppm\n  or msm option.  The Coulombic cutoff specified for this style means\n  that pairwise interactions within this distance are computed directly;\n  interactions outside that distance are computed in reciprocal space.\n  If one cutoff is specified for the born/coul/cut and\n  born/coul/long and born/coul/msm styles, it is used for both the\n  A,C and Coulombic terms.  If two cutoffs are specified, the first is\n  used as the cutoff for the A,C terms, and the second is the cutoff for\n  the Coulombic term.\n  Note that these potentials are related to the Born-Mayer-Huggins potential.\n  \n  Note\n  For all these pair styles, the terms with A and C are always\n  cutoff.  The additional Coulombic term can be cutoff or long-range (no\n  cutoff) depending on whether the style name includes coul/cut or\n  coul/long or coul/msm.  If you wish the C/r^6 term to be long-range\n  (no cutoff), then see the pair_style buck/long/coul/long command.\n  \n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands:\n  \n  A (energy units)\n  \\(\\rho\\) (distance units)\n  C (energy-distance^6 units)\n  cutoff (distance units)\n  cutoff2 (distance units)\n  \n  The second coefficient, \\(\\rho\\), must be greater than zero.\n  The coefficients A,:math:rho, and C can be written as analytical expressions\n  of \\(\\epsilon\\) and \\(\\sigma\\), in analogy to the Lennard-Jones potential\n  (Khrapak).\n  The latter 2 coefficients are optional.  If not specified, the global\n  A,C and Coulombic cutoffs are used.  If only one cutoff is specified,\n  it is used as the cutoff for both A,C and Coulombic interactions for\n  this type pair.  If both coefficients are specified, they are used as\n  the A,C and Coulombic cutoffs for this type pair.  You cannot specify\n  2 cutoffs for style buck, since it has no Coulombic terms.\n  For buck/coul/long only the LJ cutoff can be specified since a\n  Coulombic cutoff cannot be specified for an individual I,J type pair.\n  All type pairs use the same global Coulombic cutoff specified in the\n  pair_style command.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  These pair styles do not support mixing.  Thus, coefficients for all\n  I,J pairs must be specified explicitly.\n  These styles support the pair_modify shift option\n  for the energy of the exp() and 1/r^6 portion of the pair interaction.\n  The buck/coul/long pair style supports the\n  pair_modify table option to tabulate the\n  short-range portion of the long-range Coulombic interaction.\n  These styles support the pair_modify tail option for adding long-range\n  tail corrections to energy and pressure for the A,C terms in the\n  pair interaction.\n  These styles write their information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  These styles can only be used via the pair keyword of the run_style respa command.  They do not support the inner,\n  middle, outer keywords.\n  ",
    "syntax": "pair_style style args\n  \n  \n  \n  style = buck or buck/coul/cut or buck/coul/long or buck/coul/msm\n  args = list of arguments for a particular style\n  \n  buck args = cutoff\n    cutoff = global cutoff for Buckingham interactions (distance units)\n  buck/coul/cut args = cutoff (cutoff2)\n    cutoff = global cutoff for Buckingham (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  buck/coul/long args = cutoff (cutoff2)\n    cutoff = global cutoff for Buckingham (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  buck/coul/msm args = cutoff (cutoff2)\n    cutoff = global cutoff for Buckingham (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  ",
    "examples": "pair_style buck 2.5\n  pair_coeff * * 100.0 1.5 200.0\n  pair_coeff * * 100.0 1.5 200.0 3.0\n  \n  pair_style buck/coul/cut 10.0\n  pair_style buck/coul/cut 10.0 8.0\n  pair_coeff * * 100.0 1.5 200.0\n  pair_coeff 1 1 100.0 1.5 200.0 9.0\n  pair_coeff 1 1 100.0 1.5 200.0 9.0 8.0\n  \n  pair_style buck/coul/long 10.0\n  pair_style buck/coul/long 10.0 8.0\n  pair_coeff * * 100.0 1.5 200.0\n  pair_coeff 1 1 100.0 1.5 200.0 9.0\n  \n  pair_style buck/coul/msm 10.0\n  pair_style buck/coul/msm 10.0 8.0\n  pair_coeff * * 100.0 1.5 200.0\n  pair_coeff 1 1 100.0 1.5 200.0 9.0\n  \n  \n  ",
    "restrictions": "The buck/coul/long style is part of the KSPACE package.  They are\n  only enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style buck6d/coul/gauss/dsf",
    "description": "The buck6d/coul/gauss styles evaluate vdW and Coulomb\n  interactions following the MOF-FF force field after\n  (Schmid). The vdW term of the buck6d styles\n  computes a dispersion damped Buckingham potential:\n  \n  \\[\\begin{split}E = A e^{-\\kappa r} - \\frac{C}{r^6} \\cdot \\frac{1}{1 + D r^{14}} \\qquad r < r_c \\\\\\end{split}\\]\n  where A and C are a force constant, \\(\\kappa\\) is an ionic-pair dependent\n  reciprocal length parameter, D is a dispersion correction parameter,\n  and the cutoff \\(r_c\\) truncates the interaction distance.\n  The first term in the potential corresponds to the Buckingham\n  repulsion term and the second term to the dispersion attraction with\n  a damping correction analog to the Grimme correction used in DFT.\n  The latter corrects for artifacts occurring at short distances which\n  become an issue for soft vdW potentials.\n  The buck6d styles include a smoothing function which is invoked\n  according to the global smoothing parameter within the specified\n  cutoff.  Hereby a parameter of i.e. 0.9 invokes the smoothing\n  within 90% of the cutoff.  No smoothing is applied at a value\n  of 1.0. For the gauss/dsf style this smoothing is only applicable\n  for the dispersion damped Buckingham potential. For the gauss/long\n  styles the smoothing function can also be invoked for the real\n  space coulomb interactions which enforce continuous energies and\n  forces at the cutoff.\n  Both styles buck6d/coul/gauss/dsf and buck6d/coul/gauss/long\n  evaluate a Coulomb potential using spherical Gaussian type charge\n  distributions which effectively dampen electrostatic interactions\n  for high charges at close distances.  The electrostatic potential\n  is thus evaluated as:\n  \n  \\[E = \\frac{C_{q_i q_j}}{\\epsilon r_{ij}}\\,\\, \\textrm{erf}\\left(\\alpha_{ij} r_{ij}\\right)\\quad\\quad\\quad r < r_c\\]\n  where C is an energy-conversion constant, \\(q_i\\) and \\(q_j\\)\n  are the charges on the 2 atoms, epsilon is the dielectric constant which\n  can be set by the dielectric command, \\(\\alpha\\)\n  is the ion pair dependent damping parameter and erf() is the\n  error-function.  The cutoff \\(r_c\\) truncates the interaction distance.\n  The style buck6d/coul/gauss/dsf computes the Coulomb interaction\n  via the damped shifted force model described in (Fennell)\n  approximating an Ewald sum similar to the pair coul/dsf\n  styles. In buck6d/coul/gauss/long an additional damping factor is\n  applied to the Coulombic term so it can be used in conjunction with the\n  kspace_style command and its ewald or pppm\n  options. The Coulombic cutoff in this case separates the real and\n  reciprocal space evaluation of the Ewald sum.\n  If one cutoff is specified it is used for both the vdW and Coulomb\n  terms.  If two cutoffs are specified, the first is used as the cutoff\n  for the vdW terms, and the second is the cutoff for the Coulombic term.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands:\n  \n  A (energy units)\n  \\(\\rho\\) (distance^-1 units)\n  C (energy-distance^6 units)\n  D (distance^14 units)\n  \\(\\alpha\\) (distance^-1 units)\n  cutoff (distance units)\n  \n  The second coefficient, \\(\\rho\\), must be greater than zero. The\n  latter coefficient is optional.  If not specified, the global vdW cutoff\n  is used.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  These pair styles do not support mixing.  Thus, coefficients for all\n  I,J pairs must be specified explicitly.\n  These styles do not support the pair_modify shift\n  option for the energy. Instead the smoothing function should be applied\n  by setting the global smoothing parameter to a value < 1.0.\n  These styles write their information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  ",
    "syntax": "pair_style style args\n  \n  \n  \n  style = buck6d/coul/gauss/dsf or buck6d/coul/gauss/long\n  args = list of arguments for a particular style\n  \n  buck6d/coul/gauss/dsf args = smooth cutoff (cutoff2)\n    smooth  = smoothing onset within Buckingham cutoff (ratio)\n    cutoff  = global cutoff for Buckingham (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  buck6d/coul/gauss/long args = smooth smooth2 cutoff (cutoff2)\n    smooth   = smoothing onset within Buckingham cutoff (ratio)\n    smooth2  = smoothing onset within Coulombic cutoff (ratio)\n    cutoff   = global cutoff for Buckingham (and Coulombic if only 1 arg) (distance units)\n    cutoff2  = global cutoff for Coulombic (optional) (distance units)\n  ",
    "examples": "pair_style buck6d/coul/gauss/dsf    0.9000    12.0000\n  pair_coeff 1  1  1030.  3.061  457.179  4.521  0.608\n  \n  pair_style buck6d/coul/gauss/long   0.9000  1.0000  12.0000\n  pair_coeff 1  1  1030.  3.061  457.179  4.521  0.608\n  \n  \n  ",
    "restrictions": "These styles are part of the USER-MOFFF package.  They are only\n  enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style buck/long/coul/long",
    "description": "The buck/long/coul/long style computes a Buckingham potential (exp/6\n  instead of Lennard-Jones 12/6) and Coulombic potential, given by\n  \n  \\[\\begin{split}E = & A e^{-r / \\rho} - \\frac{C}{r^6} \\qquad r < r_c \\\\\n  E = & \\frac{C q_i q_j}{\\epsilon  r} \\qquad r < r_c\\end{split}\\]\n  \\(r_c\\) is the cutoff.  If one cutoff is specified in the pair_style\n  command, it is used for both the Buckingham and Coulombic terms.  If\n  two cutoffs are specified, they are used as cutoffs for the Buckingham\n  and Coulombic terms respectively.\n  The purpose of this pair style is to capture long-range interactions\n  resulting from both attractive 1/r^6 Buckingham and Coulombic 1/r\n  interactions.  This is done by use of the flag_buck and flag_coul\n  settings.  The Ismail paper has more details on when it is\n  appropriate to include long-range 1/r^6 interactions, using this\n  potential.\n  If flag_buck is set to long, no cutoff is used on the Buckingham\n  1/r^6 dispersion term.  The long-range portion can be calculated by\n  using the kspace_style ewald/disp or pppm/disp\n  commands.  The specified Buckingham cutoff then determines which\n  portion of the Buckingham interactions are computed directly by the\n  pair potential versus which part is computed in reciprocal space via\n  the Kspace style.  If flag_buck is set to cut, the Buckingham\n  interactions are simply cutoff, as with pair_style buck.\n  If flag_coul is set to long, no cutoff is used on the Coulombic\n  interactions.  The long-range portion can calculated by using any of\n  several kspace_style command options such as\n  pppm or ewald.  Note that if flag_buck is also set to long, then\n  the ewald/disp or pppm/disp Kspace style needs to be used to\n  perform the long-range calculations for both the Buckingham and\n  Coulombic interactions.  If flag_coul is set to off, Coulombic\n  interactions are not computed.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands:\n  \n  A (energy units)\n  rho (distance units)\n  C (energy-distance^6 units)\n  cutoff (distance units)\n  cutoff2 (distance units)\n  \n  The second coefficient, rho, must be greater than zero.\n  The latter 2 coefficients are optional.  If not specified, the global\n  Buckingham and Coulombic cutoffs specified in the pair_style command\n  are used.  If only one cutoff is specified, it is used as the cutoff\n  for both Buckingham and Coulombic interactions for this type pair.  If\n  both coefficients are specified, they are used as the Buckingham and\n  Coulombic cutoffs for this type pair.  Note that if you are using\n  flag_buck set to long, you cannot specify a Buckingham cutoff for\n  an atom type pair, since only one global Buckingham cutoff is allowed.\n  Similarly, if you are using flag_coul set to long, you cannot\n  specify a Coulombic cutoff for an atom type pair, since only one\n  global Coulombic cutoff is allowed.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This pair styles does not support mixing.  Thus, coefficients for all\n  I,J pairs must be specified explicitly.\n  This pair style supports the pair_modify shift\n  option for the energy of the exp() and 1/r^6 portion of the pair\n  interaction, assuming flag_buck is cut.\n  This pair style does not support the pair_modify\n  shift option for the energy of the Buckingham portion of the pair\n  interaction.\n  This pair style supports the pair_modify table and\n  table/disp options since they can tabulate the short-range portion of\n  the long-range Coulombic and dispersion interactions.\n  This pair style write its information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  This pair style supports the use of the inner, middle, and outer\n  keywords of the run_style respa command, meaning the\n  pairwise forces can be partitioned by distance at different levels of\n  the rRESPA hierarchy.  See the run_style command for\n  details.\n  ",
    "syntax": "pair_style buck/long/coul/long flag_buck flag_coul cutoff (cutoff2)\n  \n  \n  \n  flag_buck = long or cut\n  long = use Kspace long-range summation for the dispersion term 1/r^6\n  cut = use a cutoff\n  \n  flag_coul = long or off\n  long = use Kspace long-range summation for the Coulombic term 1/r\n  off = omit the Coulombic term\n  \n  cutoff = global cutoff for Buckingham (and Coulombic if only 1 cutoff) (distance units)\n  cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  \n  ",
    "examples": "pair_style buck/long/coul/long cut off 2.5\n  pair_style buck/long/coul/long cut long 2.5 4.0\n  pair_style buck/long/coul/long long long 4.0\n  pair_coeff * * 1 1\n  pair_coeff 1 1 1 3 4\n  \n  \n  ",
    "restrictions": "This style is part of the KSPACE package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style lj/charmm/coul/charmm",
    "description": "These pair styles compute Lennard Jones (LJ) and Coulombic\n  interactions with additional switching or shifting functions that ramp\n  the energy and/or force smoothly to zero between an inner and outer\n  cutoff.  They are implementations of the widely used CHARMM force\n  field used in the CHARMM MD code (and\n  others).  See (MacKerell) for a description of the\n  CHARMM force field.\n  The styles with charmm (not charmmfsw or charmmfsh) in their\n  name are the older, original LAMMPS implementations.  They compute the\n  LJ and Coulombic interactions with an energy switching function (esw,\n  shown in the formula below as S(r)), which ramps the energy smoothly\n  to zero between the inner and outer cutoff.  This can cause\n  irregularities in pair-wise forces (due to the discontinuous 2nd\n  derivative of energy at the boundaries of the switching region), which\n  in some cases can result in detectable artifacts in an MD simulation.\n  The newer styles with charmmfsw or charmmfsh in their name replace\n  the energy switching with force switching (fsw) and force shifting\n  (fsh) functions, for LJ and Coulombic interactions respectively.\n  These follow the formulas and description given in\n  (Steinbach) and (Brooks) to minimize these\n  artifacts.\n  \n  Note\n  The newer charmmfsw or charmmfsh styles were released in\n  March 2017.  We recommend they be used instead of the older charmm\n  styles.  This includes the newer dihedral_style charmmfsw command.  Eventually code from the new\n  styles will propagate into the related pair styles (e.g. implicit,\n  accelerator, free energy variants).\n  \n  \n  Note\n  The newest CHARMM pair styles reset the Coulombic energy\n  conversion factor used internally in the code, from the LAMMPS value\n  to the CHARMM value, as if it were effectively a parameter of the\n  force field.  This is because the CHARMM code uses a slightly\n  different value for the this conversion factor in real units (Kcal/mole), namely CHARMM = 332.0716, LAMMPS =\n  332.06371.  This is to enable more precise agreement by LAMMPS with\n  the CHARMM force field energies and forces, when using one of these\n  two CHARMM pair styles.\n  \n  \n  \\[\\begin{split}E = & LJ(r) \\qquad \\qquad \\qquad r < r_{\\rm in} \\\\\n    = & S(r) * LJ(r) \\qquad \\qquad r_{\\rm in} < r < r_{\\rm out} \\\\\n    = & 0 \\qquad \\qquad \\qquad \\qquad r > r_{\\rm out} \\\\\n  E = & C(r) \\qquad \\qquad \\qquad r < r_{\\rm in} \\\\\n    = & S(r) * C(r) \\qquad \\qquad r_{\\rm in} < r < r_{\\rm out} \\\\\n    = & 0 \\qquad \\qquad \\qquad \\qquad r > r_{\\rm out} \\\\\n  LJ(r) = & 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -\n          \\left(\\frac{\\sigma}{r}\\right)^6 \\right] \\\\\n  C(r) = & \\frac{C q_i q_j}{ \\epsilon r} \\\\\n  S(r) = & \\frac{ \\left[r_{\\rm out}^2 - r^2\\right]^2\n    \\left[r_{\\rm out}^2 + 2r^2 - 3{r_{\\rm in}^2}\\right]}\n  { \\left[r_{\\rm out}^2 - {r_{\\rm in}}^2\\right]^3 }\\end{split}\\]\n  where S(r) is the energy switching function mentioned above for the\n  charmm styles.  See the (Steinbach) paper for the\n  functional forms of the force switching and force shifting functions\n  used in the charmmfsw and charmmfsh styles.\n  When using the lj/charmm/coul/charmm styles, both the LJ and\n  Coulombic terms require an inner and outer cutoff. They can be the\n  same for both formulas or different depending on whether 2 or 4\n  arguments are used in the pair_style command.  For the\n  lj/charmmfsw/coul/charmmfsh style, the LJ term requires both an\n  inner and outer cutoff, while the Coulombic term requires only one\n  cutoff.  If the Coulombic cutoff is not specified (2 instead of 3\n  arguments), the LJ outer cutoff is used for the Coulombic cutoff.  In\n  all cases where an inner and outer cutoff are specified, the inner\n  cutoff distance must be less than the outer cutoff.  It is typical to\n  make the difference between the inner and outer cutoffs about 2.0\n  Angstroms.\n  Style lj/charmm/coul/charmm/implicit computes the same formulas as\n  style lj/charmm/coul/charmm except that an additional 1/r term is\n  included in the Coulombic formula.  The Coulombic energy thus varies\n  as 1/r^2.  This is effectively a distance-dependent dielectric term\n  which is a simple model for an implicit solvent with additional\n  screening.  It is designed for use in a simulation of an unsolvated\n  biomolecule (no explicit water molecules).\n  Styles lj/charmm/coul/long and lj/charmm/coul/msm compute the same\n  formulas as style lj/charmm/coul/charmm and style\n  lj/charmmfsw/coul/long computes the same formulas as style\n  lj/charmmfsw/coul/charmmfsh, except that an additional damping\n  factor is applied to the Coulombic term, so it can be used in\n  conjunction with the kspace_style command and its\n  ewald or pppm or msm option.  Only one Coulombic cutoff is\n  specified for these styles; if only 2 arguments are used in the\n  pair_style command, then the outer LJ cutoff is used as the single\n  Coulombic cutoff.  The Coulombic cutoff specified for these styles\n  means that pairwise interactions within this distance are computed\n  directly; interactions outside that distance are computed in\n  reciprocal space.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands, or by mixing as described below:\n  \n  \\(\\epsilon\\) (energy units)\n  \\(\\sigma\\) (distance units)\n  \\(\\epsilon_{14}\\) (energy units)\n  \\(\\sigma_{14}\\) (distance units)\n  \n  Note that \\(\\sigma\\) is defined in the LJ formula as the zero-crossing\n  distance for the potential, not as the energy minimum at \\(2^{1/6} \\sigma\\).\n  The latter 2 coefficients are optional.  If they are specified, they\n  are used in the LJ formula between 2 atoms of these types which are\n  also first and fourth atoms in any dihedral.  No cutoffs are specified\n  because the CHARMM force field does not allow varying cutoffs for\n  individual atom pairs; all pairs use the global cutoff(s) specified in\n  the pair_style command.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the epsilon, sigma, epsilon_14,\n  and sigma_14 coefficients for all of the lj/charmm pair styles can be\n  mixed.  The default mix value is arithmetic to coincide with the\n  usual settings for the CHARMM force field.  See the “pair_modify”\n  command for details.\n  None of the lj/charmm or lj/charmmfsw pair styles support the\n  pair_modify shift option, since the Lennard-Jones\n  portion of the pair interaction is smoothed to 0.0 at the cutoff.\n  The lj/charmm/coul/long and lj/charmmfsw/coul/long styles support\n  the pair_modify table option since they can\n  tabulate the short-range portion of the long-range Coulombic\n  interaction.\n  None of the lj/charmm or lj/charmmfsw pair styles support the\n  pair_modify tail option for adding long-range tail\n  corrections to energy and pressure, since the Lennard-Jones portion of\n  the pair interaction is smoothed to 0.0 at the cutoff.\n  All of the lj/charmm and lj/charmmfsw pair styles write their\n  information to binary restart files, so pair_style and\n  pair_coeff commands do not need to be specified in an input script\n  that reads a restart file.\n  The lj/charmm/coul/long and lj/charmmfsw/coul/long pair styles\n  support the use of the inner, middle, and outer keywords of the\n  run_style respa command, meaning the pairwise forces\n  can be partitioned by distance at different levels of the rRESPA\n  hierarchy.  The other styles only support the pair keyword of\n  run_style respa.  See the run_style command for\n  details.\n  ",
    "syntax": "pair_style style args\n  \n  \n  \n  style = lj/charmm/coul/charmm or lj/charmm/coul/charmm/implicit or lj/charmm/coul/long or lj/charmm/coul/msm or lj/charmmfsw/coul/charmmfsh or lj/charmmfsw/coul/long\n  args = list of arguments for a particular style\n  \n  lj/charmm/coul/charmm args = inner outer (inner2) (outer2)\n    inner, outer = global switching cutoffs for Lennard Jones (and Coulombic if only 2 args)\n    inner2, outer2 = global switching cutoffs for Coulombic (optional)\n  lj/charmm/coul/charmm/implicit args = inner outer (inner2) (outer2)\n    inner, outer = global switching cutoffs for LJ (and Coulombic if only 2 args)\n    inner2, outer2 = global switching cutoffs for Coulombic (optional)\n  lj/charmm/coul/long args = inner outer (cutoff)\n    inner, outer = global switching cutoffs for LJ (and Coulombic if only 2 args)\n    cutoff = global cutoff for Coulombic (optional, outer is Coulombic cutoff if only 2 args)\n  lj/charmm/coul/msm args = inner outer (cutoff)\n    inner, outer = global switching cutoffs for LJ (and Coulombic if only 2 args)\n    cutoff = global cutoff for Coulombic (optional, outer is Coulombic cutoff if only 2 args)\n  lj/charmmfsw/coul/charmmfsh args = inner outer (cutoff)\n    inner, outer = global cutoffs for LJ (and Coulombic if only 2 args)\n    cutoff = global cutoff for Coulombic (optional, outer is Coulombic cutoff if only 2 args)\n  lj/charmmfsw/coul/long args = inner outer (cutoff)\n    inner, outer = global cutoffs for LJ (and Coulombic if only 2 args)\n    cutoff = global cutoff for Coulombic (optional, outer is Coulombic cutoff if only 2 args)\n  ",
    "examples": "pair_style lj/charmm/coul/charmm 8.0 10.0\n  pair_style lj/charmm/coul/charmm 8.0 10.0 7.0 9.0\n  pair_style lj/charmmfsw/coul/charmmfsh 10.0 12.0\n  pair_style lj/charmmfsw/coul/charmmfsh 10.0 12.0 9.0\n  pair_coeff * * 100.0 2.0\n  pair_coeff 1 1 100.0 2.0 150.0 3.5\n  \n  pair_style lj/charmm/coul/charmm/implicit 8.0 10.0\n  pair_style lj/charmm/coul/charmm/implicit 8.0 10.0 7.0 9.0\n  pair_coeff * * 100.0 2.0\n  pair_coeff 1 1 100.0 2.0 150.0 3.5\n  \n  pair_style lj/charmm/coul/long 8.0 10.0\n  pair_style lj/charmm/coul/long 8.0 10.0 9.0\n  pair_style lj/charmmfsw/coul/long 8.0 10.0\n  pair_style lj/charmmfsw/coul/long 8.0 10.0 9.0\n  pair_coeff * * 100.0 2.0\n  pair_coeff 1 1 100.0 2.0 150.0 3.5\n  \n  pair_style lj/charmm/coul/msm 8.0 10.0\n  pair_style lj/charmm/coul/msm 8.0 10.0 9.0\n  pair_coeff * * 100.0 2.0\n  pair_coeff 1 1 100.0 2.0 150.0 3.5\n  \n  \n  ",
    "restrictions": "All the styles with coul/charmm or coul/charmmfsh styles are part\n  of the MOLECULE package.  All the styles with coul/long style are\n  part of the KSPACE package.  They are only enabled if LAMMPS was built\n  with those packages.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "pair_style lj/class2",
    "description": "The lj/class2 styles compute a 6/9 Lennard-Jones potential given by\n  \n  \\[E = \\epsilon \\left[ 2 \\left(\\frac{\\sigma}{r}\\right)^9 -\n    3 \\left(\\frac{\\sigma}{r}\\right)^6 \\right]\n  \\qquad r < r_c\\]\n  \\(r_c\\) is the cutoff.\n  The lj/class2/coul/cut and lj/class2/coul/long styles add a\n  Coulombic term as described for the lj/cut pair styles.\n  See (Sun) for a description of the COMPASS class2 force field.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands, or by mixing as described below:\n  \n  \\(\\epsilon\\) (energy units)\n  \\(\\sigma\\) (distance units)\n  cutoff1 (distance units)\n  cutoff2 (distance units)\n  \n  The latter 2 coefficients are optional.  If not specified, the global\n  class 2 and Coulombic cutoffs are used.  If only one cutoff is\n  specified, it is used as the cutoff for both class 2 and Coulombic\n  interactions for this type pair.  If both coefficients are specified,\n  they are used as the class 2 and Coulombic cutoffs for this type pair.\n  You cannot specify 2 cutoffs for style lj/class2, since it has no\n  Coulombic terms.\n  For lj/class2/coul/long only the class 2 cutoff can be specified\n  since a Coulombic cutoff cannot be specified for an individual I,J\n  type pair.  All type pairs use the same global Coulombic cutoff\n  specified in the pair_style command.\n  \n  If the pair_coeff command is not used to define coefficients for a\n  particular I != J type pair, the mixing rule for \\(\\epsilon\\) and\n  \\(\\sigma\\) for all class2 potentials is to use the sixthpower\n  formulas documented by the pair_modify command.\n  The pair_modify mix setting is thus ignored for\n  class2 potentials for epsilon and sigma.  However it is still followed\n  for mixing the cutoff distance.\n  \n  A version of these styles with a soft core, lj/cut/soft, suitable for use in\n  free energy calculations, is part of the USER-FEP package and is documented with\n  the pair_style */soft styles. The version with soft core is\n  only available if LAMMPS was built with that package. See the Build package doc page for more info.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the epsilon and sigma coefficients\n  and cutoff distance for all of the lj/class2 pair styles can be mixed.\n  Epsilon and sigma are always mixed with the value sixthpower.  The\n  cutoff distance is mixed by whatever option is set by the pair_modify\n  command (default = geometric).  See the “pair_modify” command for\n  details.\n  All of the lj/class2 pair styles support the\n  pair_modify shift option for the energy of the\n  Lennard-Jones portion of the pair interaction.\n  The lj/class2/coul/long pair style does not support the\n  pair_modify table option since a tabulation\n  capability has not yet been added to this potential.\n  All of the lj/class2 pair styles support the\n  pair_modify tail option for adding a long-range\n  tail correction to the energy and pressure of the Lennard-Jones\n  portion of the pair interaction.\n  All of the lj/class2 pair styles write their information to binary restart files, so pair_style and pair_coeff commands do\n  not need to be specified in an input script that reads a restart file.\n  Only the lj/class2 and lj/class2/coul/long pair styles support the use of the\n  inner, middle, and outer keywords of the run_style respa command, meaning the pairwise forces can be\n  partitioned by distance at different levels of the rRESPA hierarchy.\n  The other styles only support the pair keyword of run_style respa.\n  See the run_style command for details.\n  ",
    "syntax": "pair_style style args\n  \n  \n  \n  style = lj/class2 or lj/class2/coul/cut or lj/class2/coul/long\n  args = list of arguments for a particular style\n  \n  lj/class2 args = cutoff\n    cutoff = global cutoff for class 2 interactions (distance units)\n  lj/class2/coul/cut args = cutoff (cutoff2)\n    cutoff = global cutoff for class 2 (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  lj/class2/coul/long args = cutoff (cutoff2)\n    cutoff = global cutoff for class 2 (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  ",
    "examples": "pair_style lj/class2 10.0\n  pair_coeff * * 100.0 2.5\n  pair_coeff 1 2* 100.0 2.5 9.0\n  \n  pair_style lj/class2/coul/cut 10.0\n  pair_style lj/class2/coul/cut 10.0 8.0\n  pair_coeff * * 100.0 3.0\n  pair_coeff 1 1 100.0 3.5 9.0\n  pair_coeff 1 1 100.0 3.5 9.0 9.0\n  \n  pair_style lj/class2/coul/long 10.0\n  pair_style lj/class2/coul/long 10.0 8.0\n  pair_coeff * * 100.0 3.0\n  pair_coeff 1 1 100.0 3.5 9.0\n  \n  \n  ",
    "restrictions": "These styles are part of the CLASS2 package.  They are only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style colloid",
    "description": "Style colloid computes pairwise interactions between large colloidal\n  particles and small solvent particles using 3 formulas.  A colloidal\n  particle has a size > sigma; a solvent particle is the usual\n  Lennard-Jones particle of size sigma.\n  The colloid-colloid interaction energy is given by\n  \n  \\[\\begin{split} U_A = & - \\frac{A_{cc}}{6} \\left[\n   \\frac{2 a_1 a_2}{r^2-\\left(a_1+a_2\\right)^2}\n   + \\frac{2 a_1 a_2}{r^2 - \\left(a_1 - a_2\\right)^2}\n     + \\mathrm{ln}\n       \\left(\n  \\frac{r^2-\\left(a_1+a_2\\right)^2}{r^2-\\left(a_1-a_2\\right)^2}\n   \\right)\n  \\right] \\\\\n    & \\\\\n    U_R = & \\frac{A_{cc}}{37800}  \\frac{\\sigma^6}{r}\n    \\biggl[ \\frac{r^2-7r\\left(a_1+a_2\\right)+6\\left(a_1^2+7a_1a_2+a_2^2\\right)}\n  {\\left(r-a_1-a_2\\right)^7} \\\\\n   &\\qquad              +\\frac{r^2+7r\\left(a_1+a_2\\right)+6\\left(a_1^2+7a_1a_2+a_2^2\\right)}\n  {\\left(r+a_1+a_2\\right)^7}  \\\\\n  &\\qquad               -\\frac{r^2+7r\\left(a_1-a_2\\right)+6\\left(a_1^2-7a_1a_2+a_2^2\\right)}\n  {\\left(r+a_1-a_2\\right)^7} \\\\\n  &\\qquad       \\left.  -\\frac{r^2-7r\\left(a_1-a_2\\right)+6\\left(a_1^2-7a_1a_2+a_2^2\\right)}\n  {\\left(r-a_1+a_2\\right)^7}\n  \\right]  \\\\\n  & \\\\\n  U = & U_A + U_R, \\qquad r < r_c\\end{split}\\]\n  where \\(A_{cc}\\) is the Hamaker constant, \\(a_1\\) and \\(a_2\\) are the\n  radii of the two colloidal particles, and \\(r_c\\) is the cutoff.  This\n  equation results from describing each colloidal particle as an\n  integrated collection of Lennard-Jones particles of size sigma and is\n  derived in (Everaers).\n  The colloid-solvent interaction energy is given by\n  \n  \\[U = \\frac{2 ~ a^3 ~ \\sigma^3 ~ A_{cs}}{9 \\left( a^2 - r^2 \\right)^3}\n  \\left[ 1 - \\frac{\\left(5 ~ a^6+45~a^4~r^2+63~a^2~r^4+15~r^6\\right) \\sigma^6}\n  {15 \\left(a-r\\right)^6 \\left( a+r \\right)^6} \\right], \\quad r < r_c\\]\n  where :math:A_{cs}` is the Hamaker constant, a is the radius of the colloidal\n  particle, and \\(r_c\\) is the cutoff.  This formula is derived from the\n  colloid-colloid interaction, letting one of the particle sizes go to\n  zero.\n  The solvent-solvent interaction energy is given by the usual\n  Lennard-Jones formula\n  \n  \\[U = \\frac{A_{ss}}{36} \\left[ \\left( \\frac{\\sigma}{r}\n       \\right)^{12} - \\left( \\frac{ \\sigma}{r} \\right)^6 \\right], \\quad\n       r < r_c\\]\n  with \\(A_{ss}\\) set appropriately, which results from letting both\n  particle sizes go to zero.\n  When used in combination with pair_style yukawa/colloid, the two terms become the so-called DLVO potential,\n  which combines electrostatic repulsion and van der Waals attraction.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands, or by mixing as described below:\n  \n  A (energy units)\n  \\(\\sigma\\) (distance units)\n  d1 (distance units)\n  d2 (distance units)\n  cutoff (distance units)\n  \n  A is the Hamaker energy prefactor and should typically be set as\n  follows:\n  \n  \\(A_{cc}\\) = colloid/colloid = \\(4 \\pi^2 = 39.5\\)\n  \\(A_{cs}\\) = colloid/solvent = \\(\\sqrt{A_{cc} A_{ss}}\\)\n  \\(A_{ss}\\) = solvent/solvent = 144 (assuming epsilon = 1, so that 144/36 = 4)\n  \n  \\(\\sigma\\) is the size of the solvent particle or the constituent\n  particles integrated over in the colloidal particle and should typically\n  be set as follows:\n  \n  \\(\\sigma_{cc}\\) = colloid/colloid = 1.0\n  \\(\\sigma_{cs}\\) = colloid/solvent = arithmetic mixing between colloid \\(\\sigma\\) and solvent \\(\\sigma\\)\n  \\(\\sigma_{ss}\\) = solvent/solvent = 1.0 or whatever size the solvent particle is\n  \n  Thus typically \\(\\sigma_{cs} = 1.0\\), unless the solvent particle’s size !=\n  1.0.\n  D1 and d2 are particle diameters, so that d1 = 2*a1 and d2 = 2*a2 in\n  the formulas above.  Both d1 and d2 must be values >= 0.  If d1 > 0\n  and d2 > 0, then the pair interacts via the colloid-colloid formula\n  above.  If d1 = 0 and d2 = 0, then the pair interacts via the\n  solvent-solvent formula.  I.e. a d value of 0 is a Lennard-Jones\n  particle of size \\(\\sigma\\).  If either d1 = 0 or d2 = 0 and the other is\n  larger, then the pair interacts via the colloid-solvent formula.\n  Note that the diameter of a particular particle type may appear in\n  multiple pair_coeff commands, as it interacts with other particle\n  types.  You should insure the particle diameter is specified\n  consistently each time it appears.\n  The last coefficient is optional.  If not specified, the global cutoff\n  specified in the pair_style command is used.  However, you typically\n  want different cutoffs for interactions between different particle\n  sizes.  E.g. if colloidal particles of diameter 10 are used with\n  solvent particles of diameter 1, then a solvent-solvent cutoff of 2.5\n  would correspond to a colloid-colloid cutoff of 25.  A good\n  rule-of-thumb is to use a colloid-solvent cutoff that is half the big\n  diameter + 4 times the small diameter.  I.e. 9 = 5 + 4 for the\n  colloid-solvent cutoff in this case.\n  \n  Note\n  When using pair_style colloid for a mixture with 2 (or more)\n  widely different particles sizes (e.g. sigma=10 colloids in a\n  background sigma=1 LJ fluid), you will likely want to use these\n  commands for efficiency: neighbor multi and\n  comm_modify multi.\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the A, sigma, d1, and d2\n  coefficients and cutoff distance for this pair style can be mixed.  A\n  is an energy value mixed like a LJ epsilon.  D1 and d2 are distance\n  values and are mixed like sigma.  The default mix value is\n  geometric.  See the “pair_modify” command for details.\n  This pair style supports the pair_modify shift\n  option for the energy of the pair interaction.\n  The pair_modify table option is not relevant\n  for this pair style.\n  This pair style does not support the pair_modify\n  tail option for adding long-range tail corrections to energy and\n  pressure.\n  This pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style colloid cutoff\n  \n  \n  \n  cutoff = global cutoff for colloidal interactions (distance units)\n  \n  ",
    "examples": "pair_style colloid 10.0\n  pair_coeff * *  25 1.0 10.0 10.0\n  pair_coeff 1 1 144 1.0 0.0 0.0 3.0\n  pair_coeff 1 2  75.398 1.0 0.0 10.0 9.0\n  pair_coeff 2 2  39.478 1.0 10.0 10.0 25.0\n  \n  \n  ",
    "restrictions": "This style is part of the COLLOID package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  Normally, this pair style should be used with finite-size particles\n  which have a diameter, e.g. see the atom_style sphere command.  However, this is not a requirement,\n  since the only definition of particle size is via the pair_coeff\n  parameters for each type.  In other words, the physical radius of the\n  particle is ignored.  Thus you should insure that the d1,d2 parameters\n  you specify are consistent with the physical size of the particles of\n  that type.\n  Per-particle polydispersity is not yet supported by this pair style;\n  only per-type polydispersity is enabled via the pair_coeff parameters.\n  "
},
{
    "command": "pair_style comb",
    "description": "Style comb computes the second-generation variable charge COMB\n  (Charge-Optimized Many-Body) potential.  Style comb3 computes the\n  third-generation COMB potential.  These COMB potentials are described\n  in (COMB) and (COMB3).  Briefly, the\n  total energy \\(E_T\\) of a system of atoms is given by\n  \n  \\[\\begin{split}E_T  = & \\sum_i [ E_i^{self} (q_i) + \\sum_{j>i} [E_{ij}^{short} (r_{ij}, q_i, q_j) + E_{ij}^{Coul} (r_{ij}, q_i, q_j)] + \\\\\n         & E^{polar} (q_i, r_{ij}) + E^{vdW} (r_{ij}) + E^{barr} (q_i) + E^{corr} (r_{ij}, \\theta_{jik})]\\end{split}\\]\n  where \\(E_i^{self}\\) is the self-energy of atom i (including\n  atomic ionization energies and electron affinities),\n  \\(E_{ij}^{short}\\) is the bond-order potential between atoms i and\n  j, \\(E_{ij}^{Coul}\\) is the Coulomb interactions,\n  \\(E^{polar}\\) is the polarization term for organic systems (style\n  comb3 only), \\(E^{vdW}\\) is the van der Waals energy (style\n  comb3 only), \\(E^{barr}\\) is a charge barrier function, and\n  \\(E^{corr}\\) are angular correction terms.\n  The COMB potentials (styles comb and comb3) are variable charge\n  potentials.  The equilibrium charge on each atom is calculated by the\n  electronegativity equalization (QEq) method.  See Rick for\n  further details.  This is implemented by the fix qeq/comb command, which should normally be\n  specified in the input script when running a model with the COMB\n  potential.  The fix qeq/comb command has options\n  that determine how often charge equilibration is performed, its\n  convergence criterion, and which atoms are included in the\n  calculation.\n  Only a single pair_coeff command is used with the comb and comb3\n  styles which specifies the COMB potential file with parameters for all\n  needed elements.  These are mapped to LAMMPS atom types by specifying\n  N additional arguments after the potential file in the pair_coeff\n  command, where N is the number of LAMMPS atom types.\n  For example, if your LAMMPS simulation of a Si/SiO2/\n  HfO2 interface has 4 atom types, and you want the 1st and\n  last to be Si, the 2nd to be Hf, and the 3rd to be O, and you would\n  use the following pair_coeff command:\n  pair_coeff * * ../potentials/ffield.comb Si Hf O Si\n  \n  \n  The first two arguments must be * * so as to span all LAMMPS atom\n  types.  The first and last Si arguments map LAMMPS atom types 1 and 4\n  to the Si element in the ffield.comb file.  The second Hf argument\n  maps LAMMPS atom type 2 to the Hf element, and the third O argument\n  maps LAMMPS atom type 3 to the O element in the potential file.  If a\n  mapping value is specified as NULL, the mapping is not performed.\n  This can be used when a comb potential is used as part of the\n  hybrid pair style.  The NULL values are placeholders for atom types\n  that will be used with other potentials.\n  For style comb, the provided potential file ffield.comb contains\n  all currently-available 2nd generation COMB parameterizations: for Si,\n  Cu, Hf, Ti, O, their oxides and Zr, Zn and U metals.  For style\n  comb3, the potential file ffield.comb3 contains all\n  currently-available 3rd generation COMB parameterizations: O, Cu, N, C,\n  H, Ti, Zn and Zr.  The status of the optimization of the compounds, for\n  example Cu2O, TiN and hydrocarbons, are given in the\n  following table:\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  O\n  Cu\n  N\n  C\n  H\n  Ti\n  Zn\n  Zr\n  \n  O\n  F\n  F\n  F\n  F\n  F\n  F\n  F\n  F\n  \n  Cu\n  F\n  F\n  P\n  F\n  F\n  P\n  F\n  P\n  \n  N\n  F\n  P\n  F\n  M\n  F\n  P\n  P\n  P\n  \n  C\n  F\n  F\n  M\n  F\n  F\n  M\n  M\n  M\n  \n  H\n  F\n  F\n  F\n  F\n  F\n  M\n  M\n  F\n  \n  Ti\n  F\n  P\n  P\n  M\n  M\n  F\n  P\n  P\n  \n  Zn\n  F\n  F\n  P\n  M\n  M\n  P\n  F\n  P\n  \n  Zr\n  F\n  P\n  P\n  M\n  F\n  P\n  P\n  F\n  \n  \n  \n  \n  F = Fully optimized\n  M = Only optimized for dimer molecule\n  P = in progress, but have it from mixing rule\n  \n  For style comb3, in addition to ffield.comb3, a special parameter\n  file, lib.comb3, that is exclusively used for C/O/H systems, will be\n  automatically loaded if carbon atom is detected in LAMMPS input\n  structure.  This file must be in your working directory or in the\n  directory pointed to by the environment variable LAMMPS_POTENTIALS, as\n  described on the pair_coeff command doc page.\n  Keyword polar indicates whether the force field includes\n  the atomic polarization.  Since the equilibration of the polarization\n  has not yet been implemented, it can only set polar_off at present.\n  \n  Note\n  You can not use potential file ffield.comb with style comb3,\n  nor file ffield.comb3 with style comb.\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, where types I and J correspond to\n  two different element types, mixing is performed by LAMMPS as\n  described above from values in the potential file.\n  These pair styles does not support the pair_modify\n  shift, table, and tail options.\n  These pair styles do not write its information to binary restart files, since it is stored in potential files.  Thus, you\n  need to re-specify the pair_style, pair_coeff, and fix qeq/comb commands in an input script that reads a\n  restart file.\n  These pair styles can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style comb\n  pair_style comb3 keyword\n  \n  \n  keyword = polar\n    polar value = polar_on or polar_off = whether or not to include atomic polarization\n  ",
    "examples": "pair_style comb\n  pair_coeff * * ../potentials/ffield.comb Si\n  pair_coeff * * ../potentials/ffield.comb Hf Si O\n  \n  pair_style comb3 polar_off\n  pair_coeff * * ../potentials/ffield.comb3 O Cu N C O\n  \n  \n  ",
    "restrictions": "These pair styles are part of the MANYBODY package.  It is only\n  enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\n  These pair styles requires the newton setting to be “on”\n  for pair interactions.\n  The COMB potentials in the ffield.comb and ffield.comb3 files provided\n  with LAMMPS (see the potentials directory) are parameterized for metal\n  units.  You can use the COMB potential with any LAMMPS\n  units, but you would need to create your own COMB potential file with\n  coefficients listed in the appropriate units if your simulation\n  does not use “metal” units.\n  "
},
{
    "command": "pair_style cosine/squared",
    "description": "Style cosine/squared computes a potential of the form\n  \n  \\[\\begin{split}E =\n  \\begin{cases}\n  -\\epsilon& \\quad r < \\sigma \\\\\n  -\\epsilon\\cos\\left(\\frac{\\pi\\left(r - \\sigma\\right)}{2\\left(r_c - \\sigma\\right)}\\right)&\\quad \\sigma \\leq r < r_c \\\\\n  0& \\quad r \\geq r_c\n  \\end{cases}\\end{split}\\]\n  between two point particles, where (\\(\\sigma, -\\epsilon\\)) is the\n  location of the (rightmost) minimum of the potential, as explained in\n  the syntax section above.\n  This potential was first used in (Cooke)_#CKD for a coarse-grained lipid\n  membrane model.  It is generally very useful as a non-specific\n  interaction potential because it is fully adjustable in depth and width\n  while joining the minimum at (sigma, -epsilon) and zero at (cutoff, 0)\n  smoothly, requiring no shifting and causing no related artifacts, tail\n  energy calculations etc. This evidently requires cutoff to be larger\n  than sigma.\n  If the wca option is used then a Weeks-Chandler-Andersen potential\n  (Weeks)_#WCA is added to the above specified cosine-squared potential,\n  specifically the following:\n  \n  \\[E = \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -\n                        2\\left(\\frac{\\sigma}{r}\\right)^6 + 1\\right]\n                        , \\quad r < \\sigma\\]\n  In this case, and this case only, the \\(\\sigma\\) parameter can be equal to\n  cutoff (\\(\\sigma =\\) cutoff) which will result in ONLY the WCA potential\n  being used (and print a warning), so the minimum will be attained at\n  (sigma, 0). This is a convenience feature that enables a purely\n  repulsive potential to be used without a need to define an additional\n  pair style and use the hybrid styles.\n  The energy and force of this pair style for parameters epsilon = 1.0,\n  sigma = 1.0, cutoff = 2.5, with and without the WCA potential, are shown\n  in the graphs below:\n  \n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  Mixing is not supported for this style.\n  The shift, table and tail options are not relevant for this style.\n  This pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  These pair styles can only be used via the pair keyword of the\n  run_style respa command.  They do not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style cosine/squared cutoff\n  \n  \n  \n  cutoff = global cutoff for cosine-squared interactions (distance units)\n  \n  pair_coeff i j eps sigma\n  pair_coeff i j eps sigma cutoff\n  pair_coeff i j eps sigma wca\n  pair_coeff i j eps sigma cutoff wca\n  \n  \n  \n  i,j = a particle type\n  eps = interaction strength, i.e. the depth of the potential minimum (energy units)\n  sigma = distance of the potential minimum from 0\n  cutoff = the cutoff distance for this pair type, if different from global (distance units)\n  wca = if specified a Weeks-Chandler-Andersen potential (with eps strength and minimum at sigma) is added, otherwise not\n  \n  ",
    "examples": "pair_style cosine/squared 3.0\n  pair_coeff * * 1.0 1.3\n  pair_coeff 1 3 1.0 1.3 2.0\n  pair_coeff 1 3 1.0 1.3 wca\n  pair_coeff 1 3 1.0 1.3 2.0 wca\n  \n  \n  ",
    "restrictions": "The cosine/squared style is part of the “USER-MISC” package. It is only\n  enabled if LAMMPS is build with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style coul/cut",
    "description": "The coul/cut style computes the standard Coulombic interaction\n  potential given by\n  \n  \\[E = \\frac{C q_i q_j}{\\epsilon  r} \\qquad r < r_c\\]\n  where C is an energy-conversion constant, Qi and Qj are the charges on\n  the 2 atoms, and \\(\\epsilon\\) is the dielectric constant which can be set\n  by the dielectric command.  The cutoff \\(r_c\\) truncates\n  the interaction distance.\n  \n  Style coul/debye adds an additional exp() damping factor to the\n  Coulombic term, given by\n  \n  \\[E = \\frac{C q_i q_j}{\\epsilon  r} \\exp(- \\kappa r) \\qquad r < r_c\\]\n  where \\(\\kappa\\) is the Debye length.  This potential is another way to\n  mimic the screening effect of a polar solvent.\n  \n  Style coul/dsf computes Coulombic interactions via the damped\n  shifted force model described in Fennell, given by:\n  \n  \\[E = q_iq_j \\left[ \\frac{\\mbox{erfc} (\\alpha r)}{r} -  \\frac{\\mbox{erfc} (\\alpha r_c)}{r_c} +\n  \\left( \\frac{\\mbox{erfc} (\\alpha r_c)}{r_c^2} +  \\frac{2\\alpha}{\\sqrt{\\pi}}\\frac{\\exp (-\\alpha^2    r^2_c)}{r_c} \\right)(r-r_c) \\right] \\qquad r < r_c\\]\n  where \\(\\alpha\\) is the damping parameter and erfc() is the\n  complementary error-function. The potential corrects issues in the\n  Wolf model (described below) to provide consistent forces and energies\n  (the Wolf potential is not differentiable at the cutoff) and smooth\n  decay to zero.\n  \n  Style coul/wolf computes Coulombic interactions via the Wolf\n  summation method, described in Wolf, given by:\n  \n  \\[E_i = \\frac{1}{2} \\sum_{j \\neq i}\n  \\frac{q_i q_j {\\rm erfc}(\\alpha r_{ij})}{r_{ij}} +\n  \\frac{1}{2} \\sum_{j \\neq i}\n  \\frac{q_i q_j {\\rm erf}(\\alpha r_{ij})}{r_{ij}} \\qquad r < r_c\\]\n  where \\(\\alpha\\) is the damping parameter, and erc() and erfc() are\n  error-function and complementary error-function terms.  This potential\n  is essentially a short-range, spherically-truncated,\n  charge-neutralized, shifted, pairwise 1/r summation.  With a\n  manipulation of adding and subtracting a self term (for i = j) to the\n  first and second term on the right-hand-side, respectively, and a\n  small enough \\(\\alpha\\) damping parameter, the second term shrinks and\n  the potential becomes a rapidly-converging real-space summation.  With\n  a long enough cutoff and small enough \\(\\alpha\\) parameter, the energy and\n  forces calculated by the Wolf summation method approach those of the\n  Ewald sum.  So it is a means of getting effective long-range\n  interactions with a short-range potential.\n  \n  Style coul/streitz is the Coulomb pair interaction defined as part\n  of the Streitz-Mintmire potential, as described in this paper, in which charge distribution about an atom is modeled\n  as a Slater 1s orbital.  More details can be found in the referenced\n  paper.  To fully reproduce the published Streitz-Mintmire potential,\n  which is a variable charge potential, style coul/streitz must be\n  used with pair_style eam/alloy (or some other\n  short-range potential that has been parameterized appropriately) via\n  the pair_style hybrid/overlay command.  Likewise,\n  charge equilibration must be performed via the fix qeq/slater command. For example:\n  pair_style hybrid/overlay coul/streitz 12.0 wolf 0.31 eam/alloy\n  pair_coeff * * coul/streitz AlO.streitz Al O\n  pair_coeff * * eam/alloy AlO.eam.alloy Al O\n  fix 1 all qeq/slater 1 12.0 1.0e-6 100 coul/streitz\n  \n  \n  The keyword wolf in the coul/streitz command denotes computing\n  Coulombic interactions via Wolf summation.  An additional damping\n  parameter is required for the Wolf summation, as described for the\n  coul/wolf potential above.  Alternatively, Coulombic interactions can\n  be computed via an Ewald summation.  For example:\n  pair_style hybrid/overlay coul/streitz 12.0 ewald eam/alloy\n  kspace_style ewald 1e-6\n  \n  \n  Keyword ewald does not need a damping parameter, but a\n  kspace_style must be defined, which can be style\n  ewald or pppm.  The Ewald method was used in Streitz and\n  Mintmire’s original paper, but a Wolf summation offers a speed-up in\n  some cases.\n  For the fix qeq/slater command, the qfile can be a filename that\n  contains QEq parameters as discussed on the fix qeq\n  command doc page.  Alternatively qfile can be replaced by\n  “coul/streitz”, in which case the fix will extract QEq parameters from\n  the coul/streitz pair style itself.\n  See the examples/strietz directory for an example input script that\n  uses the Streitz-Mintmire potential.  The potentials directory has the\n  AlO.eam.alloy and AlO.streitz potential files used by the example.\n  Note that the Streiz-Mintmire potential is generally used for oxides,\n  but there is no conceptual problem with extending it to nitrides and\n  carbides (such as SiC, TiN).  Pair coul/strietz used by itself or with\n  any other pair style such as EAM, MEAM, Tersoff, or LJ in\n  hybrid/overlay mode.  To do this, you would need to provide a\n  Streitz-Mintmire parameterization for the material being modeled.\n  \n  Styles coul/long and coul/msm compute the same Coulombic\n  interactions as style coul/cut except that an additional damping\n  factor is applied so it can be used in conjunction with the\n  kspace_style command and its ewald or pppm\n  option.  The Coulombic cutoff specified for this style means that\n  pairwise interactions within this distance are computed directly;\n  interactions outside that distance are computed in reciprocal space.\n  Styles tip4p/cut and tip4p/long implement the Coulomb part of\n  the TIP4P water model of (Jorgensen), which introduces\n  a massless site located a short distance away from the oxygen atom\n  along the bisector of the HOH angle.  The atomic types of the oxygen and\n  hydrogen atoms, the bond and angle types for OH and HOH interactions,\n  and the distance to the massless charge site are specified as\n  pair_style arguments.  Style tip4p/cut uses a global cutoff for\n  Coulomb interactions; style tip4p/long is for use with a long-range\n  Coulombic solver (Ewald or PPPM).\n  \n  Note\n  For each TIP4P water molecule in your system, the atom IDs for\n  the O and 2 H atoms must be consecutive, with the O atom first.  This\n  is to enable LAMMPS to “find” the 2 H atoms associated with each O\n  atom.  For example, if the atom ID of an O atom in a TIP4P water\n  molecule is 500, then its 2 H atoms must have IDs 501 and 502.\n  \n  See the Howto tip4p doc page for more information\n  on how to use the TIP4P pair styles and lists of parameters to set.\n  Note that the neighbor list cutoff for Coulomb interactions is\n  effectively extended by a distance 2*qdist when using the TIP4P pair\n  style, to account for the offset distance of the fictitious charges on\n  O atoms in water molecules.  Thus it is typically best in an\n  efficiency sense to use a LJ cutoff >= Coulombic cutoff + 2*qdist, to\n  shrink the size of the neighbor list.  This leads to slightly larger\n  cost for the long-range calculation, so you can test the trade-off for\n  your model.\n  \n  Note that these potentials are designed to be combined with other pair\n  potentials via the pair_style hybrid/overlay\n  command.  This is because they have no repulsive core.  Hence if they\n  are used by themselves, there will be no repulsion to keep two\n  oppositely charged particles from moving arbitrarily close to each\n  other.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data or restart files read by the\n  read_data or read_restart\n  commands, or by mixing as described below:\n  \n  cutoff (distance units)\n  \n  For coul/cut and coul/debye, the cutoff coefficient is optional.\n  If it is not used (as in some of the examples above), the default\n  global value specified in the pair_style command is used.\n  For coul/long and coul/msm no cutoff can be specified for an\n  individual I,J type pair via the pair_coeff command.  All type pairs\n  use the same global Coulomb cutoff specified in the pair_style\n  command.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the cutoff distance for the\n  coul/cut style can be mixed.  The default mix value is geometric.\n  See the “pair_modify” command for details.\n  The pair_modify shift option is not relevant\n  for these pair styles.\n  The coul/long style supports the pair_modify\n  table option for tabulation of the short-range portion of the\n  long-range Coulombic interaction.\n  These pair styles do not support the pair_modify\n  tail option for adding long-range tail corrections to energy and\n  pressure.\n  These pair styles write their information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  These pair styles can only be used via the pair keyword of the\n  run_style respa command.  They do not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style coul/cut cutoff\n  pair_style coul/debye kappa cutoff\n  pair_style coul/dsf alpha cutoff\n  pair_style coul/long cutoff\n  pair_style coul/long/gpu cutoff\n  pair_style coul/wolf alpha cutoff\n  pair_style coul/streitz cutoff keyword alpha\n  pair_style tip4p/cut otype htype btype atype qdist cutoff\n  pair_style tip4p/long otype htype btype atype qdist cutoff\n  \n  \n  \n  cutoff = global cutoff for Coulombic interactions\n  kappa = Debye length (inverse distance units)\n  alpha = damping parameter (inverse distance units)\n  \n  ",
    "examples": "pair_style coul/cut 2.5\n  pair_coeff * *\n  pair_coeff 2 2 3.5\n  \n  pair_style coul/debye 1.4 3.0\n  pair_coeff * *\n  pair_coeff 2 2 3.5\n  \n  pair_style coul/dsf 0.05 10.0\n  pair_coeff * *\n  \n  pair_style coul/long 10.0\n  pair_coeff * *\n  \n  pair_style coul/msm 10.0\n  pair_coeff * *\n  \n  pair_style coul/wolf 0.2 9.0\n  pair_coeff * *\n  \n  pair_style coul/streitz 12.0 ewald\n  pair_style coul/streitz 12.0 wolf 0.30\n  pair_coeff * * AlO.streitz Al O\n  \n  pair_style tip4p/cut 1 2 7 8 0.15 12.0\n  pair_coeff * *\n  \n  pair_style tip4p/long 1 2 7 8 0.15 10.0\n  pair_coeff * *\n  \n  \n  ",
    "restrictions": "The coul/long, coul/msm and tip4p/long styles are part of the\n  KSPACE package.  They are only enabled if LAMMPS was built with that\n  package.  See the Build package doc page for more\n  info.\n  "
},
{
    "command": "pair_style coul/diel",
    "description": "Style coul/diel computes a Coulomb correction for implicit solvent\n  ion interactions in which the dielectric permittivity is distance dependent.\n  The dielectric permittivity epsilon_D(r) connects to limiting regimes:\n  One limit is defined by a small dielectric permittivity (close to vacuum)\n  at or close to contact separation between the ions. At larger separations\n  the dielectric permittivity reaches a bulk value used in the regular Coulomb\n  interaction coul/long or coul/cut.\n  The transition is modeled by a hyperbolic function which is incorporated\n  in the Coulomb correction term for small ion separations as follows\n  \n  \\[\\begin{split}E  = & \\frac{Cq_iq_j}{\\epsilon r} \\left( \\frac{\\epsilon}{\\epsilon_D(r)}-1\\right)                       \\qquad r < r_c \\\\\n  \\epsilon_D(r)  = & \\frac{5.2+\\epsilon}{2} +  \\frac{\\epsilon-5.2}{2}\\tanh\\left(\\frac{r-r_{me}}{\\sigma_e}\\right)\\end{split}\\]\n  where \\(r_{me}\\) is the inflection point of \\(\\epsilon_D(r)\\) and \\(\\sigma_e\\) is a slope\n  defining length scale. C is the same Coulomb conversion factor as in the\n  pair_styles coul/cut, coul/long, and coul/debye. In this way the Coulomb\n  interaction between ions is corrected at small distances r. The lower\n  limit of epsilon_D(r->0)=5.2 due to dielectric saturation (Stiles)\n  while the Coulomb interaction reaches its bulk limit by setting\n  \\(\\epsilon_D(r \\to \\infty) = \\epsilon\\), the bulk value of the solvent which is 78\n  for water at 298K.\n  Examples of the use of this type of Coulomb interaction include implicit\n  solvent simulations of salt ions\n  (Lenart) and of ionic surfactants (Jusufi).\n  Note that this potential is only reasonable for implicit solvent simulations\n  and in combination with coul/cut or coul/long. It is also usually combined\n  with gauss/cut, see (Lenart) or (Jusufi).\n  The following coefficients must be defined for each pair of atom\n  types via the pair_coeff command as in the example\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands:\n  \n  \\(\\epsilon\\) (no units)\n  \\(r_{me}\\) (distance units)\n  \\(\\sigma_e\\) (distance units)\n  \n  The global cutoff (\\(r_c\\)) specified in the pair_style command is used.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This pair style does not support parameter mixing. Coefficients must\n  be given explicitly for each type of particle pairs.\n  This pair style supports the pair_modify shift\n  option for the energy of the Gauss-potential portion of the pair\n  interaction.\n  The pair_modify table option is not relevant\n  for this pair style.\n  This pair style does not support the pair_modify\n  tail option for adding long-range tail corrections to energy and\n  pressure.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style coul/diel cutoff\n  \n  \n  cutoff = global cutoff (distance units)\n  ",
    "examples": "pair_style coul/diel 3.5\n  pair_coeff 1 4 78. 1.375 0.112\n  \n  \n  ",
    "restrictions": "This style is part of the “USER-MISC” package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style coul/shield",
    "description": "Style coul/shield computes a Coulomb interaction for boron and\n  nitrogen atoms located in different layers of hexagonal boron\n  nitride. This potential is designed be used in combination with\n  the pair style ilp/graphene/hbn\n  \n  Note\n  This potential is intended for electrostatic interactions between\n  two different layers of hexagonal boron nitride. Therefore, to avoid\n  interaction within the same layers, each layer should have a separate\n  molecule id and is recommended to use the “full” atom style, so that\n  charge and molecule ID information is included.\n  \n  \n  \\[\\begin{split}E      = & \\frac{1}{2} \\sum_i \\sum_{j \\neq i} V_{ij} \\\\\n  V_{ij} = & {\\rm Tap}(r_{ij})\\frac{\\kappa q_i q_j}{\\sqrt[3]{r_{ij}^3+(1/\\lambda_{ij})^3}}\\\\\n  {\\rm Tap}(r_{ij}) = & 20\\left ( \\frac{r_{ij}}{R_{cut}} \\right )^7 -\n                         70\\left ( \\frac{r_{ij}}{R_{cut}} \\right )^6 +\n                         84\\left ( \\frac{r_{ij}}{R_{cut}} \\right )^5 -\n                         35\\left ( \\frac{r_{ij}}{R_{cut}} \\right )^4 + 1\\end{split}\\]\n  Where Tap(\\(r_{ij}\\)) is the taper function which provides a continuous cutoff\n  (up to third derivative) for inter-atomic separations larger than \\(r_c\\)\n  (Leven1), (Leven2) and (Maaravi).\n  Here \\(\\lambda\\) is the shielding parameter that\n  eliminates the short-range singularity of the classical mono-polar\n  electrostatic interaction expression (Maaravi).\n  The shielding parameter \\(\\lambda\\) (1/distance units) must be defined for\n  each pair of atom types via the pair_coeff command as\n  in the example above, or in the data file or restart files read by the\n  read_data or read_restart commands:\n  The global cutoff (\\(r_c\\)) specified in the pair_style command is used.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This pair style does not support parameter mixing. Coefficients must\n  be given explicitly for each type of particle pairs.\n  The pair_modify table option is not relevant\n  for this pair style.\n  This pair style does not support the pair_modify\n  tail option for adding long-range tail corrections to energy and\n  pressure.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style coul/shield cutoff tap_flag\n  \n  \n  \n  cutoff = global cutoff (distance units)\n  tap_flag = 0/1 to turn off/on the taper function\n  \n  ",
    "examples": "pair_style coul/shield 16.0 1\n  pair_coeff 1 2 0.70\n  \n  \n  ",
    "restrictions": "This style is part of the USER-MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style coul/slater/cut",
    "description": "Styles coul/slater compute electrostatic interactions in mesoscopic models\n  which employ potentials without explicit excluded-volume interactions.\n  The goal is to prevent artificial ionic pair formation by including a charge\n  distribution in the Coulomb potential, following the formulation of\n  (Melchor):\n  \n  \\[E  =  \\frac{Cq_iq_j}{\\epsilon r} \\left( 1- \\left( 1 + \\frac{r_{ij}}{\\lambda} exp\\left( -2r_{ij}/\\lambda \\right) \\right) \\right)                       \\qquad r < r_c\\]\n  where \\(r_c\\) is the cutoff distance and \\(\\lambda\\) is the decay length of the charge.\n  C is the same Coulomb conversion factor as in the pair_styles coul/cut and coul/long. In this way the Coulomb\n  interaction between ions is corrected at small distances r.\n  For the coul/slater/cut style, the potential energy for distances larger than the cutoff is zero,\n  while for the coul/slater/long, the long-range interactions are computed either by the Ewald or the PPPM technique.\n  Phenomena that can be captured at a mesoscopic level using this type of electrostatic\n  interactions include the formation of polyelectrolyte-surfactant aggregates,\n  charge stabilization of colloidal suspensions, and the formation of\n  complexes driven by charged species in biological systems. (Vaiwala).\n  The cutoff distance is optional. If it is not used,\n  the default global value specified in the pair_style command is used.\n  For each pair of atom types, a specific cutoff distance can be defined via the pair_coeff command as in the example\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands:\n  \n  \\(r_c\\) (distance units)\n  \n  The global decay length of the charge (\\(\\lambda\\)) specified in the pair_style command is used for all pairs.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the cutoff distance for the\n  coul/slater styles can be mixed.  The default mix value is geometric.\n  See the “pair_modify” command for details.\n  The pair_modify shift and table options are not relevant\n  for these pair styles.\n  These pair styles do not support the pair_modify\n  tail option for adding long-range tail corrections to energy and\n  pressure.\n  These pair styles write their information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style coul/slater/cut lambda cutoff\n  pair_style coul/slater/long lambda cutoff\n  \n  \n  lambda = decay length of the charge (distance units)\n  cutoff = cutoff (distance units)\n  ",
    "examples": "pair_style coul/slater/cut 1.0 3.5\n  pair_coeff * *\n  pair_coeff 2 2 2.5\n  \n  pair_style coul/slater/long 1.0 12.0\n  pair_coeff * *\n  pair_coeff 1 1 5.0\n  \n  \n  ",
    "restrictions": "The  coul/slater/long style requires the long-range solvers included in the KSPACE package.\n  These styles are part of the “USER-MISC” package.  They are only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style born/coul/dsf/cs",
    "description": "These pair styles are designed to be used with the adiabatic\n  core/shell model of (Mitchell and Finchham).  See\n  the Howto coreshell doc page for an overview of\n  the model as implemented in LAMMPS.\n  All the styles are identical to the corresponding pair style without\n  the “/cs” in the name:\n  \n  pair_style born/coul/dsf\n  pair_style born/coul/long\n  pair_style born/coul/wolf\n  pair_style buck/coul/long\n  pair_style coul/long\n  pair_style coul/wolf\n  pair_style lj/cut/coul/long\n  \n  except that they correctly treat the special case where the distance\n  between two charged core and shell atoms in the same core/shell pair\n  approach r = 0.0.\n  Styles with a “/long” in the name are used with a long-range solver\n  for Coulombic interactions via the kspace_style\n  command.  They require special treatment of the short-range Coulombic\n  interactions within the cor/shell model.\n  Specifically, the short-range Coulomb interaction between a core and\n  its shell should be turned off using the\n  special_bonds command by setting the 1-2 weight\n  to 0.0, which works because the core and shell atoms are bonded to\n  each other.  This induces a long-range correction approximation which\n  fails at small distances (~< 10e-8). Therefore, the Coulomb term which\n  is used to calculate the correction factor is extended by a minimal\n  distance (r_min = 1.0-6) when the interaction between a core/shell\n  pair is treated, as follows\n  \n  \\[E = \\frac{C q_i q_j}{\\epsilon (r + r_{min})} \\qquad r \\rightarrow 0\\]\n  where C is an energy-conversion constant, \\(q_i\\) and \\(q_j\\)\n  are the charges on the core and shell, epsilon is the dielectric\n  constant and \\(r_{min}\\) is the minimal distance.\n  For styles that are not used with a long-range solver, i.e. those with\n  “/dsf” or “/wolf” in the name, the only correction is the addition of\n  a minimal distance to avoid the possible r = 0.0 case for a core/shell\n  pair.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  See the corresponding doc pages for pair styles without the “cs”\n  suffix to see how mixing, shifting, tabulation, tail correction,\n  restarting, and rRESPA are handled by theses pair styles.\n  ",
    "syntax": "pair_style style args\n  \n  \n  \n  style = born/coul/dsf/cs or born/coul/long/cs or born/coul/wolf/cs or buck/coul/long/cs or coul/long/cs or coul/wolf/cs or lj/cut/coul/long/cs\n  args = list of arguments for a particular style\n  \n  born/coul/dsf/cs args = alpha cutoff (cutoff2)\n    alpha = damping parameter (inverse distance units)\n    cutoff = global cutoff for non-Coulombic (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (distance units)\n  born/coul/long/cs args = cutoff (cutoff2)\n    cutoff = global cutoff for non-Coulombic (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  born/coul/wolf/cs args = alpha cutoff (cutoff2)\n    alpha = damping parameter (inverse distance units)\n    cutoff = global cutoff for Buckingham (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  buck/coul/long/cs args = cutoff (cutoff2)\n    cutoff = global cutoff for Buckingham (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  coul/long args = cutoff\n    cutoff = global cutoff for Coulombic (distance units)\n  coul/wolf args = alpha cutoff\n    alpha = damping parameter (inverse distance units)\n    cutoff = global cutoff for Coulombic (distance units)\n  lj/cut/coul/long/cs args = cutoff (cutoff2)\n    cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  ",
    "examples": "pair_style born/coul/dsf/cs 0.1 10.0 12.0\n  pair_coeff * *   0.0 1.00 0.00 0.00 0.00\n  pair_coeff 1 1 480.0 0.25 0.00 1.05 0.50\n  \n  pair_style born/coul/long/cs 10.0 8.0\n  pair_coeff 1 1 6.08 0.317 2.340 24.18 11.51\n  \n  pair_style born/coul/wolf/cs 0.25 10.0 12.0\n  pair_coeff * *   0.0 1.00 0.00 0.00 0.00\n  pair_coeff 1 1 480.0 0.25 0.00 1.05 0.50\n  \n  pair_style buck/coul/long/cs 10.0\n  pair_style buck/coul/long/cs 10.0 8.0\n  pair_coeff * * 100.0 1.5 200.0\n  pair_coeff 1 1 100.0 1.5 200.0 9.0\n  \n  pair_style coul/long/cs 10.0\n  pair_coeff * *\n  \n  pair_style coul/wolf/cs 0.2 9.0\n  pair_coeff * *\n  \n  pair_style lj/cut/coul/long/cs 10.0\n  pair_style lj/cut/coul/long/cs 10.0 8.0\n  pair_coeff * * 100.0 3.0\n  pair_coeff 1 1 100.0 3.5 9.0\n  \n  \n  ",
    "restrictions": "These pair styles are part of the CORESHELL package.  They are only\n  enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style lj/cut/dipole/cut",
    "description": "Style lj/cut/dipole/cut computes interactions between pairs of particles\n  that each have a charge and/or a point dipole moment.  In addition to\n  the usual Lennard-Jones interaction between the particles (Elj) the\n  charge-charge (Eqq), charge-dipole (Eqp), and dipole-dipole (Epp)\n  interactions are computed by these formulas for the energy (E), force\n  (F), and torque (T) between particles I and J.\n  \n  \\[\\begin{split}E_{LJ}  = & 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -\n                       \\left(\\frac{\\sigma}{r}\\right)^6 \\right] \\\\\n  E_{qq}  = & \\frac{q_i q_j}{r} \\\\\n  E_{qp}  = & \\frac{q}{r^3} (p \\bullet \\vec{r}) \\\\\n  E_{pp}  = & \\frac{1}{r^3} (\\vec{p_i} \\bullet \\vec{p_j}) -\n            \\frac{3}{r^5} (\\vec{p_i} \\bullet \\vec{r}) (\\vec{p_j} \\bullet \\vec{r}) \\\\\n            & \\\\\n  F_{qq}  = & \\frac{q_i q_j}{r^3} \\vec{r} \\\\\n  F_{qp}  = & -\\frac{q}{r^3} \\vec{p} + \\frac{3q}{r^5}\n            (\\vec{p} \\bullet \\vec{r}) \\vec{r} \\\\\n  F_{pp}  = & \\frac{3}{r^5} (\\vec{p_i} \\bullet \\vec{p_j}) \\vec{r} -\n            \\frac{15}{r^7} (\\vec{p_i} \\bullet \\vec{r})\n            (\\vec{p_j} \\bullet \\vec{r}) \\vec{r} +\n            \\frac{3}{r^5} \\left[ (\\vec{p_j} \\bullet \\vec{r}) \\vec{p_i} +\n            (\\vec{p_i} \\bullet \\vec{r}) \\vec{p_j} \\right] \\\\\n            & \\\\\n  T_{pq} = T_{ij}  = & \\frac{q_j}{r^3} (\\vec{p_i} \\times \\vec{r}) \\\\\n  T_{qp} = T_{ji}  = & - \\frac{q_i}{r^3} (\\vec{p_j} \\times \\vec{r}) \\\\\n  T_{pp} = T_{ij}  = & -\\frac{1}{r^3} (\\vec{p_i} \\times \\vec{p_j}) +\n                     \\frac{3}{r^5} (\\vec{p_j} \\bullet \\vec{r})\n                     (\\vec{p_i} \\times \\vec{r}) \\\\\n  T_{pp} = T_{ji}  = & -\\frac{1}{r^3} (\\vec{p_j} \\times \\vec{p_i}) +\n                     \\frac{3}{r^5} (\\vec{p_i} \\bullet \\vec{r})\n                     (\\vec{p_j} \\times \\vec{r})\\end{split}\\]\n  where \\(q_i\\) and \\(q_j\\) are the charges on the two particles,\n  \\(\\vec{p_i}\\) and \\(\\vec{p_j}\\) are the dipole moment vectors of\n  the two particles, r is their separation distance, and the vector r =\n  Ri - Rj is the separation vector between the two particles.  Note that\n  Eqq and Fqq are simply Coulombic energy and force, Fij = -Fji as\n  symmetric forces, and Tij != -Tji since the torques do not act\n  symmetrically.  These formulas are discussed in (Allen)\n  and in (Toukmaji).\n  Also note, that in the code, all of these terms (except Elj) have a\n  \\(C/\\epsilon\\) prefactor, the same as the Coulombic term in the LJ +\n  Coulombic pair styles discussed here.  C is an\n  energy-conversion constant and epsilon is the dielectric constant\n  which can be set by the dielectric command.  The\n  same is true of the equations that follow for other dipole pair\n  styles.\n  Style lj/sf/dipole/sf computes “shifted-force” interactions between\n  pairs of particles that each have a charge and/or a point dipole\n  moment. In general, a shifted-force potential is a (slightly) modified\n  potential containing extra terms that make both the energy and its\n  derivative go to zero at the cutoff distance; this removes\n  (cutoff-related) problems in energy conservation and any numerical\n  instability in the equations of motion (Allen). Shifted-force\n  interactions for the Lennard-Jones (E_LJ), charge-charge (Eqq),\n  charge-dipole (Eqp), dipole-charge (Epq) and dipole-dipole (Epp)\n  potentials are computed by these formulas for the energy (E), force\n  (F), and torque (T) between particles I and J:\n  \n  \\[ \\begin{align}\\begin{aligned}\\begin{split} E_{LJ}  = &  4\\epsilon \\left\\{ \\left[ \\left( \\frac{\\sigma}{r} \\right)^{\\!12} -\n  \\left( \\frac{\\sigma}{r} \\right)^{\\!6}  \\right] +\n  \\left[ 6\\left( \\frac{\\sigma}{r_c} \\right)^{\\!12} -\n  3\\left(\\frac{\\sigma}{r_c}\\right)^{\\!6}\\right]\\left(\\frac{r}{r_c}\\right)^{\\!2}\n  - 7\\left( \\frac{\\sigma}{r_c} \\right)^{\\!12} +\n  4\\left( \\frac{\\sigma}{r_c} \\right)^{\\!6}\\right\\} \\\\\n  E_{qq}  = & \\frac{q_i q_j}{r}\\left(1-\\frac{r}{r_c}\\right)^{\\!2} \\\\\n  E_{pq}  = & E_{ji} = -\\frac{q}{r^3} \\left[ 1 -\n  3\\left(\\frac{r}{r_c}\\right)^{\\!2} +\n  2\\left(\\frac{r}{r_c}\\right)^{\\!3}\\right] (\\vec{p}\\bullet\\vec{r}) \\\\\n  E_{qp}  = & E_{ij} = \\frac{q}{r^3} \\left[ 1 -\n  3\\left(\\frac{r}{r_c}\\right)^{\\!2} +\n  2\\left(\\frac{r}{r_c}\\right)^{\\!3}\\right] (\\vec{p}\\bullet\\vec{r}) \\\\\n  E_{pp} = & \\left[1-4\\left(\\frac{r}{r_c}\\right)^{\\!3} +\n  3\\left(\\frac{r}{r_c}\\right)^{\\!4}\\right]\\left[\\frac{1}{r^3}\n  (\\vec{p_i} \\bullet \\vec{p_j}) - \\frac{3}{r^5}\n  (\\vec{p_i} \\bullet \\vec{r}) (\\vec{p_j} \\bullet \\vec{r})\\right] \\\\\n           & \\\\\\end{split}\\\\\\begin{split}F_{LJ}  = & \\left\\{\\left[48\\epsilon \\left(\\frac{\\sigma}{r}\\right)^{\\!12} -\n  24\\epsilon \\left(\\frac{\\sigma}{r}\\right)^{\\!6} \\right]\\frac{1}{r^2} -\n  \\left[48\\epsilon \\left(\\frac{\\sigma}{r_c}\\right)^{\\!12} - 24\\epsilon\n  \\left(\\frac{\\sigma}{r_c}\\right)^{\\!6} \\right]\\frac{1}{r_c^2}\\right\\}\\vec{r}\\\\\n  F_{qq}  = & \\frac{q_i q_j}{r}\\left(\\frac{1}{r^2} -\n  \\frac{1}{r_c^2}\\right)\\vec{r} \\\\\n  F_{pq} = & F_{ij } =  -\\frac{3q}{r^5} \\left[ 1 -\n  \\left(\\frac{r}{r_c}\\right)^{\\!2}\\right](\\vec{p}\\bullet\\vec{r})\\vec{r} +\n  \\frac{q}{r^3}\\left[1-3\\left(\\frac{r}{r_c}\\right)^{\\!2} +\n  2\\left(\\frac{r}{r_c}\\right)^{\\!3}\\right] \\vec{p} \\\\\n  F_{qp} = & F_{ij}  = \\frac{3q}{r^5} \\left[ 1 -\n  \\left(\\frac{r}{r_c}\\right)^{\\!2}\\right] (\\vec{p}\\bullet\\vec{r})\\vec{r} -\n  \\frac{q}{r^3}\\left[1-3\\left(\\frac{r}{r_c}\\right)^{\\!2} +\n  2\\left(\\frac{r}{r_c}\\right)^{\\!3}\\right] \\vec{p} \\\\\n  F_{pp}  = &\\frac{3}{r^5}\\Bigg\\{\\left[1-\\left(\\frac{r}{r_c}\\right)^{\\!4}\\right]\n  \\left[(\\vec{p_i}\\bullet\\vec{p_j}) - \\frac{3}{r^2} (\\vec{p_i}\\bullet\\vec{r})\n  (\\vec{p_j} \\bullet \\vec{r})\\right] \\vec{r} + \\\\\n    & \\left[1 -\n  4\\left(\\frac{r}{r_c}\\right)^{\\!3}+3\\left(\\frac{r}{r_c}\\right)^{\\!4}\\right]\n  \\left[ (\\vec{p_j} \\bullet \\vec{r}) \\vec{p_i} + (\\vec{p_i} \\bullet \\vec{r})\n  \\vec{p_j} -\\frac{2}{r^2} (\\vec{p_i} \\bullet \\vec{r})\n  (\\vec{p_j} \\bullet \\vec{r})\\vec{r}\\right] \\Bigg\\}\\end{split}\\end{aligned}\\end{align} \\]\n  \n  \\[\\begin{split} T_{pq} = T_{ij}  = & \\frac{q_j}{r^3} \\left[ 1 -\n  3\\left(\\frac{r}{r_c}\\right)^{\\!2} +\n  2\\left(\\frac{r}{r_c}\\right)^{\\!3}\\right] (\\vec{p_i}\\times\\vec{r}) \\\\\n  T_{qp} = T_{ji}  = & - \\frac{q_i}{r^3} \\left[ 1 -\n  3\\left(\\frac{r}{r_c}\\right)^{\\!2} +\n  2\\left(\\frac{r}{r_c}\\right)^{\\!3} \\right] (\\vec{p_j}\\times\\vec{r}) \\\\\n  T_{pp} = T_{ij}  = & -\\frac{1}{r^3}\\left[1-4\\left(\\frac{r}{r_c}\\right)^{\\!3} +\n  e3\\left(\\frac{r}{r_c}\\right)^{\\!4}\\right] (\\vec{p_i} \\times \\vec{p_j}) + \\\\\n                     & \\frac{3}{r^5}\\left[1-4\\left(\\frac{r}{r_c}\\right)^{\\!3} +\n  3\\left(\\frac{r}{r_c}\\right)^{\\!4}\\right] (\\vec{p_j}\\bullet\\vec{r})\n  (\\vec{p_i} \\times \\vec{r}) \\\\\n  T_{pp} = T_{ji} = & -\\frac{1}{r^3}\\left[1-4\\left(\\frac{r}{r_c}\\right)^{\\!3} +\n  3\\left(\\frac{r}{r_c}\\right)^{\\!4}\\right](\\vec{p_j} \\times \\vec{p_i}) + \\\\\n                     & \\frac{3}{r^5}\\left[1-4\\left(\\frac{r}{r_c}\\right)^{\\!3} +\n  3\\left(\\frac{r}{r_c}\\right)^{\\!4}\\right] (\\vec{p_i} \\bullet \\vec{r})\n  (\\vec{p_j} \\times \\vec{r})\\end{split}\\]\n  where \\(\\epsilon\\) and \\(\\sigma\\) are the standard LJ\n  parameters, \\(r_c\\) is the cutoff, \\(q_i\\) and \\(q_j\\) are\n  the charges on the two particles, \\(\\vec{p_i}\\) and\n  \\(\\vec{p_j}\\) are the dipole moment vectors of the two particles, r\n  is their separation distance, and the vector r = Ri - Rj is the\n  separation vector between the two particles.  Note that Eqq and Fqq are\n  simply Coulombic energy and force, Fij = -Fji as symmetric forces, and\n  Tij != -Tji since the torques do not act symmetrically.  The\n  shifted-force formula for the Lennard-Jones potential is reported in\n  (Stoddard).  The original (non-shifted) formulas for\n  the electrostatic potentials, forces and torques can be found in\n  (Price). The shifted-force electrostatic potentials have\n  been obtained by applying equation 5.13 of (Allen). The\n  formulas for the corresponding forces and torques have been obtained by\n  applying the ‘chain rule’ as in appendix C.3 of (Allen).\n  If one cutoff is specified in the pair_style command, it is used for\n  both the LJ and Coulombic (q,p) terms.  If two cutoffs are specified,\n  they are used as cutoffs for the LJ and Coulombic (q,p) terms\n  respectively. This pair style also supports an optional scale keyword\n  as part of a pair_coeff statement, where the interactions can be\n  scaled according to this factor. This scale factor is also made available\n  for use with fix adapt.\n  Style lj/cut/dipole/long computes long-range point-dipole\n  interactions as discussed in (Toukmaji). Dipole-dipole,\n  dipole-charge, and charge-charge interactions are all supported, along\n  with the standard 12/6 Lennard-Jones interactions, which are computed\n  with a cutoff.  A kspace_style must be defined to\n  use this pair style.  Currently, only kspace_style ewald/disp support long-range point-dipole\n  interactions.\n  Style lj/long/dipole/long also computes point-dipole interactions as\n  discussed in (Toukmaji). Long-range dipole-dipole,\n  dipole-charge, and charge-charge interactions are all supported, along\n  with the standard 12/6 Lennard-Jones interactions.  LJ interactions\n  can be cutoff or long-ranged.\n  For style lj/long/dipole/long, if flag_lj is set to long, no\n  cutoff is used on the LJ 1/r^6 dispersion term.  The long-range\n  portion is calculated by using the kspace_style ewald_disp command.  The specified LJ cutoff then\n  determines which portion of the LJ interactions are computed directly\n  by the pair potential versus which part is computed in reciprocal\n  space via the Kspace style.  If flag_lj is set to cut, the LJ\n  interactions are simply cutoff, as with pair_style lj/cut.  If flag_lj is set to off, LJ interactions\n  are not computed at all.\n  If flag_coul is set to long, no cutoff is used on the Coulombic or\n  dipole interactions.  The long-range portion is calculated by using\n  ewald_disp of the kspace_style command. If\n  flag_coul is set to off, Coulombic and dipole interactions are not\n  computed at all.\n  Atoms with dipole moments should be integrated using the fix nve/sphere update dipole or the fix nvt/sphere update dipole command to rotate the\n  dipole moments.  The omega option on the fix langevin command can be used to thermostat the\n  rotational motion.  The compute temp/sphere\n  command can be used to monitor the temperature, since it includes\n  rotational degrees of freedom.  The atom_style hybrid dipole sphere command should be used since\n  it defines the point dipoles and their rotational state.\n  The magnitude and orientation of the dipole moment for each particle\n  can be defined by the set command or in the “Atoms” section\n  of the data file read in by the read_data command.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands, or by mixing as described below:\n  \n  \\(\\epsilon\\) (energy units)\n  \\(\\sigma\\) (distance units)\n  cutoff1 (distance units)\n  cutoff2 (distance units)\n  \n  The latter 2 coefficients are optional.  If not specified, the global\n  LJ and Coulombic cutoffs specified in the pair_style command are used.\n  If only one cutoff is specified, it is used as the cutoff for both LJ\n  and Coulombic interactions for this type pair.  If both coefficients\n  are specified, they are used as the LJ and Coulombic cutoffs for this\n  type pair.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the epsilon and sigma coefficients\n  and cutoff distances for this pair style can be mixed.  The default\n  mix value is geometric.  See the “pair_modify” command for details.\n  For atom type pairs I,J and I != J, the A, sigma, d1, and d2\n  coefficients and cutoff distance for this pair style can be mixed.  A\n  is an energy value mixed like a LJ epsilon.  D1 and d2 are distance\n  values and are mixed like sigma.  The default mix value is\n  geometric.  See the “pair_modify” command for details.\n  This pair style does not support the pair_modify\n  shift option for the energy of the Lennard-Jones portion of the pair\n  interaction; such energy goes to zero at the cutoff by construction.\n  The pair_modify table option is not relevant\n  for this pair style.\n  This pair style does not support the pair_modify\n  tail option for adding long-range tail corrections to energy and\n  pressure.\n  This pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style lj/cut/dipole/cut cutoff (cutoff2)\n  pair_style lj/sf/dipole/sf cutoff (cutoff2)\n  pair_style lj/cut/dipole/long cutoff (cutoff2)\n  pair_style lj/long/dipole/long flag_lj flag_coul cutoff (cutoff2)\n  \n  \n  \n  cutoff = global cutoff LJ (and Coulombic if only 1 arg) (distance units)\n  cutoff2 = global cutoff for Coulombic and dipole (optional) (distance units)\n  flag_lj = long or cut or off\n  long = use long-range damping on dispersion 1/r^6 term\n  cut = use a cutoff on dispersion 1/r^6 term\n  off = omit disperion 1/r^6 term entirely\n  \n  flag_coul = long or off\n  long = use long-range damping on Coulombic 1/r and point-dipole terms\n  off = omit Coulombic and point-dipole terms entirely\n  \n  \n  ",
    "examples": "pair_style lj/cut/dipole/cut 10.0\n  pair_coeff * * 1.0 1.0\n  pair_coeff 2 3 1.0 1.0 2.5 4.0\n  \n  pair_style lj/sf/dipole/sf 9.0\n  pair_coeff * * 1.0 1.0\n  pair_coeff 2 3 1.0 1.0 2.5 4.0 scale 0.5\n  pair_coeff 2 3 1.0 1.0 2.5 4.0\n  \n  pair_style lj/cut/dipole/long 10.0\n  pair_coeff * * 1.0 1.0\n  pair_coeff 2 3 1.0 1.0 2.5 4.0\n  \n  pair_style lj/long/dipole/long long long 3.5 10.0\n  pair_coeff * * 1.0 1.0\n  pair_coeff 2 3 1.0 1.0 2.5 4.0\n  \n  \n  ",
    "restrictions": "The lj/cut/dipole/cut, lj/cut/dipole/long, and\n  lj/long/dipole/long styles are part of the DIPOLE package.  They are\n  only enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\n  The lj/sf/dipole/sf style is part of the USER-MISC package.  It is\n  only enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\n  Using dipole pair styles with electron units is not\n  currently supported.\n  "
},
{
    "command": "pair_style dpd",
    "description": "Style dpd computes a force field for dissipative particle dynamics\n  (DPD) following the exposition in (Groot).\n  Style dpd/tstat invokes a DPD thermostat on pairwise interactions,\n  which is equivalent to the non-conservative portion of the DPD force\n  field.  This pair-wise thermostat can be used in conjunction with any\n  pair style, and in leiu of per-particle thermostats\n  like fix langevin or ensemble thermostats like\n  Nose Hoover as implemented by fix nvt.  To use\n  dpd/tstat as a thermostat for another pair style, use the pair_style hybrid/overlay command to compute both the desired\n  pair interaction and the thermostat for each pair of particles.\n  For style dpd, the force on atom I due to atom J is given as a sum\n  of 3 terms\n  \n  \\[\\begin{split}\\vec{f}  = & (F^C + F^D + F^R) \\hat{r_{ij}} \\qquad \\qquad r < r_c \\\\\n  F^C      = & A w(r) \\\\\n  F^D      = & - \\gamma w^2(r) (\\hat{r_{ij}} \\bullet \\vec{v_{ij}}) \\\\\n  F^R      = & \\sigma w(r) \\alpha (\\Delta t)^{-1/2} \\\\\n  w(r)     = & 1 - r/r_c\\end{split}\\]\n  where \\(F^C\\) is a conservative force, \\(F^D\\) is a dissipative\n  force, and \\(F^R\\) is a random force.  \\(r_{ij}\\) is a unit\n  vector in the direction \\(r_i - r_j\\), \\(V_{ij} is the vector\n  difference in velocities of the two atoms :math:\\)alpha` is a Gaussian random number with zero mean and\n  unit variance, dt is the timestep size, and w(r) is a weighting factor\n  that varies between 0 and 1.  \\(r_c\\) is the cutoff.  \\(\\sigma\\)\n  is set equal to \\(\\sqrt{2 k_B T \\gamma}\\), where \\(k_B\\) is the\n  Boltzmann constant and T is the temperature parameter in the pair_style\n  command.\n  For style dpd/tstat, the force on atom I due to atom J is the same\n  as the above equation, except that the conservative Fc term is\n  dropped.  Also, during the run, T is set each timestep to a ramped\n  value from Tstart to Tstop.\n  For style dpd, the pairwise energy associated with style dpd is\n  only due to the conservative force term Fc, and is shifted to be zero\n  at the cutoff distance Rc.  The pairwise virial is calculated using\n  all 3 terms.  For style dpd/tstat there is no pairwise energy, but\n  the last two terms of the formula make a contribution to the virial.\n  For style dpd, the following coefficients must be defined for each\n  pair of atoms types via the pair_coeff command as in\n  the examples above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands:\n  \n  A (force units)\n  \\(\\gamma\\) (force/velocity units)\n  cutoff (distance units)\n  \n  The last coefficient is optional.  If not specified, the global DPD\n  cutoff is used.  Note that sigma is set equal to sqrt(2 T gamma),\n  where T is the temperature set by the pair_style\n  command so it does not need to be specified.\n  For style dpd/tstat, the coefficients defined for each pair of\n  atoms types via the pair_coeff command is the same,\n  except that A is not included.\n  The GPU-accelerated versions of these styles are implemented based on\n  the work of (Afshar) and (Phillips).\n  \n  Note\n  If you are modeling DPD polymer chains, you may want to use the\n  pair_style srp command in conjunction with these pair\n  styles.  It is a soft segmental repulsive potential (SRP) that can\n  prevent DPD polymer chains from crossing each other.\n  \n  \n  Note\n  The virial calculation for pressure when using these pair styles\n  includes all the components of force listed above, including the\n  random force.  Since the random force depends on random numbers,\n  everything that changes the order of atoms in the neighbor list\n  (e.g. different number of MPI ranks or a different neighbor list\n  skin distance) will also change the sequence in which the random\n  numbers are applied and thus the individual forces and therefore\n  also the virial/pressure.\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  These pair styles do not support mixing.  Thus, coefficients for all\n  I,J pairs must be specified explicitly.\n  These pair styles do not support the pair_modify\n  shift option for the energy of the pair interaction.  Note that as\n  discussed above, the energy due to the conservative Fc term is already\n  shifted to be 0.0 at the cutoff distance Rc.\n  The pair_modify table option is not relevant\n  for these pair styles.\n  These pair style do not support the pair_modify\n  tail option for adding long-range tail corrections to energy and\n  pressure.\n  These pair styles writes their information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.  Note\n  that the user-specified random number seed is stored in the restart\n  file, so when a simulation is restarted, each processor will\n  re-initialize its random number generator the same way it did\n  initially.  This means the random forces will be random, but will not\n  be the same as they would have been if the original simulation had\n  continued past the restart time.\n  These pair styles can only be used via the pair keyword of the\n  run_style respa command.  They do not support the\n  inner, middle, outer keywords.\n  The dpd/tstat style can ramp its target temperature over multiple\n  runs, using the start and stop keywords of the run\n  command.  See the run command for details of how to do\n  this.\n  ",
    "syntax": "pair_style dpd T cutoff seed\n  pair_style dpd/tstat Tstart Tstop cutoff seed\n  \n  \n  \n  T = temperature (temperature units)\n  Tstart,Tstop = desired temperature at start/end of run (temperature units)\n  cutoff = global cutoff for DPD interactions (distance units)\n  seed = random # seed (positive integer)\n  \n  ",
    "examples": "pair_style dpd 1.0 2.5 34387\n  pair_coeff * * 3.0 1.0\n  pair_coeff 1 1 3.0 1.0 1.0\n  \n  pair_style dpd/tstat 1.0 1.0 2.5 34387\n  pair_coeff * * 1.0\n  pair_coeff 1 1 1.0 1.0\n  \n  \n  ",
    "restrictions": "The default frequency for rebuilding neighbor lists is every 10 steps\n  (see the neigh_modify command). This may be too\n  infrequent for style dpd simulations since particles move rapidly\n  and can overlap by large amounts.  If this setting yields a non-zero\n  number of “dangerous” reneighborings (printed at the end of a\n  simulation), you should experiment with forcing reneighboring more\n  often and see if system energies/trajectories change.\n  These pair styles requires you to use the comm_modify vel yes command so that velocities are stored by ghost\n  atoms.\n  These pair styles will not restart exactly when using the\n  read_restart command, though they should provide\n  statistically similar results.  This is because the forces they\n  compute depend on atom velocities.  See the\n  read_restart command for more details.\n  "
},
{
    "command": "pair_style dpd/fdt",
    "description": "Styles dpd/fdt and dpd/fdt/energy compute the force for dissipative\n  particle dynamics (DPD) simulations.  The dpd/fdt style is used to\n  perform DPD simulations under isothermal and isobaric conditions,\n  while the dpd/fdt/energy style is used to perform DPD simulations\n  under isoenergetic and isoenthalpic conditions (see (Lisal)).\n  For DPD simulations in general, the force on atom I due to atom J is\n  given as a sum of 3 terms\n  \n  \\[\\begin{split}\\vec{f}  = & (F^C + F^D + F^R) \\hat{r_{ij}} \\qquad \\qquad r < r_c \\\\\n  F^C      = & A w(r) \\\\\n  F^D      = & - \\gamma w^2(r) (\\hat{r_{ij}} \\bullet \\vec{v_{ij}}) \\\\\n  F^R      = & \\sigma w(r) \\alpha (\\Delta t)^{-1/2} \\\\\n  w(r)     = & 1 - r/r_c\\end{split}\\]\n  where \\(F^C\\) is a conservative force, \\(F^D\\) is a dissipative\n  force, and \\(F^R\\) is a random force.  \\(r_{ij}\\) is a unit\n  vector in the direction \\(r_i - r_j\\), \\(V_{ij} is the vector\n  difference in velocities of the two atoms :math:\\)alpha` is a Gaussian random number with zero mean and\n  unit variance, dt is the timestep size, and w(r) is a weighting factor\n  that varies between 0 and 1.  Rc is the cutoff.  The weighting factor,\n  \\(\\omega_{ij}\\), varies between 0 and 1, and is chosen to have the\n  following functional form:\n  \n  \\[\\omega_{ij} = 1 - \\frac{r_{ij}}{r_{c}}\\]\n  Note that alternative definitions of the weighting function exist, but\n  would have to be implemented as a separate pair style command.\n  For style dpd/fdt, the fluctuation-dissipation theorem defines \\(\\gamma\\)\n  to be set equal to \\(\\sigma^2/(2 T)\\), where T is the set point\n  temperature specified as a pair style parameter in the above examples.\n  The following coefficients must be defined for each pair of atoms types\n  via the pair_coeff command as in the examples above,\n  or in the data file or restart files read by the\n  read_data or read_restart commands:\n  \n  A (force units)\n  \\(\\sigma\\) (force*time^(1/2) units)\n  cutoff (distance units)\n  \n  The last coefficient is optional.  If not specified, the global DPD\n  cutoff is used.\n  Style dpd/fdt/energy is used to perform DPD simulations under\n  isoenergetic and isoenthalpic conditions.  The fluctuation-dissipation\n  theorem defines \\(\\gamma\\) to be set equal to \\(sigma^2/(2\n  \\theta)\\), where :math:theta` is the average internal temperature for the\n  pair. The particle internal temperature is related to the particle\n  internal energy through a mesoparticle equation of state (see fix\n  eos). The differential internal conductive and mechanical\n  energies are computed within style dpd/fdt/energy as:\n  \n  \\[\\begin{split}du_{i}^{cond}  = & \\kappa_{ij}(\\frac{1}{\\theta_{i}}-\\frac{1}{\\theta_{j}})\\omega_{ij}^{2} + \\alpha_{ij}\\omega_{ij}\\zeta_{ij}^{q}(\\Delta{t})^{-1/2} \\\\\n  du_{i}^{mech}  = & -\\frac{1}{2}\\gamma_{ij}\\omega_{ij}^{2}(\\frac{\\vec{r_{ij}}}{r_{ij}}\\bullet\\vec{v_{ij}})^{2} -\n  \\frac{\\sigma^{2}_{ij}}{4}(\\frac{1}{m_{i}}+\\frac{1}{m_{j}})\\omega_{ij}^{2} -\n  \\frac{1}{2}\\sigma_{ij}\\omega_{ij}(\\frac{\\vec{r_{ij}}}{r_{ij}}\\bullet\\vec{v_{ij}})\\zeta_{ij}(\\Delta{t})^{-1/2}\\end{split}\\]\n  where\n  \n  \\[\\begin{split}\\alpha_{ij}^{2}  = & 2k_{B}\\kappa_{ij} \\\\\n  \\sigma^{2}_{ij}  = & 2\\gamma_{ij}k_{B}\\Theta_{ij} \\\\\n  \\Theta_{ij}^{-1}  = & \\frac{1}{2}(\\frac{1}{\\theta_{i}}+\\frac{1}{\\theta_{j}})\\end{split}\\]\n  \\(\\zeta_ij^q\\) is a second Gaussian random number with zero mean and unit\n  variance that is used to compute the internal conductive energy. The\n  fluctuation-dissipation theorem defines \\(alpha^2\\) to be set\n  equal to :math:2k_Bkappa`, where \\(\\kappa\\) is the mesoparticle thermal\n  conductivity parameter.   The following coefficients must be defined for\n  each pair of atoms types via the pair_coeff\n  command as in the examples above, or in the data file or restart files\n  read by the read_data or read_restart\n  commands:\n  \n  A (force units)\n  \\(\\sigma\\) (force*time^(1/2) units)\n  \\(\\kappa\\) (energy*temperature/time units)\n  cutoff (distance units)\n  \n  The last coefficient is optional.  If not specified, the global DPD\n  cutoff is used.\n  The pairwise energy associated with styles dpd/fdt and\n  dpd/fdt/energy is only due to the conservative force term Fc, and is\n  shifted to be zero at the cutoff distance Rc.  The pairwise virial is\n  calculated using only the conservative term.\n  The forces computed through the dpd/fdt and dpd/fdt/energy styles\n  can be integrated with the velocity-Verlet integration scheme or the\n  Shardlow splitting integration scheme described by (Lisal).\n  In the cases when these pair styles are combined with the\n  fix shardlow, these pair styles differ from the\n  other dpd styles in that the dissipative and random forces are split\n  from the force calculation and are not computed within the pair style.\n  Thus, only the conservative force is computed by the pair style,\n  while the stochastic integration of the dissipative and random forces\n  are handled through the Shardlow splitting algorithm approach.  The\n  Shardlow splitting algorithm is advantageous, especially when\n  performing DPD under isoenergetic conditions, as it allows\n  significantly larger timesteps to be taken.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "pair_style style args\n  \n  \n  \n  style = dpd/fdt or dpd/fdt/energy\n  args = list of arguments for a particular style\n  \n  dpd/fdt args = T cutoff seed\n    T = temperature (temperature units)\n    cutoff = global cutoff for DPD interactions (distance units)\n    seed = random # seed (positive integer)\n  dpd/fdt/energy args = cutoff seed\n    cutoff = global cutoff for DPD interactions (distance units)\n    seed = random # seed (positive integer)\n  ",
    "examples": "pair_style dpd/fdt 300.0 2.5 34387\n  pair_coeff * * 3.0 1.0 2.5\n  \n  pair_style dpd/fdt/energy 2.5 34387\n  pair_coeff * * 3.0 1.0 0.1 2.5\n  \n  \n  ",
    "restrictions": "These commands are part of the USER-DPD package.  They are only\n  enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\n  Pair styles dpd/fdt and dpd/fdt/energy require use of the\n  comm_modify vel yes option so that velocities are\n  stored by ghost atoms.\n  Pair style dpd/fdt/energy requires atom_style dpd\n  to be used in order to properly account for the particle internal\n  energies and temperatures.\n  "
},
{
    "command": "pair_style drip",
    "description": "Style drip computes the interlayer interactions of layered materials using\n  the dihedral-angle-corrected registry-dependent (DRIP) potential as described\n  in (Wen), which is based on the (Kolmogorov)\n  potential and provides an improved prediction for forces.\n  The total potential energy of a system is\n  \n  \\[\\begin{split}E = & \\frac{1}{2} \\sum_{i} \\sum_{j\\notin\\text{layer}\\,i} \\phi_{ij} \\\\\n  \\phi_{ij} = &f_\\text{c}(x_r) \\left[ e^{-\\lambda(r_{ij} - z_0 )} \\left[C+f(\\rho_{ij})+  g(\\rho_{ij}, \\{\\alpha_{ij}^{(m)}\\}) \\right]- A\\left (\\frac{z_0}{r_{ij}} \\right)^6 \\right]\\end{split}\\]\n  where the \\(r^{-6}\\) term models the attractive London dispersion,\n  the exponential term is designed to capture the registry effect due to\n  overlapping pi bonds, and fc is a cutoff function.\n  This potential (DRIP) only provides the interlayer interactions between\n  graphene layers. So, to perform a realistic simulation, it should be used in\n  combination with an intralayer potential such as REBO and\n  Tersoff.\n  To keep the intralayer interactions unaffected, we should avoid applying DRIP\n  to contribute energy to intralayer interactions. This can be achieved by\n  assigning different molecular IDs to atoms in different layers, and DRIP is\n  implemented such that only atoms with different molecular ID can interact with\n  each other. For this purpose, atom style “molecular” or\n  “full” has to be used.\n  On the other way around, REBO (Tersoff\n  or any other potential used to provide the intralayer interactions) should not\n  interfere with the interlayer interactions described by DRIP. This is typically\n  automatically achieved using the commands provided in the Examples section\n  above, since the cutoff distance for carbon-carbon interaction in the intralayer\n  potentials (e.g. 2 Angstrom for REBO) is much smaller than\n  the equilibrium layer distance of graphene layers (about 3.4 Angstrom).\n  If you want, you can enforce this by assigning different atom types to atoms in\n  different layers, and apply an intralayer potential to one atom type.\n  See pair_hybrid for details.\n  \n  The pair_coeff command for DRIP takes 4+N arguments, where\n  N is the number of LAMMPS atom types. The fist three arguments must be fixed\n  to be * * drip, the fourth argument is the path to the DRIP parameter file,\n  and the remaining N arguments specifying the mapping between element in the\n  parameter file and atom types. For example, if your LAMMPS simulation has 3 atom\n  types and you want all of them to be C, you would use the following pair_coeff\n  command:\n  pair_coeff * * drip  C.drip  C C C\n  \n  \n  If a mapping value is specified as NULL, the mapping is not performed. This\n  could be useful when DRIP is used to model part of the system where other\n  element exists. Suppose you have a hydrocarbon system, with C of atom type 1\n  and H of atom type 2, you can use the following command to inform DRIP not to\n  model H atoms:\n  pair_style hybrid/overlay drip rebo\n  pair_coeff * * drip  C.drip     C NULL\n  pair_coeff * * rebo  CH.airebo  C H\n  \n  \n  \n  Note\n  The potential parameters developed in (Wen) are provided with\n  LAMMPS (see the “potentials” directory). Besides those in Wen, an\n  additional parameter “normal_cutoff”, specific to the LAMMPS implementation, is\n  used to find the three nearest neighbors of an atom to construct the normal.\n  \n  \n  Mixing, shift, table, tail correction, and restart info:\n  This pair style does not support the pair_modify mix, shift, table,\n  and tail options.\n  This pair style does not write their information to binary restart files, since\n  it is stored in potential files. Thus, you need to re-specify the pair_style and\n  pair_coeff commands in an input script that reads a restart file.\n  ",
    "syntax": "pair_style hybrid/overlay drip [styles ...]\n  \n  \n  \n  styles = other styles to be overlayed with drip (optional)\n  \n  ",
    "examples": "pair_style hybrid/overlay drip\n  pair_coeff * * none\n  pair_coeff * * drip  C.drip  C\n  \n  pair_style hybrid/overlay drip rebo\n  pair_coeff * * drip  C.drip     C\n  pair_coeff * * rebo  CH.airebo  C\n  \n  pair_style hybrid/overlay drip rebo\n  pair_coeff * * drip  C.drip     C NULL\n  pair_coeff * * rebo  CH.airebo  C H\n  \n  \n  ",
    "restrictions": "This pair style is part of the USER-MISC package. It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc\n  page for more info.\n  This pair potential requires the newton setting to be “on” for\n  pair interactions.\n  The C.drip parameter file provided with LAMMPS (see the “potentials”\n  directory) is parameterized for metal units. You can use the DRIP\n  potential with any LAMMPS units, but you would need to create your own custom\n  parameter file with coefficients listed in the appropriate units, if your\n  simulation does not use “metal” units.\n  "
},
{
    "command": "pair_style dsmc",
    "description": "Style dsmc computes collisions between pairs of particles for a\n  direct simulation Monte Carlo (DSMC) model following the exposition in\n  (Bird).  Each collision resets the velocities of the two\n  particles involved.  The number of pairwise collisions for each pair\n  or particle types and the length scale within which they occur are\n  determined by the parameters of the pair_style and pair_coeff\n  commands.\n  Stochastic collisions are performed using the variable hard sphere\n  (VHS) approach, with the user-defined max_cell_size value used as\n  the maximum DSMC cell size, and reference cross-sections for\n  collisions given using the pair_coeff command.\n  There is no pairwise energy or virial contributions associated with\n  this pair style.\n  The following coefficient must be defined for each pair of atoms types\n  via the pair_coeff command as in the examples above,\n  or in the data file or restart files read by the\n  read_data or read_restart\n  commands:\n  \n  sigma (area units, i.e. distance-squared)\n  \n  The global DSMC max_cell_size determines the maximum cell length\n  used in the DSMC calculation.  A structured mesh is overlayed on the\n  simulation box such that an integer number of cells are created in\n  each direction for each processor’s sub-domain.  Cell lengths are\n  adjusted up to the user-specified maximum cell size.\n  \n  To perform a DSMC simulation with LAMMPS, several additional options\n  should be set in your input script, though LAMMPS does not check for\n  these settings.\n  Since this pair style does not compute particle forces, you should use\n  the “fix nve/noforce” time integration fix for the DSMC particles,\n  e.g.\n  fix 1 all nve/noforce\n  \n  \n  This pair style assumes that all particles will communicated to\n  neighboring processors every timestep as they move.  This makes it\n  possible to perform all collisions between pairs of particles that are\n  on the same processor.  To ensure this occurs, you should use\n  these commands:\n  neighbor 0.0 bin\n  neigh_modify every 1 delay 0 check no\n  atom_modify sort 0 0.0\n  communicate single cutoff 0.0\n  \n  \n  These commands ensure that LAMMPS communicates particles to\n  neighboring processors every timestep and that no ghost atoms are\n  created.  The output statistics for a simulation run should indicate\n  there are no ghost particles or neighbors.\n  In order to get correct DSMC collision statistics, users should\n  specify a Gaussian velocity distribution when populating the\n  simulation domain. Note that the default velocity distribution is\n  uniform, which will not give good DSMC collision rates. Specify\n  “dist gaussian” when using the velocity command\n  as in the following:\n  velocity all create 594.6 87287 loop geom dist gaussian\n  \n  \n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This pair style does not support mixing.  Thus, coefficients for all\n  I,J pairs must be specified explicitly.\n  This pair style does not support the pair_modify\n  shift option for the energy of the pair interaction.\n  The pair_modify table option is not relevant\n  for this pair style.\n  This pair style does not support the pair_modify\n  tail option for adding long-range tail corrections to energy and\n  pressure.\n  This pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.  Note\n  that the user-specified random number seed is stored in the restart\n  file, so when a simulation is restarted, each processor will\n  re-initialize its random number generator the same way it did\n  initially.  This means the random forces will be random, but will not\n  be the same as they would have been if the original simulation had\n  continued past the restart time.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style dsmc max_cell_size seed weighting Tref Nrecompute Nsample\n  \n  \n  \n  max_cell_size = global maximum cell size for DSMC interactions (distance units)\n  seed = random # seed (positive integer)\n  weighting = macroparticle weighting\n  Tref = reference temperature (temperature units)\n  Nrecompute = re-compute v*sigma_max every this many timesteps (timesteps)\n  Nsample = sample this many times in recomputing v*sigma_max\n  \n  ",
    "examples": "pair_style dsmc 2.5 34387 10 1.0 100 20\n  pair_coeff * * 1.0\n  pair_coeff 1 1 1.0\n  \n  \n  ",
    "restrictions": "This style is part of the MC package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style e3b",
    "description": "The e3b style computes an “explicit three-body” (E3B) potential for water (Kumar 2008).\n  \n  \\[\\begin{split}E =& E_2 \\sum_{i,j}e^{-k_2 r_{ij}} + E_A \\sum_{\\substack{i,j,k,\\ell \\\\\n  \\in \\textrm{type A}}} f(r_{ij})f(r_{k\\ell}) + E_B \\sum_{\\substack{i,j,k,\\ell \\\\\n  \\in \\textrm{type B}}} f(r_{ij})f(r_{k\\ell}) + E_C \\sum_{\\substack{i,j,k,\\ell \\\\\n  \\in \\textrm{type C}}} f(r_{ij})f(r_{k\\ell}) \\\\\n  f(r) =& e^{-k_3 r}s(r) \\\\\n  s(r) =& \\begin{cases}\n  1 & r<R_s \\\\\n  \\displaystyle\\frac{(R_f-r)^2(R_f-3R_s+2r)}{(R_f-R_s)^3} & R_s\\leq r\\leq R_f \\\\\n  0 & r>R_f\\\\\n  \\end{cases}\\end{split}\\]\n  This potential was developed as a water model that includes the three-body cooperativity of hydrogen bonding explicitly.\n  To use it in this way, it must be applied in conjunction with a conventional two-body water model, through pair_style hybrid/overlay.\n  The three body interactions are split into three types: A, B, and C.\n  Type A corresponds to anti-cooperative double hydrogen bond donor interactions.\n  Type B corresponds to the cooperative interaction of molecules that both donate and accept a hydrogen bond.\n  Type C corresponds to anti-cooperative double hydrogen bond acceptor interactions.\n  The three-body interactions are smoothly cutoff by the switching function s(r) between Rs and Rc3.\n  The two-body interactions are designed to correct for the effective many-body interactions implicitly included in the conventional two-body potential.\n  The two-body interactions are cut off sharply at Rc2, because K3 is typically significantly smaller than K2.\n  See (Kumar 2008) for more details.\n  Only a single pair_coeff command is used with the e3b style.\n  The 1st two arguments must be * *.\n  The oxygen atom type for the pair style is passed as the only argument to the pair_style command, not in the pair_coeff command.\n  The hydrogen atom type is inferred by the ordering of the atoms.\n  \n  Note\n  Every atom of type Otype must be part of a water molecule.\n  Each water molecule must have consecutive IDs with the oxygen first.\n  This pair style does not test that this criteria is met.\n  \n  The pair_coeff command must have at least one keyword/value pair, as described above.\n  The preset keyword sets the potential parameters to the values used in (Tainter 2011) or (Tainter 2015).\n  To use the water models defined in those references, the e3b style should always be used in conjunction with an lj/cut/tip4p/long style through pair_style hybrid/overlay, as demonstrated in the second example above.\n  The preset 2011 option should be used with the TIP4P water model.\n  The preset 2015 option should be used with the TIP4P/2005 water model.\n  If the preset keyword is used, no other keyword is needed.\n  Changes to the preset parameters can be made by specifying the preset keyword followed by the specific parameter to change, like Ea.\n  Note that the other keywords must come after preset in the pair_style command.\n  The e3b style can also be used to implement any three-body potential of the same form by specifying all the keywords except neigh: Ea, Eb, Ec, E2, K3, K2, Rc3, Rc2, Rs, and bondL.\n  The keyword bondL specifies the intramolecular OH bond length of the water model being used.\n  This is needed to include H atoms that are within the cutoff even when the attached oxygen atom is not.\n  This pair style allocates arrays sized according to the number of pairwise interactions within Rc3.\n  To do this it needs an estimate for the number of water molecules within Rc3 of an oxygen atom.\n  This estimate defaults to 10 and can be changed using the neigh keyword, which takes an integer as an argument.\n  If the neigh setting is too small, the simulation will fail with the error “neigh is too small”.\n  If the neigh setting is too large, the pair style will use more memory than necessary.\n  This pair style tallies a breakdown of the total E3B potential energy into sub-categories, which can be accessed via the compute pair command as a vector of values of length 4.\n  The 4 values correspond to the terms in the first equation above: the E2 term, the Ea term, the Eb term, and the Ec term.\n  See the examples/USER/misc/e3b directory for a complete example script.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This pair style does not support the pair_modify\n  shift, table, and tail options.\n  This pair style does not write its information to binary restart files.  Thus, you\n  need to re-specify the pair_style and pair_coeff commands in an input\n  script that reads a restart file.\n  This pair style is incompatible with respa.\n  ",
    "syntax": "pair_style e3b Otype\n  \n  \n  \n  Otype = atom type for oxygen\n  \n  pair_coeff * * keyword\n  \n  \n  \n  one or more keyword/value pairs must be appended.\n  keyword = preset or Ea or Eb or Ec or E2 or K3 or K2 or Rs or Rc3 or Rc2 or bondL or neigh\n  If the preset keyword is given, no others are needed.\n  Otherwise, all are mandatory except for neigh.\n  The neigh keyword is always optional.\n  \n  preset arg = 2011 or 2015 = which set of predefined parameters to use\n           2011 = use the potential parameters from (Tainter 2011)\n           2015 = use the potential parameters from (Tainter 2015)\n  Ea arg = three-body energy for type A hydrogen bonding interactions (energy units)\n  Eb arg = three-body energy for type B hydrogen bonding interactions (energy units)\n  Ec arg = three-body energy for type C hydrogen bonding interactions (energy units)\n  E2 arg = two-body energy correction (energy units)\n  K3 arg = three-body exponential constant (inverse distance units)\n  K2 arg = two-body exponential constant (inverse distance units)\n  Rc3 arg = three-body cutoff (distance units)\n  Rc2 arg = two-body cutoff (distance units)\n  Rs arg = three-body switching function cutoff (distance units)\n  bondL arg = intramolecular OH bond length (distance units)\n  neigh arg = approximate integer number of molecules within Rc3 of an oxygen atom\n  ",
    "examples": "pair_style e3b 1\n  pair_coeff * * Ea 35.85 Eb -240.2 Ec 449.3 E2 108269.9 K3 1.907 K2 4.872 Rc3 5.2 Rc2 5.2 Rs 5.0 bondL 0.9572\n  \n  pair_style hybrid/overlay e3b 1 lj/cut/tip4p/long 1 2 1 1 0.15 8.5\n  pair_coeff * * e3b preset 2011\n  \n  \n  ",
    "restrictions": "This pair style is part of the USER-MISC package.  It is only enabled\n  if LAMMPS was built with that package.  See the Build package doc page for more info.\n  This pair style requires the newton setting to be “on”\n  for pair interactions.\n  This pair style requires a fixed number of atoms in the simulation, so it is incompatible with fixes like fix deposit.\n  If the number of atoms changes between runs, this pair style must be re-initialized by calling the pair_style and pair_coeffs commands.\n  This is not a fundamental limitation of the pair style, but the code currently does not support a variable number of atoms.\n  The preset keyword currently only works with real, metal, si, and cgs units.\n  "
},
{
    "command": "pair_style eam",
    "description": "Style eam computes pairwise interactions for metals and metal alloys\n  using embedded-atom method (EAM) potentials (Daw).  The total\n  energy Ei of an atom I is given by\n  \n  \\[E_i = F_\\alpha \\left(\\sum_{j \\neq i}\\ \\rho_\\beta (r_{ij})\\right) +\n        \\frac{1}{2} \\sum_{j \\neq i} \\phi_{\\alpha\\beta} (r_{ij})\\]\n  where F is the embedding energy which is a function of the atomic\n  electron density rho, phi is a pair potential interaction, and alpha\n  and beta are the element types of atoms I and J.  The multi-body\n  nature of the EAM potential is a result of the embedding energy term.\n  Both summations in the formula are over all neighbors J of atom I\n  within the cutoff distance.\n  The cutoff distance and the tabulated values of the functionals F,\n  rho, and phi are listed in one or more files which are specified by\n  the pair_coeff command.  These are ASCII text files\n  in a DYNAMO-style format which is described below.  DYNAMO was the\n  original serial EAM MD code, written by the EAM originators.  Several\n  DYNAMO potential files for different metals are included in the\n  “potentials” directory of the LAMMPS distribution.  All of these files\n  are parameterized in terms of LAMMPS metal units.\n  \n  Note\n  The eam style reads single-element EAM potentials in the\n  DYNAMO funcfl format.  Either single element or alloy systems can be\n  modeled using multiple funcfl files and style eam.  For the alloy\n  case LAMMPS mixes the single-element potentials to produce alloy\n  potentials, the same way that DYNAMO does.  Alternatively, a single\n  DYNAMO setfl file or Finnis/Sinclair EAM file can be used by LAMMPS\n  to model alloy systems by invoking the eam/alloy or eam/cd or\n  eam/fs styles as described below.  These files require no mixing\n  since they specify alloy interactions explicitly.\n  \n  \n  Note\n  Note that unlike for other potentials, cutoffs for EAM\n  potentials are not set in the pair_style or pair_coeff command; they\n  are specified in the EAM potential files themselves.  Likewise, the\n  EAM potential files list atomic masses; thus you do not need to use\n  the mass command to specify them.\n  \n  There are several WWW sites that distribute and document EAM\n  potentials stored in DYNAMO or other formats:\n  http://www.ctcms.nist.gov/potentials\n  http://cst-www.nrl.navy.mil/ccm6/ap\n  http://enpub.fulton.asu.edu/cms/potentials/main/main.htm\n  https://openkim.org\n  \n  \n  These potentials should be usable with LAMMPS, though the alternate\n  formats would need to be converted to the DYNAMO format used by LAMMPS\n  and described on this page.  The NIST site is maintained by Chandler\n  Becker (cbecker at nist.gov) who is good resource for info on\n  interatomic potentials and file formats.\n  The OpenKIM Project at\n  https://openkim.org/browse/models/by-type\n  provides EAM potentials that can be used directly in LAMMPS with the\n  kim_commands interface.\n  \n  For style eam, potential values are read from a file that is in the\n  DYNAMO single-element funcfl format.  If the DYNAMO file was created\n  by a Fortran program, it cannot have “D” values in it for exponents.\n  C only recognizes “e” or “E” for scientific notation.\n  Note that unlike for other potentials, cutoffs for EAM potentials are\n  not set in the pair_style or pair_coeff command; they are specified in\n  the EAM potential files themselves.\n  For style eam a potential file must be assigned to each I,I pair of\n  atom types by using one or more pair_coeff commands, each with a\n  single argument:\n  \n  filename\n  \n  Thus the following command\n  pair_coeff *2 1*2 cuu3.eam\n  \n  \n  will read the cuu3 potential file and use the tabulated Cu values for\n  F, phi, rho that it contains for type pairs 1,1 and 2,2 (type pairs\n  1,2 and 2,1 are ignored).  See the pair_coeff doc\n  page for alternate ways to specify the path for the potential file.\n  In effect, this makes atom types 1 and 2 in LAMMPS be Cu atoms.\n  Different single-element files can be assigned to different atom types\n  to model an alloy system.  The mixing to create alloy potentials for\n  type pairs with I != J is done automatically the same way that the\n  serial DYNAMO code originally did it; you do not need to specify\n  coefficients for these type pairs.\n  Funcfl files in the potentials directory of the LAMMPS\n  distribution have an “.eam” suffix.  A DYNAMO single-element funcfl\n  file is formatted as follows:\n  \n  line 1: comment (ignored)\n  line 2: atomic number, mass, lattice constant, lattice type (e.g. FCC)\n  line 3: Nrho, drho, Nr, dr, cutoff\n  \n  On line 2, all values but the mass are ignored by LAMMPS.  The mass is\n  in mass units, e.g. mass number or grams/mole for metal\n  units.  The cubic lattice constant is in Angstroms.  On line 3, Nrho\n  and Nr are the number of tabulated values in the subsequent arrays,\n  drho and dr are the spacing in density and distance space for the\n  values in those arrays, and the specified cutoff becomes the pairwise\n  cutoff used by LAMMPS for the potential.  The units of dr are\n  Angstroms; I’m not sure of the units for drho - some measure of\n  electron density.\n  Following the three header lines are three arrays of tabulated values:\n  \n  embedding function F(rho) (Nrho values)\n  effective charge function Z(r) (Nr values)\n  density function rho(r) (Nr values)\n  \n  The values for each array can be listed as multiple values per line,\n  so long as each array starts on a new line.  For example, the\n  individual Z(r) values are for r = 0,dr,2*dr, … (Nr-1)*dr.\n  The units for the embedding function F are eV.  The units for the\n  density function rho are the same as for drho (see above, electron\n  density).  The units for the effective charge Z are “atomic charge” or\n  sqrt(Hartree * Bohr-radii).  For two interacting atoms i,j this is used\n  by LAMMPS to compute the pair potential term in the EAM energy\n  expression as r*phi, in units of eV-Angstroms, via the formula\n  \n  \\[r \\cdot \\phi = 27.2 \\cdot 0.529 \\cdot Z_i \\cdot Z_j\\]\n  where 1 Hartree = 27.2 eV and 1 Bohr = 0.529 Angstroms.\n  \n  Style eam/alloy computes pairwise interactions using the same\n  formula as style eam.  However the associated\n  pair_coeff command reads a DYNAMO setfl file\n  instead of a funcfl file.  Setfl files can be used to model a\n  single-element or alloy system.  In the alloy case, as explained\n  above, setfl files contain explicit tabulated values for alloy\n  interactions.  Thus they allow more generality than funcfl files for\n  modeling alloys.\n  For style eam/alloy, potential values are read from a file that is\n  in the DYNAMO multi-element setfl format, except that element names\n  (Ni, Cu, etc) are added to one of the lines in the file.  If the\n  DYNAMO file was created by a Fortran program, it cannot have “D”\n  values in it for exponents.  C only recognizes “e” or “E” for\n  scientific notation.\n  Only a single pair_coeff command is used with the eam/alloy style\n  which specifies a DYNAMO setfl file, which contains information for\n  M elements.  These are mapped to LAMMPS atom types by specifying N\n  additional arguments after the filename in the pair_coeff command,\n  where N is the number of LAMMPS atom types:\n  \n  filename\n  N element names = mapping of setfl elements to atom types\n  \n  As an example, the potentials/NiAlH_jea.eam.alloy file is a setfl\n  file which has tabulated EAM values for 3 elements and their alloy\n  interactions: Ni, Al, and H.  See the pair_coeff doc\n  page for alternate ways to specify the path for the potential file.\n  If your LAMMPS simulation has 4 atoms types and you want the 1st 3 to\n  be Ni, and the 4th to be Al, you would use the following pair_coeff\n  command:\n  pair_coeff * * NiAlH_jea.eam.alloy Ni Ni Ni Al\n  \n  \n  The 1st 2 arguments must be * * so as to span all LAMMPS atom types.\n  The first three Ni arguments map LAMMPS atom types 1,2,3 to the Ni\n  element in the setfl file.  The final Al argument maps LAMMPS atom\n  type 4 to the Al element in the setfl file.  Note that there is no\n  requirement that your simulation use all the elements specified by the\n  setfl file.\n  If a mapping value is specified as NULL, the mapping is not performed.\n  This can be used when an eam/alloy potential is used as part of the\n  hybrid pair style.  The NULL values are placeholders for atom types\n  that will be used with other potentials.\n  Setfl files in the potentials directory of the LAMMPS distribution\n  have an “.eam.alloy” suffix.  A DYNAMO multi-element setfl file is\n  formatted as follows:\n  \n  lines 1,2,3 = comments (ignored)\n  line 4: Nelements Element1 Element2 … ElementN\n  line 5: Nrho, drho, Nr, dr, cutoff\n  \n  In a DYNAMO setfl file, line 4 only lists Nelements = the # of\n  elements in the setfl file.  For LAMMPS, the element name (Ni, Cu,\n  etc) of each element must be added to the line, in the order the\n  elements appear in the file.\n  The meaning and units of the values in line 5 is the same as for the\n  funcfl file described above.  Note that the cutoff (in Angstroms) is\n  a global value, valid for all pairwise interactions for all element\n  pairings.\n  Following the 5 header lines are Nelements sections, one for each\n  element, each with the following format:\n  \n  line 1 = atomic number, mass, lattice constant, lattice type (e.g. FCC)\n  embedding function F(rho) (Nrho values)\n  density function rho(r) (Nr values)\n  \n  As with the funcfl files, only the mass (in mass units,\n  e.g. mass number or grams/mole for metal units) is used by LAMMPS from\n  the 1st line.  The cubic lattice constant is in Angstroms.  The F and\n  rho arrays are unique to a single element and have the same format and\n  units as in a funcfl file.\n  Following the Nelements sections, Nr values for each pair potential\n  phi(r) array are listed for all i,j element pairs in the same format\n  as other arrays.  Since these interactions are symmetric (i,j = j,i)\n  only phi arrays with i >= j are listed, in the following order: i,j =\n  (1,1), (2,1), (2,2), (3,1), (3,2), (3,3), (4,1), …, (Nelements,\n  Nelements).  Unlike the effective charge array Z(r) in funcfl files,\n  the tabulated values for each phi function are listed in setfl files\n  directly as r*phi (in units of eV-Angstroms), since they are for atom\n  pairs.\n  \n  Style eam/cd is similar to the eam/alloy style, except that it\n  computes alloy pairwise interactions using the concentration-dependent\n  embedded-atom method (CD-EAM).  This model can reproduce the enthalpy\n  of mixing of alloys over the full composition range, as described in\n  (Stukowski). Style eam/cd/old is an older, slightly\n  different and slower two-site formulation of the model (Caro).\n  The pair_coeff command is specified the same as for the eam/alloy\n  style.  However the DYNAMO setfl file must has two\n  lines added to it, at the end of the file:\n  \n  line 1: Comment line (ignored)\n  line 2: N Coefficient0 Coefficient1 … CoefficientN\n  \n  The last line begins with the degree N of the polynomial function\n  h(x) that modifies the cross interaction between A and B elements.\n  Then N+1 coefficients for the terms of the polynomial are then\n  listed.\n  Modified EAM setfl files used with the eam/cd style must contain\n  exactly two elements, i.e. in the current implementation the eam/cd\n  style only supports binary alloys.  The first and second elements in\n  the input EAM file are always taken as the A and B species.\n  CD-EAM files in the potentials directory of the LAMMPS\n  distribution have a “.cdeam” suffix.\n  \n  Style eam/fs computes pairwise interactions for metals and metal\n  alloys using a generalized form of EAM potentials due to Finnis and\n  Sinclair (Finnis).  The total energy Ei of an atom I is\n  given by\n  \n  \\[E_i = F_\\alpha \\left(\\sum_{j \\neq i}\\\n  \\rho_{\\alpha\\beta} (r_{ij})\\right) +\n  \\frac{1}{2} \\sum_{j \\neq i} \\phi_{\\alpha\\beta} (r_{ij})\\]\n  This has the same form as the EAM formula above, except that rho is\n  now a functional specific to the atomic types of both atoms I and J,\n  so that different elements can contribute differently to the total\n  electron density at an atomic site depending on the identity of the\n  element at that atomic site.\n  The associated pair_coeff command for style eam/fs\n  reads a DYNAMO setfl file that has been extended to include\n  additional rho_alpha_beta arrays of tabulated values.  A discussion of\n  how FS EAM differs from conventional EAM alloy potentials is given in\n  (Ackland1).  An example of such a potential is the same\n  author’s Fe-P FS potential (Ackland2).  Note that while FS\n  potentials always specify the embedding energy with a square root\n  dependence on the total density, the implementation in LAMMPS does not\n  require that; the user can tabulate any functional form desired in the\n  FS potential files.\n  For style eam/fs, the form of the pair_coeff command is exactly the\n  same as for style eam/alloy, e.g.\n  pair_coeff * * NiAlH_jea.eam.fs Ni Ni Ni Al\n  \n  \n  where there are N additional arguments after the filename, where N is\n  the number of LAMMPS atom types.  See the pair_coeff\n  doc page for alternate ways to specify the path for the potential\n  file.  The N values determine the mapping of LAMMPS atom types to EAM\n  elements in the file, as described above for style eam/alloy.  As\n  with eam/alloy, if a mapping value is NULL, the mapping is not\n  performed.  This can be used when an eam/fs potential is used as\n  part of the hybrid pair style.  The NULL values are used as\n  placeholders for atom types that will be used with other potentials.\n  FS EAM files include more information than the DYNAMO setfl format\n  files read by eam/alloy, in that i,j density functionals for all\n  pairs of elements are included as needed by the Finnis/Sinclair\n  formulation of the EAM.\n  FS EAM files in the potentials directory of the LAMMPS distribution\n  have an “.eam.fs” suffix.  They are formatted as follows:\n  \n  lines 1,2,3 = comments (ignored)\n  line 4: Nelements Element1 Element2 … ElementN\n  line 5: Nrho, drho, Nr, dr, cutoff\n  \n  The 5-line header section is identical to an EAM setfl file.\n  Following the header are Nelements sections, one for each element I,\n  each with the following format:\n  \n  line 1 = atomic number, mass, lattice constant, lattice type (e.g. FCC)\n  embedding function F(rho) (Nrho values)\n  density function rho(r) for element I at element 1 (Nr values)\n  density function rho(r) for element I at element 2\n  …\n  density function rho(r) for element I at element Nelement\n  \n  The units of these quantities in line 1 are the same as for setfl\n  files.  Note that the rho(r) arrays in Finnis/Sinclair can be\n  asymmetric (i,j != j,i) so there are Nelements^2 of them listed in the\n  file.\n  Following the Nelements sections, Nr values for each pair potential\n  phi(r) array are listed in the same manner (r*phi, units of\n  eV-Angstroms) as in EAM setfl files.  Note that in Finnis/Sinclair,\n  the phi(r) arrays are still symmetric, so only phi arrays for i >= j\n  are listed.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, where types I and J correspond to\n  two different element types, mixing is performed by LAMMPS as\n  described above with the individual styles.  You never need to specify\n  a pair_coeff command with I != J arguments for the eam styles.\n  This pair style does not support the pair_modify\n  shift, table, and tail options.\n  The eam pair styles do not write their information to binary restart files, since it is stored in tabulated potential files.\n  Thus, you need to re-specify the pair_style and pair_coeff commands in\n  an input script that reads a restart file.\n  The eam pair styles can only be used via the pair keyword of the\n  run_style respa command.  They do not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style style\n  \n  \n  \n  style = eam or eam/alloy or eam/cd or eam/cd/old or eam/fs\n  \n  ",
    "examples": "pair_style eam\n  pair_coeff * * cuu3\n  pair_coeff 1*3 1\\*3 niu3.eam\n  \n  pair_style eam/alloy\n  pair_coeff * * ../potentials/NiAlH_jea.eam.alloy Ni Al Ni Ni\n  \n  pair_style eam/cd\n  pair_coeff * * ../potentials/FeCr.cdeam Fe Cr\n  \n  pair_style eam/fs\n  pair_coeff * * NiAlH_jea.eam.fs Ni Al Ni Ni\n  \n  \n  ",
    "restrictions": "All of these styles are part of the MANYBODY package.  They are only\n  enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style edip",
    "description": "The edip and edip/multi styles compute a 3-body EDIP\n  potential which is popular for modeling silicon materials where\n  it can have advantages over other models such as the\n  Stillinger-Weber or Tersoff\n  potentials. The edip style has been programmed for single element\n  potentials, while edip/multi supports multi-element EDIP runs.\n  In EDIP, the energy E of a system of atoms is\n  \n  \\[\\begin{split}E  = & \\sum_{j \\ne i} \\phi_{2}(R_{ij}, Z_{i}) + \\sum_{j \\ne i} \\sum_{k \\ne i,k > j} \\phi_{3}(R_{ij}, R_{ik}, Z_{i}) \\\\\n  \\phi_{2}(r, Z)  = & A\\left[\\left(\\frac{B}{r}\\right)^{\\rho} - e^{-\\beta Z^2}\\right]exp{\\left(\\frac{\\sigma}{r-a}\\right)} \\\\\n  \\phi_{3}(R_{ij}, R_{ik}, Z_i)  = & exp{\\left(\\frac{\\gamma}{R_{ij}-a}\\right)}exp{\\left(\\frac{\\gamma}{R_{ik}-a}\\right)}h(cos\\theta_{ijk},Z_i) \\\\\n  Z_i  = & \\sum_{m \\ne i} f(R_{im}) \\qquad\n  f(r) = \\begin{cases}\n         1 & \\quad r<c \\\\\n         \\exp\\left(\\frac{\\alpha}{1-x^{-3}}\\right) & \\quad c<r<a \\\\\n         0 & \\quad r>a\n         \\end{cases} \\\\\n  h(l,Z)  = & \\lambda [(1-e^{-Q(Z)(l+\\tau(Z))^2}) + \\eta Q(Z)(l+\\tau(Z))^2 ] \\\\\n  Q(Z)  = & Q_0 e^{-\\mu Z} \\qquad \\tau(Z) = u_1 + u_2 (u_3 e^{-u_4 Z} - e^{-2u_4 Z})\\end{split}\\]\n  where \\(\\phi_2\\) is a two-body term and \\(\\phi_3\\) is a\n  three-body term.  The summations in the formula are over all neighbors J\n  and K of atom I within a cutoff distance = a.  Both terms depend on the\n  local environment of atom I through its effective coordination number\n  defined by Z, which is unity for a cutoff distance < c and gently goes\n  to 0 at distance = a.\n  Only a single pair_coeff command is used with the edip style which\n  specifies a EDIP potential file with parameters for all\n  needed elements.  These are mapped to LAMMPS atom types by specifying\n  N additional arguments after the filename in the pair_coeff command,\n  where N is the number of LAMMPS atom types:\n  \n  filename\n  N element names = mapping of EDIP elements to atom types\n  \n  See the pair_coeff doc page for alternate ways\n  to specify the path for the potential file.\n  As an example, imagine a file Si.edip has EDIP values for Si.\n  EDIP files in the potentials directory of the LAMMPS\n  distribution have a “.edip” suffix.  Lines that are not blank or\n  comments (starting with #) define parameters for a triplet of\n  elements.  The parameters in a single entry correspond to the two-body\n  and three-body coefficients in the formula above:\n  \n  element 1 (the center atom in a 3-body interaction)\n  element 2\n  element 3\n  A (energy units)\n  B (distance units)\n  cutoffA (distance units)\n  cutoffC (distance units)\n  \\(\\alpha\\)\n  \\(\\beta\\)\n  \\(\\eta\\)\n  \\(\\gamma\\) (distance units)\n  \\(lambda\\) (energy units)\n  \\(\\mu\\)\n  \\(\\tau\\)\n  \\(\\sigma\\) (distance units)\n  Q0\n  u1\n  u2\n  u3\n  u4\n  \n  The A, B, beta, sigma parameters are used only for two-body interactions.\n  The eta, gamma, lambda, mu, Q0 and all u1 to u4 parameters are used only\n  for three-body interactions. The alpha and cutoffC parameters are used\n  for the coordination environment function only.\n  The EDIP potential file must contain entries for all the\n  elements listed in the pair_coeff command.  It can also contain\n  entries for additional elements not being used in a particular\n  simulation; LAMMPS ignores those entries.\n  For a single-element simulation, only a single entry is required\n  (e.g. SiSiSi).  For a two-element simulation, the file must contain 8\n  entries (for SiSiSi, SiSiC, SiCSi, SiCC, CSiSi, CSiC, CCSi, CCC), that\n  specify EDIP parameters for all permutations of the two elements\n  interacting in three-body configurations.  Thus for 3 elements, 27\n  entries would be required, etc.\n  At the moment, only a single element parameterization is\n  implemented. However, the author is not aware of other\n  multi-element EDIP parameterization. If you know any and\n  you are interest in that, please contact the author of\n  the EDIP package.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This pair style does not support the pair_modify\n  shift, table, and tail options.\n  This pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\n  need to re-specify the pair_style and pair_coeff commands in an input\n  script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style style\n  \n  \n  \n  style = edip or edip/multi\n  \n  ",
    "examples": "pair_style edip\n  pair_coeff * * Si.edip Si\n  \n  \n  ",
    "restrictions": "This pair style can only be used if LAMMPS was built with the\n  USER-MISC package.  See the Build package doc\n  page for more info.\n  This pair style requires the newton setting to be “on”\n  for pair interactions.\n  The EDIP potential files provided with LAMMPS (see the potentials directory)\n  are parameterized for metal units.\n  You can use the EDIP potential with any LAMMPS units, but you would need\n  to create your own EDIP potential file with coefficients listed in the\n  appropriate units if your simulation does not use “metal” units.\n  "
},
{
    "command": "pair_style eff/cut",
    "description": "This pair style contains a LAMMPS implementation of the electron Force\n  Field (eFF) potential currently under development at Caltech, as\n  described in (Jaramillo-Botero).  The eFF for Z<6\n  was first introduced by (Su) in 2007. It has been extended to\n  higher Zs by using effective core potentials (ECPs) that now cover up\n  to 2nd and 3rd row p-block elements of the periodic table.\n  eFF can be viewed as an approximation to QM wave packet dynamics and\n  Fermionic molecular dynamics, combining the ability of electronic\n  structure methods to describe atomic structure, bonding, and chemistry\n  in materials, and of plasma methods to describe nonequilibrium\n  dynamics of large systems with a large number of highly excited\n  electrons.  Yet, eFF relies on a simplification of the electronic\n  wave function in which electrons are described as floating Gaussian\n  wave packets whose position and size respond to the various dynamic\n  forces between interacting classical nuclear particles and spherical\n  Gaussian electron wave packets.  The wave function is taken to be a\n  Hartree product of the wave packets.  To compensate for the lack of\n  explicit antisymmetry in the resulting wave function, a spin-dependent\n  Pauli potential is included in the Hamiltonian.  Substituting this\n  wave function into the time-dependent Schrodinger equation produces\n  equations of motion that correspond - to second order - to classical\n  Hamiltonian relations between electron position and size, and their\n  conjugate momenta.  The N-electron wave function is described as a\n  product of one-electron Gaussian functions, whose size is a dynamical\n  variable and whose position is not constrained to a nuclear\n  center. This form allows for straightforward propagation of the\n  wave function, with time, using a simple formulation from which the\n  equations of motion are then integrated with conventional MD\n  algorithms. In addition to this spin-dependent Pauli repulsion\n  potential term between Gaussians, eFF includes the electron kinetic\n  energy from the Gaussians.  These two terms are based on\n  first-principles quantum mechanics.  On the other hand, nuclei are\n  described as point charges, which interact with other nuclei and\n  electrons through standard electrostatic potential forms.\n  The full Hamiltonian (shown below), contains then a standard\n  description for electrostatic interactions between a set of\n  delocalized point and Gaussian charges which include, nuclei-nuclei\n  (NN), electron-electron (ee), and nuclei-electron (Ne). Thus, eFF is a\n  mixed QM-classical mechanics method rather than a conventional force\n  field method (in which electron motions are averaged out into ground\n  state nuclear motions, i.e a single electronic state, and particle\n  interactions are described via empirically parameterized interatomic\n  potential functions). This makes eFF uniquely suited to simulate\n  materials over a wide range of temperatures and pressures where\n  electronically excited and ionized states of matter can occur and\n  coexist.  Furthermore, the interactions between particles -nuclei and\n  electrons- reduce to the sum of a set of effective pairwise potentials\n  in the eFF formulation.  The eff/cut style computes the pairwise\n  Coulomb interactions between nuclei and electrons (E_NN,E_Ne,E_ee),\n  and the quantum-derived Pauli (E_PR) and Kinetic energy interactions\n  potentials between electrons (E_KE) for a total energy expression\n  given as,\n  \n  \\[U\\left(R,r,s\\right) =  E_{NN} \\left( R \\right) + E_{Ne} \\left( {R,r,s} \\right) + E_{ee} \\left( {r,s} \\right) + E_{KE} \\left( {r,s} \\right) + E_{PR} \\left( { \\uparrow  \\downarrow ,S} \\right)\\]\n  The individual terms are defined as follows:\n  \n  \\[\\begin{split}E_{KE}  = & \\frac{\\hbar^2 }{{m_{e} }}\\sum\\limits_i {\\frac{3}{{2s_i^2 }}} \\\\\n  E_{NN}  = & \\frac{1}{{4\\pi \\varepsilon _0 }}\\sum\\limits_{i < j} {\\frac{{Z_i Z_j }}{{R_{ij} }}} \\\\\n  E_{Ne}  = & - \\frac{1}{{4\\pi \\varepsilon _0 }}\\sum\\limits_{i,j} {\\frac{{Z_i }}{{R_{ij} }}Erf\\left( {\\frac{{\\sqrt 2 R_{ij} }}{{s_j }}} \\right)} \\\\\n  E_{ee}  = & \\frac{1}{{4\\pi \\varepsilon _0 }}\\sum\\limits_{i < j} {\\frac{1}{{r_{ij} }}Erf\\left( {\\frac{{\\sqrt 2 r_{ij} }}{{\\sqrt {s_i^2  + s_j^2 } }}} \\right)} \\\\\n  E_{Pauli}  = & \\sum\\limits_{\\sigma _i  = \\sigma _j } {E\\left( { \\uparrow  \\uparrow } \\right)_{ij}}  + \\sum\\limits_{\\sigma _i  \\ne \\sigma _j } {E\\left( { \\uparrow  \\downarrow } \\right)_{ij}} \\\\\\end{split}\\]\n  where, s_i correspond to the electron sizes, the sigmas i’s to the\n  fixed spins of the electrons, Z_i to the charges on the nuclei, R_ij\n  to the distances between the nuclei or the nuclei and electrons, and\n  r_ij to the distances between electrons.  For additional details see\n  (Jaramillo-Botero).\n  The overall electrostatics energy is given in Hartree units of energy\n  by default and can be modified by an energy-conversion constant,\n  according to the units chosen (see electron_units).  The\n  cutoff Rc, given in Bohrs (by default), truncates the interaction\n  distance.  The recommended cutoff for this pair style should follow\n  the minimum image criterion, i.e. half of the minimum unit cell\n  length.\n  Style eff/long (not yet available) computes the same interactions as\n  style eff/cut except that an additional damping factor is applied so\n  it can be used in conjunction with the\n  kspace_style command and its ewald or pppm\n  option.  The Coulombic cutoff specified for this style means that\n  pairwise interactions within this distance are computed directly;\n  interactions outside that distance are computed in reciprocal space.\n  This potential is designed to be used with atom_style electron definitions, in order to handle the\n  description of systems with interacting nuclei and explicit electrons.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands, or by mixing as described below:\n  \n  cutoff (distance units)\n  \n  For eff/cut, the cutoff coefficient is optional.  If it is not used\n  (as in some of the examples above), the default global value specified\n  in the pair_style command is used.\n  For eff/long (not yet available) no cutoff will be specified for an\n  individual I,J type pair via the pair_coeff command.\n  All type pairs use the same global cutoff specified in the pair_style\n  command.\n  \n  The limit/eradius and pressure/evirials keywords are optional.\n  Neither or both must be specified.  If not specified they are unset.\n  The limit/eradius keyword is used to restrain electron size from\n  becoming excessively diffuse at very high temperatures were the\n  Gaussian wave packet representation breaks down, and from expanding as\n  free particles to infinite size.  If unset, electron radius is free to\n  increase without bounds.  If set, a restraining harmonic potential of\n  the form E = 1/2k_ss^2 for s > L_box/2, where k_s = 1 Hartrees/Bohr^2,\n  is applied on the electron radius.\n  The pressure/evirials keyword is used to control between two types\n  of pressure computation: if unset, the computed pressure does not\n  include the electronic radial virials contributions to the total\n  pressure (scalar or tensor).  If set, the computed pressure will\n  include the electronic radial virial contributions to the total\n  pressure (scalar and tensor).\n  The ecp keyword is used to associate an ECP representation for a\n  particular atom type.  The ECP captures the orbital overlap between a\n  core pseudo particle and valence electrons within the Pauli repulsion.\n  A list of type:element-symbol pairs may be provided for all ECP\n  representations, after the “ecp” keyword.\n  \n  Note\n  Default ECP parameters are provided for C, N, O, Al, and Si.\n  Users can modify these using the pair_coeff command as exemplified\n  above.  For this, the User must distinguish between two different\n  functional forms supported, one that captures the orbital overlap\n  assuming the s-type core interacts with an s-like valence electron\n  (s-s) and another that assumes the interaction is s-p.  For systems\n  that exhibit significant p-character (e.g. C, N, O) the s-p form is\n  recommended. The “s” ECP form requires 3 parameters and the “p” 5\n  parameters.\n  \n  \n  Note\n  there are two different pressures that can be reported for eFF\n  when defining this pair_style, one (default) that considers electrons\n  do not contribute radial virial components (i.e. electrons treated as\n  incompressible ‘rigid’ spheres) and one that does.  The radial\n  electronic contributions to the virials are only tallied if the\n  flexible pressure option is set, and this will affect both global and\n  per-atom quantities.  In principle, the true pressure of a system is\n  somewhere in between the rigid and the flexible eFF pressures, but,\n  for most cases, the difference between these two pressures will not be\n  significant over long-term averaged runs (i.e. even though the energy\n  partitioning changes, the total energy remains similar).\n  \n  \n  \n  Note\n  This implementation of eFF gives a reasonably accurate description\n  for systems containing nuclei from Z = 1-6 in “all electron”\n  representations.  For systems with increasingly non-spherical\n  electrons, Users should use the ECP representations.  ECPs are now\n  supported and validated for most of the 2nd and 3rd row elements of\n  the p-block.  Predefined parameters are provided for C, N, O, Al, and\n  Si.  The ECP captures the orbital overlap between the core and valence\n  electrons (i.e. Pauli repulsion) with one of the functional forms:\n  \n  \n  \\[\\begin{split}E_{Pauli(ECP_s)} = & p_1\\exp\\left(-\\frac{p_2r^2}{p_3+s^2} \\right) \\\\\n  E_{Pauli(ECP_p)} = & p_1\\left( \\frac{2}{p_2/s+s/p_2} \\right)\\left( r-p_3s\\right)^2\\exp \\left[ -\\frac{p_4\\left( r-p_3s \\right)^2}{p_5+s^2} \\right]\\end{split}\\]\n  Where the 1st form correspond to core interactions with s-type valence\n  electrons and the 2nd to core interactions with p-type valence\n  electrons.\n  The current version adds full support for models with fixed-core and\n  ECP definitions.  to enable larger timesteps (i.e. by avoiding the\n  high frequency vibrational modes -translational and radial- of the 2 s\n  electrons), and in the ECP case to reduce the increased orbital\n  complexity in higher Z elements (up to Z<18).  A fixed-core should be\n  defined with a mass that includes the corresponding nuclear mass plus\n  the 2 s electrons in atomic mass units (2x5.4857990943e-4), and a\n  radius equivalent to that of minimized 1s electrons (see examples\n  under /examples/USER/eff/fixed-core).  An pseudo-core should be\n  described with a mass that includes the corresponding nuclear mass,\n  plus all the core electrons (i.e no outer shell electrons), and a\n  radius equivalent to that of a corresponding minimized full-electron\n  system.  The charge for a pseudo-core atom should be given by the\n  number of outer shell electrons.\n  In general, eFF excels at computing the properties of materials in\n  extreme conditions and tracing the system dynamics over multi-picosecond\n  timescales; this is particularly relevant where electron excitations\n  can change significantly the nature of bonding in the system. It can\n  capture with surprising accuracy the behavior of such systems because\n  it describes consistently and in an unbiased manner many different\n  kinds of bonds, including covalent, ionic, multicenter, ionic, and\n  plasma, and how they interconvert and/or change when they become\n  excited.  eFF also excels in computing the relative thermochemistry of\n  isodemic reactions and conformational changes, where the bonds of the\n  reactants are of the same type as the bonds of the products.  eFF\n  assumes that kinetic energy differences dominate the overall exchange\n  energy, which is true when the electrons present are nearly spherical\n  and nodeless and valid for covalent compounds such as dense hydrogen,\n  hydrocarbons, and diamond; alkali metals (e.g. lithium), alkali earth\n  metals (e.g. beryllium) and semimetals such as boron; and various\n  compounds containing ionic and/or multicenter bonds, such as boron\n  dihydride.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the cutoff distance for the\n  eff/cut style can be mixed.  The default mix value is geometric.\n  See the “pair_modify” command for details.\n  The pair_modify shift option is not relevant for\n  these pair styles.\n  The eff/long (not yet available) style supports the\n  pair_modify table option for tabulation of the\n  short-range portion of the long-range Coulombic interaction.\n  These pair styles do not support the pair_modify\n  tail option for adding long-range tail corrections to energy and\n  pressure.\n  These pair styles write their information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  These pair styles can only be used via the pair keyword of the\n  run_style respa command.  They do not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style eff/cut cutoff keyword args ...\n  \n  \n  \n  cutoff = global cutoff for Coulombic interactions\n  zero or more keyword/value pairs may be appended\n  keyword = limit/eradius or pressure/evirials or ecp\n    limit/eradius args = none\n    pressure/evirials args = none\n    ecp args = type element type element ...\n      type = LAMMPS atom type (1 to Ntypes)\n      element = element symbol (e.g. H, Si)\n  \n  \n  ",
    "examples": "pair_style eff/cut 39.7\n  pair_style eff/cut 40.0 limit/eradius\n  pair_style eff/cut 40.0 limit/eradius pressure/evirials\n  pair_style eff/cut 40.0 ecp 1 Si 3 C\n  pair_coeff * *\n  pair_coeff 2 2 20.0\n  pair_coeff 1 s 0.320852 2.283269 0.814857\n  pair_coeff 3 p 22.721015 0.728733 1.103199 17.695345 6.693621\n  \n  \n  ",
    "restrictions": "These pair styles will only be enabled if LAMMPS is built with the\n  USER-EFF package.  It will only be enabled if LAMMPS was built with\n  that package.  See the Build package doc page for\n  more info.\n  These pair styles require that particles store electron attributes\n  such as radius, radial velocity, and radial force, as defined by the\n  atom_style.  The electron atom style does all of\n  this.\n  Thes pair styles require you to use the comm_modify vel yes command so that velocities are stored by ghost\n  atoms.\n  "
},
{
    "command": "pair_style eim",
    "description": "Style eim computes pairwise interactions for ionic compounds\n  using embedded-ion method (EIM) potentials (Zhou).  The\n  energy of the system E is given by\n  \n  \\[E = \\frac{1}{2} \\sum_{i=1}^{N} \\sum_{j=i_1}^{i_N} \\phi_{ij} \\left(r_{ij}\\right) + \\sum_{i=1}^{N}E_i\\left(q_i,\\sigma_i\\right)\\]\n  The first term is a double pairwise sum over the J neighbors of all I\n  atoms, where \\(\\phi_{ij}\\) is a pair potential.  The second term sums over\n  the embedding energy E_i of atom I, which is a function of its charge\n  q_i and the electrical potential \\(\\sigma_i\\) at its location.  E_i, q_i,\n  and \\(sigma_i\\) are calculated as\n  \n  \\[\\begin{split}q_i  = & \\sum_{j=i_1}^{i_N} \\eta_{ji}\\left(r_{ij}\\right) \\\\\n  \\sigma_i  = & \\sum_{j=i_1}^{i_N} q_j \\cdot \\psi_{ij} \\left(r_{ij}\\right) \\\\\n  E_i\\left(q_i,\\sigma_i\\right)  = & \\frac{1}{2} \\cdot q_i \\cdot \\sigma_i\\end{split}\\]\n  where \\(\\eta_{ji} is a pairwise function describing electron flow from atom\n  I to atom J, and :math:\\)psi_{ij}` is another pairwise function.  The multi-body\n  nature of the EIM potential is a result of the embedding energy term.\n  A complete list of all the pair functions used in EIM is summarized\n  below\n  \n  \\[\\begin{split}\\phi_{ij}\\left(r\\right) = & \\left\\{ \\begin{array}{lr}\n  \\left[\\frac{E_{b,ij}\\beta_{ij}}{\\beta_{ij}-\\alpha_{ij}}\\exp\\left(-\\alpha_{ij} \\frac{r-r_{e,ij}}{r_{e,ij}}\\right)-\\frac{E_{b,ij}\\alpha_{ij}}{\\beta_{ij}-\\alpha_{ij}}\\exp\\left(-\\beta_{ij} \\frac{r-r_{e,ij}}{r_{e,ij}}\\right)\\right]f_c\\left(r,r_{e,ij},r_{c,\\phi,ij}\\right),& p_{ij}=1 \\\\\n  \\left[\\frac{E_{b,ij}\\beta_{ij}}{\\beta_{ij}-\\alpha_{ij}} \\left(\\frac{r_{e,ij}}{r}\\right)^{\\alpha_{ij}}  -\\frac{E_{b,ij}\\alpha_{ij}}{\\beta_{ij}-\\alpha_{ij}} \\left(\\frac{r_{e,ij}}{r}\\right)^{\\beta_{ij}}\\right]f_c\\left(r,r_{e,ij},r_{c,\\phi,ij}\\right),& p_{ij}=2\n  \\end{array}\n  \\right.\\\\\n  \\eta_{ji} = & A_{\\eta,ij}\\left(\\chi_j-\\chi_i\\right)f_c\\left(r,r_{s,\\eta,ij},r_{c,\\eta,ij}\\right) \\\\\n  \\psi_{ij}\\left(r\\right) = & A_{\\psi,ij}\\exp\\left(-\\zeta_{ij}r\\right)f_c\\left(r,r_{s,\\psi,ij},r_{c,\\psi,ij}\\right) \\\\\n  f_{c}\\left(r,r_p,r_c\\right) = & 0.510204 \\mathrm{erfc}\\left[\\frac{1.64498\\left(2r-r_p-r_c\\right)}{r_c-r_p}\\right] - 0.010204\\end{split}\\]\n  Here \\(E_b, r_e, r_(c,\\phi), \\alpha, \\beta, A_(\\psi), \\zeta, r_(s,\\psi),\n  r_(c,\\psi), A_(\\eta), r_(s,\\eta), r_(c,\\eta), \\chi,\\) and pair function type\n  p are parameters, with subscripts ij indicating the two species of\n  atoms in the atomic pair.\n  \n  Note\n  Even though the EIM potential is treating atoms as charged ions,\n  you should not use a LAMMPS atom_style that stores a\n  charge on each atom and thus requires you to assign a charge to each\n  atom, e.g. the charge or full atom styles.  This is because the\n  EIM potential infers the charge on an atom from the equation above for\n  q_i; you do not assign charges explicitly.\n  \n  \n  All the EIM parameters are listed in a potential file which is\n  specified by the pair_coeff command.  This is an\n  ASCII text file in a format described below.  The “ffield.eim” file\n  included in the “potentials” directory of the LAMMPS distribution\n  currently includes nine elements Li, Na, K, Rb, Cs, F, Cl, Br, and I.\n  A system with any combination of these elements can be modeled.  This\n  file is parameterized in terms of LAMMPS metal units.\n  Note that unlike other potentials, cutoffs for EIM potentials are not\n  set in the pair_style or pair_coeff command; they are specified in the\n  EIM potential file itself.  Likewise, the EIM potential file lists\n  atomic masses; thus you do not need to use the mass\n  command to specify them.\n  Only a single pair_coeff command is used with the eim style which\n  specifies an EIM potential file and the element(s) to extract\n  information for.  The EIM elements are mapped to LAMMPS atom types by\n  specifying N additional arguments after the filename in the pair_coeff\n  command, where N is the number of LAMMPS atom types:\n  \n  Elem1, Elem2, …\n  EIM potential file\n  N element names = mapping of EIM elements to atom types\n  \n  See the pair_coeff doc page for alternate ways\n  to specify the path for the potential file.\n  As an example like one of those above, suppose you want to model a\n  system with Na and Cl atoms.  If your LAMMPS simulation has 4 atoms\n  types and you want the 1st 3 to be Na, and the 4th to be Cl, you would\n  use the following pair_coeff command:\n  pair_coeff * * Na Cl ffield.eim Na Na Na Cl\n  \n  \n  The 1st 2 arguments must be * * so as to span all LAMMPS atom types.\n  The filename is the EIM potential file.  The Na and Cl arguments\n  (before the file name) are the two elements for which info will be\n  extracted from the potential file.  The first three trailing Na\n  arguments map LAMMPS atom types 1,2,3 to the EIM Na element.  The\n  final Cl argument maps LAMMPS atom type 4 to the EIM Cl element.\n  If a mapping value is specified as NULL, the mapping is not performed.\n  This can be used when an eim potential is used as part of the\n  hybrid pair style.  The NULL values are placeholders for atom types\n  that will be used with other potentials.\n  The ffield.eim file in the potentials directory of the LAMMPS\n  distribution is formatted as follows:\n  Lines starting with # are comments and are ignored by LAMMPS.  Lines\n  starting with “global:” include three global values. The first value\n  divides the cations from anions, i.e., any elements with\n  electronegativity above this value are viewed as anions, and any\n  elements with electronegativity below this value are viewed as\n  cations. The second and third values are related to the cutoff\n  function - i.e. the 0.510204, 1.64498, and 0.010204 shown in the above\n  equation can be derived from these values.\n  Lines starting with “element:” are formatted as follows: name of\n  element, atomic number, atomic mass, electronic negativity, atomic\n  radius (LAMMPS ignores it), ionic radius (LAMMPS ignores it), cohesive\n  energy (LAMMPS ignores it), and q0 (must be 0).\n  Lines starting with “pair:” are entered as: element 1, element 2,\n  r_(c,phi), r_(c,phi) (redundant for historical reasons), E_b, r_e,\n  alpha, beta, r_(c,eta), A_(eta), r_(s,eta), r_(c,psi), A_(psi), zeta,\n  r_(s,psi), and p.\n  The lines in the file can be in any order; LAMMPS extracts the info it\n  needs.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "pair_style style\n  \n  \n  \n  style = eim\n  \n  ",
    "examples": "pair_style eim\n  pair_coeff * * Na Cl ../potentials/ffield.eim Na Cl\n  pair_coeff * * Na Cl ffield.eim  Na Na Na Cl\n  pair_coeff * * Na Cl ../potentials/ffield.eim Cl NULL Na\n  \n  \n  ",
    "restrictions": "This style is part of the MANYBODY package.  It is only enabled if\n  LAMMPS was built with that package.\n  "
},
{
    "command": "pair_style exp6/rx",
    "description": "Style exp6/rx is used in reaction DPD simulations, where the\n  coarse-grained (CG) particles are composed of m species whose\n  reaction rate kinetics are determined from a set of n reaction rate\n  equations through the fix rx command.  The species of\n  one CG particle can interact with a species in a neighboring CG\n  particle through a site-site interaction potential model.  The\n  exp6/rx style computes an exponential-6 potential given by\n  \n  \\[U_{ij}(r) = \\frac{\\epsilon}{\\alpha-6}\\{6\\exp[\\alpha(1-\\frac{r_{ij}}{R_{m}})]-\\alpha(\\frac{R_{m}}{r_{ij}})^6\\}\\]\n  where the \\(\\epsilon\\) parameter determines the depth of the\n  potential minimum located at \\(R_m\\), and \\(\\alpha\\) determines\n  the softness of the repulsion.\n  The coefficients must be defined for each species in a given particle\n  type via the pair_coeff command as in the examples\n  above, where the first argument is the filename that includes the\n  exponential-6 parameters for each species.  The file includes the\n  species tag followed by the \\(\\alpha, \\epsilon\\) and \\(R_m\\)\n  parameters. The format of the file is described below.\n  The second and third arguments specify the site-site interaction\n  potential between two species contained within two different\n  particles.  The species tags must either correspond to the species\n  defined in the reaction kinetics files specified with the fix rx command or they must correspond to the tag “1fluid”,\n  signifying interaction with a product species mixture determined\n  through a one-fluid approximation.  The interaction potential is\n  weighted by the geometric average of either the mole fraction concentrations\n  or the number of molecules associated with the interacting coarse-grained\n  particles (see the fractional or molecular weighting pair style options).\n  The coarse-grained potential is stored before and after the\n  reaction kinetics solver is applied, where the difference is defined\n  to be the internal chemical energy (uChem).\n  The fourth argument specifies the type of scaling that will be used\n  to scale the EXP-6 parameters as reactions occur.  Currently, there\n  are three scaling options:  exponent, polynomial and none.\n  Exponent scaling requires two additional arguments for scaling\n  the \\(R_m\\) and \\(\\epsilon\\) parameters, respectively.  The scaling factor\n  is computed by phi^exponent, where phi is the number of molecules\n  represented by the coarse-grain particle and exponent is specified\n  as a pair coefficient argument for \\(R_m\\) and \\(\\epsilon\\), respectively.\n  The \\(R_m\\) and \\(\\epsilon\\) parameters are multiplied by the scaling\n  factor to give the scaled interaction parameters for the CG particle.\n  Polynomial scaling requires a filename to be specified as a pair\n  coeff argument.  The file contains the coefficients to a fifth order\n  polynomial for the \\(\\alpha\\), \\(\\epsilon\\) and \\(R_m\\) parameters that depend\n  upon phi (the number of molecules represented by the CG particle).\n  The format of a polynomial file is provided below.\n  The none option to the scaling does not have any additional pair coeff\n  arguments.  This is equivalent to specifying the exponent option with\n  \\(R_m\\) and \\(\\epsilon\\) exponents of 0.0 and 0.0, respectively.\n  The final argument specifies the interaction cutoff (optional).\n  \n  The format of a tabulated file is as follows (without the\n  parenthesized comments):\n  # exponential-6 parameters for various species      (one or more comment or blank lines)\n  \n  h2o  exp6  11.00 0.02 3.50                          (species, exp6, alpha, Rm, epsilon)\n  no2  exp6  13.60 0.01 3.70\n  ...\n  co2  exp6  13.00 0.03 3.20\n  \n  \n  The format of the polynomial scaling file as follows (without the\n  parenthesized comments):\n  # POLYNOMIAL FILE          (one or more comment or blank lines)\n  \n  #  General Functional Form:\n  #  A*phi^5 + B*phi^4 + C*phi^3 + D*phi^2 + E*phi + F\n  #\n  #  Parameter  A        B         C        D         E        F\n                             (blank)\n  alpha        0.0000   0.00000   0.00008  0.04955  -0.73804  13.63201\n  epsilon      0.0000   0.00478  -0.06283  0.24486  -0.33737   2.60097\n  rm           0.0001  -0.00118  -0.00253  0.05812  -0.00509   1.50106\n  A section begins with a non-blank line whose 1st character is not a\n  “#”; blank lines or lines starting with “#” can be used as comments\n  between sections.\n  Following a blank line, the next N lines list the species and their\n  corresponding parameters.  The first argument is the species tag, the\n  second argument is the exp6 tag, the 3rd argument is the \\(\\alpha\\)\n  parameter (energy units), the 4th argument is the \\(\\epsilon\\) parameter\n  (energy-distance^6 units), and the 5th argument is the \\(R_m\\) parameter\n  (distance units).  If a species tag of “1fluid” is listed as a pair\n  coefficient, a one-fluid approximation is specified where a\n  concentration-dependent combination of the parameters is computed\n  through the following equations:\n  \n  \\[\\begin{split}R_{m}^{3} = & \\sum_{a}\\sum_{b} x_{a}x_{b}R_{m,ab}^{3} \\\\\n  \\epsilon  = & \\frac{1}{R_{m}^{3}}\\sum_{a}\\sum_{b} x_{a}x_{b}\\epsilon_{ab}R_{m,ab}^{3} \\\\\n  \\alpha    = & \\frac{1}{\\epsilon R_{m}^{3}}\\sum_{a}\\sum_{b} x_{a}x_{b}\\alpha_{ab}\\epsilon_{ab}R_{m,ab}^{3}\\end{split}\\]\n  where\n  \n  \\[\\begin{split}\\epsilon_{ab} = & \\sqrt{\\epsilon_{a}\\epsilon_{b}} \\\\\n  R_{m,ab}      = & \\frac{R_{m,a}+R_{m,b}}{2} \\\\\n  \\alpha_{ab}   = & \\sqrt{\\alpha_{a}\\alpha_{b}}\\end{split}\\]\n  and \\(x_a\\) and \\(x_b\\) are the mole fractions of a and b, respectively, which\n  comprise the gas mixture.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This pair style does not support mixing.  Thus, coefficients for all\n  I,J pairs must be specified explicitly.\n  This style does not support the pair_modify shift option\n  for the energy of the exp() and 1/r^6 portion of the pair interaction.\n  This style does not support the pair_modify tail option for adding long-range\n  tail corrections to energy and pressure for the A,C terms in the\n  pair interaction.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "pair_style exp6/rx cutoff ...\n  \n  \n  \n  cutoff = global cutoff for DPD interactions (distance units)\n  weighting = fractional or molecular (optional)\n  \n  ",
    "examples": "pair_style exp6/rx 10.0\n  pair_style exp6/rx 10.0 fractional\n  pair_style exp6/rx 10.0 molecular\n  pair_coeff * * exp6.params h2o h2o exponent 1.0 1.0 10.0\n  pair_coeff * * exp6.params h2o 1fluid exponent 1.0 1.0 10.0\n  pair_coeff * * exp6.params 1fluid 1fluid exponent 1.0 1.0 10.0\n  pair_coeff * * exp6.params 1fluid 1fluid none 10.0\n  pair_coeff * * exp6.params 1fluid 1fluid polynomial filename 10.0\n  \n  \n  ",
    "restrictions": "This command is part of the USER-DPD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style extep",
    "description": "Style extep computes the Extended Tersoff Potential (ExTeP)\n  interactions as described in (Los2017).\n  ",
    "syntax": "pair_style extep\n  \n  \n  ",
    "examples": "pair_style extep\n  pair_coeff * * BN.extep B N\n  \n  \n  ",
    "restrictions": "none\n  "
},
{
    "command": "pair_style lj/cut/soft",
    "description": "These pair styles have a soft repulsive core, tunable by a parameter lambda,\n  in order to avoid singularities during free energy calculations when sites are\n  created or annihilated (Beutler).  When lambda tends to 0 the pair\n  interaction vanishes with a soft repulsive core.  When lambda tends to 1, the pair\n  interaction approaches the normal, non-soft potential. These pair styles\n  are suited for “alchemical” free energy calculations using the fix adapt/fep and compute fep commands.\n  The lj/cut/soft style and related sub-styles compute the 12-6 Lennard-Jones\n  and Coulomb potentials modified by a soft core, with the functional form\n  \n  \\[E = \\lambda^n 4 \\epsilon \\left\\{\n  \\frac{1}{ \\left[ \\alpha_{\\mathrm{LJ}} (1-\\lambda)^2 +\n  \\left( \\displaystyle\\frac{r}{\\sigma} \\right)^6 \\right]^2 } -\n  \\frac{1}{ \\alpha_{\\mathrm{LJ}} (1-\\lambda)^2 +\n  \\left( \\displaystyle\\frac{r}{\\sigma} \\right)^6 }\n  \\right\\} \\qquad r < r_c\\]\n  The lj/class2/soft style is a 9-6 potential with the exponent of the\n  denominator of the first term in brackets taking the value 1.5 instead of 2\n  (other details differ, see the form of the potential in\n  pair_style lj/class2).\n  Coulomb interactions can also be damped with a soft core at short distance,\n  \n  \\[E = \\lambda^n \\frac{ C q_i q_j}{\\epsilon \\left[ \\alpha_{\\mathrm{C}}\n  (1-\\lambda)^2 + r^2 \\right]^{1/2}} \\qquad r < r_c\\]\n  In the Coulomb part \\(C\\) is an energy-conversion constant, \\(q_i\\) and\n  \\(q_j\\) are the charges on the 2 atoms, and epsilon is the dielectric\n  constant which can be set by the dielectric command.\n  The coefficient lambda is an activation parameter. When \\(\\lambda = 1\\) the\n  pair potential is identical to a Lennard-Jones term or a Coulomb term or a\n  combination of both. When \\(\\lambda = 0\\) the interactions are\n  deactivated. The transition between these two extrema is smoothed by a soft\n  repulsive core in order to avoid singularities in potential energy and forces\n  when sites are created or annihilated and can overlap (Beutler).\n  The parameters \\(n\\), \\(\\alpha_\\mathrm{LJ}\\) and\n  \\(\\alpha_\\mathrm{C}\\) are set in the pair_style command,\n  before the cutoffs.  Usual choices for the exponent are \\(n = 2\\) or\n  \\(n = 1\\). For the remaining coefficients \\(\\alpha_\\mathrm{LJ} = 0.5\\)\n  and \\(\\alpha_\\mathrm{C} = 10~\\text{A}^2\\) are appropriate choices. Plots of\n  the 12-6 LJ and Coulomb terms are shown below, for lambda ranging from 1 to 0\n  every 0.1.\n  \n  \n  For the lj/cut/coul/cut/soft or lj/cut/coul/long/soft pair styles, as well\n  as for the equivalent class2 versions, the following coefficients must be\n  defined for each pair of atoms types via the pair_coeff\n  command as in the examples above, or in the data file or restart files read by\n  the read_data or read_restart commands,\n  or by mixing as described below:\n  \n  \\(\\epsilon\\) (energy units)\n  \\(\\sigma\\) (distance units)\n  \\(\\lambda\\) (activation parameter, between 0 and 1)\n  cutoff1 (distance units)\n  cutoff2 (distance units)\n  \n  The latter two coefficients are optional.  If not specified, the global\n  LJ and Coulombic cutoffs specified in the pair_style command are used.\n  If only one cutoff is specified, it is used as the cutoff for both LJ\n  and Coulombic interactions for this type pair.  If both coefficients\n  are specified, they are used as the LJ and Coulombic cutoffs for this\n  type pair.  You cannot specify 2 cutoffs for style lj/cut/soft,\n  since it has no Coulombic terms. For the coul/cut/soft and\n  coul/long/soft only lambda and the optional cutoff2 are to be\n  specified.\n  Style lj/cut/tip4p/long/soft implements a soft-core version of the TIP4P water\n  model. The usage of the TIP4P pair style is documented in the pair_lj styles. In the soft version the parameters \\(n\\),\n  \\(\\alpha_\\mathrm{LJ}\\) and \\(\\alpha_\\mathrm {C}\\) are set in the\n  pair_style command, after the specific parameters of the\n  TIP4P water model and before the cutoffs. The activation parameter lambda is\n  supplied as an argument of the pair_coeff command, after\n  epsilon and sigma and before the optional cutoffs.\n  Style lj/charmm/coul/long/soft implements a soft-core version of the modified\n  12-6 LJ potential used in CHARMM and documented in the pair_style\n  lj/charmm/coul/long style. In the soft version the parameters\n  \\(n\\), \\(\\alpha_\\mathrm{LJ}\\) and \\(\\alpha_\\mathrm{C}\\) are set in\n  the pair_style command, before the global cutoffs. The\n  activation parameter lambda is introduced as an argument of the pair_coeff command, after \\(\\epsilon\\) and \\(\\sigma\\) and before the\n  optional eps14 and sigma14.\n  Style lj/class2/soft implements a soft-core version of the 9-6 potential in\n  pair_style lj/class2. In the soft version the parameters\n  \\(n\\), \\(\\alpha_\\mathrm{LJ}\\) and \\(\\alpha_\\mathrm{C}\\) are set in the\n  pair_style command, before the global cutoffs. The\n  activation parameter lambda is introduced as an argument of the the\n  pair_coeff command, after \\(\\epsilon\\) and\n  \\(\\sigma\\) and before the optional cutoffs.\n  The coul/cut/soft, coul/long/soft and tip4p/long/soft sub-styles are\n  designed to be combined with other pair potentials via the pair_style\n  hybrid/overlay command.  This is because they have no repulsive\n  core.  Hence, if used by themselves, there will be no repulsion to keep two\n  oppositely charged particles from overlapping each other. In this case, if\n  \\(\\lambda = 1\\), a singularity may occur.  These sub-styles are suitable to\n  represent charges embedded in the Lennard-Jones radius of another site (for\n  example hydrogen atoms in several water models).\n  \n  Note\n  When using the soft-core Coulomb potentials with long-range solvers (coul/long/soft, lj/cut/coul/long/soft, etc.)  in a free energy\n  calculation in which sites holding electrostatic charges are being created or\n  annihilated (using fix adapt/fep and compute fep) it is important to adapt both the \\(\\lambda\\) activation\n  parameter (from 0 to 1, or the reverse) and the value of the charge (from 0\n  to its final value, or the reverse). This ensures that long-range\n  electrostatic terms (kspace) are correct. It is not necessary to use\n  soft-core Coulomb potentials if the van der Waals site is present during the\n  free-energy route, thus avoiding overlap of the charges. Examples are\n  provided in the LAMMPS source directory tree, under examples/USER/fep.\n  \n  \n  Note\n  To avoid division by zero do not set \\(\\sigma = 0\\) in the lj/cut/soft\n  and related styles; use the lambda parameter instead to activate/deactivate\n  interactions, or use \\(\\epsilon = 0\\) and \\(\\sigma = 1\\).\n  Alternatively, when sites do not interact though the Lennard-Jones term\n  the coul/long/soft or similar sub-style can be used via the\n  pair_style hybrid/overlay command.\n  \n  \n  The morse/soft variant modifies the pair_morse style at\n  short range to have a soft core. The functional form differs from that of the\n  lj/soft styles, and is instead given by:\n  \n  \\[\\begin{split}\\begin{split}\n  s(\\lambda) =& (1 - \\lambda) / (1 - \\lambda_f), \\qquad B = -2D e^{-2 \\alpha\n  r_0} (e^{\\alpha r_0} - 1) / 3 \\\\\n  E =& D_0 \\left[ e^{- 2 \\alpha (r - r_0)} - 2 e^{- \\alpha (r - r_0)} \\right] +\n  s(\\lambda) B e^{-3\\alpha(r-r_0)}, \\qquad \\hspace{2.85em}\\lambda \\geq\n  \\lambda_f,\\quad r < r_c \\\\\n  E =& \\left( D_0 \\left[ e^{- 2 \\alpha (r - r_0)} - 2 e^{- \\alpha (r - r_0)}\n  \\right] + B e^{-3\\alpha(r-r_0)} \\right)(\\lambda/\\lambda_f)^n, \\qquad \\lambda\n  < \\lambda_f,\\quad r < r_c\n  \\end{split}\\end{split}\\]\n  The morse/soft style requires the following pair coefficients:\n  \n  \\(D_0\\) (energy units)\n  \\(\\alpha\\) (1/distance units)\n  \\(r_0\\) (distance units)\n  \\(\\lambda\\) (unitless, between 0.0 and 1.0)\n  cutoff (distance units)\n  \n  The last coefficient is optional. If not specified, the global morse cutoff is\n  used.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script by\n  including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the suffix\n  command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, tail correction, restart info:\n  The different versions of the lj/cut/soft pair styles support mixing.  For\n  atom type pairs I,J and I != J, the \\(\\epsilon\\) and \\(\\sigma\\)\n  coefficients and cutoff distance for these pair style can be mixed.  The default\n  mix value is geometric for 12-6 styles.\n  The mixing rule for epsilon and sigma for lj/class2/soft 9-6 potentials is to\n  use the sixthpower formulas. The pair_modify mix setting\n  is thus ignored for class2 potentials for \\(\\epsilon\\) and\n  \\(\\sigma\\). However it is still followed for mixing the cutoff distance. See\n  the pair_modify command for details.\n  The morse/soft pair style does not support mixing. Thus, coefficients for all\n  LJ pairs must be specified explicitly.\n  All of the pair styles with soft core support the pair_modify\n  shift option for the energy of the Lennard-Jones portion of the pair\n  interaction.\n  The different versions of the lj/cut/soft pair styles support the\n  pair_modify tail option for adding a long-range tail\n  correction to the energy and pressure for the Lennard-Jones portion of the pair\n  interaction.\n  \n  Note\n  The analytical form of the tail corrections for energy and pressure used in\n  the lj/cut/soft potentials are approximate, being identical to that of the\n  corresponding non-soft potentials scaled by a factor \\(\\lambda^n\\). The\n  errors due to this approximation should be negligible. For example, for a\n  cutoff of \\(2.5\\sigma\\) this approximation leads to maximum relative\n  errors in tail corrections of the order of 1e-4 for energy and virial\n  (\\(\\alpha_\\mathrm{LJ} = 0.5, n = 2\\)). The error vanishes when lambda\n  approaches 0 or 1. Note that these are the errors affecting the long-range\n  tail (itself a correction to the interaction energy) which includes other\n  approximations, namely that the system is homogeneous (local density equal\n  the average density) beyond the cutoff.\n  \n  The morse/soft pair style does not support the pair_modify tail option for adding long-range tail corrections to energy and\n  pressure.\n  All of these pair styles write information to binary restart files, so pair_style and pair_coeff commands do not need to be specified\n  in an input script that reads a restart file.\n  ",
    "syntax": "pair_style style args\n  \n  \n  \n  style = lj/cut/soft or lj/cut/coul/cut/soft or lj/cut/coul/long/soft or lj/cut/tip4p/long/soft or lj/charmm/coul/long/soft or lj/class2/soft or lj/class2/coul/cut/soft or lj/class2/coul/long/soft or coul/cut/soft or coul/long/soft or tip4p/long/soft or morse/soft\n  args = list of arguments for a particular style\n  \n  lj/cut/soft args = n alpha_lj cutoff\n    n, alpha_LJ = parameters of soft-core potential\n    cutoff = global cutoff for Lennard-Jones interactions (distance units)\n  lj/cut/coul/cut/soft args = n alpha_LJ alpha_C cutoff (cutoff2)\n    n, alpha_LJ, alpha_C = parameters of soft-core potential\n    cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  lj/cut/coul/long/soft args = n alpha_LJ alpha_C cutoff\n    n, alpha_LJ, alpha_C = parameters of the soft-core potential\n    cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  lj/cut/tip4p/long/soft args = otype htype btype atype qdist n alpha_LJ alpha_C cutoff (cutoff2)\n    otype,htype = atom types for TIP4P O and H\n    btype,atype = bond and angle types for TIP4P waters\n    qdist = distance from O atom to massless charge (distance units)\n    n, alpha_LJ, alpha_C = parameters of the soft-core potential\n    cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  lj/charmm/coul/long/soft args = n alpha_LJ alpha_C inner outer (cutoff)\n    n, alpha_LJ, alpha_C = parameters of the soft-core potential\n    inner, outer = global switching cutoffs for LJ (and Coulombic if only 5 args)\n    cutoff = global cutoff for Coulombic (optional, outer is Coulombic cutoff if only 5 args)\n  lj/class2/soft args = n alpha_lj cutoff\n    n, alpha_LJ = parameters of soft-core potential\n    cutoff = global cutoff for Lennard-Jones interactions (distance units)\n  lj/class2/coul/cut/soft args = n alpha_LJ alpha_C cutoff (cutoff2)\n    n, alpha_LJ, alpha_C = parameters of soft-core potential\n    cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  lj/class2/coul/long/soft args = n alpha_LJ alpha_C cutoff (cutoff2)\n    n, alpha_LJ, alpha_C = parameters of soft-core potential\n    cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  coul/cut/soft args = n alpha_C cutoff\n    n, alpha_C = parameters of the soft-core potential\n    cutoff = global cutoff for Coulomb interactions (distance units)\n  coul/long/soft args = n alpha_C cutoff\n    n, alpha_C = parameters of the soft-core potential\n    cutoff = global cutoff for Coulomb interactions (distance units)\n  tip4p/long/soft args = otype htype btype atype qdist n alpha_C cutoff\n    otype,htype = atom types for TIP4P O and H\n    btype,atype = bond and angle types for TIP4P waters\n    qdist = distance from O atom to massless charge (distance units)\n    n, alpha_C = parameters of the soft-core potential\n    cutoff = global cutoff for Coulomb interactions (distance units)\n  morse/soft args = n lf cutoff\n    n = soft-core parameter\n    lf = transformation range is lf < lambda < 1\n    cutoff = global cutoff for Morse interactions (distance units)\n  ",
    "examples": "pair_style lj/cut/soft 2.0 0.5 9.5\n  pair_coeff * * 0.28 3.1 1.0\n  pair_coeff 1 1 0.28 3.1 1.0 9.5\n  \n  pair_style lj/cut/coul/cut/soft 2.0 0.5 10.0 9.5\n  pair_style lj/cut/coul/cut/soft 2.0 0.5 10.0 9.5 9.5\n  pair_coeff * * 0.28 3.1 1.0\n  pair_coeff 1 1 0.28 3.1 0.5 10.0\n  pair_coeff 1 1 0.28 3.1 0.5 10.0 9.5\n  \n  pair_style lj/cut/coul/long/soft 2.0 0.5 10.0 9.5\n  pair_style lj/cut/coul/long/soft 2.0 0.5 10.0 9.5 9.5\n  pair_coeff * * 0.28 3.1 1.0\n  pair_coeff 1 1 0.28 3.1 0.0 10.0\n  pair_coeff 1 1 0.28 3.1 0.0 10.0 9.5\n  \n  pair_style lj/cut/tip4p/long/soft 1 2 7 8 0.15 2.0 0.5 10.0 9.8\n  pair_style lj/cut/tip4p/long/soft 1 2 7 8 0.15 2.0 0.5 10.0 9.8 9.5\n  pair_coeff * * 0.155 3.1536 1.0\n  pair_coeff 1 1 0.155 3.1536 1.0 9.5\n  \n  pair_style lj/charmm/coul/long 2.0 0.5 10.0 8.0 10.0\n  pair_style lj/charmm/coul/long 2.0 0.5 10.0 8.0 10.0 9.0\n  pair_coeff * * 0.28 3.1 1.0\n  pair_coeff 1 1 0.28 3.1 1.0 0.14 3.1\n  \n  pair_style lj/class2/coul/long/soft 2.0 0.5 10.0 9.5\n  pair_style lj/class2/coul/long/soft 2.0 0.5 10.0 9.5 9.5\n  pair_coeff * * 0.28 3.1 1.0\n  pair_coeff 1 1 0.28 3.1 0.0 10.0\n  pair_coeff 1 1 0.28 3.1 0.0 10.0 9.5\n  \n  pair_style coul/long/soft 1.0 10.0 9.5\n  pair_coeff * * 1.0\n  pair_coeff 1 1 1.0 9.5\n  \n  pair_style tip4p/long/soft 1 2 7 8 0.15 2.0 0.5 10.0 9.8\n  pair_coeff * * 1.0\n  pair_coeff 1 1 1.0 9.5\n  \n  pair_style morse/soft 4 0.9 10.0\n  pair_coeff * * 100.0 2.0 1.5 1.0\n  pair_coeff 1 1 100.0 2.0 1.5 1.0 3.0\n  \n  \n  ",
    "restrictions": "The pair styles with soft core are only enabled if LAMMPS was built with the\n  USER-FEP package. The long versions also require the KSPACE package to be\n  installed. The soft tip4p versions also require the MOLECULE package to be\n  installed. These styles are only enabled if LAMMPS was built with those\n  packages.  See the Build package doc page for more\n  info.\n  "
},
{
    "command": "pair_style gauss",
    "description": "Style gauss computes a tethering potential of the form\n  \n  \\[E = - A \\exp(-B r^2) \\qquad r < r_c\\]\n  between an atom and its corresponding tether site which will typically\n  be a frozen atom in the simulation.  \\(r_c\\) is the cutoff.\n  The following coefficients must be defined for each pair of atom types\n  via the pair_coeff command as in the examples above,\n  or in the data file or restart files read by the\n  read_data or read_restart\n  commands:\n  \n  A (energy units)\n  B (1/distance^2 units)\n  cutoff (distance units)\n  \n  The last coefficient is optional. If not specified, the global cutoff\n  is used.\n  Style gauss/cut computes a generalized Gaussian interaction potential\n  between pairs of particles:\n  \n  \\[E = \\frac{H}{\\sigma_h\\sqrt{2\\pi}} \\exp\\left[-\\frac{(r-r_{mh})^2}{2\\sigma_h^2}\\right]\\]\n  where H determines together with the standard deviation \\(\\sigma_h\\)\n  the peak height of the Gaussian function, and \\(r_{mh}\\) the peak\n  position.  Examples of the use of the Gaussian potentials include\n  implicit solvent simulations of salt ions (Lenart) and\n  of surfactants (Jusufi).  In these instances the\n  Gaussian potential mimics the hydration barrier between a pair of\n  particles. The hydration barrier is located at \\(r_{mh}\\) and has a\n  width of \\(\\sigma_h\\). The prefactor determines the height of the\n  potential barrier.\n  The following coefficients must be defined for each pair of atom types\n  via the pair_coeff command as in the example above,\n  or in the data file or restart files read by the\n  read_data or read_restart\n  commands:\n  \n  H (energy * distance units)\n  \\(r_{mh}\\) (distance units)\n  \\(\\sigma_h\\) (distance units)\n  cutoff (distance units)\n  \n  The last coefficient is optional. If not specified, the global cutoff\n  is used.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the A, B, H, sigma_h, r_mh\n  parameters, and the cutoff distance for these pair styles can be mixed:\n  A (energy units)\n  sqrt(1/B) (distance units, see below)\n  H (energy units)\n  sigma_h (distance units)\n  r_mh (distance units)\n  cutoff (distance units):ul\n  The default mix value is geometric.\n  Only arithmetic and geometric mix values are supported.\n  See the “pair_modify” command for details.\n  The A and H parameters are mixed using the same rules normally\n  used to mix the “epsilon” parameter in a Lennard Jones interaction.\n  The sigma_h, r_mh, and the cutoff distance are mixed using the same\n  rules used to mix the “sigma” parameter in a Lennard Jones interaction.\n  The B parameter is converted to a distance (sigma), before mixing\n  (using sigma=B^-0.5), and converted back to a coefficient\n  afterwards (using B=sigma^2).\n  Negative A values are converted to positive A values (using abs(A))\n  before mixing, and converted back after mixing\n  (by multiplying by min(sign(Ai),sign(Aj))).\n  This way, if either particle is repulsive (if Ai<0 or Aj<0),\n  then the default interaction between both particles will be repulsive.\n  The gauss style does not support the pair_modify\n  shift option. There is no effect due to the Gaussian well beyond the\n  cutoff; hence reasonable cutoffs need to be specified.\n  The gauss/cut style supports the pair_modify shift\n  option for the energy of the Gauss-potential portion of the pair\n  interaction.\n  The pair_modify table and tail options are not\n  relevant for these pair styles.\n  These pair styles write their information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  These pair styles can only be used via the pair keyword of the\n  run_style respa command.  They do not support the\n  inner, middle, outer keywords.\n  The gauss pair style tallies an “occupancy” count of how many Gaussian-well\n  sites have an atom within the distance at which the force is a maximum\n  = sqrt(0.5/b).  This quantity can be accessed via the compute pair command as a vector of values of length 1.\n  To print this quantity to the log file (with a descriptive column\n  heading) the following commands could be included in an input script:\n  compute gauss all pair gauss\n  variable occ equal c_gauss[1]\n  thermo_style custom step temp epair v_occ\n  \n  \n  ",
    "syntax": "pair_style gauss cutoff\n  pair_style gauss/cut cutoff\n  \n  \n  \n  cutoff = global cutoff for Gauss interactions (distance units)\n  \n  ",
    "examples": "pair_style gauss 12.0\n  pair_coeff * * 1.0 0.9\n  pair_coeff 1 4 1.0 0.9 10.0\n  \n  pair_style gauss/cut 3.5\n  pair_coeff 1 4 0.2805 1.45 0.112\n  \n  \n  ",
    "restrictions": "The gauss/cut style is part of the “user-misc” package. It is only\n  enabled if LAMMPS is build with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style gayberne",
    "description": "The gayberne styles compute a Gay-Berne anisotropic LJ interaction\n  (Berardi) between pairs of ellipsoidal particles or an\n  ellipsoidal and spherical particle via the formulas\n  \n  \\[\\begin{split}U ( \\mathbf{A}_1, \\mathbf{A}_2, \\mathbf{r}_{12} ) = & U_r (\n  \\mathbf{A}_1, \\mathbf{A}_2, \\mathbf{r}_{12}, \\gamma ) \\cdot \\eta_{12} (\n  \\mathbf{A}_1, \\mathbf{A}_2, \\upsilon ) \\cdot \\chi_{12} ( \\mathbf{A}_1,\n  \\mathbf{A}_2, \\mathbf{r}_{12}, \\mu ) \\\\\n  U_r = & 4 \\epsilon ( \\varrho^{12} - \\varrho^6) \\\\\n  \\varrho = & \\frac{\\sigma}{ h_{12} + \\gamma \\sigma}\\end{split}\\]\n  where A1 and A2 are the transformation matrices from the simulation box\n  frame to the body frame and \\(r_{12}\\) is the center to center\n  vector between the particles.  \\(U_r\\) controls the shifted distance\n  dependent interaction based on the distance of closest approach of the\n  two particles (\\(h_{12}\\)) and the user-specified shift parameter\n  gamma.  When both particles are spherical, the formula reduces to the\n  usual Lennard-Jones interaction (see details below for when Gay-Berne\n  treats a particle as “spherical”).\n  For large uniform molecules it has been shown that the energy\n  parameters are approximately representable in terms of local contact\n  curvatures (Everaers):\n  \n  \\[\\epsilon_a = \\sigma \\cdot { \\frac{a}{ b \\cdot c } }; \\epsilon_b =\n  \\sigma \\cdot { \\frac{b}{ a \\cdot c } }; \\epsilon_c = \\sigma \\cdot {\n  \\frac{c}{ a \\cdot b } }\\]\n  The variable names utilized as potential parameters are for the most\n  part taken from (Everaers) in order to be consistent with\n  the RE-squared pair potential.  Details on the\n  upsilon and mu parameters are given\n  here.\n  More details of the Gay-Berne formulation are given in the references\n  listed below and in this supplementary document.\n  Use of this pair style requires the NVE, NVT, or NPT fixes with the\n  asphere extension (e.g. fix nve/asphere) in\n  order to integrate particle rotation.  Additionally, atom_style ellipsoid should be used since it defines the\n  rotational state and the size and shape of each ellipsoidal particle.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands, or by mixing as described below:\n  \n  \\(\\epsilon\\) = well depth (energy units)\n  \\(\\sigma\\) = minimum effective particle radii (distance units)\n  \\(\\epsilon_{i,a}\\) = relative well depth of type I for side-to-side interactions\n  \\(\\epsilon_{i,b}\\) = relative well depth of type I for face-to-face interactions\n  \\(\\epsilon_{i,c}\\) = relative well depth of type I for end-to-end interactions\n  \\(\\epsilon_{j,a}\\) = relative well depth of type J for side-to-side interactions\n  \\(\\epsilon_{j,b}\\) = relative well depth of type J for face-to-face interactions\n  \\(\\epsilon_{j,c}\\) = relative well depth of type J for end-to-end interactions\n  cutoff (distance units)\n  \n  The last coefficient is optional.  If not specified, the global\n  cutoff specified in the pair_style command is used.\n  It is typical with the Gay-Berne potential to define \\(\\sigma\\) as\n  the minimum of the 3 shape diameters of the particles involved in an I,I\n  interaction, though this is not required.  Note that this is a different\n  meaning for \\(\\sigma\\) than the pair_style resquared potential uses.\n  The \\(\\epsilon_i\\) and \\(\\epsilon_j\\) coefficients are actually\n  defined for atom types, not for pairs of atom types.  Thus, in a series\n  of pair_coeff commands, they only need to be specified once for each\n  atom type.\n  Specifically, if any of \\(\\epsilon_{i,a}\\), \\(\\epsilon_{i,b}\\),\n  \\(\\epsilon_{i,c}\\) are non-zero, the three values are assigned to\n  atom type I.  If all the \\(\\epsilon_i\\) values are zero, they are\n  ignored.  If any of \\(\\epsilon_{j,a}\\), \\(\\epsilon_{j,b}\\),\n  \\(\\epsilon_{j,c}\\) are non-zero, the three values are assigned to\n  atom type J.  If all three epsilon_j values are zero, they are ignored.\n  Thus the typical way to define the \\(\\epsilon_i\\) and\n  \\(\\epsilon_j\\) coefficients is to list their values in “pair_coeff\n  I J” commands when I = J, but set them to 0.0 when I != J.  If you do\n  list them when I != J, you should insure they are consistent with their\n  values in other pair_coeff commands, since only the last setting will\n  be in effect.\n  Note that if this potential is being used as a sub-style of\n  pair_style hybrid, and there is no “pair_coeff I I”\n  setting made for Gay-Berne for a particular type I (because I-I\n  interactions are computed by another hybrid pair potential), then you\n  still need to insure the \\(\\epsilon\\) a,b,c coefficients are assigned to\n  that type. e.g. in a “pair_coeff I J” command.\n  \n  Note\n  If the \\(\\epsilon\\) a = b = c for an atom type, and if the shape\n  of the particle itself is spherical, meaning its 3 shape parameters\n  are all the same, then the particle is treated as an LJ sphere by the\n  Gay-Berne potential.  This is significant because if two LJ spheres\n  interact, then the simple Lennard-Jones formula is used to compute\n  their interaction energy/force using the specified epsilon and sigma\n  as the standard LJ parameters.  This is much cheaper to compute than\n  the full Gay-Berne formula.  To treat the particle as a LJ sphere\n  with sigma = D, you should normally set \\(\\epsilon\\) a = b = c =\n  1.0, set the pair_coeff \\(\\sigma = D\\), and also set the 3 shape\n  parameters for the particle to D.  The one exception is that if the 3\n  shape parameters are set to 0.0, which is a valid way in LAMMPS to\n  specify a point particle, then the Gay-Berne potential will treat\n  that as shape parameters of 1.0 (i.e. a LJ particle with\n  \\(\\sigma = 1\\)), since it requires finite-size particles.  In\n  this case you should still set the pair_coeff \\(\\sigma\\) to 1.0\n  as well.\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the epsilon and sigma coefficients\n  and cutoff distance for this pair style can be mixed.  The default mix\n  value is geometric.  See the “pair_modify” command for details.\n  This pair styles supports the pair_modify shift\n  option for the energy of the Lennard-Jones portion of the pair\n  interaction, but only for sphere-sphere interactions.  There is no\n  shifting performed for ellipsoidal interactions due to the anisotropic\n  dependence of the interaction.\n  The pair_modify table option is not relevant\n  for this pair style.\n  This pair style does not support the pair_modify\n  tail option for adding long-range tail corrections to energy and\n  pressure.\n  This pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style gayberne gamma upsilon mu cutoff\n  \n  \n  \n  gamma = shift for potential minimum (typically 1)\n  upsilon = exponent for eta orientation-dependent energy function\n  mu = exponent for chi orientation-dependent energy function\n  cutoff = global cutoff for interactions (distance units)\n  \n  ",
    "examples": "pair_style gayberne 1.0 1.0 1.0 10.0\n  pair_coeff * * 1.0 1.7 1.7 3.4 3.4 1.0 1.0 1.0\n  \n  \n  ",
    "restrictions": "The gayberne style is part of the ASPHERE package.  It is only\n  enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\n  These pair style require that atoms store torque and a quaternion to\n  represent their orientation, as defined by the\n  atom_style.  It also require they store a per-type\n  shape.  The particles cannot store a per-particle\n  diameter.\n  This pair style requires that atoms be ellipsoids as defined by the\n  atom_style ellipsoid command.\n  Particles acted on by the potential can be finite-size aspherical or\n  spherical particles, or point particles.  Spherical particles have all\n  3 of their shape parameters equal to each other.  Point particles have\n  all 3 of their shape parameters equal to 0.0.\n  The Gay-Berne potential does not become isotropic as r increases\n  (Everaers).  The distance-of-closest-approach\n  approximation used by LAMMPS becomes less accurate when high-aspect\n  ratio ellipsoids are used.\n  "
},
{
    "command": "pair_style gran/hooke",
    "description": "The gran styles use the following formulas for the frictional force\n  between two granular particles, as described in\n  (Brilliantov), (Silbert), and\n  (Zhang), when the distance r between two particles of radii\n  Ri and Rj is less than their contact distance d = Ri + Rj.  There is\n  no force between the particles when r > d.\n  The two Hookean styles use this formula:\n  \n  \\[F_{hk} = (k_n \\delta \\mathbf{n}_{ij} -\n  m_{eff} \\gamma_n\\mathbf{ v}_n) -\n  (k_t \\mathbf{ \\Delta s}_t +\n  m_{eff} \\gamma_t \\mathbf{v}_t)\\]\n  The Hertzian style uses this formula:\n  \n  \\[F_{hz} = \\sqrt{\\delta} \\sqrt{\\frac{R_i R_j}{R_i + R_j}} F_{hk} =\n    \\sqrt{\\delta} \\sqrt{\\frac{R_i R_j}{R_i + R_j}}\n    \\Big[ (k_n \\delta \\mathbf{n}_{ij} -\n      m_{eff} \\: \\gamma_n \\mathbf{ v}_n) -\n      (k_t \\mathbf{ \\Delta s}_t +\n      m_{eff} \\: \\gamma_t \\mathbf{v}_t) \\Big]\\]\n  In both equations the first parenthesized term is the normal force\n  between the two particles and the second parenthesized term is the\n  tangential force.  The normal force has 2 terms, a contact force and a\n  damping force.  The tangential force also has 2 terms: a shear force\n  and a damping force.  The shear force is a “history” effect that\n  accounts for the tangential displacement between the particles for the\n  duration of the time they are in contact.  This term is included in\n  pair styles hooke/history and hertz/history, but is not included\n  in pair style hooke.  The tangential damping force term is included\n  in all three pair styles if dampflag is set to 1; it is not included\n  if dampflag is set to 0.\n  The other quantities in the equations are as follows:\n  \n  \\(\\delta\\) = d - r = overlap distance of 2 particles\n  \\(K_n\\) = elastic constant for normal contact\n  \\(K_t\\) = elastic constant for tangential contact\n  \\(\\gamma_n\\) = viscoelastic damping constant for normal contact\n  \\(\\gamma_t\\) = viscoelastic damping constant for tangential contact\n  \\(m_{eff} = M_i M_j / (M_i + M_j) =\\) effective mass of 2 particles of mass M_i and M_j\n  \\(\\mathbf{\\Delta s}_t =\\) tangential displacement vector between 2 particles       which is truncated to satisfy a frictional yield criterion\n  \\(n_{ij} =\\) unit vector along the line connecting the centers of the 2 particles\n  \\(V_n =\\) normal component of the relative velocity of the 2 particles\n  \\(V_t =\\) tangential component of the relative velocity of the 2 particles\n  \n  The \\(K_n\\), \\(K_t\\), \\(\\gamma_n\\), and \\(\\gamma_t\\)\n  coefficients are specified as parameters to the pair_style command.  If\n  a NULL is used for \\(K_t\\), then a default value is used where\n  \\(K_t = 2/7 K_n\\).  If a NULL is used for \\(\\gamma_t\\), then a\n  default value is used where \\(\\gamma_t = 1/2 \\gamma_n\\).\n  The interpretation and units for these 4 coefficients are different in\n  the Hookean versus Hertzian equations.\n  The Hookean model is one where the normal push-back force for two\n  overlapping particles is a linear function of the overlap distance.\n  Thus the specified \\(K_n\\) is in units of (force/distance).  Note\n  that this push-back force is independent of absolute particle size (in\n  the monodisperse case) and of the relative sizes of the two particles\n  (in the polydisperse case).  This model also applies to the other terms\n  in the force equation so that the specified \\(\\gamma_n\\) is in units\n  of (1/time), \\(K_t\\) is in units of (force/distance), and\n  \\(\\gamma_t\\) is in units of (1/time).\n  The Hertzian model is one where the normal push-back force for two\n  overlapping particles is proportional to the area of overlap of the\n  two particles, and is thus a non-linear function of overlap distance.\n  Thus Kn has units of force per area and is thus specified in units of\n  (pressure).  The effects of absolute particle size (monodispersity)\n  and relative size (polydispersity) are captured in the radii-dependent\n  pre-factors.  When these pre-factors are carried through to the other\n  terms in the force equation it means that the specified \\(\\gamma_n\\) is in\n  units of (1/(time*distance)), \\(K_t\\) is in units of (pressure), and\n  \\(\\gamma_t\\) is in units of (1/(time*distance)).\n  Note that in the Hookean case, \\(K_n\\) can be thought of as a linear\n  spring constant with units of force/distance.  In the Hertzian case,\n  \\(K_n\\) is like a non-linear spring constant with units of\n  force/area or pressure, and as shown in the (Zhang)\n  paper, \\(K_n = 4G / (3(1-\\nu))\\) where \\(\\nu =\\) the Poisson ratio,\n  G = shear modulus = \\(E / (2(1+\\nu))\\), and E = Young’s modulus.  Similarly,\n  \\(K_t = 4G / (2-\\nu)\\).  (NOTE: in an earlier version of the manual, we incorrectly\n  stated that \\(K_t = 8G / (2-\\nu)\\).)\n  Thus in the Hertzian case \\(K_n\\) and \\(K_t\\) can be set to\n  values that corresponds to properties of the material being modeled.\n  This is also true in the Hookean case, except that a spring constant\n  must be chosen that is appropriate for the absolute size of particles in\n  the model.  Since relative particle sizes are not accounted for, the\n  Hookean styles may not be a suitable model for polydisperse systems.\n  \n  Note\n  In versions of LAMMPS before 9Jan09, the equation for Hertzian\n  interactions did not include the \\(\\sqrt{r_i r_j / (r_i + r_j)}\\)\n  term and thus was not as accurate for polydisperse systems.  For\n  monodisperse systems, \\(\\sqrt{ r_i r_j /(r_i+r_j)}\\) is a\n  constant factor that effectively scales all 4 coefficients:\n  \\(K_n, K_t, \\gamma_n, \\gamma_t\\).  Thus you can set the values of\n  these 4 coefficients appropriately in the current code to reproduce\n  the results of a previous Hertzian monodisperse calculation.  For\n  example, for the common case of a monodisperse system with particles\n  of diameter 1, all 4 of these coefficients should now be set 2x\n  larger than they were previously.\n  \n  Xmu is also specified in the pair_style command and is the upper limit\n  of the tangential force through the Coulomb criterion Ft = xmu*Fn,\n  where Ft and Fn are the total tangential and normal force components\n  in the formulas above.  Thus in the Hookean case, the tangential force\n  between 2 particles grows according to a tangential spring and\n  dash-pot model until Ft/Fn = xmu and is then held at Ft = Fn*xmu until\n  the particles lose contact.  In the Hertzian case, a similar analogy\n  holds, though the spring is no longer linear.\n  \n  Note\n  Normally, xmu should be specified as a fractional value between\n  0.0 and 1.0, however LAMMPS allows large values (up to 1.0e4) to allow\n  for modeling of systems which can sustain very large tangential\n  forces.\n  \n  The effective mass m_eff is given by the formula above for two\n  isolated particles.  If either particle is part of a rigid body, its\n  mass is replaced by the mass of the rigid body in the formula above.\n  This is determined by searching for a fix rigid\n  command (or its variants).\n  For granular styles there are no additional coefficients to set for\n  each pair of atom types via the pair_coeff command.\n  All settings are global and are made via the pair_style command.\n  However you must still use the pair_coeff for all\n  pairs of granular atom types.  For example the command\n  pair_coeff * *\n  \n  \n  should be used if all atoms in the simulation interact via a granular\n  potential (i.e. one of the pair styles above is used).  If a granular\n  potential is used as a sub-style of pair_style hybrid, then specific atom types can be used in the\n  pair_coeff command to determine which atoms interact via a granular\n  potential.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  The pair_modify mix, shift, table, and tail options\n  are not relevant for granular pair styles.\n  These pair styles write their information to binary restart files, so a pair_style command does not need to be\n  specified in an input script that reads a restart file.\n  These pair styles can only be used via the pair keyword of the\n  run_style respa command.  They do not support the\n  inner, middle, outer keywords.\n  The single() function of these pair styles returns 0.0 for the energy\n  of a pairwise interaction, since energy is not conserved in these\n  dissipative potentials.  It also returns only the normal component of\n  the pairwise interaction force.  However, the single() function also\n  calculates 10 extra pairwise quantities.  The first 3 are the\n  components of the tangential force between particles I and J, acting\n  on particle I.  The 4th is the magnitude of this tangential force.\n  The next 3 (5-7) are the components of the relative velocity in the\n  normal direction (along the line joining the 2 sphere centers).  The\n  last 3 (8-10) the components of the relative velocity in the\n  tangential direction.\n  These extra quantities can be accessed by the compute pair/local command, as p1, p2, …,\n  p10.\n  ",
    "syntax": "pair_style style Kn Kt gamma_n gamma_t xmu dampflag\n  \n  \n  \n  style = gran/hooke or gran/hooke/history or gran/hertz/history\n  Kn = elastic constant for normal particle repulsion (force/distance units or pressure units - see discussion below)\n  Kt = elastic constant for tangential contact (force/distance units or pressure units - see discussion below)\n  gamma_n = damping coefficient for collisions in normal direction (1/time units or 1/time-distance units - see discussion below)\n  gamma_t = damping coefficient for collisions in tangential direction (1/time units or 1/time-distance units - see discussion below)\n  xmu = static yield criterion (unitless value between 0.0 and 1.0e4)\n  dampflag = 0 or 1 if tangential damping force is excluded or included\n  \n  \n  Note\n  Versions of LAMMPS before 9Jan09 had different style names for\n  granular force fields.  This is to emphasize the fact that the\n  Hertzian equation has changed to model polydispersity more accurately.\n  A side effect of the change is that the Kn, Kt, gamma_n, and gamma_t\n  coefficients in the pair_style command must be specified with\n  different values in order to reproduce calculations made with earlier\n  versions of LAMMPS, even for monodisperse systems.  See the NOTE below\n  for details.\n  \n  ",
    "examples": "pair_style gran/hooke/history 200000.0 NULL 50.0 NULL 0.5 1\n  pair_style gran/hooke 200000.0 70000.0 50.0 30.0 0.5 0\n  \n  \n  ",
    "restrictions": "All the granular pair styles are part of the GRANULAR package.  It is\n  only enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\n  These pair styles require that atoms store torque and angular velocity\n  (omega) as defined by the atom_style.  They also\n  require a per-particle radius is stored.  The sphere atom style does\n  all of this.\n  This pair style requires you to use the comm_modify vel yes command so that velocities are stored by ghost\n  atoms.\n  These pair styles will not restart exactly when using the\n  read_restart command, though they should provide\n  statistically similar results.  This is because the forces they\n  compute depend on atom velocities.  See the\n  read_restart command for more details.\n  "
},
{
    "command": "pair_style granular",
    "description": "The granular styles support a variety of options for the normal,\n  tangential, rolling and twisting forces resulting from contact between\n  two granular particles. This expands on the options offered by the\n  pair gran/* pair styles. The total computed forces\n  and torques are the sum of various models selected for the normal,\n  tangential, rolling and twisting modes of motion.\n  All model choices and parameters are entered in the\n  pair_coeff command, as described below.  Unlike\n  e.g. pair gran/hooke, coefficient values are not\n  global, but can be set to different values for different combinations\n  of particle types, as determined by the pair_coeff\n  command.  If the contact model choice is the same for two particle\n  types, the mixing for the cross-coefficients can be carried out\n  automatically. This is shown in the last example, where model\n  choices are the same for type 1 - type 1 as for type 2 - type2\n  interactions, but coefficients are different. In this case, the\n  mixed coefficients for type 1 - type 2 interactions can be determined from\n  mixing rules discussed below.  For additional flexibility,\n  coefficients as well as model forms can vary between particle types,\n  as shown in the fourth example: type 1 - type 1 interactions are based\n  on a Johnson-Kendall-Roberts normal contact model and 2-2 interactions\n  are based on a DMT cohesive model (see below).  In that example, 1-1\n  and 2-2 interactions have different model forms, in which case mixing of\n  coefficients cannot be determined, so 1-2 interactions must be\n  explicitly defined via the pair_coeff 1 * command, otherwise an\n  error would result.\n  \n  The first required keyword for the pair_coeff command is the normal\n  contact model. Currently supported options for normal contact models\n  and their required arguments are:\n  \n  hooke : \\(k_n\\), \\(\\eta_{n0}\\) (or \\(e\\))\n  hertz : \\(k_n\\), \\(\\eta_{n0}\\) (or \\(e\\))\n  hertz/material : E, \\(\\eta_{n0}\\) (or \\(e\\)), \\(\\nu\\)\n  dmt : E, \\(\\eta_{n0}\\) (or \\(e\\)), \\(\\nu\\), \\(\\gamma\\)\n  jkr : E, \\(\\eta_{n0}\\) (or \\(e\\)), \\(\\nu\\), \\(\\gamma\\)\n  \n  Here, \\(k_n\\) is spring stiffness (with units that depend on model\n  choice, see below); \\(\\eta_{n0}\\) is a damping prefactor (or, in its\n  place a coefficient of restitution \\(e\\), depending on the choice of\n  damping mode, see below); E is Young’s modulus in units of\n  force/length^2, i.e. pressure; \\(\\nu\\) is Poisson’s ratio and\n  \\(\\gamma\\) is a surface energy density, in units of\n  energy/length^2.\n  For the hooke model, the normal, elastic component of force acting\n  on particle i due to contact with particle j is given by:\n  \n  \\[\\mathbf{F}_{ne, Hooke} = k_N \\delta_{ij} \\mathbf{n}\\]\n  Where \\(\\delta_{ij} = R_i + R_j - \\|\\mathbf{r}_{ij}\\|\\) is the particle\n  overlap, \\(R_i, R_j\\) are the particle radii, \\(\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j\\) is the vector separating the two\n  particle centers (note the i-j ordering so that \\(F_{ne}\\) is\n  positive for repulsion), and \\(\\mathbf{n} = \\frac{\\mathbf{r}_{ij}}{\\|\\mathbf{r}_{ij}\\|}\\).  Therefore,\n  for hooke, the units of the spring constant \\(k_n\\) are\n  force/distance, or equivalently mass/time^2.\n  For the hertz model, the normal component of force is given by:\n  \n  \\[\\mathbf{F}_{ne, Hertz} = k_N R_{eff}^{1/2}\\delta_{ij}^{3/2} \\mathbf{n}\\]\n  Here, \\(R_{eff} = \\frac{R_i R_j}{R_i + R_j}\\) is the effective\n  radius, denoted for simplicity as R from here on.  For hertz, the\n  units of the spring constant \\(k_n\\) are force/length^2, or\n  equivalently pressure.\n  For the hertz/material model, the force is given by:\n  \n  \\[\\mathbf{F}_{ne, Hertz/material} = \\frac{4}{3} E_{eff} R_{eff}^{1/2}\\delta_{ij}^{3/2} \\mathbf{n}\\]\n  Here, \\(E_{eff} = E = \\left(\\frac{1-\\nu_i^2}{E_i} + \\frac{1-\\nu_j^2}{E_j}\\right)^{-1}\\) is the effective Young’s\n  modulus, with \\(\\nu_i, \\nu_j\\) the Poisson ratios of the particles of\n  types i and j. Note that if the elastic modulus and the shear\n  modulus of the two particles are the same, the hertz/material model\n  is equivalent to the hertz model with \\(k_N = 4/3 E_{eff}\\)\n  The dmt model corresponds to the\n  (Derjaguin-Muller-Toporov) cohesive model, where the force\n  is simply Hertz with an additional attractive cohesion term:\n  \n  \\[\\mathbf{F}_{ne, dmt} = \\left(\\frac{4}{3} E R^{1/2}\\delta_{ij}^{3/2} - 4\\pi\\gamma R\\right)\\mathbf{n}\\]\n  The jkr model is the (Johnson-Kendall-Roberts) model,\n  where the force is computed as:\n  \n  \\[\\mathbf{F}_{ne, jkr} = \\left(\\frac{4Ea^3}{3R} - 2\\pi a^2\\sqrt{\\frac{4\\gamma E}{\\pi a}}\\right)\\mathbf{n}\\]\n  Here, a is the radius of the contact zone, related to the overlap\n  \\(\\delta\\) according to:\n  \n  \\[\\delta = a^2/R - 2\\sqrt{\\pi \\gamma a/E}\\]\n  LAMMPS internally inverts the equation above to solve for a in terms\n  of \\(\\delta\\), then solves for the force in the previous\n  equation. Additionally, note that the JKR model allows for a tensile\n  force beyond contact (i.e. for \\(\\delta < 0\\)), up to a maximum of\n  \\(3\\pi\\gamma R\\) (also known as the ‘pull-off’ force).  Note that this\n  is a hysteretic effect, where particles that are not contacting\n  initially will not experience force until they come into contact\n  \\(\\delta \\geq 0\\); as they move apart and (\\(\\delta < 0\\)), they\n  experience a tensile force up to \\(3\\pi\\gamma R\\), at which point they\n  lose contact.\n  \n  In addition, the normal force is augmented by a damping term of the\n  following general form:\n  \n  \\[\\mathbf{F}_{n,damp} = -\\eta_n \\mathbf{v}_{n,rel}\\]\n  Here, \\(\\mathbf{v}_{n,rel} = (\\mathbf{v}_j - \\mathbf{v}_i) \\cdot \\mathbf{n} \\mathbf{n}\\) is the component of relative velocity along\n  \\(\\mathbf{n}\\).\n  The optional damping keyword to the pair_coeff command followed by\n  a keyword determines the model form of the damping factor \\(\\eta_n\\),\n  and the interpretation of the \\(\\eta_{n0}\\) or \\(e\\) coefficients\n  specified as part of the normal contact model settings. The damping\n  keyword and corresponding model form selection may be appended\n  anywhere in the pair coeff command.  Note that the choice of damping\n  model affects both the normal and tangential damping (and depending on\n  other settings, potentially also the twisting damping).  The options\n  for the damping model currently supported are:\n  \n  velocity\n  mass_velocity\n  viscoelastic\n  tsuji\n  \n  If the damping keyword is not specified, the viscoelastic model is\n  used by default.\n  For damping velocity, the normal damping is simply equal to the\n  user-specified damping coefficient in the normal model:\n  \n  \\[\\eta_n = \\eta_{n0}\\]\n  Here, \\(\\eta_{n0}\\) is the damping coefficient specified for the normal\n  contact model, in units of mass/time.\n  For damping mass_velocity, the normal damping is given by:\n  \n  \\[\\eta_n = \\eta_{n0} m_{eff}\\]\n  Here, \\(\\eta_{n0}\\) is the damping coefficient specified for the normal\n  contact model, in units of mass/time and\n  \\(m_{eff} = m_i m_j/(m_i + m_j)\\) is the effective mass.\n  Use damping mass_velocity to reproduce the damping behavior of\n  pair gran/hooke/*.\n  The damping viscoelastic model is based on the viscoelastic\n  treatment of (Brilliantov et al), where the normal\n  damping is given by:\n  \n  \\[\\eta_n = \\eta_{n0}\\ a m_{eff}\\]\n  Here, a is the contact radius, given by \\(a =\\sqrt{R\\delta}\\)\n  for all models except jkr, for which it is given implicitly according\n  to \\(\\delta = a^2/R - 2\\sqrt{\\pi \\gamma a/E}\\).  For damping viscoelastic,\n  \\(\\eta_{n0}\\) is in units of 1/(time*distance).\n  The tsuji model is based on the work of (Tsuji et al). Here, the damping coefficient specified as part of\n  the normal model is interpreted as a restitution coefficient\n  \\(e\\). The damping constant \\(\\eta_n\\) is given by:\n  \n  \\[\\eta_n = \\alpha (m_{eff}k_n)^{1/2}\\]\n  For normal contact models based on material parameters, \\(k_n = 4/3Ea\\).  The parameter \\(\\alpha\\) is related to the restitution\n  coefficient e according to:\n  \n  \\[\\alpha = 1.2728-4.2783e+11.087e^2-22.348e^3+27.467e^4-18.022e^5+4.8218e^6\\]\n  The dimensionless coefficient of restitution \\(e\\) specified as part\n  of the normal contact model parameters should be between 0 and 1, but\n  no error check is performed on this.\n  The total normal force is computed as the sum of the elastic and\n  damping components:\n  \n  \\[\\mathbf{F}_n = \\mathbf{F}_{ne} + \\mathbf{F}_{n,damp}\\]\n  \n  The pair_coeff command also requires specification of the tangential\n  contact model. The required keyword tangential is expected, followed\n  by the model choice and associated parameters. Currently supported\n  tangential model choices and their expected parameters are as follows:\n  \n  linear_nohistory : \\(x_{\\gamma,t}\\), \\(\\mu_s\\)\n  linear_history : \\(k_t\\), \\(x_{\\gamma,t}\\), \\(\\mu_s\\)\n  mindlin : \\(k_t\\) or NULL, \\(x_{\\gamma,t}\\), \\(\\mu_s\\)\n  mindlin_rescale : \\(k_t\\) or NULL, \\(x_{\\gamma,t}\\), \\(\\mu_s\\)\n  \n  Here, \\(x_{\\gamma,t}\\) is a dimensionless multiplier for the normal\n  damping \\(\\eta_n\\) that determines the magnitude of the tangential\n  damping, \\(\\mu_t\\) is the tangential (or sliding) friction\n  coefficient, and \\(k_t\\) is the tangential stiffness coefficient.\n  For tangential linear_nohistory, a simple velocity-dependent Coulomb\n  friction criterion is used, which mimics the behavior of the pair\n  gran/hooke style. The tangential force (mathbf{F}_t) is given by:\n  \n  \\[\\mathbf{F}_t =  -min(\\mu_t F_{n0}, \\|\\mathbf{F}_\\mathrm{t,damp}\\|) \\mathbf{t}\\]\n  The tangential damping force \\(\\mathbf{F}_\\mathrm{t,damp}\\) is given by:\n  \n  \\[\\mathbf{F}_\\mathrm{t,damp} = -\\eta_t \\mathbf{v}_{t,rel}\\]\n  The tangential damping prefactor \\(\\eta_t\\) is calculated by scaling\n  the normal damping \\(\\eta_n\\) (see above):\n  \n  \\[\\eta_t = -x_{\\gamma,t} \\eta_n\\]\n  The normal damping prefactor \\(\\eta_n\\) is determined by the choice\n  of the damping keyword, as discussed above.  Thus, the damping\n  keyword also affects the tangential damping.  The parameter\n  \\(x_{\\gamma,t}\\) is a scaling coefficient. Several works in the\n  literature use \\(x_{\\gamma,t} = 1\\) (Marshall,\n  Tsuji et al, Silbert et al).  The relative\n  tangential velocity at the point of contact is given by\n  \\(\\mathbf{v}_{t, rel} = \\mathbf{v}_{t} - (R_i\\Omega_i + R_j\\Omega_j) \\times \\mathbf{n}\\), where \\(\\mathbf{v}_{t} = \\mathbf{v}_r - \\mathbf{v}_r\\cdot\\mathbf{n}{n}\\),\n  \\(\\mathbf{v}_r = \\mathbf{v}_j - \\mathbf{v}_i\\).\n  The direction of the applied force is \\(\\mathbf{t} = \\mathbf{v_{t,rel}}/\\|\\mathbf{v_{t,rel}}\\|\\) .\n  The normal force value \\(F_{n0}\\) used to compute the critical force\n  depends on the form of the contact model. For non-cohesive models\n  (hertz, hertz/material, hooke), it is given by the magnitude of\n  the normal force:\n  \n  \\[F_{n0} = \\|\\mathbf{F}_n\\|\\]\n  For cohesive models such as jkr and dmt, the critical force is\n  adjusted so that the critical tangential force approaches \\(\\mu_t F_{pulloff}\\), see Marshall, equation 43, and\n  Thornton.  For both models, \\(F_{n0}\\) takes the\n  form:\n  \n  \\[F_{n0} = \\|\\mathbf{F}_ne + 2 F_{pulloff}\\|\\]\n  Where \\(F_{pulloff} = 3\\pi \\gamma R\\) for jkr, and\n  \\(F_{pulloff} = 4\\pi \\gamma R\\) for dmt.\n  The remaining tangential options all use accumulated tangential\n  displacement (i.e. contact history). This is discussed below in the\n  context of the linear_history option, but the same treatment of the\n  accumulated displacement applies to the other options as well.\n  For tangential linear_history, the tangential force is given by:\n  \n  \\[\\mathbf{F}_t =  -min(\\mu_t F_{n0}, \\|-k_t\\mathbf{\\xi} + \\mathbf{F}_\\mathrm{t,damp}\\|) \\mathbf{t}\\]\n  Here, \\(\\mathbf{\\xi}\\) is the tangential displacement accumulated\n  during the entire duration of the contact:\n  \n  \\[\\mathbf{\\xi} = \\int_{t0}^t \\mathbf{v}_{t,rel}(\\tau) \\mathrm{d}\\tau\\]\n  This accumulated tangential displacement must be adjusted to account\n  for changes in the frame of reference of the contacting pair of\n  particles during contact. This occurs due to the overall motion of the\n  contacting particles in a rigid-body-like fashion during the duration\n  of the contact. There are two modes of motion that are relevant: the\n  ‘tumbling’ rotation of the contacting pair, which changes the\n  orientation of the plane in which tangential displacement occurs; and\n  ‘spinning’ rotation of the contacting pair about the vector connecting\n  their centers of mass (\\(\\mathbf{n}\\)).  Corrections due to the\n  former mode of motion are made by rotating the accumulated\n  displacement into the plane that is tangential to the contact vector\n  at each step, or equivalently removing any component of the tangential\n  displacement that lies along \\(\\mathbf{n}\\), and rescaling to\n  preserve the magnitude.  This follows the discussion in\n  Luding, see equation 17 and relevant discussion in that\n  work:\n  \n  \\[\\mathbf{\\xi} = \\left(\\mathbf{\\xi'} - (\\mathbf{n} \\cdot \\mathbf{\\xi'})\\mathbf{n}\\right) \\frac{\\|\\mathbf{\\xi'}\\|}{\\|\\mathbf{\\xi'}\\| - \\mathbf{n}\\cdot\\mathbf{\\xi'}}\\]\n  Here, \\(\\mathbf{\\xi'}\\) is the accumulated displacement prior to the\n  current time step and \\(\\mathbf{\\xi}\\) is the corrected\n  displacement. Corrections to the displacement due to the second mode\n  of motion described above (rotations about \\(\\mathbf{n}\\)) are not\n  currently implemented, but are expected to be minor for most\n  simulations.\n  Furthermore, when the tangential force exceeds the critical force, the\n  tangential displacement is re-scaled to match the value for the\n  critical force (see Luding, equation 20 and related\n  discussion):\n  \n  \\[\\mathbf{\\xi} = -\\frac{1}{k_t}\\left(\\mu_t F_{n0}\\mathbf{t} + \\mathbf{F}_{t,damp}\\right)\\]\n  The tangential force is added to the total normal force (elastic plus\n  damping) to produce the total force on the particle. The tangential\n  force also acts at the contact point (defined as the center of the\n  overlap region) to induce a torque on each particle according to:\n  \n  \\[\\mathbf{\\tau}_i = -(R_i - 0.5 \\delta) \\mathbf{n} \\times \\mathbf{F}_t\\]\n  \n  \\[\\mathbf{\\tau}_j = -(R_j - 0.5 \\delta) \\mathbf{n} \\times \\mathbf{F}_t\\]\n  For tangential mindlin, the Mindlin no-slip solution is used, which differs from the linear_history\n  option by an additional factor of a, the radius of the contact region. The tangential force is given by:\n  \n  \\[\\mathbf{F}_t =  -min(\\mu_t F_{n0}, \\|-k_t a \\mathbf{\\xi} + \\mathbf{F}_\\mathrm{t,damp}\\|) \\mathbf{t}\\]\n  Here, a is the radius of the contact region, given by \\(a =\\sqrt{R\\delta}\\)\n  for all normal contact models, except for jkr, where it is given\n  implicitly by \\(\\delta = a^2/R - 2\\sqrt{\\pi \\gamma a/E}\\), see\n  discussion above. To match the Mindlin solution, one should set \\(k_t = 4G/(2-\\nu)\\), where \\(G\\) is the shear modulus, related to Young’s modulus\n  \\(E\\) by \\(G = E/(2(1+\\nu))\\), where \\(\\nu\\) is Poisson’s ratio. This\n  can also be achieved by specifying NULL for \\(k_t\\), in which case a\n  normal contact model that specifies material parameters \\(E\\) and\n  \\(\\nu\\) is required (e.g. hertz/material, dmt or jkr). In this\n  case, mixing of the shear modulus for different particle types i and\n  j is done according to:\n  \n  \\[1/G = 2(2-\\nu_i)(1+\\nu_i)/E_i + 2(2-\\nu_j)(1+\\nu_j)/E_j\\]\n  The mindlin_rescale option uses the same form as mindlin, but the\n  magnitude of the tangential displacement is re-scaled as the contact\n  unloads, i.e. if \\(a < a_{t_{n-1}}\\):\n  \n  \\[\\mathbf{\\xi} = \\mathbf{\\xi_{t_{n-1}}} \\frac{a}{a_{t_{n-1}}}\\]\n  Here, \\(t_{n-1}\\) indicates the value at the previous time\n  step. This rescaling accounts for the fact that a decrease in the\n  contact area upon unloading leads to the contact being unable to\n  support the previous tangential loading, and spurious energy is\n  created without the rescaling above (Walton ). See also\n  discussion in Thornton et al, 2013 , particularly\n  equation 18(b) of that work and associated discussion.\n  \n  The optional rolling keyword enables rolling friction, which resists\n  pure rolling motion of particles. The options currently supported are:\n  \n  none\n  sds : \\(k_{roll}\\), \\(\\gamma_{roll}\\), \\(\\mu_{roll}\\)\n  \n  If the rolling keyword is not specified, the model defaults to none.\n  For rolling sds, rolling friction is computed via a\n  spring-dashpot-slider, using a ‘pseudo-force’ formulation, as detailed\n  by Luding. Unlike the formulation in\n  Marshall, this allows for the required adjustment of\n  rolling displacement due to changes in the frame of reference of the\n  contacting pair.  The rolling pseudo-force is computed analogously to\n  the tangential force:\n  \n  \\[\\mathbf{F}_{roll,0} =  k_{roll} \\mathbf{\\xi}_{roll}  - \\gamma_{roll} \\mathbf{v}_{roll}\\]\n  Here, \\(\\mathbf{v}_{roll} = -R(\\mathbf{\\Omega}_i - \\mathbf{\\Omega}_j) \\times \\mathbf{n}\\) is the relative rolling\n  velocity, as given in Wang et al and\n  Luding. This differs from the expressions given by Kuhn and Bagi and used in Marshall; see Wang et al for details. The rolling displacement is given by:\n  \n  \\[\\mathbf{\\xi}_{roll} = \\int_{t_0}^t \\mathbf{v}_{roll} (\\tau) \\mathrm{d} \\tau\\]\n  A Coulomb friction criterion truncates the rolling pseudo-force if it\n  exceeds a critical value:\n  \n  \\[\\mathbf{F}_{roll} =  min(\\mu_{roll} F_{n,0}, \\|\\mathbf{F}_{roll,0}\\|)\\mathbf{k}\\]\n  Here, \\(\\mathbf{k} = \\mathbf{v}_{roll}/\\|\\mathbf{v}_{roll}\\|\\) is the direction of\n  the pseudo-force.  As with tangential displacement, the rolling\n  displacement is rescaled when the critical force is exceeded, so that\n  the spring length corresponds the critical force. Additionally, the\n  displacement is adjusted to account for rotations of the frame of\n  reference of the two contacting particles in a manner analogous to the\n  tangential displacement.\n  The rolling pseudo-force does not contribute to the total force on\n  either particle (hence ‘pseudo’), but acts only to induce an equal and\n  opposite torque on each particle, according to:\n  \n  \\[\\tau_{roll,i} =  R_{eff} \\mathbf{n} \\times \\mathbf{F}_{roll}\\]\n  \n  \\[\\tau_{roll,j} =  -\\tau_{roll,i}\\]\n  \n  The optional twisting keyword enables twisting friction, which\n  resists rotation of two contacting particles about the vector\n  \\(\\mathbf{n}\\) that connects their centers. The options currently\n  supported are:\n  \n  none\n  sds : \\(k_{twist}\\), \\(\\gamma_{twist}\\), \\(\\mu_{twist}\\)\n  marshall\n  \n  If the twisting keyword is not specified, the model defaults to none.\n  For both twisting sds and twisting marshall, a history-dependent\n  spring-dashpot-slider is used to compute the twisting torque. Because\n  twisting displacement is a scalar, there is no need to adjust for\n  changes in the frame of reference due to rotations of the particle\n  pair. The formulation in Marshall therefore provides\n  the most straightforward treatment:\n  \n  \\[\\tau_{twist,0} = -k_{twist}\\xi_{twist} - \\gamma_{twist}\\Omega_{twist}\\]\n  Here \\(\\xi_{twist} = \\int_{t_0}^t \\Omega_{twist} (\\tau) \\mathrm{d}\\tau\\) is the twisting angular displacement, and\n  \\(\\Omega_{twist} = (\\mathbf{\\Omega}_i - \\mathbf{\\Omega}_j) \\cdot \\mathbf{n}\\) is the relative twisting angular velocity. The torque\n  is then truncated according to:\n  \n  \\[\\tau_{twist} = min(\\mu_{twist} F_{n,0}, \\tau_{twist,0})\\]\n  Similar to the sliding and rolling displacement, the angular\n  displacement is rescaled so that it corresponds to the critical value\n  if the twisting torque exceeds this critical value:\n  \n  \\[\\xi_{twist} = \\frac{1}{k_{twist}} (\\mu_{twist} F_{n,0}sgn(\\Omega_{twist}) - \\gamma_{twist}\\Omega_{twist})\\]\n  For twisting sds, the coefficients \\(k_{twist}, \\gamma_{twist}\\)\n  and \\(\\mu_{twist}\\) are simply the user input parameters that follow\n  the twisting sds keywords in the pair_coeff command.\n  For twisting_marshall, the coefficients are expressed in terms of\n  sliding friction coefficients, as discussed in\n  Marshall (see equations 32 and 33 of that work):\n  \n  \\[k_{twist} = 0.5k_ta^2\\]\n  \n  \\[\\eta_{twist} = 0.5\\eta_ta^2\\]\n  \n  \\[\\mu_{twist} = \\frac{2}{3}a\\mu_t\\]\n  Finally, the twisting torque on each particle is given by:\n  \n  \\[\\mathbf{\\tau}_{twist,i} = \\tau_{twist}\\mathbf{n}\\]\n  \n  \\[\\mathbf{\\tau}_{twist,j} = -\\mathbf{\\tau}_{twist,i}\\]\n  \n  The granular pair style can reproduce the behavior of the\n  pair gran/* styles with the appropriate settings (some very\n  minor differences can be expected due to corrections in\n  displacement history frame-of-reference, and the application\n  of the torque at the center of the contact rather than\n  at each particle). The first example above\n  is equivalent to pair gran/hooke 1000.0 NULL 50.0 50.0 0.4 1.\n  The second example is equivalent to\n  pair gran/hooke/history 1000.0 500.0 50.0 50.0 0.4 1.\n  The third example is equivalent to\n  pair gran/hertz/history 1000.0 500.0 50.0 50.0 0.4 1.\n  \n  LAMMPS automatically sets pairwise cutoff values for pair_style\n  granular based on particle radii (and in the case of jkr pull-off\n  distances). In the vast majority of situations, this is adequate.\n  However, a cutoff value can optionally be appended to the pair_style\n  granular command to specify a global cutoff (i.e. a cutoff for all\n  atom types). Additionally, the optional cutoff keyword can be passed\n  to the pair_coeff command, followed by a cutoff value.  This will\n  set a pairwise cutoff for the atom types in the pair_coeff command.\n  These options may be useful in some rare cases where the automatic\n  cutoff determination is not sufficient, e.g.  if particle diameters\n  are being modified via the fix adapt command. In that case, the\n  global cutoff specified as part of the pair_style granular command\n  is applied to all atom types, unless it is overridden for a given atom\n  type combination by the cutoff value specified in the pair coeff\n  command.  If cutoff is only specified in the pair coeff command\n  and no global cutoff is appended to the pair_style granular command,\n  then LAMMPS will use that cutoff for the specified atom type\n  combination, and automatically set pairwise cutoffs for the remaining\n  atom types.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  The pair_modify mix, shift, table, and tail options\n  are not relevant for granular pair styles.\n  Mixing of coefficients is carried out using geometric averaging for\n  most quantities, e.g. if friction coefficient for type 1-type 1\n  interactions is set to \\(\\mu_1\\), and friction coefficient for type\n  2-type 2 interactions is set to \\(\\mu_2\\), the friction coefficient\n  for type1-type2 interactions is computed as \\(\\sqrt{\\mu_1\\mu_2}\\)\n  (unless explicitly specified to a different value by a pair_coeff 1 2\n  … command). The exception to this is elastic modulus, only\n  applicable to hertz/material, dmt and jkr normal contact\n  models. In that case, the effective elastic modulus is computed as:\n  \n  \\[E_{eff,ij} = \\left(\\frac{1-\\nu_i^2}{E_i} + \\frac{1-\\nu_j^2}{E_j}\\right)^{-1}\\]\n  If the i-j coefficients \\(E_{ij}\\) and \\(\\nu_{ij}\\) are\n  explicitly specified, the effective modulus is computed as:\n  \n  \\[E_{eff,ij} = \\left(\\frac{1-\\nu_{ij}^2}{E_{ij}} + \\frac{1-\\nu_{ij}^2}{E_{ij}}\\right)^{-1}\\]\n  or\n  \n  \\[E_{eff,ij} = \\frac{E_{ij}}{2(1-\\nu_{ij})}\\]\n  These pair styles write their information to binary restart files, so a pair_style command does not need to be\n  specified in an input script that reads a restart file.\n  These pair styles can only be used via the pair keyword of the\n  run_style respa command.  They do not support the\n  inner, middle, outer keywords.\n  The single() function of these pair styles returns 0.0 for the energy\n  of a pairwise interaction, since energy is not conserved in these\n  dissipative potentials.  It also returns only the normal component of\n  the pairwise interaction force.  However, the single() function also\n  calculates 12 extra pairwise quantities.  The first 3 are the\n  components of the tangential force between particles I and J, acting\n  on particle I.  The 4th is the magnitude of this tangential force.\n  The next 3 (5-7) are the components of the rolling torque acting on\n  particle I. The next entry (8) is the magnitude of the rolling torque.\n  The next entry (9) is the magnitude of the twisting torque acting\n  about the vector connecting the two particle centers.\n  The last 3 (10-12) are the components of the vector connecting\n  the centers of the two particles (x_I - x_J).\n  These extra quantities can be accessed by the compute pair/local command, as p1, p2, …,\n  p12.\n  ",
    "syntax": "pair_style granular cutoff\n  \n  \n  \n  cutoff = global cutoff (optional).  See discussion below.\n  \n  ",
    "examples": "pair_style granular\n  pair_coeff * * hooke 1000.0 50.0 tangential linear_nohistory 1.0 0.4 damping mass_velocity\n  \n  pair_style granular\n  pair_coeff * * hooke 1000.0 50.0 tangential linear_history 500.0 1.0 0.4 damping mass_velocity\n  \n  pair_style granular\n  pair_coeff * * hertz 1000.0 50.0 tangential mindlin 1000.0 1.0 0.4\n  \n  pair_style granular\n  pair_coeff * * hertz/material 1e8 0.3 0.3 tangential mindlin_rescale NULL 1.0 0.4 damping tsuji\n  \n  pair_style granular\n  pair_coeff 1 * jkr 1000.0 500.0 0.3 10 tangential mindlin 800.0 1.0 0.5 rolling sds 500.0 200.0 0.5 twisting marshall\n  pair_coeff 2 2 hertz 200.0 100.0 tangential linear_history 300.0 1.0 0.1 rolling sds 200.0 100.0 0.1 twisting marshall\n  \n  pair_style granular\n  pair_coeff 1 1 dmt 1000.0 50.0 0.3 0.0 tangential mindlin NULL 0.5 0.5 rolling sds 500.0 200.0 0.5 twisting marshall\n  pair_coeff 2 2 dmt 1000.0 50.0 0.3 10.0 tangential mindlin NULL 0.5 0.1 rolling sds 500.0 200.0 0.1 twisting marshall\n  \n  \n  ",
    "restrictions": "All the granular pair styles are part of the GRANULAR package.  It is\n  only enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\n  These pair styles require that atoms store torque and angular velocity\n  (omega) as defined by the atom_style.  They also\n  require a per-particle radius is stored.  The sphere atom style does\n  all of this.\n  This pair style requires you to use the comm_modify vel yes command so that velocities are stored by ghost\n  atoms.\n  These pair styles will not restart exactly when using the\n  read_restart command, though they should provide\n  statistically similar results.  This is because the forces they\n  compute depend on atom velocities.  See the\n  read_restart command for more details.\n  "
},
{
    "command": "pair_style lj/gromacs",
    "description": "The lj/gromacs styles compute shifted LJ and Coulombic interactions\n  with an additional switching function S(r) that ramps the energy and force\n  smoothly to zero between an inner and outer cutoff.  It is a commonly\n  used potential in the GROMACS MD code and for\n  the coarse-grained models of (Marrink).\n  \n  \\[\\begin{split}E_{LJ} = & 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -\n           \\left(\\frac{\\sigma}{r}\\right)^6 \\right] + S_{LJ}(r)\n                      \\qquad r < r_c \\\\\n  E_C  = & \\frac{C q_i q_j}{\\epsilon  r} + S_C(r) \\qquad r < r_c \\\\\n  S(r) = & C \\qquad r < r_1 \\\\\n  S(r) = & \\frac{A}{3} (r - r_1)^3 + \\frac{B}{4} (r - r_1)^4 + C \\qquad  r_1 < r < r_c \\\\\n  A = & (-3 E'(r_c) + (r_c - r_1) E''(r_c))/(r_c - r_1)^2 \\\\\n  B = & (2 E'(r_c) - (r_c - r_1) E''(r_c))/(r_c - r_1)^3 \\\\\n  C = & -E(r_c) + \\frac{1}{2} (r_c - r_1) E'(r_c) - \\frac{1}{12} (r_c - r_1)^2 E''(r_c)\\end{split}\\]\n  \\(r_1\\) is the inner cutoff; \\(r_c\\) is the outer cutoff.  The\n  coefficients A, B, and C are computed by LAMMPS to perform the shifting\n  and smoothing.  The function S(r) is actually applied once to each term\n  of the LJ formula and once to the Coulombic formula, so there are 2 or 3\n  sets of A,B,C coefficients depending on which pair_style is used.  The\n  boundary conditions applied to the smoothing function are as follows:\n  \\(S'(r_1) = S''(r_1) = 0, S(r_c) = -E(r_c), S'(r_c) = -E'(r_c)\\),\n  and \\(S''(r_c) = -E''(r_c)\\), where E(r) is the corresponding term\n  in the LJ or Coulombic potential energy function.  Single and double\n  primes denote first and second derivatives with respect to r,\n  respectively.\n  The inner and outer cutoff for the LJ and Coulombic terms can be the\n  same or different depending on whether 2 or 4 arguments are used in\n  the pair_style command.  The inner LJ cutoff must be > 0, but the\n  inner Coulombic cutoff can be >= 0.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands, or by mixing as described below:\n  \n  \\(\\epsilon\\) (energy units)\n  \\(\\sigma\\) (distance units)\n  inner (distance units)\n  outer (distance units)\n  \n  Note that sigma is defined in the LJ formula as the zero-crossing\n  distance for the potential, not as the energy minimum at \\(2^{1/6} \\sigma\\).\n  The last 2 coefficients are optional inner and outer cutoffs for style\n  lj/gromacs.  If not specified, the global inner and outer values\n  are used.\n  The last 2 coefficients cannot be used with style\n  lj/gromacs/coul/gromacs because this force field does not allow\n  varying cutoffs for individual atom pairs; all pairs use the global\n  cutoff(s) specified in the pair_style command.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the epsilon and sigma coefficients\n  and cutoff distance for all of the lj/cut pair styles can be mixed.\n  The default mix value is geometric.  See the “pair_modify” command\n  for details.\n  None of the GROMACS pair styles support the\n  pair_modify shift option, since the Lennard-Jones\n  portion of the pair interaction is already smoothed to 0.0 at the\n  cutoff.\n  The pair_modify table option is not relevant\n  for this pair style.\n  None of the GROMACS pair styles support the\n  pair_modify tail option for adding long-range tail\n  corrections to energy and pressure, since there are no corrections for\n  a potential that goes to 0.0 at the cutoff.\n  All of the GROMACS pair styles write their information to binary restart files, so pair_style and pair_coeff commands do\n  not need to be specified in an input script that reads a restart file.\n  All of the GROMACS pair styles can only be used via the pair\n  keyword of the run_style respa command.  They do not\n  support the inner, middle, outer keywords.\n  ",
    "syntax": "pair_style style args\n  \n  \n  \n  style = lj/gromacs or lj/gromacs/coul/gromacs\n  args = list of arguments for a particular style\n  \n  lj/gromacs args = inner outer\n    inner, outer = global switching cutoffs for Lennard Jones\n  lj/gromacs/coul/gromacs args = inner outer (inner2) (outer2)\n    inner, outer = global switching cutoffs for Lennard Jones (and Coulombic if only 2 args)\n    inner2, outer2 = global switching cutoffs for Coulombic (optional)\n  ",
    "examples": "pair_style lj/gromacs 9.0 12.0\n  pair_coeff * * 100.0 2.0\n  pair_coeff 2 2 100.0 2.0 8.0 10.0\n  \n  pair_style lj/gromacs/coul/gromacs 9.0 12.0\n  pair_style lj/gromacs/coul/gromacs 8.0 10.0 7.0 9.0\n  pair_coeff * * 100.0 2.0\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "pair_style hbond/dreiding/lj",
    "description": "The hbond/dreiding styles compute the Acceptor-Hydrogen-Donor (AHD)\n  3-body hydrogen bond interaction for the DREIDING\n  force field, given by:\n  \n  \\[\\begin{split}E  = & \\left[LJ(r) | Morse(r) \\right] \\qquad \\qquad \\qquad r < r_{\\rm in} \\\\\n     = & S(r) * \\left[LJ(r) | Morse(r) \\right] \\qquad \\qquad r_{\\rm in} < r < r_{\\rm out} \\\\\n     = & 0 \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad r > r_{\\rm out} \\\\\n  LJ(r)  = & AR^{-12}-BR^{-10}cos^n\\theta=\n        \\epsilon\\left\\lbrace 5\\left[ \\frac{\\sigma}{r}\\right]^{12}-\n        6\\left[ \\frac{\\sigma}{r}\\right]^{10}  \\right\\rbrace cos^n\\theta\\\\\n  Morse(r)  = & D_0\\left\\lbrace \\chi^2 - 2\\chi\\right\\rbrace cos^n\\theta=\n        D_{0}\\left\\lbrace e^{- 2 \\alpha (r - r_0)} - 2 e^{- \\alpha (r - r_0)}\n        \\right\\rbrace cos^n\\theta \\\\\n  S(r)  = & \\frac{ \\left[r_{\\rm out}^2 - r^2\\right]^2\n  \\left[r_{\\rm out}^2 + 2r^2 - 3{r_{\\rm in}^2}\\right]}\n  { \\left[r_{\\rm out}^2 - {r_{\\rm in}}^2\\right]^3 }\\end{split}\\]\n  where \\(r_{\\rm in}\\) is the inner spline distance cutoff,\n  \\(r_{\\rm out}\\) is the outer distance cutoff, \\(\\theta_c\\) is\n  the angle cutoff, and n is the cosine periodicity.\n  Here, r is the radial distance between the donor (D) and acceptor\n  (A) atoms and \\(\\theta\\) is the bond angle between the acceptor, the\n  hydrogen (H) and the donor atoms:\n  \n  These 3-body interactions can be defined for pairs of acceptor and\n  donor atoms, based on atom types.  For each donor/acceptor atom pair,\n  the 3rd atom in the interaction is a hydrogen permanently bonded to\n  the donor atom, e.g. in a bond list read in from a data file via the\n  read_data command.  The atom types of possible\n  hydrogen atoms for each donor/acceptor type pair are specified by the\n  pair_coeff command (see below).\n  Style hbond/dreiding/lj is the original DREIDING potential of\n  (Mayo).  It uses a LJ 12/10 functional for the Donor-Acceptor\n  interactions. To match the results in the original paper, use n = 4.\n  Style hbond/dreiding/morse is an improved version using a Morse\n  potential for the Donor-Acceptor interactions. (Liu) showed\n  that the Morse form gives improved results for Dendrimer simulations,\n  when n = 2.\n  See the Howto bioFF doc page for more information\n  on the DREIDING force field.\n  \n  Note\n  Because the Dreiding hydrogen bond potential is only one portion\n  of an overall force field which typically includes other pairwise\n  interactions, it is common to use it as a sub-style in a pair_style hybrid/overlay command, where another pair style\n  provides the repulsive core interaction between pairs of atoms, e.g. a\n  1/r^12 Lennard-Jones repulsion.\n  \n  \n  Note\n  When using the hbond/dreiding pair styles with pair_style hybrid/overlay, you should explicitly define pair\n  interactions between the donor atom and acceptor atoms, (as well as\n  between these atoms and ALL other atoms in your system).  Whenever\n  pair_style hybrid/overlay is used, ordinary mixing\n  rules are not applied to atoms like the donor and acceptor atoms\n  because they are typically referenced in multiple pair styles.\n  Neglecting to do this can cause difficult-to-detect physics problems.\n  \n  \n  Note\n  In the original Dreiding force field paper 1-4 non-bonded\n  interactions ARE allowed.  If this is desired for your model, use the\n  special_bonds command (e.g. “special_bonds lj 0.0 0.0 1.0”) to turn\n  these interactions on.\n  \n  \n  The following coefficients must be defined for pairs of eligible\n  donor/acceptor types via the pair_coeff command as\n  in the examples above.\n  \n  Note\n  Unlike other pair styles and their associated\n  pair_coeff commands, you do not need to specify\n  pair_coeff settings for all possible I,J type pairs.  Only I,J type\n  pairs for atoms which act as joint donors/acceptors need to be\n  specified; all other type pairs are assumed to be inactive.\n  \n  \n  Note\n  A pair_coeff command can be specified multiple\n  times for the same donor/acceptor type pair.  This enables multiple\n  hydrogen types to be assigned to the same donor/acceptor type pair.\n  For other pair_styles, if the pair_coeff command is re-used for the\n  same I.J type pair, the settings for that type pair are overwritten.\n  For the hydrogen bond potentials this is not the case; the settings\n  are cumulative.  This means the only way to turn off a previous\n  setting, is to re-use the pair_style command and start over.\n  \n  For the hbond/dreiding/lj style the list of coefficients is as\n  follows:\n  \n  K = hydrogen atom type = 1 to Ntypes\n  donor flag = i or j\n  \\(\\epsilon\\) (energy units)\n  \\(\\sigma\\) (distance units)\n  n = exponent in formula above\n  distance cutoff \\(r_{\\rm in}\\) (distance units)\n  distance cutoff \\(r_{\\rm out}\\) (distance units)\n  angle cutoff (degrees)\n  \n  For the hbond/dreiding/morse style the list of coefficients is as\n  follows:\n  \n  K = hydrogen atom type = 1 to Ntypes\n  donor flag = i or j\n  \\(D_0\\) (energy units)\n  \\(\\alpha\\) (1/distance units)\n  \\(r_0\\) (distance units)\n  n = exponent in formula above\n  distance cutoff \\(r_{\\rm in}\\) (distance units)\n  distance cutoff \\(r_{out}\\) (distance units)\n  angle cutoff (degrees)\n  \n  A single hydrogen atom type K can be specified, or a wild-card asterisk\n  can be used in place of or in conjunction with the K arguments to\n  select multiple types as hydrogen atoms.  This takes the form\n  “*” or “*n” or “n*” or “m*n”.  See the pair_coeff\n  command doc page for details.\n  If the donor flag is i, then the atom of type I in the pair_coeff\n  command is treated as the donor, and J is the acceptor.  If the donor\n  flag is j, then the atom of type J in the pair_coeff command is\n  treated as the donor and I is the donor.  This option is required\n  because the pair_coeff command requires that I <= J.\n  \\(\\epsilon\\) and \\(\\sigma\\) are settings for the hydrogen bond\n  potential based on a Lennard-Jones functional form.  Note that sigma is\n  defined as the zero-crossing distance for the potential, not as the\n  energy minimum at \\(2^{1/6} \\sigma\\).\n  \\(D_0\\) and \\(\\alpha\\) and \\(r_0\\) are settings for the\n  hydrogen bond potential based on a Morse functional form.\n  The last 3 coefficients for both styles are optional.  If not\n  specified, the global n, distance cutoff, and angle cutoff specified\n  in the pair_style command are used.  If you wish to only override the\n  2nd or 3rd optional parameter, you must also specify the preceding\n  optional parameters.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  These pair styles do not support mixing. You must explicitly identify\n  each donor/acceptor type pair.\n  These styles do not support the pair_modify shift\n  option for the energy of the interactions.\n  The pair_modify table option is not relevant for\n  these pair styles.\n  These pair styles do not support the pair_modify\n  tail option for adding long-range tail corrections to energy and\n  pressure.\n  These pair styles do not write their information to binary restart files, so pair_style and pair_coeff commands need to be\n  re-specified in an input script that reads a restart file.\n  These pair styles can only be used via the pair keyword of the\n  run_style respa command.  They do not support the\n  inner, middle, outer keywords.\n  These pair styles tally a count of how many hydrogen bonding\n  interactions they calculate each timestep and the hbond energy.  These\n  quantities can be accessed via the compute pair\n  command as a vector of values of length 2.\n  To print these quantities to the log file (with a descriptive column\n  heading) the following commands could be included in an input script:\n  compute hb all pair hbond/dreiding/lj\n  variable n_hbond equal c_hb[1] #number hbonds\n  variable E_hbond equal c_hb[2] #hbond energy\n  thermo_style custom step temp epair v_E_hbond\n  \n  \n  ",
    "syntax": "pair_style style N inner_distance_cutoff outer_distance_cutoff angle_cutof\n  \n  \n  \n  style = hbond/dreiding/lj or hbond/dreiding/morse\n  n = cosine angle periodicity\n  inner_distance_cutoff = global inner cutoff for Donor-Acceptor interactions (distance units)\n  outer_distance_cutoff = global cutoff for Donor-Acceptor interactions (distance units)\n  angle_cutoff = global angle cutoff for Acceptor-Hydrogen-Donor\n  interactions (degrees)\n  \n  ",
    "examples": "pair_style hybrid/overlay lj/cut 10.0 hbond/dreiding/lj 4 9.0 11.0 90\n  pair_coeff 1 2 hbond/dreiding/lj 3 i 9.5 2.75 4 9.0 11.0 90.0\n  \n  pair_style hybrid/overlay lj/cut 10.0 hbond/dreiding/morse 2 9.0 11.0 90\n  pair_coeff 1 2 hbond/dreiding/morse 3 i 3.88 1.7241379 2.9 2 9 11 90\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "pair_style hybrid",
    "description": "The hybrid and hybrid/overlay styles enable the use of multiple\n  pair styles in one simulation.  With the hybrid style, exactly one\n  pair style is assigned to each pair of atom types.  With the\n  hybrid/overlay style, one or more pair styles can be assigned to\n  each pair of atom types.  The assignment of pair styles to type pairs\n  is made via the pair_coeff command.\n  Here are two examples of hybrid simulations.  The hybrid style could\n  be used for a simulation of a metal droplet on a LJ surface.  The\n  metal atoms interact with each other via an eam potential, the\n  surface atoms interact with each other via a lj/cut potential, and\n  the metal/surface interaction is also computed via a lj/cut\n  potential.  The hybrid/overlay style could be used as in the 2nd\n  example above, where multiple potentials are superposed in an additive\n  fashion to compute the interaction between atoms.  In this example,\n  using lj/cut and coul/long together gives the same result as if\n  the lj/cut/coul/long potential were used by itself.  In this case,\n  it would be more efficient to use the single combined potential, but\n  in general any combination of pair potentials can be used together in\n  to produce an interaction that is not encoded in any single pair_style\n  file, e.g. adding Coulombic forces between granular particles.\n  All pair styles that will be used are listed as “sub-styles” following\n  the hybrid or hybrid/overlay keyword, in any order.  Each\n  sub-style’s name is followed by its usual arguments, as illustrated in\n  the example above.  See the doc pages of individual pair styles for a\n  listing and explanation of the appropriate arguments.\n  Note that an individual pair style can be used multiple times as a\n  sub-style.  For efficiency this should only be done if your model\n  requires it.  E.g. if you have different regions of Si and C atoms and\n  wish to use a Tersoff potential for pure Si for one set of atoms, and\n  a Tersoff potential for pure C for the other set (presumably with some\n  3rd potential for Si-C interactions), then the sub-style tersoff\n  could be listed twice.  But if you just want to use a Lennard-Jones or\n  other pairwise potential for several different atom type pairs in your\n  model, then you should just list the sub-style once and use the\n  pair_coeff command to assign parameters for the different type pairs.\n  \n  Note\n  There is one exception to this option to list an individual\n  pair style multiple times: GPU-enabled pair styles in the GPU package.\n  This is because the GPU package currently assumes that only one\n  instance of a pair style is being used.\n  \n  In the pair_coeff commands, the name of a pair style must be added\n  after the I,J type specification, with the remaining coefficients\n  being those appropriate to that style.  If the pair style is used\n  multiple times in the pair_style command, then an additional numeric\n  argument must also be specified which is a number from 1 to M where M\n  is the number of times the sub-style was listed in the pair style\n  command.  The extra number indicates which instance of the sub-style\n  these coefficients apply to.\n  For example, consider a simulation with 3 atom types: types 1 and 2\n  are Ni atoms, type 3 are LJ atoms with charges.  The following\n  commands would set up a hybrid simulation:\n  pair_style hybrid eam/alloy lj/cut/coul/cut 10.0 lj/cut 8.0\n  pair_coeff * * eam/alloy nialhjea Ni Ni NULL\n  pair_coeff 3 3 lj/cut/coul/cut 1.0 1.0\n  pair_coeff 1*2 3 lj/cut 0.8 1.3\n  \n  \n  As an example of using the same pair style multiple times, consider a\n  simulation with 2 atom types.  Type 1 is Si, type 2 is C.  The\n  following commands would model the Si atoms with Tersoff, the C atoms\n  with Tersoff, and the cross-interactions with Lennard-Jones:\n  pair_style hybrid lj/cut 2.5 tersoff tersoff\n  pair_coeff * * tersoff 1 Si.tersoff Si NULL\n  pair_coeff * * tersoff 2 C.tersoff NULL C\n  pair_coeff 1 2 lj/cut 1.0 1.5\n  \n  \n  If pair coefficients are specified in the data file read via the\n  read_data command, then the same rule applies.\n  E.g. “eam/alloy” or “lj/cut” must be added after the atom type, for\n  each line in the “Pair Coeffs” section, e.g.\n  Pair Coeffs\n  \n  1 lj/cut/coul/cut 1.0 1.0\n  ...\n  \n  \n  Note that the pair_coeff command for some potentials such as\n  pair_style eam/alloy includes a mapping specification\n  of elements to all atom types, which in the hybrid case, can include\n  atom types not assigned to the eam/alloy potential.  The NULL\n  keyword is used by many such potentials (eam/alloy, Tersoff, AIREBO,\n  etc), to denote an atom type that will be assigned to a different\n  sub-style.\n  For the hybrid style, each atom type pair I,J is assigned to exactly\n  one sub-style.  Just as with a simulation using a single pair style,\n  if you specify the same atom type pair in a second pair_coeff command,\n  the previous assignment will be overwritten.\n  For the hybrid/overlay style, each atom type pair I,J can be\n  assigned to one or more sub-styles.  If you specify the same atom type\n  pair in a second pair_coeff command with a new sub-style, then the\n  second sub-style is added to the list of potentials that will be\n  calculated for two interacting atoms of those types.  If you specify\n  the same atom type pair in a second pair_coeff command with a\n  sub-style that has already been defined for that pair of atoms, then\n  the new pair coefficients simply override the previous ones, as in the\n  normal usage of the pair_coeff command.  E.g. these two sets of\n  commands are the same:\n  pair_style lj/cut 2.5\n  pair_coeff * * 1.0 1.0\n  pair_coeff 2 2 1.5 0.8\n  \n  pair_style hybrid/overlay lj/cut 2.5\n  pair_coeff * * lj/cut 1.0 1.0\n  pair_coeff 2 2 lj/cut 1.5 0.8\n  \n  \n  Coefficients must be defined for each pair of atoms types via the\n  pair_coeff command as described above, or in the\n  data file or restart files read by the read_data or\n  read_restart commands, or by mixing as described\n  below.\n  For both the hybrid and hybrid/overlay styles, every atom type\n  pair I,J (where I <= J) must be assigned to at least one sub-style via\n  the pair_coeff command as in the examples above, or\n  in the data file read by the read_data, or by mixing\n  as described below.\n  If you want there to be no interactions between a particular pair of\n  atom types, you have 3 choices.  You can assign the type pair to some\n  sub-style and use the neigh_modify exclude type\n  command.  You can assign it to some sub-style and set the coefficients\n  so that there is effectively no interaction (e.g. epsilon = 0.0 in a\n  LJ potential).  Or, for hybrid and hybrid/overlay simulations, you\n  can use this form of the pair_coeff command in your input script:\n  pair_coeff        2 3 none\n  \n  \n  or this form in the “Pair Coeffs” section of the data file:\n  3 none\n  \n  \n  If an assignment to none is made in a simulation with the\n  hybrid/overlay pair style, it wipes out all previous assignments of\n  that atom type pair to sub-styles.\n  Note that you may need to use an atom_style hybrid\n  command in your input script, if atoms in the simulation will need\n  attributes from several atom styles, due to using multiple pair\n  potentials.\n  \n  Different force fields (e.g. CHARMM vs AMBER) may have different rules\n  for applying weightings that change the strength of pairwise\n  interactions between pairs of atoms that are also 1-2, 1-3, and 1-4\n  neighbors in the molecular bond topology, as normally set by the\n  special_bonds command.  Different weights can be\n  assigned to different pair hybrid sub-styles via the pair_modify special command. This allows multiple force fields\n  to be used in a model of a hybrid system, however, there is no consistent\n  approach to determine parameters automatically for the interactions\n  between the two force fields, this is only recommended when particles\n  described by the different force fields do not mix.\n  Here is an example for mixing CHARMM and AMBER: The global amber\n  setting sets the 1-4 interactions to non-zero scaling factors and\n  then overrides them with 0.0 only for CHARMM:\n  special_bonds amber\n  pair_hybrid lj/charmm/coul/long 8.0 10.0 lj/cut/coul/long 10.0\n  pair_modify pair lj/charmm/coul/long special lj/coul 0.0 0.0 0.0\n  \n  \n  The this input achieves the same effect:\n  special_bonds 0.0 0.0 0.1\n  pair_hybrid lj/charmm/coul/long 8.0 10.0 lj/cut/coul/long 10.0\n  pair_modify pair lj/cut/coul/long special lj 0.0 0.0 0.5\n  pair_modify pair lj/cut/coul/long special coul 0.0 0.0 0.83333333\n  pair_modify pair lj/charmm/coul/long special lj/coul 0.0 0.0 0.0\n  \n  \n  Here is an example for mixing Tersoff with OPLS/AA based on\n  a data file that defines bonds for all atoms where for the\n  Tersoff part of the system the force constants for the bonded\n  interactions have been set to 0. Note the global settings are\n  effectively lj/coul 0.0 0.0 0.5 as required for OPLS/AA:\n  special_bonds lj/coul 1e-20 1e-20 0.5\n  pair_hybrid tersoff lj/cut/coul/long 12.0\n  pair_modify pair tersoff special lj/coul 1.0 1.0 1.0\n  \n  \n  For use with the various compute */tally\n  computes, the pair_modify compute/tally\n  command can be used to selectively turn off processing of\n  the compute tally styles, for example, if those pair styles\n  (e.g. many-body styles) do not support this feature.\n  See the pair_modify doc page for details on\n  the specific syntax, requirements and restrictions.\n  \n  The potential energy contribution to the overall system due to an\n  individual sub-style can be accessed and output via the compute pair command.\n  \n  \n  Note\n  Several of the potentials defined via the pair_style command in\n  LAMMPS are really many-body potentials, such as Tersoff, AIREBO, MEAM,\n  ReaxFF, etc.  The way to think about using these potentials in a\n  hybrid setting is as follows.\n  \n  A subset of atom types is assigned to the many-body potential with a\n  single pair_coeff command, using “* *” to include\n  all types and the NULL keywords described above to exclude specific\n  types not assigned to that potential.  If types 1,3,4 were assigned in\n  that way (but not type 2), this means that all many-body interactions\n  between all atoms of types 1,3,4 will be computed by that potential.\n  Pair_style hybrid allows interactions between type pairs 2-2, 1-2,\n  2-3, 2-4 to be specified for computation by other pair styles.  You\n  could even add a second interaction for 1-1 to be computed by another\n  pair style, assuming pair_style hybrid/overlay is used.\n  But you should not, as a general rule, attempt to exclude the\n  many-body interactions for some subset of the type pairs within the\n  set of 1,3,4 interactions, e.g. exclude 1-1 or 1-3 interactions.  That\n  is not conceptually well-defined for many-body interactions, since the\n  potential will typically calculate energies and foces for small groups\n  of atoms, e.g. 3 or 4 atoms, using the neighbor lists of the atoms to\n  find the additional atoms in the group.  It is typically non-physical\n  to think of excluding an interaction between a particular pair of\n  atoms when the potential computes 3-body or 4-body interactions.\n  However, you can still use the pair_coeff none setting or the\n  neigh_modify exclude command to exclude certain\n  type pairs from the neighbor list that will be passed to a many-body\n  sub-style.  This will alter the calculations made by a many-body\n  potential, since it builds its list of 3-body, 4-body, etc\n  interactions from the pair list.  You will need to think carefully as\n  to whether it produces a physically meaningful result for your model.\n  For example, imagine you have two atom types in your model, type 1 for\n  atoms in one surface, and type 2 for atoms in the other, and you wish\n  to use a Tersoff potential to compute interactions within each\n  surface, but not between surfaces.  Then either of these two command\n  sequences would implement that model:\n  pair_style hybrid tersoff\n  pair_coeff * * tersoff SiC.tersoff C C\n  pair_coeff 1 2 none\n  \n  pair_style tersoff\n  pair_coeff * * SiC.tersoff C C\n  neigh_modify exclude type 1 2\n  \n  \n  Either way, only neighbor lists with 1-1 or 2-2 interactions would be\n  passed to the Tersoff potential, which means it would compute no\n  3-body interactions containing both type 1 and 2 atoms.\n  Here is another example, using hybrid/overlay, to use 2 many-body\n  potentials together, in an overlapping manner.  Imagine you have CNT\n  (C atoms) on a Si surface.  You want to use Tersoff for Si/Si and Si/C\n  interactions, and AIREBO for C/C interactions.  Si atoms are type 1; C\n  atoms are type 2.  Something like this will work:\n  pair_style hybrid/overlay tersoff airebo 3.0\n  pair_coeff * * tersoff SiC.tersoff.custom Si C\n  pair_coeff * * airebo CH.airebo NULL C\n  \n  \n  Note that to prevent the Tersoff potential from computing C/C\n  interactions, you would need to modify the SiC.tersoff file to turn\n  off C/C interaction, i.e. by setting the appropriate coefficients to\n  0.0.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.\n  Since the hybrid and hybrid/overlay styles delegate computation to\n  the individual sub-styles, the suffix versions of the hybrid and\n  hybrid/overlay styles are used to propagate the corresponding suffix\n  to all sub-styles, if those versions exist. Otherwise the\n  non-accelerated version will be used.\n  The individual accelerated sub-styles are part of the GPU, USER-OMP\n  and OPT packages, respectively.  They are only enabled if LAMMPS was\n  built with those packages.  See the Build package\n  doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  Any pair potential settings made via the\n  pair_modify command are passed along to all\n  sub-styles of the hybrid potential.\n  For atom type pairs I,J and I != J, if the sub-style assigned to I,I\n  and J,J is the same, and if the sub-style allows for mixing, then the\n  coefficients for I,J can be mixed.  This means you do not have to\n  specify a pair_coeff command for I,J since the I,J type pair will be\n  assigned automatically to the sub-style defined for both I,I and J,J\n  and its coefficients generated by the mixing rule used by that\n  sub-style.  For the hybrid/overlay style, there is an additional\n  requirement that both the I,I and J,J pairs are assigned to a single\n  sub-style.  See the “pair_modify” command for details of mixing rules.\n  See the See the doc page for the sub-style to see if allows for\n  mixing.\n  The hybrid pair styles supports the pair_modify\n  shift, table, and tail options for an I,J pair interaction, if the\n  associated sub-style supports it.\n  For the hybrid pair styles, the list of sub-styles and their\n  respective settings are written to binary restart files, so a pair_style command does\n  not need to specified in an input script that reads a restart file.\n  However, the coefficient information is not stored in the restart\n  file.  Thus, pair_coeff commands need to be re-specified in the\n  restart input script.\n  These pair styles support the use of the inner, middle, and\n  outer keywords of the run_style respa command, if\n  their sub-styles do.\n  ",
    "syntax": "pair_style hybrid style1 args style2 args ...\n  pair_style hybrid/overlay style1 args style2 args ...\n  \n  \n  \n  style1,style2 = list of one or more pair styles and their arguments\n  \n  ",
    "examples": "pair_style hybrid lj/cut/coul/cut 10.0 eam lj/cut 5.0\n  pair_coeff 1*2 1*2 eam niu3\n  pair_coeff 3 3 lj/cut/coul/cut 1.0 1.0\n  pair_coeff 1*2 3 lj/cut 0.5 1.2\n  \n  pair_style hybrid/overlay lj/cut 2.5 coul/long 2.0\n  pair_coeff * * lj/cut 1.0 1.0\n  pair_coeff * * coul/long\n  \n  \n  ",
    "restrictions": "When using a long-range Coulombic solver (via the\n  kspace_style command) with a hybrid pair_style,\n  one or more sub-styles will be of the “long” variety,\n  e.g. lj/cut/coul/long or buck/coul/long.  You must insure that the\n  short-range Coulombic cutoff used by each of these long pair styles is\n  the same or else LAMMPS will generate an error.\n  "
},
{
    "command": "pair_style ilp/graphene/hbn",
    "description": "The ilp/graphene/hbn style computes the registry-dependent interlayer\n  potential (ILP) potential as described in (Leven1),\n  (Leven2) and (Maaravi).\n  The normals are calculated in the way as described\n  in (Kolmogorov).\n  \n  \\[\\begin{split}E  = & \\frac{1}{2} \\sum_i \\sum_{j \\neq i} V_{ij} \\\\\n  V_{ij}  = & {\\rm Tap}(r_{ij})\\left \\{ e^{-\\alpha (r_{ij}/\\beta -1)}\n               \\left [ \\epsilon + f(\\rho_{ij}) + f(\\rho_{ji})\\right ] -\n                \\frac{1}{1+e^{-d\\left [ \\left ( r_{ij}/\\left (s_R \\cdot r^{eff} \\right ) \\right )-1 \\right ]}}\n                \\cdot \\frac{C_6}{r^6_{ij}} \\right \\}\\\\\n  \\rho_{ij}^2 = & r_{ij}^2 - ({\\bf r}_{ij} \\cdot {\\bf n}_i)^2 \\\\\n  \\rho_{ji}^2  = & r_{ij}^2 - ({\\bf r}_{ij} \\cdot {\\bf n}_j)^2 \\\\\n  f(\\rho)  = &  C e^{ -( \\rho / \\delta )^2 } \\\\\n  {\\rm Tap}(r_{ij})  = & 20\\left ( \\frac{r_{ij}}{R_{cut}} \\right )^7 -\n                          70\\left ( \\frac{r_{ij}}{R_{cut}} \\right )^6 +\n                          84\\left ( \\frac{r_{ij}}{R_{cut}} \\right )^5 -\n                          35\\left ( \\frac{r_{ij}}{R_{cut}} \\right )^4 + 1\\end{split}\\]\n  Where \\(\\mathrm{Tap}(r_{ij})\\) is the taper function which provides\n  a continuous cutoff (up to third derivative) for interatomic separations\n  larger than \\(r_c\\) (Maaravi). The definitions of\n  each parameter in the above equation can be found in (Leven1) and (Maaravi).\n  It is important to include all the pairs to build the neighbor list for\n  calculating the normals.\n  \n  Note\n  This potential (ILP) is intended for interlayer interactions between two\n  different layers of graphene, hexagonal boron nitride (h-BN) and their hetero-junction.\n  To perform a realistic simulation, this potential must be used in combination with\n  intralayer potential, such as AIREBO or Tersoff potential.\n  To keep the intralayer properties unaffected, the interlayer interaction\n  within the same layers should be avoided. Hence, each atom has to have a layer\n  identifier such that atoms residing on the same layer interact via the\n  appropriate intralayer potential and atoms residing on different layers\n  interact via the ILP. Here, the molecule id is chosen as the layer identifier,\n  thus a data file with the “full” atom style is required to use this potential.\n  \n  The parameter file (e.g. BNCH.ILP), is intended for use with metal\n  units, with energies in meV. Two additional parameters,\n  S, and rcut are included in the parameter file. S is designed to\n  facilitate scaling of energies. rcut is designed to build the neighbor\n  list for calculating the normals for each atom pair.\n  \n  Note\n  The parameters presented in the parameter file (e.g. BNCH.ILP),\n  are fitted with taper function by setting the cutoff equal to 16.0\n  Angstrom.  Using different cutoff or taper function should be careful.\n  The parameters for atoms pairs between Boron and Nitrogen are fitted with\n  a screened Coulomb interaction coul/shield. Therefore,\n  to simulated the properties of h-BN correctly, this potential must be used in\n  combination with the pair style coul/shield.\n  \n  \n  Note\n  Four new sets of parameters of ILP for 2D layered Materials with bilayer and\n  bulk configurations are presented in (Ouyang1) and (Ouyang2), respectively.\n  These parameters provide a good description in both short- and long-range interaction regimes.\n  While the old ILP parameters published in (Leven2) and\n  (Maaravi) are only suitable for long-range interaction\n  regime. This feature is essential for simulations in high pressure\n  regime (i.e., the interlayer distance is smaller than the equilibrium\n  distance). The benchmark tests and comparison of these parameters can\n  be found in (Ouyang1) and (Ouyang2).\n  \n  This potential must be used in combination with hybrid/overlay.\n  Other interactions can be set to zero using pair_style none.\n  This pair style tallies a breakdown of the total interlayer potential\n  energy into sub-categories, which can be accessed via the compute pair command as a vector of values of length 2.\n  The 2 values correspond to the following sub-categories:\n  \n  E_vdW = vdW (attractive) energy\n  E_Rep = Repulsive energy\n  \n  To print these quantities to the log file (with descriptive column\n  headings) the following commands could be included in an input script:\n  compute 0 all pair ilp/graphene/hbn\n  variable Evdw  equal c_0[1]\n  variable Erep  equal c_0[2]\n  thermo_style custom step temp epair v_Erep v_Evdw\n  \n  \n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This pair style does not support the pair_modify mix, shift, table, and\n  tail options.\n  This pair style does not write their information to binary restart\n  files, since it is stored in potential files. Thus, you need to\n  re-specify the pair_style and pair_coeff commands in an input script\n  that reads a restart file.\n  ",
    "syntax": "pair_style [hybrid/overlay ...] ilp/graphene/hbn cutoff tap_flag\n  \n  \n  \n  cutoff = global cutoff (distance units)\n  tap_flag = 0/1 to turn off/on the taper function\n  \n  ",
    "examples": "pair_style  hybrid/overlay ilp/graphene/hbn 16.0 1\n  pair_coeff  * * ilp/graphene/hbn  BNCH.ILP B N C\n  \n  pair_style  hybrid/overlay rebo tersoff ilp/graphene/hbn 16.0 coul/shield 16.0\n  pair_coeff  * * rebo              CH.rebo     NULL NULL C\n  pair_coeff  * * tersoff           BNC.tersoff B    N    NULL\n  pair_coeff  * * ilp/graphene/hbn  BNCH.ILP    B    N    C\n  pair_coeff  1 1 coul/shield 0.70\n  pair_coeff  1 2 coul/shield 0.695\n  pair_coeff  2 2 coul/shield 0.69\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  This pair potential requires the newton setting to be on for pair\n  interactions.\n  The BNCH.ILP potential file provided with LAMMPS (see the potentials\n  directory) are parameterized for metal units.  You can use this\n  potential with any LAMMPS units, but you would need to create your\n  BNCH.ILP potential file with coefficients listed in the appropriate\n  units, if your simulation does not use metal units.\n  "
},
{
    "command": "pair_style kim",
    "description": "This pair style is a wrapper on the Open Knowledgebase of Interatomic Models (OpenKIM) repository of interatomic\n  potentials to enable their use in LAMMPS scripts.\n  The preferred interface for using interatomic models archived in\n  OpenKIM is the kim_commands interface. That\n  interface supports both “KIM Portable Models” (PMs) that conform to the\n  KIM API Portable Model Interface (PMI) and can be used by any\n  simulation code that conforms to the KIM API/PMI, and\n  “KIM Simulator Models” that are natively implemented within a single\n  simulation code (like LAMMPS) and can only be used with it.\n  The pair_style kim command is limited to KIM PMs. It is\n  used by the kim_commands interface as needed.\n  \n  Note\n  Since pair_style kim is called by kim_interactions as needed,\n  is not recommended to be directly used in input scripts.\n  \n  \n  The argument model is the name of the KIM PM.\n  For potentials archived in OpenKIM\n  this is the extended KIM ID (see kim_commands\n  for details). LAMMPS can invoke any KIM PM, however there can\n  be incompatibilities (for example due to unit matching issues).\n  In the event of an incompatibility, the code will terminate with\n  an error message. Check both the LAMMPS and KIM log files for details.\n  Only a single pair_coeff command is used with the kim style, which\n  specifies the mapping of LAMMPS atom types to the species supported by\n  the KIM PM.  This is done by specifying N additional arguments\n  after the * * in the pair_coeff command, where N is the number of\n  LAMMPS atom types:\n  \n  N element names = mapping of KIM elements to atom types\n  \n  For example, consider a KIM PM that supports Si and C species.\n  If the LAMMPS simulation has four atom types, where the first three are Si,\n  and the fourth is C, the following pair_coeff command would be used:\n  pair_coeff * * Si Si Si C\n  \n  \n  The first two arguments must be * * so as to span all LAMMPS atom types.\n  The first three Si arguments map LAMMPS atom types 1, 2, and 3 to Si as\n  defined within KIM PM.  The final C argument maps LAMMPS atom type 4 to C.\n  \n  In addition to the usual LAMMPS error messages, the KIM library itself\n  may generate errors, which should be printed to the screen.  In this\n  case it is also useful to check the kim.log file for additional error\n  information.  The file kim.log should be generated in the same\n  directory where LAMMPS is running.\n  To download, build, and install the KIM library on your system, see\n  the lib/kim/README file.  Once you have done this and built LAMMPS\n  with the KIM package installed you can run the example input scripts\n  in examples/kim.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This pair style does not support the pair_modify\n  mix, shift, table, and tail options.\n  This pair style does not write its information to binary restart files, since KIM stores the potential parameters.\n  Thus, you need to re-specify the pair_style and pair_coeff commands in\n  an input script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style kim model\n  \n  \n  model = name of a KIM model (the KIM ID for models archived in OpenKIM)\n  ",
    "examples": "pair_style kim SW_StillingerWeber_1985_Si__MO_405512056662_005\n  pair_coeff * * Si\n  \n  \n  ",
    "restrictions": "This pair style is part of the KIM package. See details on\n  restrictions in kim_commands.\n  This current version of pair_style kim is compatible with the\n  kim-api package version 2.0.0 and higher.\n  "
},
{
    "command": "pair_style kolmogorov/crespi/full",
    "description": "The kolmogorov/crespi/full style computes the Kolmogorov-Crespi (KC)\n  interaction potential as described in (Kolmogorov).\n  No simplification is made,\n  \n  \\[\\begin{split} E  = & \\frac{1}{2} \\sum_i \\sum_{j \\neq i} V_{ij} \\\\\n   V_{ij}  = & e^{-\\lambda (r_{ij} -z_0)} \\left [ C + f(\\rho_{ij}) + f(\\rho_{ji}) - A \\left ( \\frac{r_{ij}}{z_0}\\right )^{-6} \\right ] \\\\\n  \\rho_{ij}^2 = & r_{ij}^2 - ({\\bf r}_{ij}\\cdot {\\bf n}_{i})^2 \\\\\n  \\rho_{ji}^2 = & r_{ij}^2 - ({\\bf r}_{ij}\\cdot  {\\bf n}_{j})^2 \\\\\n  f(\\rho) & =  e^{-(\\rho/\\delta)^2} \\sum_{n=0}^2 C_{2n} { (\\rho/\\delta) }^{2n}\\end{split}\\]\n  It is important to have a sufficiently large cutoff to ensure smooth\n  forces and to include all the pairs to build the neighbor list for\n  calculating the normals.  Energies are shifted so that they go\n  continuously to zero at the cutoff assuming that the exponential part of\n  \\(V_{ij}\\) (first term) decays sufficiently fast.  This shift is achieved by\n  the last term in the equation for \\(V_{ij}\\) above. This is essential only\n  when the tapper function is turned off. The formula of taper function\n  can be found in pair style ilp/graphene/hbn.\n  \n  Note\n  This potential (ILP) is intended for interlayer interactions between two\n  different layers of graphene. To perform a realistic simulation, this potential\n  must be used in combination with intralayer potential, such as\n  AIREBO or Tersoff potential.\n  To keep the intralayer properties unaffected, the interlayer interaction\n  within the same layers should be avoided. Hence, each atom has to have a layer\n  identifier such that atoms residing on the same layer interact via the\n  appropriate intralayer potential and atoms residing on different layers\n  interact via the ILP. Here, the molecule id is chosen as the layer identifier,\n  thus a data file with the “full” atom style is required to use this potential.\n  \n  The parameter file (e.g. CH.KC), is intended for use with metal\n  units, with energies in meV. Two additional parameters, S,\n  and rcut are included in the parameter file. S is designed to\n  facilitate scaling of energies. rcut is designed to build the neighbor\n  list for calculating the normals for each atom pair.\n  \n  Note\n  Two new sets of parameters of KC potential for hydrocarbons, CH.KC\n  (without the taper function) and CH_taper.KC (with the taper function)\n  are presented in (Ouyang1).  The energy for the KC potential\n  with the taper function goes continuously to zero at the cutoff.  The\n  parameters in both CH.KC and CH_taper.KC provide a good description in\n  both short- and long-range interaction regimes. While the original\n  parameters (CC.KC) published in (Kolmogorov) are only\n  suitable for long-range interaction regime.  This feature is essential\n  for simulations in high pressure regime (i.e., the interlayer distance\n  is smaller than the equilibrium distance).  The benchmark tests and\n  comparison of these parameters can be found in (Ouyang1) and (Ouyang2).\n  \n  This potential must be used in combination with hybrid/overlay.\n  Other interactions can be set to zero using pair_style none.\n  This pair style tallies a breakdown of the total interlayer potential\n  energy into sub-categories, which can be accessed via the compute pair command as a vector of values of length 2.\n  The 2 values correspond to the following sub-categories:\n  \n  E_vdW = vdW (attractive) energy\n  E_Rep = Repulsive energy\n  \n  To print these quantities to the log file (with descriptive column\n  headings) the following commands could be included in an input script:\n  compute 0 all pair kolmogorov/crespi/full\n  variable Evdw  equal c_0[1]\n  variable Erep  equal c_0[2]\n  thermo_style custom step temp epair v_Erep v_Evdw\n  \n  \n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This pair style does not support the pair_modify mix, shift, table,\n  and tail options.\n  This pair style does not write their information to binary restart\n  files, since it is stored in potential files. Thus, you need to\n  re-specify the pair_style and pair_coeff commands in an input script\n  that reads a restart file.\n  ",
    "syntax": "pair_style hybrid/overlay kolmogorov/crespi/full cutoff tap_flag\n  \n  \n  \n  cutoff = global cutoff (distance units)\n  tap_flag = 0/1 to turn off/on the taper function\n  \n  ",
    "examples": "pair_style hybrid/overlay kolmogorov/crespi/full 20.0 0\n  pair_coeff * * none\n  pair_coeff * * kolmogorov/crespi/full  CH.KC   C C\n  \n  pair_style hybrid/overlay rebo kolmogorov/crespi/full 16.0 1\n  pair_coeff * * rebo                    CH.rebo      C H\n  pair_coeff * * kolmogorov/crespi/full  CH_taper.KC  C H\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  This pair potential requires the newton setting to be on for pair\n  interactions.\n  The CH.KC potential file provided with LAMMPS (see the potentials\n  folder) are parameterized for metal units.  You can use this potential\n  with any LAMMPS units, but you would need to create your own custom\n  CC.KC potential file with all coefficients converted to the appropriate\n  units.\n  "
},
{
    "command": "pair_style kolmogorov/crespi/z",
    "description": "The kolmogorov/crespi/z style computes the Kolmogorov-Crespi interaction\n  potential as described in (Kolmogorov). An important simplification is made,\n  which is to take all normals along the z-axis.\n  \n  \\[\\begin{split}E  = & \\frac{1}{2} \\sum_i \\sum_{j \\neq i} V_{ij} \\\\\n  V_{ij}  = & e^{-\\lambda(r_{ij} -z_0}) \\left[ C + f(\\rho_{ij}) + f(\\rho_{ji}) \\right] - A \\left( \\frac{r_{ij}}{z_0}\\right)^{-6} + A \\left( \\frac{\\textrm{cutoff}}{z_0}\\right)^{-6} \\\\\n  \\rho_{ij}^2 = & \\rho_{ji}^2  =  x_{ij}^2 + y_{ij}^2 \\qquad \\qquad (\\mathbf{n}_i \\equiv \\mathbf{\\hat{z}}) \\\\\n  f(\\rho)  = &  e^{-(\\rho/\\delta)^2} \\sum_{n=0}^2 C_{2n} \\left( \\rho/\\delta \\right)^{2n}\\end{split}\\]\n  It is important to have a sufficiently large cutoff to ensure smooth forces.\n  Energies are shifted so that they go continuously to zero at the cutoff assuming\n  that the exponential part of \\(V_{ij}\\) (first term) decays sufficiently fast.\n  This shift is achieved by the last term in the equation for \\(V_{ij}\\) above.\n  This potential is intended for interactions between two layers of graphene.\n  Therefore, to avoid interaction between layers in multi-layered materials,\n  each layer should have a separate atom type and interactions should only\n  be computed between atom types of neighboring layers.\n  The parameter file (e.g. CC.KC), is intended for use with metal\n  units, with energies in meV. An additional parameter, S,\n  is available to facilitate scaling of energies in accordance with\n  (vanWijk).\n  This potential must be used in combination with hybrid/overlay.\n  Other interactions can be set to zero using pair_style none.\n  ",
    "syntax": "pair_style [hybrid/overlay ...] kolmogorov/crespi/z cutoff\n  \n  \n  ",
    "examples": "pair_style hybrid/overlay kolmogorov/crespi/z 20.0\n  pair_coeff * * none\n  pair_coeff 1 2 kolmogorov/crespi/z  CC.KC   C C\n  \n  pair_style hybrid/overlay rebo kolmogorov/crespi/z 14.0\n  pair_coeff * * rebo                 CH.rebo    C C\n  pair_coeff 1 2 kolmogorov/crespi/z  CC.KC      C C\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style lcbop",
    "description": "The lcbop pair style computes the long-range bond-order potential\n  for carbon (LCBOP) of (Los and Fasolino).  See section II in\n  that paper for the analytic equations associated with the potential.\n  Only a single pair_coeff command is used with the lcbop style which\n  specifies an LCBOP potential file with parameters for specific\n  elements.  These are mapped to LAMMPS atom types by specifying N\n  additional arguments after the filename in the pair_coeff command,\n  where N is the number of LAMMPS atom types:\n  \n  filename\n  N element names = mapping of LCBOP elements to atom types\n  \n  See the pair_coeff doc page for alternate ways\n  to specify the path for the potential file.\n  As an example, if your LAMMPS simulation has 4 atom types and you want\n  the 1st 3 to be C you would use the following pair_coeff command:\n  pair_coeff * * C.lcbop C C C NULL\n  \n  \n  The 1st 2 arguments must be * * so as to span all LAMMPS atom types.\n  The first C argument maps LAMMPS atom type 1 to the C element in the\n  LCBOP file. If a mapping value is specified as NULL, the mapping is\n  not performed.  This can be used when a lcbop potential is used as\n  part of the hybrid pair style.  The NULL values are placeholders for\n  atom types that will be used with other potentials.\n  The parameters/coefficients for the LCBOP potential as applied to C\n  are listed in the C.lcbop file to agree with the original (Los and Fasolino) paper.  Thus the parameters are specific to this\n  potential and the way it was fit, so modifying the file should be done\n  carefully.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This pair style does not support the pair_modify\n  mix, shift, table, and tail options.\n  This pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\n  need to re-specify the pair_style and pair_coeff commands in an input\n  script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style lcbop\n  \n  \n  ",
    "examples": "pair_style lcbop\n  pair_coeff * * ../potentials/C.lcbop C\n  \n  \n  ",
    "restrictions": "This pair styles is part of the MANYBODY package.  It is only enabled\n  if LAMMPS was built with that package.  See the Build package doc page for more info.\n  This pair potential requires the newton setting to be\n  “on” for pair interactions.\n  The C.lcbop potential file provided with LAMMPS (see the potentials\n  directory) is parameterized for metal units.  You can use\n  the LCBOP potential with any LAMMPS units, but you would need to\n  create your own LCBOP potential file with coefficients listed in the\n  appropriate units if your simulation does not use “metal” units.\n  "
},
{
    "command": "pair_style lebedeva/z",
    "description": "The lebedeva/z style computes the Lebedeva interaction\n  potential as described in (Lebedeva et al.). An important simplification is made,\n  which is to take all normals along the z-axis.\n  \n  \\[\\begin{split}E       = & \\frac{1}{2} \\sum_i \\sum_{i \\neq j} V_{ij}\\\\\n  V_{ij}  = & B e^{-\\alpha(r_{ij} - z_0)} \\\\\n            & + C(1 + D_1\\rho^2_{ij} + D_2\\rho^4_{ij} e^{-\\lambda_1\\rho^2_{ij}} e^{-\\lambda_2 (z^2_{ij} - z^2_0)} \\\\\n            & - A \\left(\\frac{z_0}{r_ij}\\right)^6 + A \\left( \\frac{z_0}{r_c} \\right)^6 \\\\\n  \\rho^2_{ij} = & x^2_{ij} + y^2_{ij} \\qquad (\\mathbf{n_i} \\equiv \\mathbf{\\hat{z}})\\end{split}\\]\n  It is important to have a sufficiently large cutoff to ensure smooth forces.\n  Energies are shifted so that they go continuously to zero at the cutoff assuming\n  that the exponential part of \\(V_{ij}\\) (first term) decays sufficiently fast.\n  This shift is achieved by the last term in the equation for \\(V_{ij}\\) above.\n  The parameter file (e.g. CC.Lebedeva), is intended for use with metal\n  units, with energies in meV. An additional parameter, S,\n  is available to facilitate scaling of energies.\n  This potential must be used in combination with hybrid/overlay.\n  Other interactions can be set to zero using pair_style none.\n  ",
    "syntax": "pair_style [hybrid/overlay ...] lebedeva/z cutoff\n  \n  \n  ",
    "examples": "pair_style hybrid/overlay lebedeva/z 20.0\n  pair_coeff * * none\n  pair_coeff 1 2 lebedeva/z  CC.Lebedeva   C C\n  \n  pair_style hybrid/overlay rebo lebedeva/z 14.0\n  pair_coeff * * rebo        CH.rebo       C C\n  pair_coeff 1 2 lebedeva/z  CC.Lebedeva   C C\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style line/lj",
    "description": "Style line/lj treats particles which are line segments as a set of\n  small spherical particles that tile the line segment length as explained\n  below.  Interactions between two line segments, each with N1 and N2\n  spherical particles, are calculated as the pairwise sum of N1*N2\n  Lennard-Jones interactions.  Interactions between a line segment with N\n  spherical particles and a point particle are treated as the pairwise sum\n  of N Lennard-Jones interactions.  See the pair_style lj/cut doc page for the definition of Lennard-Jones interactions.\n  The set of non-overlapping spherical sub-particles that represent a\n  line segment are generated in the following manner.  Their size is a\n  function of the line segment length and the specified sub-particle\n  size for that particle type.  If a line segment has a length L and is\n  of type I, then the number of spheres N that represent the segment is\n  calculated as N = L/sizeI, rounded up to an integer value.  Thus if L\n  is not evenly divisible by sizeI, N is incremented to include one\n  extra sphere.  The centers of the spheres are spaced equally along the\n  line segment.  Imagine N+1 equally-space points, which include the 2\n  end points of the segment.  The sphere centers are halfway between\n  each pair of points.\n  The LJ interaction between 2 spheres on different line segments (or a\n  sphere on a line segment and a point particles) is computed with\n  sub-particle \\(\\epsilon\\), \\(\\sigma\\), and cutoff values that\n  are set by the pair_coeff command, as described below.  If the distance\n  between the 2 spheres is greater than the sub-particle cutoff, there is\n  no interaction.  This means that some pairs of sub-particles on 2 line\n  segments may interact, but others may not.\n  For purposes of creating the neighbor list for pairs of interacting\n  line segments or lines/point particles, a regular particle-particle\n  cutoff is used, as defined by the cutoff setting above in the\n  pair_style command or overridden with an optional argument in the\n  pair_coeff command for a type pair as discussed below.  The distance\n  between the centers of 2 line segments, or the center of a line\n  segment and a point particle, must be less than this distance (plus\n  the neighbor skin; see the neighbor command), for\n  the pair of particles to be included in the neighbor list.\n  \n  Note\n  This means that a too-short value for the cutoff setting can\n  exclude a pair of particles from the neighbor list even if pairs of\n  their sub-particle spheres would interact, based on the sub-particle\n  cutoff specified in the pair_coeff command.  E.g. sub-particles at the\n  ends of the line segments that are close to each other.  Which may not\n  be what you want, since it means the ends of 2 line segments could\n  pass through each other.  It is up to you to specify a cutoff\n  setting that is consistent with the length of the line segments you\n  are using and the sub-particle cutoff settings.\n  \n  For style line/lj, the following coefficients must be defined for\n  each pair of atom types via the pair_coeff command\n  as in the examples above, or in the data file or restart files read by\n  the read_data or read_restart\n  commands:\n  \n  sizeI (distance units)\n  sizeJ (distance units)\n  \\(\\epsilon\\) (energy units)\n  \\(\\sigma\\) (distance units)\n  subcutoff (distance units)\n  cutoff (distance units)\n  \n  The sizeI and sizeJ coefficients are the sub-particle sizes for\n  line particles of type I and type J.  They are used to define the N\n  sub-particles per segment as described above.  These coefficients are\n  actually stored on a per-type basis.  Thus if there are multiple\n  pair_coeff commands that involve type I, as either the first or\n  second atom type, you should use consistent values for sizeI or sizeJ\n  in all of them.  If you do not do this, the last value specified for\n  sizeI will apply to all segments of type I.  If typeI or typeJ refers\n  to point particles, the corresponding sizeI or sizeJ is ignored; it\n  can be set to 0.0.\n  The \\(\\epsilon\\), \\(\\sigma\\), and subcutoff coefficients are\n  used to compute an LJ interactions between a pair of sub-particles on 2\n  line segments (of type I and J), or between a sub particle/point\n  particle pair.  As discussed above, the subcutoff and cutoff params\n  are different.  The latter is only used for building the neighbor list\n  when the distance between centers of two line segments or one segment\n  and a point particle is calculated.\n  The cutoff coefficient is optional.  If not specified, the global\n  cutoff is used.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, coefficients must be specified.\n  No default mixing rules are used.\n  This pair style does not support the pair_modify\n  shift, table, and tail options.\n  This pair style does not write its information to binary restart files.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style line/lj cutoff\n  \n  \n  cutoff = global cutoff for interactions (distance units)\n  ",
    "examples": "pair_style line/lj 3.0\n  pair_coeff * * 1.0 1.0 1.0 0.8 1.12\n  pair_coeff 1 2 1.0 2.0 1.0 1.5 1.12 5.0\n  pair_coeff 1 2 1.0 0.0 1.0 1.0 2.5\n  \n  \n  ",
    "restrictions": "This style is part of the ASPHERE package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  Defining particles to be line segments so they participate in\n  line/line or line/particle interactions requires the use the\n  atom_style line command.\n  "
},
{
    "command": "pair_style list",
    "description": "Style list computes interactions between explicitly listed pairs of\n  atoms with the option to select functional form and parameters for\n  each individual pair.  Because the parameters are set in the list\n  file, the pair_coeff command has no parameters (but still needs to be\n  provided).  The check and nocheck keywords enable/disable a test\n  that checks whether all listed bonds were present and computed.\n  This pair style can be thought of as a hybrid between bonded,\n  non-bonded, and restraint interactions.  It will typically be used as\n  an additional interaction within the hybrid/overlay pair style.  It\n  currently supports three interaction styles: a 12-6 Lennard-Jones, a\n  Morse and a harmonic potential.\n  The format of the list file is as follows:\n  \n  one line per pair of atoms\n  empty lines will be ignored\n  comment text starts with a ‘#’ character\n  line syntax: ID1 ID2 style coeffs cutoff\n  ID1 = atom ID of first atom\n  ID2 = atom ID of second atom\n  style = style of interaction\n  coeffs = list of coeffs\n  cutoff = cutoff for interaction (optional)\n  \n  \n  \n  \n  The cutoff parameter is optional. If not specified, the global cutoff\n  is used.\n  Here is an example file:\n  # this is a comment\n  \n  15 259 lj126     1.0 1.0      50.0\n  15 603 morse    10.0 1.2 2.0  10.0 # and another comment\n  18 470 harmonic 50.0 1.2       5.0\n  \n  \n  The style lj126 computes pairwise interactions with the formula\n  \n  \\[E = 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6 \\right] \\qquad r < r_c\\]\n  and the coefficients:\n  \n  \\(\\epsilon\\) (energy units)\n  \\(\\sigma\\) (distance units)\n  \n  The style morse computes pairwise interactions with the formula\n  \n  \\[E = D_0 \\left[ e^{- 2 \\alpha (r - r_0)} - 2 e^{- \\alpha (r - r_0)} \\right] \\qquad r < r_c\\]\n  and the coefficients:\n  \n  \\(D_0\\) (energy units)\n  \\(\\alpha\\) (1/distance units)\n  \\(r_0\\) (distance units)\n  \n  The style harmonic computes pairwise interactions with the formula\n  \n  \\[E = K (r - r_0)^2\\]\n  and the coefficients:\n  \n  \\(K\\) (energy units)\n  \\(r_0\\) (distance units)\n  \n  Note that the usual 1/2 factor is included in \\(K\\).\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This pair style does not support mixing since all parameters are\n  explicit for each pair.\n  The pair_modify shift option is supported by this\n  pair style.\n  The pair_modify table and tail options are not\n  relevant for this pair style.\n  This pair style does not write its information to binary restart files, so pair_style and pair_coeff commands need\n  to be specified in an input script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style list listfile cutoff keyword\n  \n  \n  \n  listfile = name of file with list of pairwise interactions\n  cutoff = global cutoff (distance units)\n  keyword = optional flag nocheck or check (default is check)\n  \n  ",
    "examples": "pair_style list restraints.txt 200.0\n  pair_coeff * *\n  \n  pair_style hybrid/overlay lj/cut 1.1225 list pair_list.txt 300.0\n  pair_coeff * * lj/cut 1.0 1.0\n  pair_coeff 3* 3* list\n  \n  \n  ",
    "restrictions": "This pair style does not use a neighbor list and instead identifies\n  atoms by their IDs. This has two consequences: 1) The cutoff has to be\n  chosen sufficiently large, so that the second atom of a pair has to be\n  a ghost atom on the same node on which the first atom is local;\n  otherwise the interaction will be skipped. You can use the check\n  option to detect, if interactions are missing. 2) Unlike other pair\n  styles in LAMMPS, an atom I will not interact with multiple images of\n  atom J (assuming the images are within the cutoff distance), but only\n  with the nearest image.\n  This style is part of the USER-MISC package. It is only enabled if\n  LAMMPS is build with that package. See the Build package doc page on for more info.\n  "
},
{
    "command": "pair_style lj/cut",
    "description": "The lj/cut styles compute the standard 12/6 Lennard-Jones potential,\n  given by\n  \n  \\[E = 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -\n      \\left(\\frac{\\sigma}{r}\\right)^6 \\right]\n                      \\qquad r < r_c\\]\n  Rc is the cutoff.\n  Style lj/cut/coul/cut adds a Coulombic pairwise interaction given by\n  \n  \\[E = \\frac{C q_i q_j}{\\epsilon  r} \\qquad r < r_c\\]\n  where C is an energy-conversion constant, \\(q_i\\) and \\(q_j\\)\n  are the charges on the 2 atoms, and \\(\\epsilon\\) is the dielectric\n  constant which can be set by the dielectric command.\n  If one cutoff is specified in the pair_style command, it is used for\n  both the LJ and Coulombic terms.  If two cutoffs are specified, they are\n  used as cutoffs for the LJ and Coulombic terms respectively.\n  Style lj/cut/coul/debye adds an additional exp() damping factor\n  to the Coulombic term, given by\n  \n  \\[E = \\frac{C q_i q_j}{\\epsilon  r} \\exp(- \\kappa r) \\qquad r < r_c\\]\n  where \\(\\kappa\\) is the inverse of the Debye length.  This potential\n  is another way to mimic the screening effect of a polar solvent.\n  Style lj/cut/coul/dsf computes the Coulombic term via the damped\n  shifted force model described in Fennell, given by:\n  \n  \\[E =\n   q_iq_j \\left[ \\frac{\\mbox{erfc} (\\alpha r)}{r} -  \\frac{\\mbox{erfc} (\\alpha r_c)}{r_c} +\n  \\left( \\frac{\\mbox{erfc} (\\alpha r_c)}{r_c^2} +  \\frac{2\\alpha}{\\sqrt{\\pi}}\\frac{\\exp (-\\alpha^2    r^2_c)}{r_c} \\right)(r-r_c) \\right] \\qquad r < r_c\\]\n  where \\(\\alpha\\) is the damping parameter and erfc() is the complementary\n  error-function. This potential is essentially a short-range,\n  spherically-truncated, charge-neutralized, shifted, pairwise 1/r\n  summation.  The potential is based on Wolf summation, proposed as an\n  alternative to Ewald summation for condensed phase systems where\n  charge screening causes electrostatic interactions to become\n  effectively short-ranged. In order for the electrostatic sum to be\n  absolutely convergent, charge neutralization within the cutoff radius\n  is enforced by shifting the potential through placement of image\n  charges on the cutoff sphere. Convergence can often be improved by\n  setting \\(\\alpha\\) to a small non-zero value.\n  Styles lj/cut/coul/long and lj/cut/coul/msm compute the same\n  Coulombic interactions as style lj/cut/coul/cut except that an\n  additional damping factor is applied to the Coulombic term so it can\n  be used in conjunction with the kspace_style\n  command and its ewald or pppm option.  The Coulombic cutoff\n  specified for this style means that pairwise interactions within this\n  distance are computed directly; interactions outside that distance are\n  computed in reciprocal space.\n  Style coul/wolf adds a Coulombic pairwise interaction via the Wolf\n  summation method, described in Wolf, given by:\n  \n  \\[E_i = \\frac{1}{2} \\sum_{j \\neq i}\n  \\frac{q_i q_j {\\rm erfc}(\\alpha r_{ij})}{r_{ij}} +\n  \\frac{1}{2} \\sum_{j \\neq i}\n  \\frac{q_i q_j {\\rm erf}(\\alpha r_{ij})}{r_{ij}} \\qquad r < r_c\\]\n  where \\(\\alpha\\) is the damping parameter, and erfc() is the\n  complementary error-function terms.  This potential is essentially a\n  short-range, spherically-truncated, charge-neutralized, shifted,\n  pairwise 1/r summation.  With a manipulation of adding and subtracting\n  a self term (for i = j) to the first and second term on the\n  right-hand-side, respectively, and a small enough \\(\\alpha\\) damping\n  parameter, the second term shrinks and the potential becomes a\n  rapidly-converging real-space summation.  With a long enough cutoff and\n  small enough \\(\\alpha\\) parameter, the energy and forces calculated by the\n  Wolf summation method approach those of the Ewald sum.  So it is a means\n  of getting effective long-range interactions with a short-range\n  potential.\n  Styles lj/cut/tip4p/cut and lj/cut/tip4p/long implement the TIP4P\n  water model of (Jorgensen), which introduces a massless\n  site located a short distance away from the oxygen atom along the\n  bisector of the HOH angle.  The atomic types of the oxygen and\n  hydrogen atoms, the bond and angle types for OH and HOH interactions,\n  and the distance to the massless charge site are specified as\n  pair_style arguments.  Style lj/cut/tip4p/cut uses a cutoff for\n  Coulomb interactions; style lj/cut/tip4p/long is for use with a\n  long-range Coulombic solver (Ewald or PPPM).\n  \n  Note\n  For each TIP4P water molecule in your system, the atom IDs for\n  the O and 2 H atoms must be consecutive, with the O atom first.  This\n  is to enable LAMMPS to “find” the 2 H atoms associated with each O\n  atom.  For example, if the atom ID of an O atom in a TIP4P water\n  molecule is 500, then its 2 H atoms must have IDs 501 and 502.\n  \n  See the Howto tip4p doc page for more information\n  on how to use the TIP4P pair styles and lists of parameters to set.\n  Note that the neighbor list cutoff for Coulomb interactions is\n  effectively extended by a distance 2*qdist when using the TIP4P pair\n  style, to account for the offset distance of the fictitious charges on\n  O atoms in water molecules.  Thus it is typically best in an\n  efficiency sense to use a LJ cutoff >= Coulombic cutoff + 2*qdist, to\n  shrink the size of the neighbor list.  This leads to slightly larger\n  cost for the long-range calculation, so you can test the trade-off for\n  your model.\n  For all of the lj/cut pair styles, the following coefficients must\n  be defined for each pair of atoms types via the\n  pair_coeff command as in the examples above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands, or by mixing as\n  described below:\n  \n  \\(\\epsilon\\) (energy units)\n  \\(\\sigma\\) (distance units)\n  cutoff1 (distance units)\n  cutoff2 (distance units)\n  \n  Note that \\(\\sigma\\) is defined in the LJ formula as the zero-crossing\n  distance for the potential, not as the energy minimum at \\(2^{\\frac{1}{6}} \\sigma\\).\n  The latter 2 coefficients are optional.  If not specified, the global\n  LJ and Coulombic cutoffs specified in the pair_style command are used.\n  If only one cutoff is specified, it is used as the cutoff for both LJ\n  and Coulombic interactions for this type pair.  If both coefficients\n  are specified, they are used as the LJ and Coulombic cutoffs for this\n  type pair.  You cannot specify 2 cutoffs for style lj/cut, since it\n  has no Coulombic terms.\n  For lj/cut/coul/long and lj/cut/coul/msm and lj/cut/tip4p/cut\n  and lj/cut/tip4p/long only the LJ cutoff can be specified since a\n  Coulombic cutoff cannot be specified for an individual I,J type pair.\n  All type pairs use the same global Coulombic cutoff specified in the\n  pair_style command.\n  \n  A version of these styles with a soft core, lj/cut/soft, suitable\n  for use in free energy calculations, is part of the USER-FEP package and\n  is documented with the pair_style */soft\n  styles. The version with soft core is only available if LAMMPS was built\n  with that package. See the Build package doc page\n  for more info.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the epsilon and sigma coefficients\n  and cutoff distance for all of the lj/cut pair styles can be mixed.\n  The default mix value is geometric.  See the “pair_modify” command\n  for details.\n  All of the lj/cut pair styles support the\n  pair_modify shift option for the energy of the\n  Lennard-Jones portion of the pair interaction.\n  The lj/cut/coul/long and lj/cut/tip4p/long pair styles support the\n  pair_modify table option since they can tabulate\n  the short-range portion of the long-range Coulombic interaction.\n  All of the lj/cut pair styles support the\n  pair_modify tail option for adding a long-range\n  tail correction to the energy and pressure for the Lennard-Jones\n  portion of the pair interaction.\n  All of the lj/cut pair styles write their information to binary restart files, so pair_style and pair_coeff commands do\n  not need to be specified in an input script that reads a restart file.\n  The lj/cut and lj/cut/coul/long pair styles support the use of the\n  inner, middle, and outer keywords of the run_style respa command, meaning the pairwise forces can be\n  partitioned by distance at different levels of the rRESPA hierarchy.\n  The other styles only support the pair keyword of run_style respa.\n  See the run_style command for details.\n  ",
    "syntax": "pair_style style args\n  \n  \n  \n  style = lj/cut or lj/cut/coul/cut or lj/cut/coul/debye or lj/cut/coul/dsf or lj/cut/coul/long lj/cut/coul/msm or lj/cut/tip4p/long\n  args = list of arguments for a particular style\n  \n  lj/cut args = cutoff\n    cutoff = global cutoff for Lennard Jones interactions (distance units)\n  lj/cut/coul/cut args = cutoff (cutoff2)\n    cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  lj/cut/coul/debye args = kappa cutoff (cutoff2)\n    kappa = inverse of the Debye length (inverse distance units)\n    cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  lj/cut/coul/dsf args = alpha cutoff (cutoff2)\n    alpha = damping parameter (inverse distance units)\n    cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (distance units)\n  lj/cut/coul/long args = cutoff (cutoff2)\n    cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  lj/cut/coul/msm args = cutoff (cutoff2)\n    cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  lj/cut/coul/wolf args = alpha cutoff (cutoff2)\n    alpha = damping parameter (inverse distance units)\n    cutoff = global cutoff for LJ (and Coulombic if only 2 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  lj/cut/tip4p/cut args = otype htype btype atype qdist cutoff (cutoff2)\n    otype,htype = atom types for TIP4P O and H\n    btype,atype = bond and angle types for TIP4P waters\n    qdist = distance from O atom to massless charge (distance units)\n    cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  lj/cut/tip4p/long args = otype htype btype atype qdist cutoff (cutoff2)\n    otype,htype = atom types for TIP4P O and H\n    btype,atype = bond and angle types for TIP4P waters\n    qdist = distance from O atom to massless charge (distance units)\n    cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  ",
    "examples": "pair_style lj/cut 2.5\n  pair_coeff * * 1 1\n  pair_coeff 1 1 1 1.1 2.8\n  \n  pair_style lj/cut/coul/cut 10.0\n  pair_style lj/cut/coul/cut 10.0 8.0\n  pair_coeff * * 100.0 3.0\n  pair_coeff 1 1 100.0 3.5 9.0\n  pair_coeff 1 1 100.0 3.5 9.0 9.0\n  \n  pair_style lj/cut/coul/debye 1.5 3.0\n  pair_style lj/cut/coul/debye 1.5 2.5 5.0\n  pair_coeff * * 1.0 1.0\n  pair_coeff 1 1 1.0 1.5 2.5\n  pair_coeff 1 1 1.0 1.5 2.5 5.0\n  \n  pair_style lj/cut/coul/dsf 0.05 2.5 10.0\n  pair_coeff * * 1.0 1.0\n  pair_coeff 1 1 1.0 1.0 2.5\n  \n  pair_style lj/cut/coul/long 10.0\n  pair_style lj/cut/coul/long 10.0 8.0\n  pair_coeff * * 100.0 3.0\n  pair_coeff 1 1 100.0 3.5 9.0\n  \n  pair_style lj/cut/coul/msm 10.0\n  pair_style lj/cut/coul/msm 10.0 8.0\n  pair_coeff * * 100.0 3.0\n  pair_coeff 1 1 100.0 3.5 9.0\n  \n  pair_style lj/cut/tip4p/cut 1 2 7 8 0.15 12.0\n  pair_style lj/cut/tip4p/cut 1 2 7 8 0.15 12.0 10.0\n  pair_coeff * * 100.0 3.0\n  pair_coeff 1 1 100.0 3.5 9.0\n  \n  pair_style lj/cut/coul/wolf 0.2 5. 10.0\n  pair_coeff * * 1.0 1.0\n  pair_coeff 1 1 1.0 1.0 2.5\n  \n  pair_style lj/cut/tip4p/long 1 2 7 8 0.15 12.0\n  pair_style lj/cut/tip4p/long 1 2 7 8 0.15 12.0 10.0\n  pair_coeff * * 100.0 3.0\n  pair_coeff 1 1 100.0 3.5 9.0\n  \n  \n  ",
    "restrictions": "The lj/cut/coul/long and lj/cut/tip4p/long styles are part of the\n  KSPACE package. The lj/cut/tip4p/cut style is part of the MOLECULE\n  package. These styles are only enabled if LAMMPS was built with those\n  packages.  See the Build package doc page for\n  more info.\n  "
},
{
    "command": "pair_style lj96/cut",
    "description": "The lj96/cut style compute a 9/6 Lennard-Jones potential, instead\n  of the standard 12/6 potential, given by\n  \n  \\[E = 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{9} -\n  \\left(\\frac{\\sigma}{r}\\right)^6 \\right]\n                      \\qquad r < r_c\\]\n  \\(r_c\\) is the cutoff.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands, or by mixing as described below:\n  \n  \\(\\epsilon\\) (energy units)\n  \\(\\sigma\\) (distance units)\n  cutoff (distance units)\n  \n  The last coefficient is optional.  If not specified, the global LJ\n  cutoff specified in the pair_style command is used.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the epsilon and sigma coefficients\n  and cutoff distance for all of the lj/cut pair styles can be mixed.\n  The default mix value is geometric.  See the “pair_modify” command\n  for details.\n  This pair style supports the pair_modify shift\n  option for the energy of the pair interaction.\n  The pair_modify table option is not relevant\n  for this pair style.\n  This pair style supports the pair_modify tail\n  option for adding a long-range tail correction to the energy and\n  pressure of the pair interaction.\n  This pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  This pair style supports the use of the inner, middle, and outer\n  keywords of the run_style respa command, meaning the\n  pairwise forces can be partitioned by distance at different levels of\n  the rRESPA hierarchy.  See the run_style command for\n  details.\n  ",
    "syntax": "pair_style lj96/cut cutoff\n  \n  \n  \n  cutoff = global cutoff for lj96/cut interactions (distance units)\n  \n  ",
    "examples": "pair_style lj96/cut 2.5\n  pair_coeff * * 1.0 1.0 4.0\n  pair_coeff 1 1 1.0 1.0\n  \n  \n  ",
    "restrictions": "none\n  "
},
{
    "command": "pair_style lj/cubic",
    "description": "The lj/cubic style computes a truncated LJ interaction potential\n  whose energy and force are continuous everywhere.  Inside the\n  inflection point the interaction is identical to the standard 12/6\n  Lennard-Jones potential.  The LJ function outside the\n  inflection point is replaced with a cubic function of distance. The\n  energy, force, and second derivative are continuous at the inflection\n  point.  The cubic coefficient A3 is chosen so that both energy and\n  force go to zero at the cutoff distance.  Outside the cutoff distance\n  the energy and force are zero.\n  \n  \\[\\begin{split}E & = u_{LJ}(r) \\qquad r \\leq r_s \\\\\n    & = u_{LJ}(r_s) + (r-r_s) u'_{LJ}(r_s) - \\frac{1}{6} A_3 (r-r_s)^3 \\qquad r_s < r \\leq r_c \\\\\n    & = 0 \\qquad r > r_c\\end{split}\\]\n  The location of the inflection point \\(r_s\\) is defined\n  by the LJ diameter, \\(r_s/\\sigma = (26/7)^{1/6}\\). The cutoff distance\n  is defined by \\(r_c/r_s = 67/48\\) or \\(r_c/\\sigma = 1.737...\\)\n  The analytic expression for the\n  the cubic coefficient\n  \\(A_3 r_{min}^3/\\epsilon = 27.93...\\) is given in the paper by\n  Holian and Ravelo (Holian).\n  This potential is commonly used to study the shock mechanics of FCC\n  solids, as in Ravelo et al. (Ravelo).\n  The following coefficients must be defined for each pair of atom types\n  via the pair_coeff command as in the example above,\n  or in the data file or restart files read by the\n  read_data or read_restart\n  commands, or by mixing as described below:\n  \n  \\(\\epsilon\\) (energy units)\n  \\(\\sigma\\) (distance units)\n  \n  Note that \\(\\sigma\\) is defined in the LJ formula as the\n  zero-crossing distance for the potential, not as the energy minimum,\n  which is located at \\(r_{min} = 2^{\\frac{1}{6}} \\sigma\\). In the\n  above example, \\(\\sigma = 0.8908987\\), so \\(r_{min} = 1.0\\).\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the epsilon and sigma coefficients\n  and cutoff distance for all of the lj/cut pair styles can be mixed.\n  The default mix value is geometric.  See the “pair_modify” command\n  for details.\n  The lj/cubic pair style does not support the\n  pair_modify shift option,\n  since pair interaction is already smoothed to 0.0 at the\n  cutoff.\n  The pair_modify table option is not relevant\n  for this pair style.\n  The lj/cubic pair style does not support the\n  pair_modify tail option for adding long-range tail\n  corrections to energy and pressure, since there are no corrections for\n  a potential that goes to 0.0 at the cutoff.\n  The lj/cubic pair style writes its information to binary restart files, so pair_style and pair_coeff commands do\n  not need to be specified in an input script that reads a restart file.\n  The lj/cubic pair style can only be used via the pair\n  keyword of the run_style respa command.  It does not\n  support the inner, middle, outer keywords.\n  ",
    "syntax": "pair_style lj/cubic\n  \n  \n  ",
    "examples": "pair_style lj/cubic\n  pair_coeff * * 1.0 0.8908987\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "pair_style lj/expand",
    "description": "Style lj/expand computes a LJ interaction with a distance shifted by\n  delta which can be useful when particles are of different sizes, since\n  it is different that using different sigma values in a standard LJ\n  formula:\n  \n  \\[E = 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r - \\Delta}\\right)^{12} -\n    \\left(\\frac{\\sigma}{r - \\Delta}\\right)^6 \\right]\n    \\qquad r < r_c + \\Delta\\]\n  \\(r_c\\) is the cutoff which does not include the \\(\\Delta\\)\n  distance.  I.e. the actual force cutoff is the sum of \\(r_c +\n  \\Delta\\).\n  For all of the lj/expand pair styles, the following coefficients must\n  be defined for each pair of atoms types via the pair_coeff command as in the examples above, or in the data file or\n  restart files read by the read_data or\n  read_restart commands, or by mixing as described\n  below:\n  \n  \\(\\epsilon\\) (energy units)\n  \\(\\sigma\\) (distance units)\n  \\(\\Delta\\) (distance units)\n  cutoff (distance units)\n  \n  The \\(\\Delta\\) values can be positive or negative.  The last\n  coefficient is optional.  If not specified, the global LJ cutoff is\n  used.\n  For lj/expand/coul/long only the LJ cutoff can be specified since a\n  Coulombic cutoff cannot be specified for an individual I,J type pair.\n  All type pairs use the same global Coulombic cutoff specified in the\n  pair_style command.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the epsilon, sigma, and shift\n  coefficients and cutoff distance for this pair style can be mixed.\n  Shift is always mixed via an arithmetic rule.  The other\n  coefficients are mixed according to the pair_modify mix value.  The\n  default mix value is geometric.  See the “pair_modify” command for\n  details.\n  This pair style supports the pair_modify shift\n  option for the energy of the pair interaction.\n  The pair_modify table option is not relevant\n  for this pair style.\n  This pair style supports the pair_modify tail\n  option for adding a long-range tail correction to the energy and\n  pressure of the pair interaction.\n  This pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style lj/expand cutoff\n  \n  \n  \n  cutoff = global cutoff for lj/expand interactions (distance units)\n  \n  ",
    "examples": "pair_style lj/expand 2.5\n  pair_coeff * * 1.0 1.0 0.5\n  pair_coeff 1 1 1.0 1.0 -0.2 2.0\n  \n  pair_style lj/expand/coul/long 2.5\n  pair_style lj/expand/coul/long 2.5 4.0\n  pair_coeff * * 1.0 1.0 0.5\n  pair_coeff 1 1 1.0 1.0 -0.2 3.0\n  \n  \n  ",
    "restrictions": "none\n  "
},
{
    "command": "pair_style lj/long/coul/long",
    "description": "Style lj/long/coul/long computes the standard 12/6 Lennard-Jones potential:\n  \n  \\[\\begin{split}E = 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -\n                      \\left(\\frac{\\sigma}{r}\\right)^6 \\right]\n                      \\qquad r < r_c \\\\\\end{split}\\]\n  with \\(\\epsilon\\) and \\(\\sigma\\) being the usual Lennard-Jones\n  potential parameters, plus the Coulomb potential, given by:\n  \n  \\[E = \\frac{C q_i q_j}{\\epsilon  r} \\qquad r < r_c\\]\n  where C is an energy-conversion constant, \\(q_i\\) and \\(q_j\\) are the charges on\n  the 2 atoms, \\(\\epsilon\\) is the dielectric constant which can be set by\n  the dielectric command, and \\(r_c\\) is the cutoff.  If\n  one cutoff is specified in the pair_style command, it is used for both\n  the LJ and Coulombic terms.  If two cutoffs are specified, they are\n  used as cutoffs for the LJ and Coulombic terms respectively.\n  The purpose of this pair style is to capture long-range interactions\n  resulting from both attractive 1/r^6 Lennard-Jones and Coulombic 1/r\n  interactions.  This is done by use of the flag_lj and flag_coul\n  settings.  The In ‘t Veld paper has more details on when it is\n  appropriate to include long-range 1/r^6 interactions, using this\n  potential.\n  Style lj/long/tip4p/long implements the TIP4P water model of\n  (Jorgensen), which introduces a massless site located a\n  short distance away from the oxygen atom along the bisector of the HOH\n  angle.  The atomic types of the oxygen and hydrogen atoms, the bond\n  and angle types for OH and HOH interactions, and the distance to the\n  massless charge site are specified as pair_style arguments.\n  \n  Note\n  For each TIP4P water molecule in your system, the atom IDs for\n  the O and 2 H atoms must be consecutive, with the O atom first.  This\n  is to enable LAMMPS to “find” the 2 H atoms associated with each O\n  atom.  For example, if the atom ID of an O atom in a TIP4P water\n  molecule is 500, then its 2 H atoms must have IDs 501 and 502.\n  \n  See the Howto tip4p doc page for more\n  information on how to use the TIP4P pair style.  Note that the\n  neighbor list cutoff for Coulomb interactions is effectively extended\n  by a distance 2*qdist when using the TIP4P pair style, to account for\n  the offset distance of the fictitious charges on O atoms in water\n  molecules.  Thus it is typically best in an efficiency sense to use a\n  LJ cutoff >= Coulombic cutoff + 2*qdist, to shrink the size of the\n  neighbor list.  This leads to slightly larger cost for the long-range\n  calculation, so you can test the trade-off for your model.\n  If flag_lj is set to long, no cutoff is used on the LJ 1/r^6\n  dispersion term.  The long-range portion can be calculated by using\n  the kspace_style ewald/disp or pppm/disp commands.\n  The specified LJ cutoff then determines which portion of the LJ\n  interactions are computed directly by the pair potential versus which\n  part is computed in reciprocal space via the Kspace style.  If\n  flag_lj is set to cut, the LJ interactions are simply cutoff, as\n  with pair_style lj/cut.\n  If flag_coul is set to long, no cutoff is used on the Coulombic\n  interactions.  The long-range portion can calculated by using any of\n  several kspace_style command options such as\n  pppm or ewald.  Note that if flag_lj is also set to long, then\n  the ewald/disp or pppm/disp Kspace style needs to be used to\n  perform the long-range calculations for both the LJ and Coulombic\n  interactions.  If flag_coul is set to off, Coulombic interactions\n  are not computed.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands, or by mixing as described below:\n  \n  \\(\\epsilon\\) (energy units)\n  \\(\\sigma\\) (distance units)\n  cutoff1 (distance units)\n  cutoff2 (distance units)\n  \n  Note that sigma is defined in the LJ formula as the zero-crossing\n  distance for the potential, not as the energy minimum at 2^(1/6)\n  sigma.\n  The latter 2 coefficients are optional.  If not specified, the global\n  LJ and Coulombic cutoffs specified in the pair_style command are used.\n  If only one cutoff is specified, it is used as the cutoff for both LJ\n  and Coulombic interactions for this type pair.  If both coefficients\n  are specified, they are used as the LJ and Coulombic cutoffs for this\n  type pair.\n  Note that if you are using flag_lj set to long, you\n  cannot specify a LJ cutoff for an atom type pair, since only one\n  global LJ cutoff is allowed.  Similarly, if you are using flag_coul\n  set to long, you cannot specify a Coulombic cutoff for an atom type\n  pair, since only one global Coulombic cutoff is allowed.\n  For lj/long/tip4p/long only the LJ cutoff can be specified\n  since a Coulombic cutoff cannot be specified for an individual I,J\n  type pair.  All type pairs use the same global Coulombic cutoff\n  specified in the pair_style command.\n  \n  A version of these styles with a soft core, lj/cut/soft, suitable for use in\n  free energy calculations, is part of the USER-FEP package and is documented with\n  the pair_style */soft styles. The version with soft core is\n  only available if LAMMPS was built with that package. See the Build package doc page for more info.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the epsilon and sigma coefficients\n  and cutoff distance for all of the lj/long pair styles can be mixed.\n  The default mix value is geometric.  See the “pair_modify” command\n  for details.\n  These pair styles support the pair_modify shift\n  option for the energy of the Lennard-Jones portion of the pair\n  interaction, assuming flag_lj is cut.\n  These pair styles support the pair_modify table and\n  table/disp options since they can tabulate the short-range portion of\n  the long-range Coulombic and dispersion interactions.\n  Thes pair styles do not support the pair_modify\n  tail option for adding a long-range tail correction to the\n  Lennard-Jones portion of the energy and pressure.\n  These pair styles write their information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  The pair lj/long/coul/long styles support the use of the inner,\n  middle, and outer keywords of the run_style respa\n  command, meaning the pairwise forces can be partitioned by distance at\n  different levels of the rRESPA hierarchy.  See the\n  run_style command for details.\n  ",
    "syntax": "pair_style style args\n  \n  \n  \n  style = lj/long/coul/long or lj/long/tip4p/long\n  args = list of arguments for a particular style\n  \n  lj/long/coul/long args = flag_lj flag_coul cutoff (cutoff2)\n    flag_lj = long or cut or off\n      long = use Kspace long-range summation for dispersion 1/r^6 term\n      cut = use a cutoff on dispersion 1/r^6 term\n      off = omit disperion 1/r^6 term entirely\n    flag_coul = long or off\n      long = use Kspace long-range summation for Coulombic 1/r term\n      off = omit Coulombic term\n    cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  lj/long/tip4p/long args = flag_lj flag_coul otype htype btype atype qdist cutoff (cutoff2)\n    flag_lj = long or cut\n      long = use Kspace long-range summation for dispersion 1/r^6 term\n      cut = use a cutoff\n    flag_coul = long or off\n      long = use Kspace long-range summation for Coulombic 1/r term\n      off = omit Coulombic term\n    otype,htype = atom types for TIP4P O and H\n    btype,atype = bond and angle types for TIP4P waters\n    qdist = distance from O atom to massless charge (distance units)\n    cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  ",
    "examples": "pair_style lj/long/coul/long cut off 2.5\n  pair_style lj/long/coul/long cut long 2.5 4.0\n  pair_style lj/long/coul/long long long 2.5 4.0\n  pair_coeff * * 1 1\n  pair_coeff 1 1 1 3 4\n  \n  pair_style lj/long/tip4p/long long long 1 2 7 8 0.15 12.0\n  pair_style lj/long/tip4p/long long long 1 2 7 8 0.15 12.0 10.0\n  pair_coeff * * 100.0 3.0\n  pair_coeff 1 1 100.0 3.5 9.0\n  \n  \n  ",
    "restrictions": "These styles are part of the KSPACE package.  They are only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style lj/smooth",
    "description": "Style lj/smooth computes a LJ interaction with a force smoothing\n  applied between the inner and outer cutoff.\n  \n  \\[\\begin{split}E & =  4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -\n                        \\left(\\frac{\\sigma}{r}\\right)^6 \\right]\n                        \\qquad r < r_{in} \\\\\n  F & =  C_1 + C_2 (r - r_{in}) + C_3 (r - r_{in})^2 + C_4 (r - r_{in})^3\n                      \\qquad r_{in} < r < r_c\\end{split}\\]\n  The polynomial coefficients C1, C2, C3, C4 are computed by LAMMPS to\n  cause the force to vary smoothly from the inner cutoff \\(r_{in}\\) to the\n  outer cutoff \\(r_c\\).\n  At the inner cutoff the force and its 1st derivative\n  will match the non-smoothed LJ formula.  At the outer cutoff the force\n  and its 1st derivative will be 0.0.  The inner cutoff cannot be 0.0.\n  \n  Note\n  this force smoothing causes the energy to be discontinuous both\n  in its values and 1st derivative.  This can lead to poor energy\n  conservation and may require the use of a thermostat.  Plot the energy\n  and force resulting from this formula via the\n  pair_write command to see the effect.\n  \n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands, or by mixing as described below:\n  \n  \\(\\epsilon\\) (energy units)\n  \\(\\sigma\\) (distance units)\n  \\(r_{in}\\) (distance units)\n  \\(r_c\\) (distance units)\n  \n  The last 2 coefficients are optional inner and outer cutoffs.  If not\n  specified, the global values for \\(r_{in}\\) and \\(r_c\\) are used.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the epsilon, sigma, Rin\n  coefficients and the cutoff distance for this pair style can be mixed.\n  Rin is a cutoff value and is mixed like the cutoff.  The other\n  coefficients are mixed according to the pair_modify mix option.  The\n  default mix value is geometric.  See the “pair_modify” command for\n  details.\n  This pair style supports the pair_modify shift\n  option for the energy of the pair interaction.\n  The pair_modify table option is not relevant\n  for this pair style.\n  This pair style does not support the pair_modify\n  tail option for adding long-range tail corrections to energy and\n  pressure, since the energy of the pair interaction is smoothed to 0.0\n  at the cutoff.\n  This pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style lj/smooth Rin Rc\n  \n  \n  \n  Rin = inner cutoff beyond which force smoothing will be applied (distance units)\n  Rc = outer cutoff for lj/smooth interactions (distance units)\n  \n  ",
    "examples": "pair_style lj/smooth 8.0 10.0\n  pair_coeff * * 10.0 1.5\n  pair_coeff 1 1 20.0 1.3 7.0 9.0\n  \n  \n  ",
    "restrictions": "none\n  "
},
{
    "command": "pair_style lj/smooth/linear",
    "description": "Style lj/smooth/linear computes a truncated and force-shifted LJ\n  interaction (aka Shifted Force Lennard-Jones) that combines the\n  standard 12/6 Lennard-Jones function and subtracts a linear term based\n  on the cutoff distance, so that both, the potential and the force, go\n  continuously to zero at the cutoff Rc (Toxvaerd):\n  \n  \\[\\begin{split}\\phi\\left(r\\right) & =  4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -\n                      \\left(\\frac{\\sigma}{r}\\right)^6 \\right] \\\\\n  E\\left(r\\right) & =  \\phi\\left(r\\right)  - \\phi\\left(R_c\\right) - \\left(r - R_c\\right) \\left.\\frac{d\\phi}{d r} \\right|_{r=R_c}       \\qquad r < R_c\\end{split}\\]\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands, or by mixing as described below:\n  \n  \\(\\epsilon\\) (energy units)\n  \\(\\sigma\\) (distance units)\n  cutoff (distance units)\n  \n  The last coefficient is optional. If not specified, the global\n  LJ cutoff specified in the pair_style command is used.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the epsilon and sigma coefficients\n  and cutoff distance can be mixed. The default mix value is geometric.\n  See the “pair_modify” command for details.\n  This pair style does not support the pair_modify\n  shift option for the energy of the pair interaction, since it goes\n  to 0.0 at the cutoff by construction.\n  The pair_modify table option is not relevant\n  for this pair style.\n  This pair style does not support the pair_modify\n  tail option for adding long-range tail corrections to energy and\n  pressure, since the energy of the pair interaction is smoothed to 0.0\n  at the cutoff.\n  This pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style lj/smooth/linear cutoff\n  \n  \n  \n  cutoff = global cutoff for Lennard-Jones interactions (distance units)\n  \n  ",
    "examples": "pair_style lj/smooth/linear 2.5\n  pair_coeff * * 1.0 1.0\n  pair_coeff 1 1 0.3 3.0 9.0\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "pair_style lj/switch3/coulgauss/long",
    "description": "The lj/switch3/coulgauss style evaluates the LJ\n  vdW potential\n  \n  \\[E = 4\\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12}-\\left(\\frac{\\sigma}{r}\\right)^{6} \\right]\\]\n  , which goes smoothly to zero at the cutoff r_c as defined\n  by the switching function\n  \n  \\[\\begin{split}S_3(r) = \\left\\lbrace \\begin{array}{ll}\n                      1 & \\quad\\mathrm{if}\\quad r < r_\\mathrm{c} - w \\\\\n                      3x^2 - 2x^3 & \\quad\\mathrm{if}\\quad r < r_\\mathrm{c} \\quad\\mathrm{with\\quad} x=\\frac{r_\\mathrm{c} - r}{w} \\\\\n                      0 & \\quad\\mathrm{if}\\quad r >= r_\\mathrm{c}\n                  \\end{array} \\right.\\end{split}\\]\n  where w is the width defined in the arguments. This potential\n  is combined with Coulomb interaction between Gaussian charge densities:\n  \n  \\[E = \\frac{q_i q_j \\mathrm{erf}\\left( r/\\sqrt{\\gamma_1^2+\\gamma_2^2} \\right) }{\\epsilon r_{ij}}\\]\n  where \\(q_i\\) and \\(q_j\\) are the charges on the 2 atoms,\n  \\(\\epsilon\\) is the dielectric constant which can be set by the\n  dielectric command, \\(\\gamma_i\\) and\n  \\(\\gamma_j\\) are the widths of the Gaussian charge distribution and\n  erf() is the error-function.  This style has to be used in conjunction\n  with the kspace_style command\n  If one cutoff is specified it is used for both the vdW and Coulomb\n  terms.  If two cutoffs are specified, the first is used as the cutoff\n  for the vdW terms, and the second is the cutoff for the Coulombic term.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands:\n  \n  \\(\\epsilon\\) (energy)\n  \\(\\sigma\\) (distance)\n  \\(\\gamma\\) (distance)\n  \n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  Shifting the potential energy is not necessary because the switching\n  function ensures that the potential is zero at the cut-off.\n  ",
    "syntax": "pair_style style args\n  \n  \n  \n  style = lj/switch3/coulgauss/long\n  args = list of arguments for a particular style\n  \n  lj/switch3/coulgauss/long args = cutoff (cutoff2) width\n    cutoff  = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n    width  = width parameter of the smoothing function (distance units)\n  ",
    "examples": "pair_style lj/switch3/coulgauss/long    12.0 3.0\n  pair_coeff 1  0.2 2.5 1.2\n  \n  pair_style lj/switch3/coulgauss/long   12.0 10.0 3.0\n  pair_coeff 1  0.2 2.5 1.2\n  \n  \n  ",
    "restrictions": "These styles are part of the USER-YAFF package.  They are only\n  enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style local/density",
    "description": "The local density (LD) potential is a mean-field manybody potential, and, in some\n  sense,a generalization of embedded atom models (EAM). The name “local density\n  potential” arises from the fact that it assigns an energy to an atom depending\n  on the number of neighboring atoms of given type around it within a predefined\n  spherical volume (i.e., within a cutoff). The bottom-up coarse-graining (CG)\n  literature suggests that such potentials can be widely useful  in capturing\n  effective multibody forces in a computationally efficient manner so as to\n  improve the quality of CG models of implicit solvation:ref:(Sanyal1) <Sanyal1> and\n  phase-segregation in liquid mixtures:ref:(Sanyal2) <Sanyal2>, and provide guidelines\n  to determine the extent of manybody correlations present in a CG\n  model.:ref:(Rosenberger) <Rosenberger> The LD potential in LAMMPS is primarily\n  intended to be used as a corrective potential over traditional pair potentials\n  in bottom-up CG models, i.e., as a hybrid pair style with\n  other explicit pair interaction terms (e.g., table spline, Lennard Jones, etc.).\n  Because the LD potential is not a pair potential per se,  it is implemented\n  simply as a single auxiliary file with all specifications that will be read\n  upon initialization.\n  \n  Note\n  Thus when used as the only interaction in the system, there is no\n  corresponding pair_coeff command and when used with other pair styles using the\n  hybrid/overlay option, the corresponding pair_coeff command must be supplied\n  *  * as placeholders for the atom types.\n  \n  \n  System with a single CG atom type:\n  A system of a single atom type (e.g., LJ argon) with a single local density (LD)\n  potential would have an energy given by:\n  \n  \\[U_{LD} = \\sum_i F(\\rho_i)\\]\n  where \\(\\rho_i\\) is the LD at atom i and \\(F(\\rho)\\) is\n  similar in spirit to the embedding function used in EAM potentials. The\n  LD at atom i is given by the sum\n  \n  \\[\\rho_i = \\sum_{j \\neq i} \\varphi(r_{ij})\\]\n  where \\(\\varphi\\) is an indicator function that is one at r=0 and\n  zero beyond a cutoff distance R2. The choice of the functional form of\n  \\(\\varphi\\) is somewhat arbitrary, but the following piecewise cubic\n  function has proven sufficiently general: (Sanyal1),\n  (Sanyal2) (Rosenberger)\n  \n  \\[\\begin{split}\\varphi(r) =\n  \\begin{cases}\n  1 & r \\le R_1 \\\\\n  c_0 + c_2r^2 + c_4r^4 + c_6r^6  & r \\in (R_1, R_2) \\\\\n  0 & r \\ge R_2\n  \\end{cases}\\end{split}\\]\n  The constants c are chosen so that the indicator function smoothly\n  interpolates between 1 and 0 between the distances R1 and R2, which are\n  called the inner and outer cutoffs, respectively. Thus phi satisfies\n  phi(R1) = 1, phi(R2) = dphi/dr @ (r=R1) =  dphi/dr @ (r=R2) = 0. The embedding\n  function F(rho) may or may not have a closed-form expression. To maintain\n  generality, it is practically represented with a spline-interpolated table\n  over a predetermined range of rho. Outside of that range it simply adopts zero\n  values at the endpoints.\n  It can be shown that the total force between two atoms due to the LD potential\n  takes the form of a pair force, which motivates its designation as a LAMMPS\n  pair style. Please see (Sanyal1) for details of the derivation.\n  \n  Systems with arbitrary numbers of atom types:\n  The potential is easily generalized to systems involving multiple atom types:\n  \n  \\[U_{LD} = \\sum_i a_\\alpha F(\\rho_i)\\]\n  with the LD expressed as\n  \n  \\[\\rho_i = \\sum_{j \\neq i} b_\\beta \\varphi(r_{ij})\\]\n  where \\(\\alpha\\) gives the type of atom i, \\(\\beta\\) the\n  type of atom j, and the coefficients a and b filter for atom\n  types as specified by the user. a is called the central atom filter as\n  it determines to which atoms the potential applies; \\(a_{\\alpha} =\n  1\\) if the LD potential applies to atom type \\(\\alpha\\) else zero. On the\n  other hand, b is called the neighbor atom filter because it specifies\n  which atom types to use in the calculation of the LD; \\(b_{\\beta} =\n  1\\) if atom type \\(\\beta\\) contributes to the LD and zero otherwise.\n  \n  Note\n  Note that the potentials need not be symmetric with respect to atom\n  types, which is the reason for two distinct sets of coefficients a\n  and b. An atom type may contribute to the LD but not the\n  potential, or to the potential but not the LD. Such decisions are\n  made by the user and should (ideally) be motivated on physical\n  grounds for the problem at hand.\n  \n  \n  General form for implementation in LAMMPS:\n  Of course, a system with many atom types may have many different possible LD\n  potentials, each with their own atom type filters, cutoffs, and embedding\n  functions. The most general form of this potential as implemented in the\n  pair_style local/density is:\n  \n  \\[U_{LD} = \\sum_k U_{LD}^{(k)} = \\sum_i \\left[ \\sum_k a_\\alpha^{(k)} F^{(k)} \\left(\\rho_i^{(k)}\\right) \\right]\\]\n  where, k is an index that spans the (arbitrary) number of applied LD\n  potentials N_LD. Each LD is calculated as before with:\n  \n  \\[\\rho_i^{(k)} = \\sum_j b_\\beta^{(k)} \\varphi^{(k)} (r_{ij})\\]\n  The superscript on the indicator function phi simply indicates that it is\n  associated with specific values of the cutoff distances R1(k) and R2(k). In\n  summary, there may be N_LD distinct LD potentials. With each potential type (k),\n  one must specify:\n  \n  the inner and outer cutoffs as R1 and R2\n  the central type filter a(k), where k = 1,2,…N_LD\n  the neighbor type filter b(k), where k = 1,2,…N_LD\n  the LD potential function F(k)(rho), typically as a table that is later spline-interpolated\n  \n  \n  Tabulated input file format:\n  Line 1:             comment or blank (ignored)\n  Line 2:             comment or blank (ignored)\n  Line 3:             N_LD N_rho (# of LD potentials and # of tabulated values, single space separated)\n  Line 4:             blank (ignored)\n  Line 5:             R1(k) R2(k) (lower and upper cutoffs, single space separated)\n  Line 6:             central-types (central atom types, single space separated)\n  Line 7:             neighbor-types (neighbor atom types single space separated)\n  Line 8:             rho_min rho_max drho (min, max and diff. in tabulated rho values, single space separated)\n  Line 9:             F(k)(rho_min + 0.drho)\n  Line 10:            F(k)(rho_min + 1.drho)\n  Line 11:            F(k)(rho_min + 2.drho)\n  ...\n  Line 9+N_rho:       F(k)(rho_min + N_rho . drho)\n  Line 10+N_rho:      blank (ignored)\n  \n  Block 2\n  \n  Block 3\n  \n  Block N_LD\n  \n  \n  Lines 5 to 9+N_rho constitute the first block. Thus the input file is separated\n  (by blank lines) into N_LD blocks each representing a separate LD potential and\n  each specifying its own upper and lower cutoffs, central and neighbor atoms,\n  and potential.  In general, blank lines anywhere are ignored.\n  \n  Mixing, shift, table, tail correction, restart, info:\n  This pair style does not support automatic mixing. For atom type pairs\n  \\(\\alpha\\), \\(\\beta\\) and \\(\\alpha\\) != \\(\\beta\\), even\n  if LD potentials of type (\\(\\alpha\\), \\(\\alpha\\)) and\n  (\\(\\beta\\), \\(\\beta\\)) are provided, you will need to explicitly\n  provide LD potential types (\\(\\alpha\\), \\(\\beta\\)) and\n  (\\(\\beta\\), \\(\\alpha\\)) if need be (Here, the notation\n  (\\(\\alpha\\), \\(\\beta\\)) means that \\(\\alpha\\) is the central\n  atom to which the LD potential is applied and \\(\\beta\\) is the\n  neighbor atom which contributes to the LD potential on \\(\\alpha\\)).\n  This pair style does not support the pair_modify\n  shift, table, and tail options.\n  The local/density pair style does not write its information to binary restart files, since it is stored in tabulated potential files.\n  Thus, you need to re-specify the pair_style and pair_coeff commands in\n  an input script that reads a restart file.\n  ",
    "syntax": "pair_style style arg\n  \n  \n  \n  style = local/density\n  arg = name of file containing tabulated values of local density and the potential\n  \n  ",
    "examples": "pair_style local/density benzene_water.localdensity.table\n  \n  pair_style hybrid/overlay table spline 500 local/density\n  pair_coeff * * local/density  benzene_water.localdensity.table\n  \n  \n  ",
    "restrictions": "The local/density pair style is a part of the USER-MISC package. It is only\n  enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style lubricate",
    "description": "Styles lubricate and lubricate/poly compute hydrodynamic\n  interactions between mono-disperse finite-size spherical particles in\n  a pairwise fashion.  The interactions have 2 components.  The first is\n  Ball-Melrose lubrication terms via the formulas in (Ball and Melrose)\n  \n  \\[\\begin{split}W & =  - a_{sq} | (v_1 - v_2) \\bullet \\mathbf{nn} |^2 -\n  a_{sh} | (\\omega_1 + \\omega_2) \\bullet\n  (\\mathbf{I} - \\mathbf{nn}) - 2 \\Omega_N |^2 - \\\\\n  &  a_{pu} | (\\omega_1 - \\omega_2) \\bullet (\\mathbf{I} - \\mathbf{nn}) |^2 -\n  a_{tw} | (\\omega_1 - \\omega_2) \\bullet \\mathbf{nn} |^2  \\qquad r < r_c \\\\\n  & \\\\\n  \\Omega_N & = \\mathbf{n} \\times (v_1 - v_2) / r\\end{split}\\]\n  which represents the dissipation W between two nearby particles due to\n  their relative velocities in the presence of a background solvent with\n  viscosity mu.  Note that this is dynamic viscosity which has units of\n  mass/distance/time, not kinematic viscosity.\n  The Asq (squeeze) term is the strongest and is included if flagHI is\n  set to 1 (default). It scales as 1/gap where gap is the separation\n  between the surfaces of the 2 particles. The Ash (shear) and Apu\n  (pump) terms are only included if flaglog is set to 1. They are the\n  next strongest interactions, and the only other singular interaction,\n  and scale as log(gap). Note that flaglog = 1 and flagHI = 0 is\n  invalid, and will result in a warning message, after which flagHI will\n  be set to 1. The Atw (twist) term is currently not included. It is\n  typically a very small contribution to the lubrication forces.\n  The flagHI and flagVF settings are optional.  Neither should be\n  used, or both must be defined.\n  Cutinner sets the minimum center-to-center separation that will be\n  used in calculations irrespective of the actual separation.  Cutoff\n  is the maximum center-to-center separation at which an interaction is\n  computed.  Using a cutoff less than 3 radii is recommended if\n  flaglog is set to 1.\n  The other component is due to the Fast Lubrication Dynamics (FLD)\n  approximation, described in (Kumar), which can be\n  represented by the following equation\n  \n  \\[F^{H} = -R_{FU}(U-U^{\\infty}) + R_{FE}E^{\\infty}\\]\n  where U represents the velocities and angular velocities of the\n  particles, \\(U^{\\infty}\\) represents the velocity and the angular velocity\n  of the undisturbed fluid, and \\(E^{\\infty}\\) represents the rate of strain\n  tensor of the undisturbed fluid with viscosity mu. Again, note that\n  this is dynamic viscosity which has units of mass/distance/time, not\n  kinematic viscosity. Volume fraction corrections to R_FU are included\n  as long as flagVF is set to 1 (default).\n  \n  Note\n  When using the FLD terms, these pair styles are designed to be\n  used with explicit time integration and a correspondingly small\n  timestep.  Thus either fix nve/sphere or fix nve/asphere should be used for time integration.\n  To perform implicit FLD, see the pair_style lubricateU command.\n  \n  Style lubricate requires monodisperse spherical particles; style\n  lubricate/poly allows for polydisperse spherical particles.\n  The viscosity mu can be varied in a time-dependent manner over the\n  course of a simulation, in which case in which case the pair_style\n  setting for mu will be overridden.  See the fix adapt\n  command for details.\n  If the suspension is sheared via the fix deform\n  command then the pair style uses the shear rate to adjust the\n  hydrodynamic interactions accordingly. Volume changes due to fix\n  deform are accounted for when computing the volume fraction\n  corrections to R_FU.\n  When computing the volume fraction corrections to R_FU, the presence\n  of walls (whether moving or stationary) will affect the volume\n  fraction available to colloidal particles. This is currently accounted\n  for with the following types of walls: wall/lj93,\n  wall/lj126, wall/colloid, and\n  wall/harmonic.  For these wall styles, the correct\n  volume fraction will be used when walls do not coincide with the box\n  boundary, as well as when walls move and thereby cause a change in the\n  volume fraction. Other wall styles will still work, but they will\n  result in the volume fraction being computed based on the box\n  boundaries.\n  Since lubrication forces are dissipative, it is usually desirable to\n  thermostat the system at a constant temperature. If Brownian motion\n  (at a constant temperature) is desired, it can be set using the\n  pair_style brownian command. These pair styles\n  and the brownian style should use consistent parameters for mu,\n  flaglog, flagfld, cutinner, cutoff, flagHI and flagVF.\n  \n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands, or by mixing as described below:\n  \n  cutinner (distance units)\n  cutoff (distance units)\n  \n  The two coefficients are optional.  If neither is specified, the two\n  cutoffs specified in the pair_style command are used.  Otherwise both\n  must be specified.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed in this section of\n  the manual.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See this section of the manual for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the two cutoff distances for this\n  pair style can be mixed.  The default mix value is geometric.  See\n  the “pair_modify” command for details.\n  This pair style does not support the pair_modify\n  shift option for the energy of the pair interaction.\n  The pair_modify table option is not relevant\n  for this pair style.\n  This pair style does not support the pair_modify\n  tail option for adding long-range tail corrections to energy and\n  pressure.\n  This pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style style mu flaglog flagfld cutinner cutoff flagHI flagVF\n  \n  \n  \n  style = lubricate or lubricate/poly\n  mu = dynamic viscosity (dynamic viscosity units)\n  flaglog = 0/1 to exclude/include log terms in the lubrication approximation\n  flagfld = 0/1 to exclude/include Fast Lubrication Dynamics (FLD) effects\n  cutinner = inner cutoff distance (distance units)\n  cutoff = outer cutoff for interactions (distance units)\n  flagHI (optional) = 0/1 to exclude/include 1/r hydrodynamic interactions\n  flagVF (optional) = 0/1 to exclude/include volume fraction corrections in the long-range isotropic terms\n  \n  Examples: (all assume radius = 1)\n  pair_style lubricate 1.5 1 1 2.01 2.5\n  pair_coeff 1 1 2.05 2.8\n  pair_coeff * *\n  \n  pair_style lubricate 1.5 1 1 2.01 2.5\n  pair_coeff * *\n  variable mu equal ramp(1,2)\n  fix 1 all adapt 1 pair lubricate mu * * v_mu\n  \n  \n  ",
    "examples": "pair_style local/density benzene_water.localdensity.table\n  \n  pair_style hybrid/overlay table spline 500 local/density\n  pair_coeff * * local/density  benzene_water.localdensity.table\n  \n  \n  ",
    "restrictions": "These styles are part of the COLLOID package.  They are only enabled\n  if LAMMPS was built with that package.  See the Build package doc page for more info.\n  Only spherical monodisperse particles are allowed for pair_style\n  lubricate.\n  Only spherical particles are allowed for pair_style lubricate/poly.\n  These pair styles will not restart exactly when using the\n  read_restart command, though they should provide\n  statistically similar results.  This is because the forces they\n  compute depend on atom velocities.  See the\n  read_restart command for more details.\n  "
},
{
    "command": "pair_style lubricateU",
    "description": "Styles lubricateU and lubricateU/poly compute velocities and\n  angular velocities for finite-size spherical particles such that the\n  hydrodynamic interaction balances the force and torque due to all\n  other types of interactions.\n  The interactions have 2 components.  The first is\n  Ball-Melrose lubrication terms via the formulas in (Ball and Melrose)\n  \n  \\[\\begin{split}W & =  - a_{sq} | (v_1 - v_2) \\bullet \\mathbf{nn} |^2 -\n  a_{sh} | (\\omega_1 + \\omega_2) \\bullet\n  (\\mathbf{I} - \\mathbf{nn}) - 2 \\Omega_N |^2 - \\\\\n  &  a_{pu} | (\\omega_1 - \\omega_2) \\bullet (\\mathbf{I} - \\mathbf{nn}) |^2 -\n  a_{tw} | (\\omega_1 - \\omega_2) \\bullet \\mathbf{nn} |^2  \\qquad r < r_c \\\\\n  & \\\\\n  \\Omega_N & = \\mathbf{n} \\times (v_1 - v_2) / r\\end{split}\\]\n  which represents the dissipation W between two nearby particles due to\n  their relative velocities in the presence of a background solvent with\n  viscosity mu.  Note that this is dynamic viscosity which has units of\n  mass/distance/time, not kinematic viscosity.\n  The Asq (squeeze) term is the strongest and is included as long as\n  flagHI is set to 1 (default). It scales as 1/gap where gap is the\n  separation between the surfaces of the 2 particles. The Ash (shear)\n  and Apu (pump) terms are only included if flaglog is set to 1. They\n  are the next strongest interactions, and the only other singular\n  interaction, and scale as log(gap). Note that flaglog = 1 and\n  flagHI = 0 is invalid, and will result in a warning message, after\n  which flagHI will be set to 1. The Atw (twist) term is currently not\n  included. It is typically a very small contribution to the lubrication\n  forces.\n  The flagHI and flagVF settings are optional.  Neither should be\n  used, or both must be defined.\n  Cutinner sets the minimum center-to-center separation that will be\n  used in calculations irrespective of the actual separation.  Cutoff\n  is the maximum center-to-center separation at which an interaction is\n  computed.  Using a cutoff less than 3 radii is recommended if\n  flaglog is set to 1.\n  The other component is due to the Fast Lubrication Dynamics (FLD)\n  approximation, described in (Kumar).  The equation being\n  solved to balance the forces and torques is\n  \n  \\[-R_{FU}(U-U^{\\infty}) = -R_{FE}E^{\\infty} - F^{rest}\\]\n  where U represents the velocities and angular velocities of the\n  particles, \\(U^{\\infty}\\) represents the velocities and the angular\n  velocities of the undisturbed fluid, and \\(E^{\\infty}\\) represents\n  the rate of strain tensor of the undisturbed fluid flow with viscosity\n  mu. Again, note that this is dynamic viscosity which has units of\n  mass/distance/time, not kinematic viscosity.  Volume fraction\n  corrections to R_FU are included if flagVF is set to 1 (default).\n  Frest represents the forces and torques due to all other types of\n  interactions, e.g. Brownian, electrostatic etc.  Note that this\n  algorithm neglects the inertial terms, thereby removing the\n  restriction of resolving the small interial time scale, which may not\n  be of interest for colloidal particles.  This pair style solves for\n  the velocity such that the hydrodynamic force balances all other types\n  of forces, thereby resulting in a net zero force (zero inertia limit).\n  When defining this pair style, it must be defined last so that when\n  this style is invoked all other types of forces have already been\n  computed.  For the same reason, it won’t work if additional non-pair\n  styles are defined (such as bond or Kspace forces) as they are\n  calculated in LAMMPS after the pairwise interactions have been\n  computed.\n  \n  Note\n  When using these styles, the these pair styles are designed to\n  be used with implicit time integration and a correspondingly larger\n  timestep.  Thus either fix nve/noforce should\n  be used for spherical particles defined via atom_style sphere or fix nve/asphere/noforce should be used for\n  spherical particles defined via atom_style ellipsoid.  This is because the velocity and angular\n  momentum of each particle is set by the pair style, and should not be\n  reset by the time integration fix.\n  \n  Style lubricateU requires monodisperse spherical particles; style\n  lubricateU/poly allows for polydisperse spherical particles.\n  If the suspension is sheared via the fix deform\n  command then the pair style uses the shear rate to adjust the\n  hydrodynamic interactions accordingly. Volume changes due to fix\n  deform are accounted for when computing the volume fraction\n  corrections to R_FU.\n  When computing the volume fraction corrections to R_FU, the presence\n  of walls (whether moving or stationary) will affect the volume\n  fraction available to colloidal particles. This is currently accounted\n  for with the following types of walls: wall/lj93,\n  wall/lj126, wall/colloid, and\n  wall/harmonic.  For these wall styles, the correct\n  volume fraction will be used when walls do not coincide with the box\n  boundary, as well as when walls move and thereby cause a change in the\n  volume fraction. To use these wall styles with pair_style lubricateU\n  or lubricateU/poly, the fld yes option must be specified in the\n  fix wall command.\n  Since lubrication forces are dissipative, it is usually desirable to\n  thermostat the system at a constant temperature. If Brownian motion\n  (at a constant temperature) is desired, it can be set using the\n  pair_style brownian command. These pair styles\n  and the brownian style should use consistent parameters for mu,\n  flaglog, flagfld, cutinner, cutoff, flagHI and flagVF.\n  \n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands, or by mixing as described below:\n  \n  cutinner (distance units)\n  cutoff (distance units)\n  \n  The two coefficients are optional.  If neither is specified, the two\n  cutoffs specified in the pair_style command are used.  Otherwise both\n  must be specified.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the two cutoff distances for this\n  pair style can be mixed.  The default mix value is geometric.  See\n  the “pair_modify” command for details.\n  This pair style does not support the pair_modify\n  shift option for the energy of the pair interaction.\n  The pair_modify table option is not relevant\n  for this pair style.\n  This pair style does not support the pair_modify\n  tail option for adding long-range tail corrections to energy and\n  pressure.\n  This pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style style mu flaglog cutinner cutoff gdot flagHI flagVF\n  \n  \n  \n  style = lubricateU or lubricateU/poly\n  mu = dynamic viscosity (dynamic viscosity units)\n  flaglog = 0/1 to exclude/include log terms in the lubrication approximation\n  cutinner = inner cut off distance (distance units)\n  cutoff = outer cutoff for interactions (distance units)\n  gdot = shear rate (1/time units)\n  flagHI (optional) = 0/1 to exclude/include 1/r hydrodynamic interactions\n  flagVF (optional) = 0/1 to exclude/include volume fraction corrections in the long-range isotropic terms\n  \n  Examples: (all assume radius = 1)\n  pair_style lubricateU 1.5 1 2.01 2.5 0.01 1 1\n  pair_coeff 1 1 2.05 2.8\n  pair_coeff * *\n  \n  \n  ",
    "examples": "pair_style local/density benzene_water.localdensity.table\n  \n  pair_style hybrid/overlay table spline 500 local/density\n  pair_coeff * * local/density  benzene_water.localdensity.table\n  \n  \n  ",
    "restrictions": "These styles are part of the COLLOID package.  They are only enabled\n  if LAMMPS was built with that package.  See the Build package doc page for more info.\n  Currently, these pair styles assume that all other types of\n  forces/torques on the particles have been already been computed when\n  it is invoked.  This requires this style to be defined as the last of\n  the pair styles, and that no fixes apply additional constraint forces.\n  One exception is the fix wall/colloid commands, which\n  has an “fld” option to apply their wall forces correctly.\n  Only spherical monodisperse particles are allowed for pair_style\n  lubricateU.\n  Only spherical particles are allowed for pair_style lubricateU/poly.\n  For sheared suspensions, it is assumed that the shearing is done in\n  the xy plane, with x being the velocity direction and y being the\n  velocity-gradient direction. In this case, one must use fix deform with the same rate of shear (erate).\n  "
},
{
    "command": "pair_style lj/mdf",
    "description": "The lj/mdf, buck/mdf and lennard/mdf compute the standard 12-6\n  Lennard-Jones and Buckingham potential with the addition of a taper\n  function that ramps the energy and force smoothly to zero between an\n  inner and outer cutoff.\n  \n  \\[E_{smooth}(r) = E(r)*f(r)\\]\n  The tapering, f(r), is done by using the Mei, Davenport, Fernando\n  function (Mei).\n  \n  \\[\\begin{split}f(r) & = 1.0  \\qquad \\qquad \\mathrm{for} \\qquad r < r_m \\\\\n  f(r) & = (1 - x)^3*(1+3x+6x^2) \\quad \\mathrm{for} \\qquad r_m < r < r_{cut} \\\\\n  f(r) & = 0.0  \\qquad \\qquad \\mathrm{for} \\qquad  r >= r_{cut} \\\\\\end{split}\\]\n  where\n  \n  \\[x = \\frac{(r-r_m)}{(r_{cut}-r_m)}\\]\n  Here \\(r_m\\) is the inner cutoff radius and \\(r_{cut}\\) is the\n  outer cutoff radius.\n  \n  For the lj/mdf pair_style, the potential energy, E(r), is the\n  standard 12-6 Lennard-Jones written in the epsilon/sigma form:\n  \n  \\[E(r) = 4\\epsilon\\biggl[\\bigl(\\frac{\\sigma}{r}\\bigr)^{12} - \\bigl(\\frac{\\sigma}{r}\\bigr)^6\\biggr]\\]\n  Either the first two or all of the following coefficients must be\n  defined for each pair of atoms types via the pair_coeff command as in\n  the examples above, or in the data file read by the read_data. The two cutoffs default to the global values and\n  \\(\\epsilon\\) and \\(\\sigma\\) can also be determined by mixing as\n  described below:\n  \n  \\(\\epsilon\\) (energy units)\n  \\(\\sigma\\) (distance units)\n  \\(r_m\\) (distance units)\n  \\(r_{cut}\\) (distance units)\n  \n  \n  For the buck/mdf pair_style, the potential energy, E(r), is the\n  standard Buckingham potential with three required coefficients.\n  The two cutoffs can be omitted and default to the corresponding\n  global values:\n  \n  \\[E(r) = A e^{(-r/\\rho)} -\\frac{C}{r^6}\\]\n  \n  A (energy units)\n  \\(\\rho\\) (distance units)\n  C (energy-distance^6 units)\n  \\(r_m\\) (distance units)\n  \\(r_{cut}\\) (distance units)\n  \n  \n  For the lennard/mdf pair_style, the potential energy, E(r), is the\n  standard 12-6 Lennard-Jones written in the A/B form:\n  \n  \\[E(r) = \\frac{A}{r^{12}} - \\frac{B}{r^{6}}\\]\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples above, or in the\n  data file read by the read_data commands, or by mixing as described below.\n  The two cutoffs default to their global values and must be either both\n  given or both left out:\n  \n  A (energy-distance^12 units)\n  B (energy-distance^6 units)\n  \\(r_m\\) (distance units)\n  \\(r_{cut}\\) (distance units)\n  \n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the \\(\\epsilon\\) and\n  \\(sigma\\) coefficients and cutoff distances for the lj/mdf pair\n  style can be mixed.  The default mix value is geometric.  See the\n  “pair_modify” command for details. The other two pair styles buck/mdf\n  and lennard/mdf do not support mixing, so all I,J pairs of coefficients\n  must be specified explicitly.\n  None of the lj/mdf, buck/mdf, or lennard/mdf pair styles supports\n  the pair_modify shift option or long-range\n  tail corrections to pressure and energy.\n  These styles write their information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  These styles can only be used via the pair keyword of the run_style respa command.  They do not support the inner,\n  middle, outer keywords.\n  ",
    "syntax": "pair_style style args\n  \n  \n  \n  style = lj/mdf or buck/mdf or lennard/mdf\n  args = list of arguments for a particular style\n  lj/mdf args = cutoff1 cutoff2\n    cutoff1 = inner cutoff for the start of the tapering function\n    cutoff1 = out cutoff for the end of the tapering function\n  buck/mdf args = cutoff1 cutoff2\n    cutoff1 = inner cutoff for the start of the tapering function\n    cutoff1 = out cutoff for the end of the tapering function\n  lennard/mdf args = cutoff1 cutoff2\n    cutoff1 = inner cutoff for the start of the tapering function\n    cutoff1 = out cutoff for the end of the tapering function\n  \n  \n  ",
    "examples": "pair_style lj/mdf 2.5 3.0\n  pair_coeff * * 1.0 1.0\n  pair_coeff 1 1 1.1 2.8 3.0 3.2\n  \n  pair_style buck 2.5 3.0\n  pair_coeff * * 100.0 1.5 200.0\n  pair_coeff * * 100.0 1.5 200.0 3.0 3.5\n  \n  pair_style lennard/mdf 2.5 3.0\n  pair_coeff * * 1.0 1.0\n  pair_coeff 1 1 1021760.3664 2120.317338 3.0 3.2\n  \n  \n  ",
    "restrictions": "These pair styles can only be used if LAMMPS was built with the\n  USER-MISC package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "pair_style meam/spline",
    "description": "The meam/spline style computes pairwise interactions for metals\n  using a variant of modified embedded-atom method (MEAM) potentials\n  (Lenosky).  For a single species (“old-style”) MEAM,\n  the total energy E is given by\n  \n  \\[\\begin{split}E & =\\sum_{i<j}\\phi(r_{ij})+\\sum_{i}U(n_{i}) \\\\\n  n_{i} & =\\sum_{j}\\rho(r_{ij})+\\sum_{\\substack{j<k,\\\\j,k\\neq i}}f(r_{ij})f(r_{ik})g[\\cos(\\theta_{jik})]\\end{split}\\]\n  where \\(\\rho_i\\) is the density at atom I, \\(\\theta_{jik}\\) is\n  the angle between atoms J, I, and K centered on atom I. The five\n  functions \\(\\phi, U, \\rho, f,\\) and g are represented by cubic splines.\n  The meam/spline style also supports a new style multicomponent\n  modified embedded-atom method (MEAM) potential (Zhang), where\n  the total energy E is given by\n  \n  \\[\\begin{split}E &= \\sum_{i<j}\\phi_{ij}(r_{ij})+\\sum_{i}U_i(n_{i}) \\\\\n  n_{i} & = \\sum_{j\\ne i}\\rho_j(r_{ij})+\\sum_{\\substack{j<k,\\\\j,k\\neq i}}f_{j}(r_{ij})f_{k}(r_{ik})g_{jk}[\\cos(\\theta_{jik})]\\end{split}\\]\n  where the five functions \\(\\phi, U, \\rho, f,\\) and g depend on the\n  chemistry of the atoms in the interaction.  In particular, if there are\n  N different chemistries, there are N different U, \\(\\rho\\), and\n  f functions, while there are N(N+1)/2 different \\(\\phi\\) and g\n  functions.  The new style multicomponent MEAM potential files are\n  indicated by the second line in the file starts with “meam/spline”\n  followed by the number of elements and the name of each element.\n  The cutoffs and the coefficients for these spline functions are listed\n  in a parameter file which is specified by the\n  pair_coeff command.  Parameter files for different\n  elements are included in the “potentials” directory of the LAMMPS\n  distribution and have a “.meam.spline” file suffix.  All of these\n  files are parameterized in terms of LAMMPS metal units.\n  Note that unlike for other potentials, cutoffs for spline-based MEAM\n  potentials are not set in the pair_style or pair_coeff command; they\n  are specified in the potential files themselves.\n  Unlike the EAM pair style, which retrieves the atomic mass from the\n  potential file, the spline-based MEAM potentials do not include mass\n  information; thus you need to use the mass command to\n  specify it.\n  Only a single pair_coeff command is used with the meam/spline style\n  which specifies a potential file with parameters for all needed\n  elements.  These are mapped to LAMMPS atom types by specifying N\n  additional arguments after the filename in the pair_coeff command,\n  where N is the number of LAMMPS atom types:\n  \n  filename\n  N element names = mapping of spline-based MEAM elements to atom types\n  \n  See the pair_coeff doc page for alternate ways\n  to specify the path for the potential file.\n  As an example, imagine the Ti.meam.spline file has values for Ti (old style).  If\n  your LAMMPS simulation has 3 atoms types and they are all to be\n  treated with this potentials, you would use the following pair_coeff\n  command:\n  pair_coeff * * Ti.meam.spline Ti Ti Ti\n  \n  \n  The 1st 2 arguments must be * * so as to span all LAMMPS atom types.\n  The three Ti arguments map LAMMPS atom types 1,2,3 to the Ti element\n  in the potential file.  If a mapping value is specified as NULL, the\n  mapping is not performed.  This can be used when a meam/spline\n  potential is used as part of the hybrid pair style.  The NULL values\n  are placeholders for atom types that will be used with other\n  potentials. The old-style potential maps any non-NULL species named\n  on the command line to that single type.\n  An example with a two component spline (new style) is TiO.meam.spline, where\n  the command\n  pair_coeff * * TiO.meam.spline Ti O\n  \n  \n  will map the 1st atom type to Ti and the second atom type to O. Note\n  in this case that the species names need to match exactly with the\n  names of the elements in the TiO.meam.spline file; otherwise an\n  error will be raised. This behavior is different than the old style\n  MEAM files.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This pair style does not support the pair_modify\n  shift, table, and tail options.\n  The meam/spline pair style does not write its information to binary restart files, since it is stored in an external\n  potential parameter file.  Thus, you need to re-specify the pair_style\n  and pair_coeff commands in an input script that reads a restart file.\n  The meam/spline pair style can only be used via the pair keyword of the\n  run_style respa command.  They do not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style meam/spline\n  \n  \n  ",
    "examples": "pair_style meam/spline\n  pair_coeff * * Ti.meam.spline Ti\n  pair_coeff * * Ti.meam.spline Ti Ti Ti\n  \n  \n  ",
    "restrictions": "This pair style requires the newton setting to be “on”\n  for pair interactions.\n  This pair style is only enabled if LAMMPS was built with the USER-MISC\n  package.  See the Build package doc page for more\n  info.\n  "
},
{
    "command": "pair_style meam/sw/spline",
    "description": "The meam/sw/spline style computes pairwise interactions for metals\n  using a variant of modified embedded-atom method (MEAM) potentials\n  (Lenosky) with an additional Stillinger-Weber (SW) term\n  (Stillinger) in the energy.  This form of the potential\n  was first proposed by Nicklas, Fellinger, and Park\n  (Nicklas).  We refer to it as MEAM+SW.  The total energy E\n  is given by\n  \n  \\[\\begin{split}E & = E_{MEAM} + E_{SW} \\\\\n  E_{MEAM} & =  \\sum _{IJ} \\phi (r_{IJ}) + \\sum _{I} U(\\rho _I) \\\\\n  E_{SW} & =  \\sum _{I} \\sum _{JK} F(r_{IJ}) \\, F(r_{IK}) \\, G(\\cos(\\theta _{JIK})) \\\\\n  \\rho _I & = \\sum _J \\rho(r_{IJ}) + \\sum _{JK} f(r_{IJ}) \\, f(r_{IK}) \\, g(\\cos(\\theta _{JIK}))\\end{split}\\]\n  where \\(\\rho_I\\) is the density at atom I, \\(\\theta_{JIK}\\) is\n  the angle between atoms J, I, and K centered on atom I. The seven\n  functions \\(\\phi, F, G, U, \\rho, f,\\) and g are represented by\n  cubic splines.\n  The cutoffs and the coefficients for these spline functions are listed\n  in a parameter file which is specified by the\n  pair_coeff command.  Parameter files for different\n  elements are included in the “potentials” directory of the LAMMPS\n  distribution and have a “.meam.sw.spline” file suffix.  All of these\n  files are parameterized in terms of LAMMPS metal units.\n  Note that unlike for other potentials, cutoffs for spline-based\n  MEAM+SW potentials are not set in the pair_style or pair_coeff\n  command; they are specified in the potential files themselves.\n  Unlike the EAM pair style, which retrieves the atomic mass from the\n  potential file, the spline-based MEAM+SW potentials do not include\n  mass information; thus you need to use the mass command to\n  specify it.\n  Only a single pair_coeff command is used with the meam/sw/spline style\n  which specifies a potential file with parameters for all needed\n  elements.  These are mapped to LAMMPS atom types by specifying N\n  additional arguments after the filename in the pair_coeff command,\n  where N is the number of LAMMPS atom types:\n  \n  filename\n  N element names = mapping of spline-based MEAM+SW elements to atom types\n  \n  See the pair_coeff doc page for alternate ways\n  to specify the path for the potential file.\n  As an example, imagine the Ti.meam.sw.spline file has values for Ti.\n  If your LAMMPS simulation has 3 atoms types and they are all to be\n  treated with this potential, you would use the following pair_coeff\n  command:\n  pair_coeff * * Ti.meam.sw.spline Ti Ti Ti\n  \n  \n  The 1st 2 arguments must be * * so as to span all LAMMPS atom types.\n  The three Ti arguments map LAMMPS atom types 1,2,3 to the Ti element\n  in the potential file. If a mapping value is specified as NULL, the\n  mapping is not performed. This can be used when a meam/sw/spline\n  potential is used as part of the hybrid pair style. The NULL values\n  are placeholders for atom types that will be used with other\n  potentials.\n  \n  Note\n  The meam/sw/spline style currently supports only\n  single-element MEAM+SW potentials.  It may be extended for alloy\n  systems in the future.\n  \n  Example input scripts that use this pair style are provided\n  in the examples/USER/misc/meam_sw_spline directory.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  The pair style does not support multiple element types or mixing.\n  It has been designed for pure elements only.\n  This pair style does not support the pair_modify\n  shift, table, and tail options.\n  The meam/sw/spline pair style does not write its information to\n  binary restart files, since it is stored in an external\n  potential parameter file.  Thus, you need to re-specify the pair_style\n  and pair_coeff commands in an input script that reads a restart file.\n  The meam/sw/spline pair style can only be used via the pair\n  keyword of the run_style respa command.  They do not\n  support the inner, middle, outer keywords.\n  ",
    "syntax": "pair_style meam/sw/spline\n  \n  \n  ",
    "examples": "pair_style meam/sw/spline\n  pair_coeff * * Ti.meam.sw.spline Ti\n  pair_coeff * * Ti.meam.sw.spline Ti Ti Ti\n  \n  \n  ",
    "restrictions": "This pair style requires the newton setting to be “on”\n  for pair interactions.\n  This pair style is only enabled if LAMMPS was built with the USER-MISC\n  package.  See the Build package doc page for more\n  info.\n  "
},
{
    "command": "pair_style meam/c",
    "description": "\n  Note\n  The behavior of the MEAM potential for alloy systems has changed\n  as of November 2010; see description below of the mixture_ref_t\n  parameter\n  \n  Style meam/c computes pairwise interactions for a variety of materials\n  using modified embedded-atom method (MEAM) potentials\n  (Baskes).  Conceptually, it is an extension to the original\n  EAM potentials which adds angular forces.  It is\n  thus suitable for modeling metals and alloys with fcc, bcc, hcp and\n  diamond cubic structures, as well as covalently bonded materials like\n  silicon and carbon. Style meam/c is a translation of the (now obsolete)\n  meam code from Fortran to C++. It is functionally equivalent to meam\n  but more efficient, and thus meam has been removed from LAMMPS after\n  the 12 December 2018 release.\n  In the MEAM formulation, the total energy E of a system of atoms is\n  given by:\n  \n  \\[E = \\sum_i \\left\\{ F_i(\\bar{\\rho}_i)\n      + \\frac{1}{2} \\sum_{i \\neq j} \\phi_{ij} (r_{ij}) \\right\\}\\]\n  where F is the embedding energy which is a function of the atomic\n  electron density \\(\\rho\\), and \\(\\phi\\) is a pair potential\n  interaction.  The pair interaction is summed over all neighbors J of\n  atom I within the cutoff distance.  As with EAM, the multi-body nature\n  of the MEAM potential is a result of the embedding energy term.  Details\n  of the computation of the embedding and pair energies, as implemented in\n  LAMMPS, are given in (Gullet) and references therein.\n  The various parameters in the MEAM formulas are listed in two files\n  which are specified by the pair_coeff command.\n  These are ASCII text files in a format consistent with other MD codes\n  that implement MEAM potentials, such as the serial DYNAMO code and\n  Warp.  Several MEAM potential files with parameters for different\n  materials are included in the “potentials” directory of the LAMMPS\n  distribution with a “.meam” suffix.  All of these are parameterized in\n  terms of LAMMPS metal units.\n  Note that unlike for other potentials, cutoffs for MEAM potentials are\n  not set in the pair_style or pair_coeff command; they are specified in\n  the MEAM potential files themselves.\n  Only a single pair_coeff command is used with the meam style which\n  specifies two MEAM files and the element(s) to extract information\n  for.  The MEAM elements are mapped to LAMMPS atom types by specifying\n  N additional arguments after the 2nd filename in the pair_coeff\n  command, where N is the number of LAMMPS atom types:\n  \n  MEAM library file\n  Elem1, Elem2, …\n  MEAM parameter file\n  N element names = mapping of MEAM elements to atom types\n  \n  See the pair_coeff doc page for alternate ways\n  to specify the path for the potential files.\n  As an example, the potentials/library.meam file has generic MEAM\n  settings for a variety of elements.  The potentials/SiC.meam file has\n  specific parameter settings for a Si and C alloy system.  If your\n  LAMMPS simulation has 4 atoms types and you want the 1st 3 to be Si,\n  and the 4th to be C, you would use the following pair_coeff command:\n  pair_coeff * * library.meam Si C sic.meam Si Si Si C\n  \n  \n  The 1st 2 arguments must be * * so as to span all LAMMPS atom types.\n  The first filename is the element library file. The list of elements following\n  it extracts lines from the library file and assigns numeric indices to these\n  elements. The second filename is the alloy parameter file, which refers to\n  elements using the numeric indices assigned before.\n  The arguments after the parameter file map LAMMPS atom types to elements, i.e.\n  LAMMPS atom types 1,2,3 to the MEAM Si element.  The final C argument maps\n  LAMMPS atom type 4 to the MEAM C element.\n  If the 2nd filename is specified as NULL, no parameter file is read,\n  which simply means the generic parameters in the library file are\n  used.  Use of the NULL specification for the parameter file is\n  discouraged for systems with more than a single element type\n  (e.g. alloys), since the parameter file is expected to set element\n  interaction terms that are not captured by the information in the\n  library file.\n  If a mapping value is specified as NULL, the mapping is not performed.\n  This can be used when a meam potential is used as part of the\n  hybrid pair style.  The NULL values are placeholders for atom types\n  that will be used with other potentials.\n  \n  Note\n  If the 2nd filename is NULL, the element names between the two\n  filenames can appear in any order, e.g. “Si C” or “C Si” in the\n  example above.  However, if the 2nd filename is not NULL (as in the\n  example above), it contains settings that are Fortran-indexed for the\n  elements that precede it.  Thus you need to insure you list the\n  elements between the filenames in an order consistent with how the\n  values in the 2nd filename are indexed.  See details below on the\n  syntax for settings in the 2nd file.\n  \n  The MEAM library file provided with LAMMPS has the name\n  potentials/library.meam.  It is the “meamf” file used by other MD\n  codes.  Aside from blank and comment lines (start with #) which can\n  appear anywhere, it is formatted as a series of entries, each of which\n  has 19 parameters and can span multiple lines:\n  elt, lat, z, ielement, atwt, alpha, b0, b1, b2, b3, alat, esub, asub,\n  t0, t1, t2, t3, rozero, ibar\n  The “elt” and “lat” parameters are text strings, such as elt = Si or\n  Cu and lat = dia or fcc.  Because the library file is used by Fortran\n  MD codes, these strings may be enclosed in single quotes, but this is\n  not required.  The other numeric parameters match values in the\n  formulas above.  The value of the “elt” string is what is used in the\n  pair_coeff command to identify which settings from the library file\n  you wish to read in.  There can be multiple entries in the library\n  file with the same “elt” value; LAMMPS reads the first matching entry it\n  finds and ignores the rest.\n  Other parameters in the MEAM library file correspond to single-element\n  potential parameters:\n  lat      = lattice structure of reference configuration\n  z        = number of nearest neighbors in the reference structure\n  ielement = atomic number\n  atwt     = atomic weight\n  alat     = lattice constant of reference structure\n  esub     = energy per atom (eV) in the reference structure at equilibrium\n  asub     = \"A\" parameter for MEAM (see e.g. (Baskes))\n  The alpha, b0, b1, b2, b3, t0, t1, t2, t3 parameters correspond to the\n  standard MEAM parameters in the literature (Baskes) (the b\n  parameters are the standard beta parameters). Note that only parameters\n  normalized to t0 = 1.0 are supported.  The rozero parameter is\n  an element-dependent density scaling that weights the reference\n  background density (see e.g. equation 4.5 in (Gullet)) and\n  is typically 1.0 for single-element systems.  The ibar parameter\n  selects the form of the function G(Gamma) used to compute the electron\n  density; options are\n   0 => G = sqrt(1+Gamma)\n   1 => G = exp(Gamma/2)\n   2 => not implemented\n   3 => G = 2/(1+exp(-Gamma))\n   4 => G = sqrt(1+Gamma)\n  -5 => G = +-sqrt(abs(1+Gamma))\n  \n  \n  If used, the MEAM parameter file contains settings that override or\n  complement the library file settings.  Examples of such parameter\n  files are in the potentials directory with a “.meam” suffix.  Their\n  format is the same as is read by other Fortran MD codes.  Aside from\n  blank and comment lines (start with #) which can appear anywhere, each\n  line has one of the following forms.  Each line can also have a\n  trailing comment (starting with #) which is ignored.\n  keyword = value\n  keyword(I) = value\n  keyword(I,J) = value\n  keyword(I,J,K) = value\n  \n  \n  The indices I, J, K correspond to the elements selected from the\n  MEAM library file numbered in the order of how those elements were\n  selected starting from 1. Thus for the example given before\n  pair_coeff * * library.meam Si C sic.meam Si Si Si C\n  \n  \n  an index of 1 would refer to Si and an index of 2 to C.\n  The recognized keywords for the parameter file are as follows:\n  rc          = cutoff radius for cutoff function; default = 4.0\n  delr        = length of smoothing distance for cutoff function; default = 0.1\n  rho0(I)     = relative density for element I (overwrites value\n                read from meamf file)\n  Ec(I,J)     = cohesive energy of reference structure for I-J mixture\n  delta(I,J)  = heat of formation for I-J alloy; if Ec_IJ is input as\n                zero, then LAMMPS sets Ec_IJ = (Ec_II + Ec_JJ)/2 - delta_IJ\n  alpha(I,J)  = alpha parameter for pair potential between I and J (can\n                be computed from bulk modulus of reference structure\n  re(I,J)     = equilibrium distance between I and J in the reference\n                structure\n  Cmax(I,J,K) = Cmax screening parameter when I-J pair is screened\n                by K (I<=J); default = 2.8\n  Cmin(I,J,K) = Cmin screening parameter when I-J pair is screened\n                by K (I<=J); default = 2.0\n  lattce(I,J) = lattice structure of I-J reference structure:\n                  fcc = face centered cubic\n                  bcc = body centered cubic\n                  hcp = hexagonal close-packed\n                  dim = dimer\n                  dia = diamond (interlaced fcc for alloy)\n                  dia3= diamond structure with primary 1NN and secondary 3NN interaction\n                  b1  = rock salt (NaCl structure)\n                  c11 = MoSi2 structure\n                  l12 = Cu3Au structure (lower case L, followed by 12)\n                  b2  = CsCl structure (interpenetrating simple cubic)\n                  ch4 = methane-like structure, only for binary system\n                  lin = linear structure (180 degree angle)\n                  zig = zigzag structure with a uniform angle\n                  tri = H2O-like structure that has an angle\n  nn2(I,J)    = turn on second-nearest neighbor MEAM formulation for\n                I-J pair (see for example (Lee)).\n                  0 = second-nearest neighbor formulation off\n                  1 = second-nearest neighbor formulation on\n                  default = 0\n  attrac(I,J) = additional cubic attraction term in Rose energy I-J pair potential\n                  default = 0\n  repuls(I,J) = additional cubic repulsive term in Rose energy I-J pair potential\n                  default = 0\n  zbl(I,J)    = blend the MEAM I-J pair potential with the ZBL potential for small\n                atom separations (ZBL)\n                  default = 1\n  theta(I,J)  = angle between three atoms in line, zigzag, and trimer reference structures in degrees\n                  default = 180\n  gsmooth_factor  = factor determining the length of the G-function smoothing\n                    region; only significant for ibar=0 or ibar=4.\n                        99.0 = short smoothing region, sharp step\n                        0.5  = long smoothing region, smooth step\n                        default = 99.0\n  augt1           = integer flag for whether to augment t1 parameter by\n                    3/5*t3 to account for old vs. new meam formulations;\n                      0 = don't augment t1\n                      1 = augment t1\n                      default = 1\n  ialloy          = integer flag to use alternative averaging rule for t parameters,\n                    for comparison with the DYNAMO MEAM code\n                      0 = standard averaging (matches ialloy=0 in DYNAMO)\n                      1 = alternative averaging (matches ialloy=1 in DYNAMO)\n                      2 = no averaging of t (use single-element values)\n                      default = 0\n  mixture_ref_t   = integer flag to use mixture average of t to compute the background\n                    reference density for alloys, instead of the single-element values\n                    (see description and warning elsewhere in this doc page)\n                      0 = do not use mixture averaging for t in the reference density\n                      1 = use mixture averaging for t in the reference density\n                      default = 0\n  erose_form      = integer value to select the form of the Rose energy function\n                    (see description below).\n                      default = 0\n  emb_lin_neg     = integer value to select embedding function for negative densities\n                      0 = F(rho)=0\n                      1 = F(rho) = -asub*esub*rho (linear in rho, matches DYNAMO)\n                      default = 0\n  bkgd_dyn        = integer value to select background density formula\n                      0 = rho_bkgd = rho_ref_meam(a) (as in the reference structure)\n                      1 = rho_bkgd = rho0_meam(a)*Z_meam(a) (matches DYNAMO)\n                      default = 0\n  Rc, delr, re are in distance units (Angstroms in the case of metal\n  units).  Ec and delta are in energy units (eV in the case of metal\n  units).\n  Each keyword represents a quantity which is either a scalar, vector,\n  2d array, or 3d array and must be specified with the correct\n  corresponding array syntax.  The indices I,J,K each run from 1 to N\n  where N is the number of MEAM elements being used.\n  Thus these lines\n  rho0(2) = 2.25\n  alpha(1,2) = 4.37\n  \n  \n  set rho0 for the 2nd element to the value 2.25 and set alpha for the\n  alloy interaction between elements 1 and 2 to 4.37.\n  The augt1 parameter is related to modifications in the MEAM\n  formulation of the partial electron density function.  In recent\n  literature, an extra term is included in the expression for the\n  third-order density in order to make the densities orthogonal (see for\n  example (Wang), equation 3d); this term is included in the\n  MEAM implementation in lammps.  However, in earlier published work\n  this term was not included when deriving parameters, including most of\n  those provided in the library.meam file included with lammps, and to\n  account for this difference the parameter t1 must be augmented by\n  3/5*t3.  If augt1=1, the default, this augmentation is done\n  automatically.  When parameter values are fit using the modified\n  density function, as in more recent literature, augt1 should be set to\n  0.\n  The mixture_ref_t parameter is available to match results with those\n  of previous versions of lammps (before January 2011).  Newer versions\n  of lammps, by default, use the single-element values of the t\n  parameters to compute the background reference density.  This is the\n  proper way to compute these parameters.  Earlier versions of lammps\n  used an alloy mixture averaged value of t to compute the background\n  reference density.  Setting mixture_ref_t=1 gives the old behavior.\n  WARNING: using mixture_ref_t=1 will give results that are demonstrably\n  incorrect for second-neighbor MEAM, and non-standard for\n  first-neighbor MEAM; this option is included only for matching with\n  previous versions of lammps and should be avoided if possible.\n  The parameters attrac and repuls, along with the integer selection\n  parameter erose_form, can be used to modify the Rose energy function\n  used to compute the pair potential.  This function gives the energy of\n  the reference state as a function of interatomic spacing.  The form of\n  this function is:\n  astar = alpha * (r/re - 1.d0)\n  if erose_form = 0: erose = -Ec*(1+astar+a3*(astar**3)/(r/re))*exp(-astar)\n  if erose_form = 1: erose = -Ec*(1+astar+(-attrac+repuls/r)*(astar**3))*exp(-astar)\n  if erose_form = 2: erose = -Ec*(1 +astar + a3*(astar**3))*exp(-astar)\n  a3 = repuls, astar < 0\n  a3 = attrac, astar >= 0\n  Most published MEAM parameter sets use the default values attrac=repulse=0.\n  Setting repuls=attrac=delta corresponds to the form used in several\n  recent published MEAM parameter sets, such as (Valone)\n  \n  Note\n  The default form of the erose expression in LAMMPS was corrected\n  in March 2009.  The current version is correct, but may show different\n  behavior compared with earlier versions of lammps with the attrac\n  and/or repuls parameters are non-zero.  To obtain the previous default\n  form, use erose_form = 1 (this form does not seem to appear in the\n  literature).  An alternative form (see e.g. (Lee2)) is\n  available using erose_form = 2.\n  \n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, where types I and J correspond to\n  two different element types, mixing is performed by LAMMPS with\n  user-specifiable parameters as described above.  You never need to\n  specify a pair_coeff command with I != J arguments for this style.\n  This pair style does not support the pair_modify\n  shift, table, and tail options.\n  This pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\n  need to re-specify the pair_style and pair_coeff commands in an input\n  script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style meam/c\n  \n  \n  ",
    "examples": "pair_style meam/c\n  pair_coeff * * ../potentials/library.meam Si ../potentials/si.meam Si\n  pair_coeff * * ../potentials/library.meam Ni Al NULL Ni Al Ni Ni\n  \n  \n  ",
    "restrictions": "The meam/c style is provided in the USER-MEAMC package. It is\n  only enabled if LAMMPS was built with that package.\n  See the Build package doc page for more info.\n  The maximum number of elements, that can be read from the MEAM\n  library file, is determined at compile time. The default is 5.\n  If you need support for more elements, you have to change the\n  define for the constant ‘maxelt’ at the beginning of the file\n  src/USER-MEAMC/meam.h and update/recompile LAMMPS. There is no\n  limit on the number of atoms types.\n  "
},
{
    "command": "pair_style mesocnt",
    "description": "Style mesocnt implements a mesoscopic potential\n  for the interaction of carbon nanotubes (CNTs). In this potential,\n  CNTs are modelled as chains of cylindrical segments in which\n  each infinitesimal surface element interacts with all other\n  CNT surface elements with the Lennard-Jones (LJ) term adopted from\n  the airebo style. The interaction energy\n  is then computed by integrating over the surfaces of all interacting\n  CNTs.\n  The potential is based on interactions between one cylindrical\n  segment and infinitely or semi-infinitely long CNTs as described\n  in (Volkov1). Chains of segments are\n  converted to these (semi-)infinite CNTs bases on an approximate\n  chain approach outlined in (Volkov2).\n  This allows to simplify the computation of the interactions\n  significantly and reduces the computational times to the\n  same order of magnitude as for regular bead spring models\n  where beads interact with the standard pair_lj/cut\n  potential.\n  In LAMMPS, cylindrical segments are represented by bonds. Each\n  segment is defined by its two end points (“nodes”) which correspond\n  to atoms in LAMMPS. For the exact functional form of the potential\n  and implementation details, the reader is referred to the\n  original papers (Volkov1) and\n  (Volkov2).\n  The potential requires tabulated data provided in a single ASCII\n  text file specified in the pair_coeff command.\n  The first line of the file provides a time stamp and\n  general information. The second line lists four integers giving\n  the number of data points provided in the subsequent four\n  data tables. The third line lists four floating point numbers:\n  the CNT radius R, the LJ parameter sigma and two numerical\n  parameters delta1 and delta2. These four parameters are given\n  in Angstroms. This is followed by four data tables each separated\n  by a single empty line. The first two tables have two columns\n  and list the parameters uInfParallel and Gamma respectively.\n  The last two tables have three columns giving data on a quadratic\n  array and list the parameters Phi and uSemiParallel respectively.\n  uInfParallel and uSemiParallel are given in eV/Angstrom, Phi is\n  given in eV and Gamma is unitless.\n  Potential files for CNTs can be readily generated using the freely\n  available code provided on\n  https://github.com/phankl/cntpot\n  \n  \n  Using the same approach, it should also be possible to\n  generate potential files for other 1D systems such as\n  boron nitride nanotubes.\n  \n  Note\n  LAMMPS comes with one mesocnt style potential file\n  where the default number of data points per table is 1001.\n  This is sufficient for NVT simulations. For proper energy\n  conservation, we recommend using a potential file where\n  the resolution for Phi is at least 2001 data points.\n  \n  \n  Note\n  The mesocnt style requires CNTs to be represented\n  as a chain of atoms connected by bonds. Atoms need\n  to be numbered consecutively within one chain.\n  Atoms belonging to different CNTs need to be assigned\n  different molecule IDs.\n  \n  A full summary of the method and LAMMPS implementation details\n  is expected to soon become available in Computer Physics\n  Communications.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This pair style does not support mixing.\n  This pair style does not support the pair_modify\n  shift, table, and tail options.\n  The mesocnt pair style do not write their information to binary restart files,\n  since it is stored in tabulated potential files.\n  Thus, you need to re-specify the pair_style and pair_coeff commands in\n  an input script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  They do not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style mesocnt\n  \n  \n  ",
    "examples": "pair_style mesocnt\n  pair_coeff * * 10_10.cnt\n  \n  \n  ",
    "restrictions": "This style is part of the USER-MISC package.  It is only\n  enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\n  This pair potential requires the newton setting to be\n  “on” for pair interactions.\n  "
},
{
    "command": "pair_style edpd",
    "description": "The edpd style computes the pairwise interactions and heat fluxes\n  for eDPD particles following the formulations in\n  (Li2014_JCP) and Li2015_CC. The time\n  evolution of an eDPD particle is governed by the conservation of\n  momentum and energy given by\n  \n  \\[\\begin{split}\\frac{\\mathrm{d}^2 \\mathbf{r}_i}{\\mathrm{d} t^2}=\n  \\frac{\\mathrm{d} \\mathbf{v}_i}{\\mathrm{d} t}\n  =\\mathbf{F}_{i}=\\sum_{i\\neq j}(\\mathbf{F}_{ij}^{C}+\\mathbf{F}_{ij}^{D}+\\mathbf{F}_{ij}^{R}) \\\\\n  C_v\\frac{\\mathrm{d} T_i}{\\mathrm{d} t}= q_{i} = \\sum_{i\\neq j}(q_{ij}^{C}+q_{ij}^{V}+q_{ij}^{R}),\\end{split}\\]\n  where the three components of \\(F_{i}\\) including the conservative\n  force \\(F_{ij}^C\\), dissipative force \\(F_{ij}^D\\) and random\n  force \\(F_{ij}^R\\) are expressed as\n  \n  \\[\\begin{split}\\mathbf{F}_{ij}^{C} & = \\alpha_{ij}{\\omega_{C}}(r_{ij})\\mathbf{e}_{ij} \\\\\n  \\mathbf{F}_{ij}^{D} & = -\\gamma {\\omega_{D}}(r_{ij})(\\mathbf{e}_{ij} \\cdot \\mathbf{v}_{ij})\\mathbf{e}_{ij} \\\\\n  \\mathbf{F}_{ij}^{R} & = \\sigma {\\omega_{R}}(r_{ij}){\\xi_{ij}}\\Delta t^{-1/2} \\mathbf{e}_{ij} \\\\\n  \\omega_{C}(r) & = 1 - r/r_c \\\\\n  \\alpha_{ij} & = A\\cdot k_B(T_i + T_j)/2 \\\\\n  \\omega_{D}(r) & = \\omega^2_{R}(r) = (1-r/r_c)^s \\\\\n  \\sigma_{ij}^2 & = 4\\gamma k_B T_i T_j/(T_i + T_j)\\end{split}\\]\n  in which the exponent of the weighting function s can be defined as a\n  temperature-dependent variable. The heat flux between particles\n  accounting for the collisional heat flux \\(q^C\\), viscous heat flux\n  \\(q^V\\), and random heat flux \\(q^R\\) are given by\n  \n  \\[\\begin{split}q_i^C & = \\sum_{j \\ne i} k_{ij} \\omega_{CT}(r_{ij}) \\left( \\frac{1}{T_i} - \\frac{1}{T_j} \\right) \\\\\n  q_i^V & = \\frac{1}{2 C_v}\\sum_{j \\ne i}{ \\left\\{ \\omega_D(r_{ij})\\left[\\gamma_{ij} \\left( \\mathbf{e}_{ij} \\cdot \\mathbf{v}_{ij} \\right)^2 - \\frac{\\left( \\sigma _{ij} \\right)^2}{m}\\right] - \\sigma _{ij} \\omega_R(r_{ij})\\left( \\mathbf{e}_{ij} \\cdot \\mathbf{v}_{ij} \\right){\\xi_{ij}} \\right\\} } \\\\\n  q_i^R & = \\sum_{j \\ne i} \\beta _{ij} \\omega_{RT}(r_{ij}) d {t^{ - 1/2}} \\xi_{ij}^e \\\\\n  \\omega_{CT}(r) & =\\omega_{RT}^2(r)=\\left(1-r/r_{ct}\\right)^{s_T} \\\\\n  k_{ij} & =C_v^2\\kappa(T_i + T_j)^2/4k_B \\\\\n  \\beta_{ij}^2 & = 2k_Bk_{ij}\\end{split}\\]\n  where the mesoscopic heat friction \\(\\kappa\\) is given by\n  \n  \\[\\kappa  = \\frac{315k_B\\upsilon }{2\\pi \\rho C_v r_{ct}^5}\\frac{1}{Pr},\\]\n  with \\(\\upsilon\\) being the kinematic viscosity. For more details,\n  see Eq.(15) in (Li2014_JCP).\n  The following coefficients must be defined in eDPD system for each\n  pair of atom types via the pair_coeff command as in\n  the examples above.\n  \n  A (force units)\n  \\(\\gamma\\) (force/velocity units)\n  power_f (positive real)\n  cutoff (distance units)\n  kappa (thermal conductivity units)\n  power_T (positive real)\n  cutoff_T (distance units)\n  optional keyword = power or kappa\n  \n  The keyword power or kappa is optional. Both “power” and “kappa”\n  require 4 parameters \\(c_1, c_2, c_3, c_4\\) showing the temperature\n  dependence of the exponent \\(s(T) = \\mathrm{power}_f ( 1+c_1\n  (T-1) + c_2 (T-1)^2 + c_3 (T-1)^3 + c_4 (T-1)^4 )\\) and of the mesoscopic\n  heat friction \\(s_T(T) = \\kappa (1 + c_1 (T-1) + c_2 (T-1)^2 + c_3\n  (T-1)^3 + c_4 (T-1)^4)\\).  If the keyword power or kappa is not\n  specified, the eDPD system will use constant power_f and\n  \\(\\kappa\\), which is independent to temperature changes.\n  \n  The mdpd/rhosum style computes the local particle mass density\n  \\(\\rho\\) for mDPD particles by kernel function interpolation.\n  The following coefficients must be defined for each pair of atom types\n  via the pair_coeff command as in the examples above.\n  \n  cutoff (distance units)\n  \n  \n  The mdpd style computes the many-body interactions between mDPD\n  particles following the formulations in\n  (Li2013_POF). The dissipative and random forces are in\n  the form same as the classical DPD, but the conservative force is\n  local density dependent, which are given by\n  \n  \\[\\begin{split}\\mathbf{F}_{ij}^C & = Aw_c(r_{ij})\\mathbf{e}_{ij} + B(\\rho_i+\\rho_j)w_d(r_{ij})\\mathbf{e}_{ij} \\\\\n  \\mathbf{F}_{ij}^{D} & = -\\gamma {\\omega_{D}}(r_{ij})(\\mathbf{e}_{ij} \\cdot \\mathbf{v}_{ij})\\mathbf{e}_{ij} \\\\\n  \\mathbf{F}_{ij}^{R} & = \\sigma {\\omega_{R}}(r_{ij}){\\xi_{ij}}\\Delta t^{-1/2} \\mathbf{e}_{ij}\\end{split}\\]\n  where the first term in \\(F_C\\) with a negative coefficient \\(A\n  < 0\\) stands for an attractive force within an interaction range\n  \\(r_c\\), and the second term with \\(B > 0\\) is the\n  density-dependent repulsive force within an interaction range\n  \\(r_d\\).\n  The following coefficients must be defined for each pair of atom types via the\n  pair_coeff command as in the examples above.\n  \n  A (force units)\n  B (force units)\n  \\(\\gamma\\) (force/velocity units)\n  cutoff_c (distance units)\n  cutoff_d (distance units)\n  \n  \n  The tdpd style computes the pairwise interactions and chemical\n  concentration fluxes for tDPD particles following the formulations in\n  (Li2015_JCP).  The time evolution of a tDPD particle is\n  governed by the conservation of momentum and concentration given by\n  \n  \\[\\begin{split}\\frac{\\mathrm{d}^2 \\mathbf{r}_i}{\\mathrm{d} t^2} & = \\frac{\\mathrm{d} \\mathbf{v}_i}{\\mathrm{d} t}=\\mathbf{F}_{i}=\\sum_{i\\neq j}(\\mathbf{F}_{ij}^{C}+\\mathbf{F}_{ij}^{D}+\\mathbf{F}_{ij}^{R}) \\\\\n  \\frac{\\mathrm{d} C_{i}}{\\mathrm{d} t} & = Q_{i} = \\sum_{i\\neq j}(Q_{ij}^{D}+Q_{ij}^{R}) + Q_{i}^{S}\\end{split}\\]\n  where the three components of \\(F_{i}\\) including the conservative\n  force \\(F_{ij}^C\\), dissipative force \\(F_{ij}^C\\) and random\n  force \\(F_{ij}^C\\) are expressed as\n  \n  \\[\\begin{split}\\mathbf{F}_{ij}^{C} & = A{\\omega_{C}}(r_{ij})\\mathbf{e}_{ij} \\\\\n  \\mathbf{F}_{ij}^{D} & = -\\gamma {\\omega_{D}}(r_{ij})(\\mathbf{e}_{ij} \\cdot \\mathbf{v}_{ij})\\mathbf{e}_{ij}  \\\\\n  \\mathbf{F}_{ij}^{R} & = \\sigma {\\omega_{R}}(r_{ij}){\\xi_{ij}}\\Delta t^{-1/2} \\mathbf{e}_{ij} \\\\\n  \\omega_{C}(r) & = 1 - r/r_c \\\\\n  \\omega_{D}(r) & = \\omega^2_{R}(r) = (1-r/r_c)^{\\rm power_f} \\\\\n  \\sigma^2 = 2\\gamma k_B T\\end{split}\\]\n  The concentration flux between two tDPD particles includes the Fickian\n  flux \\(Q_{ij}^D\\) and random flux \\(Q_{ij}^R\\), which are given\n  by\n  \n  \\[\\begin{split}Q_{ij}^D & = -\\kappa_{ij} w_{DC}(r_{ij}) \\left( C_i - C_j \\right) \\\\\n  Q_{ij}^R & = \\epsilon_{ij}\\left( C_i + C_j \\right) w_{RC}(r_{ij}) \\xi_{ij} \\\\\n  w_{DC}(r_{ij}) & =w^2_{RC}(r_{ij}) = (1 - r/r_{cc})^{\\rm power_{cc}} \\\\\n  \\epsilon_{ij}^2 & = m_s^2\\kappa_{ij}\\rho\\end{split}\\]\n  where the parameters kappa and epsilon determine the strength of the\n  Fickian and random fluxes. \\(m_s\\) is the mass of a single solute\n  molecule.  In general, \\(m_s\\) is much smaller than the mass of a\n  tDPD particle m. For more details, see (Li2015_JCP).\n  The following coefficients must be defined for each pair of atom types via the\n  pair_coeff command as in the examples above.\n  \n  A (force units)\n  \\(\\gamma\\) (force/velocity units)\n  power_f (positive real)\n  cutoff (distance units)\n  cutoff_CC (distance units)\n  \\(\\kappa_i\\) (diffusivity units)\n  \\(\\epsilon_i\\) (diffusivity units)\n  power_cc_i (positive real)\n  \n  The last 3 values must be repeated Nspecies times, so that values for\n  each of the Nspecies chemical species are specified, as indicated by\n  the “I” suffix.  In the first pair_coeff example above for pair_style\n  tdpd, Nspecies = 1.  In the second example, Nspecies = 2, so 3\n  additional coeffs are specified (for species 2).\n  \n  Example scripts\n  There are example scripts for using all these pair styles in\n  examples/USER/meso.  The example for an eDPD simulation models heat\n  conduction with source terms analog of periodic Poiseuille flow\n  problem. The setup follows Fig.12 in (Li2014_JCP). The\n  output of the short eDPD simulation (about 2 minutes on a single core)\n  gives a temperature and density profiles as\n  \n  The example for a mDPD simulation models the oscillations of a liquid\n  droplet started from a liquid film. The mDPD parameters are adopted\n  from (Li2013_POF).  The short mDPD run (about 2 minutes\n  on a single core) generates a particle trajectory which can\n  be visualized as follows.\n  \n  \n  The first image is the initial state of the simulation.  If you\n  click it a GIF movie should play in your browser.  The second image\n  is the final state of the simulation.\n  The example for a tDPD simulation computes the effective diffusion\n  coefficient of a tDPD system using a method analogous to the periodic\n  Poiseuille flow.  The tDPD system is specified with two chemical\n  species, and the setup follows Fig.1 in\n  (Li2015_JCP). The output of the short tDPD simulation\n  (about one and a half minutes on a single core) gives the\n  concentration profiles of the two chemical species as\n  \n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  The styles edpd, mdpd, mdpd/rhosum and tdpd do not support\n  mixing. Thus, coefficients for all I,J pairs must be specified explicitly.\n  The styles edpd, mdpd, mdpd/rhosum and tdpd do not support\n  the pair_modify shift, table, and tail options.\n  The styles edpd, mdpd, mdpd/rhosum and tdpd do not write\n  information to binary restart files. Thus, you need\n  to re-specify the pair_style and pair_coeff commands in an input script\n  that reads a restart file.\n  ",
    "syntax": "pair_style style args\n  \n  \n  \n  style = edpd or mdpd or mdpd/rhosum or tdpd\n  args = list of arguments for a particular style\n  edpd args = cutoff seed\n    cutoff = global cutoff for eDPD interactions (distance units)\n    seed = random # seed (integer) (if <= 0, eDPD will use current time as the seed)\n  mdpd args = T cutoff seed\n    T = temperature (temperature units)\n    cutoff = global cutoff for mDPD interactions (distance units)\n    seed = random # seed (integer) (if <= 0, mDPD will use current time as the seed)\n  mdpd/rhosum args =\n  tdpd args = T cutoff seed\n    T = temperature (temperature units)\n    cutoff = global cutoff for tDPD interactions (distance units)\n    seed = random # seed (integer) (if <= 0, tDPD will use current time as the seed)\n  \n  \n  ",
    "examples": "pair_style edpd 1.58 9872598\n  pair_coeff * * 18.75 4.5 0.41 1.58 1.42E-5 2.0 1.58\n  pair_coeff 1 1 18.75 4.5 0.41 1.58 1.42E-5 2.0 1.58 power 10.54 -3.66 3.44 -4.10\n  pair_coeff 1 1 18.75 4.5 0.41 1.58 1.42E-5 2.0 1.58 power 10.54 -3.66 3.44 -4.10 kappa -0.44 -3.21 5.04 0.00\n  \n  pair_style hybrid/overlay mdpd/rhosum mdpd 1.0 1.0 65689\n  pair_coeff 1 1 mdpd/rhosum  0.75\n  pair_coeff 1 1 mdpd -40.0 25.0 18.0 1.0 0.75\n  \n  pair_style tdpd 1.0 1.58 935662\n  pair_coeff * * 18.75 4.5 0.41 1.58 1.58 1.0 1.0E-5 2.0\n  pair_coeff 1 1 18.75 4.5 0.41 1.58 1.58 1.0 1.0E-5 2.0 3.0 1.0E-5 2.0\n  \n  \n  ",
    "restrictions": "The pair styles edpd, mdpd, mdpd/rhosum and tdpd are part of\n  the USER-MESODPD package. It is only enabled if LAMMPS was built with\n  that package.  See the Build package doc page for\n  more info.\n  "
},
{
    "command": "pair_style mgpt",
    "description": "Within DFT quantum mechanics, generalized pseudopotential theory (GPT)\n  (Moriarty1) provides a first-principles approach to\n  multi-ion interatomic potentials in d-band transition metals, with a\n  volume-dependent, real-space total-energy functional for the N-ion\n  elemental bulk material in the form\n  \n  \\[E_{\\rm tot}({\\bf R}_1 \\ldots {\\bf R}_N) = NE_{\\rm vol}(\\Omega )\n  + \\frac{1}{2} \\sum _{i,j} \\mbox{}^\\prime \\ v_2(ij;\\Omega )\n  + \\frac{1}{6} \\sum _{i,j,k} \\mbox{}^\\prime \\ v_3(ijk;\\Omega )\n  + \\frac{1}{24} \\sum _{i,j,k,l} \\mbox{}^\\prime \\ v_4(ijkl;\\Omega )\\]\n  where the prime on each summation sign indicates the exclusion of all\n  self-interaction terms from the summation.  The leading volume term\n  E_vol as well as the two-ion central-force pair potential v_2 and the\n  three- and four-ion angular-force potentials, v_3 and v_4, depend\n  explicitly on the atomic volume Omega, but are structure independent\n  and transferable to all bulk ion configurations, either ordered or\n  disordered, and with of without the presence of point and line\n  defects.  The simplified model GPT or MGPT (Moriarty2,\n  Moriarty3), which retains the form of E_tot and permits\n  more efficient large-scale atomistic simulations, derives from the GPT\n  through a series of systematic approximations applied to E_vol and the\n  potentials v_n that are valid for mid-period transition metals with\n  nearly half-filled d bands.\n  Both analytic (Moriarty2) and matrix\n  (Moriarty3) representations of MGPT have been developed.\n  In the more general matrix representation, which can also be applied\n  to f-band actinide metals and permits both canonical and non-canonical\n  d/f bands, the multi-ion potentials are evaluated on the fly during a\n  simulation through d- or f-state matrix multiplication, and the forces\n  that move the ions are determined analytically.  Fast matrix-MGPT\n  algorithms have been developed independently by Glosli\n  (Glosli, Moriarty3) and by Oppelstrup\n  (Oppelstrup)\n  The mgpt pair style calculates forces, energies, and the total\n  energy per atom, E_tot/N, using the Oppelstrup matrix-MGPT algorithm.\n  Input potential and control data are entered through the\n  pair_coeff command.  Each material treated requires\n  input parmin and potin potential files, as shown in the above\n  examples, as well as specification by the user of the initial atomic\n  volume Omega through pair_coeff.  At the beginning of a time step in\n  any simulation, the total volume of the simulation cell V should\n  always be equal to Omega*N, where N is the number of metal ions\n  present, taking into account the presence of any vacancies and/or\n  interstitials in the case of a solid.  In a constant-volume\n  simulation, which is the normal mode of operation for the mgpt pair\n  style, Omega, V and N all remain constant throughout the simulation\n  and thus are equal to their initial values.  In a constant-stress\n  simulation, the cell volume V will change (slowly) as the simulation\n  proceeds.  After each time step, the atomic volume should be updated\n  by the code as Omega = V/N.  In addition, the volume term E_vol and\n  the potentials v_2, v_3 and v_4 have to be removed at the end of the\n  time step, and then respecified at the new value of Omega.  In all\n  simulations, Omega must remain within the defined volume range for\n  E_vol and the potentials for the given material.\n  The default option volpress yes in the pair_coeff\n  command includes all volume derivatives of E_tot required to calculate\n  the stress tensor and pressure correctly.  The option volpress no\n  disregards the pressure contribution resulting from the volume term\n  E_vol, and can be used for testing and analysis purposes.  The\n  additional optional variable nbody controls the specific terms in\n  E_tot that are calculated.  The default option and the normal option\n  for mid-period transition and actinide metals is nbody 1234 for which\n  all four terms in E_tot are retained.  The option nbody 12, for\n  example, retains only the volume term and the two-ion pair potential\n  term and can be used for GPT series-end transition metals that can be\n  well described without v_3 and v_4.  The nbody option can also be used\n  to test or analyze the contribution of any of the four terms in E_tot\n  to a given calculated property.\n  The mgpt pair style makes extensive use of matrix algebra and\n  includes optimized kernels for the BlueGene/Q architecture and the\n  Intel/AMD (x86) architectures.  When compiled with the appropriate\n  compiler and compiler switches (-msse3 on x86, and using the IBM XL\n  compiler on BG/Q), these optimized routines are used automatically.\n  For BG/Q machines, building with the default Makefile for that\n  architecture (e.g., “make bgq”) should enable the optimized algebra\n  routines.  For x-86 machines, there is a provided Makefile.mgptfast\n  which enables the fast algebra routines, i.e. build LAMMPS with “make\n  mgptfast”.  The user will be informed in the output files of the\n  matrix kernels in use. To further improve speed, on x86 the option\n  precision single can be added to the pair_coeff\n  command line, which improves speed (up to a factor of two) at the cost\n  of doing matrix calculations with 7 digit precision instead of the\n  default 16. For consistency the default option can be specified\n  explicitly by the option precision double.\n  All remaining potential and control data are contained with the parmin\n  and potin files, including cutoffs, atomic mass, and other basic MGPT\n  variables.  Specific MGPT potential data for the transition metals\n  tantalum (Ta4 and Ta6.8x potentials), molybdenum (Mo5.2 potentials),\n  and vanadium (V6.1 potentials) are contained in the LAMMPS potentials\n  directory.  The stored files are, respectively, Ta4.mgpt.parmin,\n  Ta4.mgpt.potin, Ta6.8x.mgpt.parmin, Ta6.8x.mgpt.potin,\n  Mo5.2.mgpt.parmin, Mo5.2.mgpt.potin, V6.1.mgpt.parmin, and\n  V6.1.mgpt.potin .  Useful corresponding informational “README” files\n  on the Ta4, Ta6.8x, Mo5.2 and V6.1 potentials are also included in the\n  potentials directory.  These latter files indicate the volume mesh and\n  range for each potential and give appropriate references for the\n  potentials.  It is expected that MGPT potentials for additional\n  materials will be added over time.\n  Useful example MGPT scripts are given in the examples/USER/mgpt\n  directory.  These scripts show the necessary steps to perform\n  constant-volume calculations and simulations.  It is strongly\n  recommended that the user work through and understand these examples\n  before proceeding to more complex simulations.\n  \n  Note\n  For good performance, LAMMPS should be built with the compiler\n  flags “-O3 -msse3 -funroll-loops” when including this pair style.  The\n  src/MAKE/OPTIONS/Makefile.mgptfast is an example machine Makefile with\n  these options included as part of a standard MPI build.  Note that it\n  as provided, it will build with whatever low-level compiler (g++, icc,\n  etc) is the default for your MPI installation.\n  \n  \n  Mixing, shift, table tail correction, restart:\n  This pair style does not support the pair_modify\n  mix, shift, table, and tail options.\n  This pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\n  needs to re-specify the pair_style and pair_coeff commands in an input\n  script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style mgpt\n  \n  \n  ",
    "examples": "pair_style mgpt\n  pair_coeff * * Ta6.8x.mgpt.parmin Ta6.8x.mgpt.potin Omega\n  cp ~/lammps/potentials/Ta6.8x.mgpt.parmin parmin\n  cp ~/lammps/potentials/Ta6.8x.mgpt.potin potin\n  pair_coeff * * parmin potin Omega volpress yes nbody 1234 precision double\n  pair_coeff * * parmin potin Omega volpress yes nbody 12\n  \n  \n  ",
    "restrictions": "This pair style is part of the USER-MGPT package and is only enabled\n  if LAMMPS is built with that package.  See the Build package doc page for more info.\n  The MGPT potentials require the newtion setting to be\n  “on” for pair style interactions.\n  The stored parmin and potin potential files provided with LAMMPS in\n  the “potentials” directory are written in Rydberg atomic units, with\n  energies in Rydbergs and distances in Bohr radii. The mgpt pair\n  style converts Rydbergs to Hartrees to make the potential files\n  compatible with LAMMPS electron units.\n  The form of E_tot used in the mgpt pair style is only appropriate\n  for elemental bulk solids and liquids.  This includes solids with\n  point and extended defects such as vacancies, interstitials, grain\n  boundaries and dislocations.  Alloys and free surfaces, however,\n  require significant modifications, which are not included in the\n  mgpt pair style.  Likewise, the hybrid pair style is not allowed,\n  where MGPT would be used for some atoms but not for others.\n  Electron-thermal effects are not included in the standard MGPT\n  potentials provided in the “potentials” directory, where the\n  potentials have been constructed at zero electron temperature.\n  Physically, electron-thermal effects may be important in 3d (e.g., V)\n  and 4d (e.g., Mo) transition metals at high temperatures near melt and\n  above.  It is expected that temperature-dependent MGPT potentials for\n  such cases will be added over time.\n  "
},
{
    "command": "pair_style mie/cut",
    "description": "The mie/cut style computes the Mie potential, given by\n  \n  \\[E =  C \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{\\gamma_{rep}} - \\left(\\frac{\\sigma}{r}\\right)^{\\gamma_{att}} \\right]\n                        \\qquad r < r_c\\]\n  Rc is the cutoff and C is a function that depends on the repulsive and\n  attractive exponents, given by:\n  \n  \\[C = \\left(\\frac{\\gamma_{rep}}{\\gamma_{rep}-\\gamma_{att}}\\right) \\left(\\frac{\\gamma_{rep}}{\\gamma_{att}}\\right)^{\\left(\\frac{\\gamma_{att}}{\\gamma_{rep}-\\gamma_{att}}\\right)}\\]\n  Note that for 12/6 exponents, C is equal to 4 and the formula is the\n  same as the standard Lennard-Jones potential.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands, or by mixing as described below:\n  \n  epsilon (energy units)\n  sigma (distance units)\n  gammaR\n  gammaA\n  cutoff (distance units)\n  \n  The last coefficient is optional.  If not specified, the global\n  cutoff specified in the pair_style command is used.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the epsilon and sigma coefficients\n  and cutoff distance for all of the mie/cut pair styles can be mixed.\n  If not explicitly defined, both the repulsive and attractive gamma\n  exponents for different atoms will be calculated following the same\n  mixing rule defined for distances.  The default mix value is\n  geometric. See the “pair_modify” command for details.\n  This pair style supports the pair_modify shift\n  option for the energy of the pair interaction.\n  This pair style supports the pair_modify tail\n  option for adding a long-range tail correction to the energy and\n  pressure of the pair interaction.\n  This pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  This pair style supports the use of the inner, middle, and outer\n  keywords of the run_style respa command, meaning the\n  pairwise forces can be partitioned by distance at different levels of\n  the rRESPA hierarchy.  See the run_style command for\n  details.\n  ",
    "syntax": "pair_style mie/cut cutoff\n  \n  \n  \n  cutoff = global cutoff for mie/cut interactions (distance units)\n  \n  ",
    "examples": "pair_style mie/cut 10.0\n  pair_coeff 1 1 0.72 3.40 23.00 6.66\n  pair_coeff 2 2 0.30 3.55 12.65 6.00\n  pair_coeff 1 2 0.46 3.32 16.90 6.31\n  \n  \n  ",
    "restrictions": "none\n  "
},
{
    "command": "pair_style mm3/switch3/coulgauss/long",
    "description": "The mm3/switch3/coulgauss/long style evaluates the MM3\n  vdW potential (Allinger)\n  \n  \\[\\begin{split}E & = \\epsilon_{ij} \\left[ -2.25 \\left(\\frac{r_{v,ij}}{r_{ij}}\\right)^6 + 1.84(10)^5 \\exp\\left[-12.0 r_{ij}/r_{v,ij}\\right] \\right] S_3(r_{ij}) \\\\\n  r_{v,ij} & =  r_{v,i} + r_{v,j} \\\\\n  \\epsilon_{ij} & = \\sqrt{\\epsilon_i \\epsilon_j}\\end{split}\\]\n  , which goes smoothly to zero at the cutoff r_c as defined\n  by the switching function\n  \n  \\[\\begin{split}S_3(r) = \\left\\lbrace \\begin{array}{ll}\n                      1 & \\quad\\mathrm{if}\\quad r < r_\\mathrm{c} - w \\\\\n                      3x^2 - 2x^3 & \\quad\\mathrm{if}\\quad r < r_\\mathrm{c} \\quad\\mathrm{with\\quad} x=\\frac{r_\\mathrm{c} - r}{w} \\\\\n                      0 & \\quad\\mathrm{if}\\quad r >= r_\\mathrm{c}\n                  \\end{array} \\right.\\end{split}\\]\n  where w is the width defined in the arguments. This potential\n  is combined with Coulomb interaction between Gaussian charge densities:\n  \n  \\[E = \\frac{q_i q_j \\mathrm{erf}\\left( r/\\sqrt{\\gamma_1^2+\\gamma_2^2} \\right) }{\\epsilon r_{ij}}\\]\n  where \\(q_i\\) and \\(q_j\\) are the charges on the 2 atoms,\n  epsilon is the dielectric constant which can be set by the\n  dielectric command, :\\(\\gamma_i\\) and\n  \\(\\gamma_j\\) are the widths of the Gaussian charge distribution and\n  erf() is the error-function.  This style has to be used in conjunction\n  with the kspace_style command\n  If one cutoff is specified it is used for both the vdW and Coulomb\n  terms.  If two cutoffs are specified, the first is used as the cutoff\n  for the vdW terms, and the second is the cutoff for the Coulombic term.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands:\n  \n  \\(\\epsilon\\) (energy)\n  \\(r_v\\) (distance)\n  \\(\\gamma\\) (distance)\n  \n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  Mixing rules are fixed for this style as defined above.\n  Shifting the potential energy is not necessary because the switching\n  function ensures that the potential is zero at the cut-off.\n  ",
    "syntax": "pair_style style args\n  \n  \n  \n  style = mm3/switch3/coulgauss/long\n  args = list of arguments for a particular style\n  \n  mm3/switch3/coulgauss/long args = cutoff (cutoff2) width\n    cutoff  = global cutoff for MM3 (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n    width  = width parameter of the smoothing function (distance units)\n  ",
    "examples": "pair_style mm3/switch3/coulgauss/long    12.0 3.0\n  pair_coeff 1  0.2 2.5 1.2\n  \n  pair_style mm3/switch3/coulgauss/long   12.0 10.0 3.0\n  pair_coeff 1  0.2 2.5 1.2\n  \n  \n  ",
    "restrictions": "These styles are part of the USER-YAFF package.  They are only\n  enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style momb",
    "description": "Style momb computes pairwise van der Waals (vdW) and short-range\n  interactions using the Morse potential and (Grimme) method\n  implemented in the Many-Body Metal-Organic (MOMB) force field\n  described comprehensively in (Fichthorn) and\n  (Zhou). Grimme’s method is widely used to correct for\n  dispersion in density functional theory calculations.\n  \n  \\[\\begin{split} E & = D_0 [\\exp^{-2 \\alpha (r-r_0)} - 2\\exp^{-\\alpha (r-r_0)}] - s_6 \\frac{C_6}{r^6} f_{damp}(r,R_r) \\\\\n  f_{damp}(r,R_r) & = \\frac{1}{1 + \\exp^{-d(r/R_r - 1)}}\\end{split}\\]\n  For the momb pair style, the following coefficients must be defined\n  for each pair of atoms types via the pair_coeff\n  command as in the examples above, or in the data file or restart files\n  read by the read_data as described below:\n  \n  \\(D_0\\) (energy units)\n  \\(\\alpha\\) (1/distance units)\n  \\(r_0\\) (distance units)\n  \\(C_6\\) (energy*distance^6 units)\n  \\(R_r\\) (distance units, typically sum of atomic vdW radii)\n  \n  ",
    "syntax": "pair_style momb cutoff s6 d\n  \n  \n  \n  cutoff = global cutoff (distance units)\n  s6 = global scaling factor of the exchange-correlation functional used (unitless)\n  d = damping scaling factor of Grimme’s method (unitless)\n  \n  ",
    "examples": "pair_style momb 12.0 0.75 20.0\n  pair_style hybrid/overlay eam/fs lj/charmm/coul/long 10.0 12.0 momb 12.0 0.75 20.0 morse 5.5\n  \n  pair_coeff 1 2 momb 0.0 1.0 1.0 10.2847 2.361\n  \n  \n  ",
    "restrictions": "This style is part of the USER-MISC package. It is only enabled if\n  LAMMPS is built with that package. See the Build package doc page on for more info.\n  "
},
{
    "command": "pair_style morse",
    "description": "Style morse computes pairwise interactions with the formula\n  \n  \\[E = D_0 \\left[ e^{- 2 \\alpha (r - r_0)} - 2 e^{- \\alpha (r - r_0)} \\right]\n      \\qquad r < r_c\\]\n  Rc is the cutoff.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands:\n  \n  \\(D_0\\) (energy units)\n  \\(\\alpha\\) (1/distance units)\n  \\(r_0\\) (distance units)\n  cutoff (distance units)\n  \n  The last coefficient is optional.  If not specified, the global morse\n  cutoff is used.\n  \n  The morse/smooth/linear variant is similar to the lj/smooth/linear\n  variant in that it adds to the potential a shift and a linear term\n  so that both, potential energy and force, go to zero at the cut-off:\n  \n  \\[\\begin{split}\\phi\\left(r\\right) & =  D_0 \\left[ e^{- 2 \\alpha (r - r_0)} - 2 e^{- \\alpha (r - r_0)} \\right] \\qquad r < r_c \\\\\n  E\\left(r\\right) & =  \\phi\\left(r\\right)  - \\phi\\left(R_c\\right) - \\left(r - R_c\\right) \\left.\\frac{d\\phi}{d r} \\right|_{r=R_c}       \\qquad r < R_c\\end{split}\\]\n  The syntax of the pair_style and pair_coeff commands are the same for\n  the morse and morse/smooth/linear styles.\n  \n  A version of the morse style with a soft core, morse/soft,\n  suitable for use in free energy calculations, is part of the USER-FEP\n  package and is documented with the pair_style */soft styles. The version with soft core is only available if\n  LAMMPS was built with that package. See the Build package doc page for more info.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  None of these pair styles support mixing.  Thus, coefficients for all\n  I,J pairs must be specified explicitly.\n  All of these pair styles support the pair_modify\n  shift option for the energy of the pair interaction.\n  The pair_modify table options is not relevant for\n  the Morse pair styles.\n  None of these pair styles support the pair_modify\n  tail option for adding long-range tail corrections to energy and\n  pressure.\n  All of these pair styles write their information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  These pair styles can only be used via the pair keyword of the\n  run_style respa command.  They do not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style style args\n  \n  \n  \n  style = morse or morse/smooth/linear or morse/soft\n  args = list of arguments for a particular style\n  \n  morse args = cutoff\n    cutoff = global cutoff for Morse interactions (distance units)\n  morse/smooth/linear args = cutoff\n    cutoff = global cutoff for Morse interactions (distance units)\n  ",
    "examples": "pair_style morse 2.5\n  pair_style morse/smooth/linear 2.5\n  pair_coeff * * 100.0 2.0 1.5\n  pair_coeff 1 1 100.0 2.0 1.5 3.0\n  \n  \n  ",
    "restrictions": "The morse/smooth/linear pair style is only enabled if LAMMPS was\n  built with the USER-MISC package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style multi/lucy",
    "description": "Style multi/lucy computes a density-dependent force following from\n  the many-body form described in (Moore) and\n  (Warren) as\n  \n  \\[F_{i}^{DD}(\\rho_i,\\rho_j,r_{ij}) = \\frac{1}{2} \\omega_{DD}\\left(r_{ij}\\right)\n  \\left[A\\left(\\rho_i\\right) + A\\left(\\rho_j\\right)\\right]e_{ij}\\]\n  which consists of a density-dependent function, \\(A(\\rho)\\), and a\n  radial-dependent weight function, \\(\\omega_{DD}(r_{ij})\\).  The\n  radial-dependent weight function, \\(\\omega_{DD}(r_{ij})\\), is taken\n  as the Lucy function:\n  \n  \\[\\omega_{DD}\\left(r_{ij}\\right) = \\left(1+\\frac{3r_{ij}}{r_{cut}}\\right)\\left(1+\\frac{r_{ij}}{r_{cut}}\\right)^3\\]\n  The density-dependent energy for a given particle is given by:\n  \n  \\[u_{i}^{DD}\\left(\\rho_{i}\\right) = \\frac{\\pi r_{cut}^4}{84} \\int_{\\rho_0}^{\\rho_i} A\\left(\\rho'\\right) d\\rho'\\]\n  See the supporting information of (Brennan) or the\n  publication by (Moore) for more details on the functional\n  form.\n  An interpolation table is used to evaluate the density-dependent energy\n  (\\(\\int A(\\rho') d\\rho'\\)) and force (\\(A(\\rho')\\)).  Note that\n  the pre-factor to the energy is computed after the interpolation, thus\n  the \\(\\int A(\\rho') d \\rho'\\) will have units of energy / length^4.\n  The interpolation table is created as a pre-computation by fitting\n  cubic splines to the file values and interpolating the\n  density-dependent energy and force at each of N densities.  During a\n  simulation, the tables are used to interpolate the density-dependent\n  energy and force as needed for each pair of particles separated by a\n  distance R.  The interpolation is done in one of 2 styles: lookup\n  and linear.\n  For the lookup style, the density is used to find the nearest table\n  entry, which is the density-dependent energy and force.\n  For the linear style, the density is used to find the 2 surrounding\n  table values from which the density-dependent energy and force are\n  computed by linear interpolation.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above.\n  \n  filename\n  keyword\n  cutoff (distance units)\n  \n  The filename specifies a file containing the tabulated\n  density-dependent energy and force.  The keyword specifies a section\n  of the file.  The cutoff is an optional coefficient.  If not\n  specified, the outer cutoff in the table itself (see below) will be\n  used to build an interpolation table that extend to the largest\n  tabulated distance.  If specified, only file values up to the cutoff\n  are used to create the interpolation table.  The format of this file\n  is described below.\n  \n  The format of a tabulated file is a series of one or more sections,\n  defined as follows (without the parenthesized comments):\n  # Density-dependent function (one or more comment or blank lines)\n  \n  DD-FUNCTION                (keyword is first text on line)\n  N 500 R 1.0 10.0           (N, R, RSQ parameters)\n                             (blank)\n  1 1.0 25.5 102.34          (index, density, energy/r^4, force)\n  2 1.02 23.4 98.5\n  ...\n  500 10.0 0.001 0.003\n  A section begins with a non-blank line whose 1st character is not a\n  “#”; blank lines or lines starting with “#” can be used as comments\n  between sections.  The first line begins with a keyword which\n  identifies the section.  The line can contain additional text, but the\n  initial text must match the argument specified in the pair_coeff\n  command.  The next line lists (in any order) one or more parameters\n  for the table.  Each parameter is a keyword followed by one or more\n  numeric values.\n  The parameter “N” is required and its value is the number of table\n  entries that follow.  Note that this may be different than the N\n  specified in the pair_style multi/lucy command.\n  Let Ntable = N in the pair_style command, and Nfile = “N” in the\n  tabulated file.  What LAMMPS does is a preliminary interpolation by\n  creating splines using the Nfile tabulated values as nodal points.  It\n  uses these to interpolate the density-dependent energy and force at\n  Ntable different points.  The resulting tables of length Ntable are\n  then used as described above, when computing the density-dependent\n  energy and force.  This means that if you want the interpolation\n  tables of length Ntable to match exactly what is in the tabulated file\n  (with effectively no preliminary interpolation), you should set Ntable\n  = Nfile, and use the “RSQ” parameter.  This is because the internal\n  table abscissa is always RSQ (separation distance squared), for\n  efficient lookup.\n  All other parameters are optional.  If “R” or “RSQ” does\n  not appear, then the distances in each line of the table are used\n  as-is to perform spline interpolation.  In this case, the table values\n  can be spaced in density uniformly or however you wish to position table\n  values in regions of large gradients.\n  If used, the parameters “R” or “RSQ” are followed by 2 values rlo and\n  rhi.  If specified, the density associated with each\n  density-dependent energy and force value is computed from these 2 values\n  (at high accuracy), rather than using the (low-accuracy) value listed in\n  each line of the table.  The density values in the table file are\n  ignored in this case.  For “R”, distances uniformly spaced between rlo\n  and rhi are computed; for “RSQ”, squared distances uniformly spaced\n  between rlo*rlo and rhi*rhi are computed.\n  \n  Note\n  If you use “R” or “RSQ”, the tabulated distance values in the file\n  are effectively ignored, and replaced by new values as described in\n  the previous paragraph.  If the density value in the table is not\n  very close to the new value (i.e. round-off difference), then you\n  will be assigning density-dependent energy and force values to a\n  different density, which is probably not what you want.  LAMMPS will\n  warn if this is occurring.\n  \n  Following a blank line, the next N lines list the tabulated values.\n  On each line, the 1st value is the index from 1 to N, the 2nd value is\n  r (in density units), the 3rd value is the density-dependent function value\n  (in energy units / length^4), and the 4th is the force (in force units).  The\n  density values must increase from one line to the next.\n  Note that one file can contain many sections, each with a tabulated\n  potential.  LAMMPS reads the file section by section until it finds\n  one that matches the specified keyword.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This pair style does not support mixing.  Thus, coefficients for all\n  I,J pairs must be specified explicitly.\n  The pair_modify shift, table, and tail options are\n  not relevant for this pair style.\n  This pair style writes the settings for the “pair_style multi/lucy” command\n  to binary restart files, so a pair_style command does\n  not need to specified in an input script that reads a restart file.\n  However, the coefficient information is not stored in the restart\n  file, since it is tabulated in the potential files.  Thus, pair_coeff\n  commands do need to be specified in the restart input script.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style multi/lucy style N keyword ...\n  \n  \n  \n  style = lookup or linear = method of interpolation\n  N = use N values in lookup, linear tables\n  \n  ",
    "examples": "pair_style multi/lucy linear 1000\n  pair_coeff * * multibody.table ENTRY1 7.0\n  \n  \n  ",
    "restrictions": "This command is part of the USER-DPD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style multi/lucy/rx",
    "description": "Style multi/lucy/rx is used in reaction DPD simulations, where the\n  coarse-grained (CG) particles are composed of m species whose\n  reaction rate kinetics are determined from a set of n reaction rate\n  equations through the fix rx command.  The species of\n  one CG particle can interact with a species in a neighboring CG\n  particle through a site-site interaction potential model.  Style\n  multi/lucy/rx computes the site-site density-dependent force\n  following from the many-body form described in (Moore) and\n  (Warren) as\n  \n  \\[F_{i}^{DD}(\\rho_i,\\rho_j,r_{ij}) = \\frac{1}{2} \\omega_{DD}\\left(r_{ij}\\right)\n  \\left[A\\left(\\rho_i\\right) + A\\left(\\rho_j\\right)\\right]e_{ij}\\]\n  which consists of a density-dependent function, \\(A(\\rho)\\), and a\n  radial-dependent weight function, \\(\\omega_{DD}(r_{ij})\\).  The\n  radial-dependent weight function, \\(\\omega_{DD}(r_{ij})\\), is taken\n  as the Lucy function:\n  \n  \\[\\omega_{DD}\\left(r_{ij}\\right) = \\left(1+\\frac{3r_{ij}}{r_{cut}}\\right)\\left(1+\\frac{r_{ij}}{r_{cut}}\\right)^3\\]\n  The density-dependent energy for a given particle is given by:\n  \n  \\[u_{i}^{DD}\\left(\\rho_{i}\\right) = \\frac{\\pi r_{cut}^4}{84} \\int_{\\rho_0}^{\\rho_i} A\\left(\\rho'\\right) d\\rho'\\]\n  See the supporting information of (Brennan) or the\n  publication by (Moore) for more details on the functional\n  form.\n  An interpolation table is used to evaluate the density-dependent energy\n  (\\(\\int A(\\rho') d \\rho'\\)) and force (\\(A(\\rho')\\)).  Note that\n  the pre-factor to the energy is computed after the interpolation, thus\n  the \\(\\int A(\\rho') d\\rho'\\) will have units of energy / length^4.\n  The interpolation table is created as a pre-computation by fitting\n  cubic splines to the file values and interpolating the\n  density-dependent energy and force at each of N densities.  During a\n  simulation, the tables are used to interpolate the density-dependent\n  energy and force as needed for each pair of particles separated by a\n  distance R.  The interpolation is done in one of 2 styles: lookup\n  and linear.\n  For the lookup style, the density is used to find the nearest table\n  entry, which is the density-dependent energy and force.\n  For the linear style, the density is used to find the 2 surrounding\n  table values from which the density-dependent energy and force are\n  computed by linear interpolation.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above.\n  \n  filename\n  keyword\n  species1\n  species2\n  cutoff (distance units)\n  \n  The filename specifies a file containing the tabulated\n  density-dependent energy and force.  The keyword specifies a section\n  of the file.  The cutoff is an optional coefficient.  If not\n  specified, the outer cutoff in the table itself (see below) will be\n  used to build an interpolation table that extend to the largest\n  tabulated distance.  If specified, only file values up to the cutoff\n  are used to create the interpolation table.  The format of this file\n  is described below.\n  The species tags define the site-site interaction potential between\n  two species contained within two different particles.  The species\n  tags must either correspond to the species defined in the reaction\n  kinetics files specified with the fix rx command or they\n  must correspond to the tag “1fluid”, signifying interaction with a\n  product species mixture determined through a one-fluid approximation.\n  The interaction potential is weighted by the geometric average of\n  either the mole fraction concentrations or the number of molecules\n  associated with the interacting coarse-grained particles (see the\n  fractional or molecular weighting pair style options). The coarse-grained potential is\n  stored before and after the reaction kinetics solver is applied, where\n  the difference is defined to be the internal chemical energy (uChem).\n  \n  The format of a tabulated file is a series of one or more sections,\n  defined as follows (without the parenthesized comments):\n  # Density-dependent function (one or more comment or blank lines)\n  \n  DD-FUNCTION                (keyword is first text on line)\n  N 500 R 1.0 10.0           (N, R, RSQ parameters)\n                             (blank)\n  1 1.0 25.5 102.34          (index, density, energy/r^4, force)\n  2 1.02 23.4 98.5\n  ...\n  500 10.0 0.001 0.003\n  A section begins with a non-blank line whose 1st character is not a\n  “#”; blank lines or lines starting with “#” can be used as comments\n  between sections.  The first line begins with a keyword which\n  identifies the section.  The line can contain additional text, but the\n  initial text must match the argument specified in the pair_coeff\n  command.  The next line lists (in any order) one or more parameters\n  for the table.  Each parameter is a keyword followed by one or more\n  numeric values.\n  The parameter “N” is required and its value is the number of table\n  entries that follow.  Note that this may be different than the N\n  specified in the pair_style multi/lucy/rx\n  command.  Let Ntable = N in the pair_style command, and Nfile = “N”\n  in the tabulated file.  What LAMMPS does is a preliminary\n  interpolation by creating splines using the Nfile tabulated values as\n  nodal points.  It uses these to interpolate the density-dependent\n  energy and force at Ntable different points.  The resulting tables of\n  length Ntable are then used as described above, when computing the\n  density-dependent energy and force.  This means that if you want the\n  interpolation tables of length Ntable to match exactly what is in the\n  tabulated file (with effectively no preliminary interpolation), you\n  should set Ntable = Nfile, and use the “RSQ” parameter.  This is\n  because the internal table abscissa is always RSQ (separation distance\n  squared), for efficient lookup.\n  All other parameters are optional.  If “R” or “RSQ” does not appear,\n  then the distances in each line of the table are used as-is to perform\n  spline interpolation.  In this case, the table values can be spaced in\n  density uniformly or however you wish to position table values in\n  regions of large gradients.\n  If used, the parameters “R” or “RSQ” are followed by 2 values rlo\n  and rhi.  If specified, the density associated with each\n  density-dependent energy and force value is computed from these 2\n  values (at high accuracy), rather than using the (low-accuracy) value\n  listed in each line of the table.  The density values in the table\n  file are ignored in this case.  For “R”, distances uniformly spaced\n  between rlo and rhi are computed; for “RSQ”, squared distances\n  uniformly spaced between rlo*rlo and rhi*rhi are computed.\n  \n  Note\n  If you use “R” or “RSQ”, the tabulated distance values in the\n  file are effectively ignored, and replaced by new values as described\n  in the previous paragraph.  If the density value in the table is not\n  very close to the new value (i.e. round-off difference), then you will\n  be assigning density-dependent energy and force values to a different\n  density, which is probably not what you want.  LAMMPS will warn if\n  this is occurring.\n  \n  Following a blank line, the next N lines list the tabulated values.\n  On each line, the 1st value is the index from 1 to N, the 2nd value is\n  r (in density units), the 3rd value is the density-dependent function\n  value (in energy units / length^4), and the 4th is the force (in force\n  units).  The density values must increase from one line to the next.\n  Note that one file can contain many sections, each with a tabulated\n  potential.  LAMMPS reads the file section by section until it finds\n  one that matches the specified keyword.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This pair style does not support mixing.  Thus, coefficients for all\n  I,J pairs must be specified explicitly.\n  The pair_modify shift, table, and tail options are\n  not relevant for this pair style.\n  This pair style writes the settings for the “pair_style multi/lucy/rx” command\n  to binary restart files, so a pair_style command does\n  not need to specified in an input script that reads a restart file.\n  However, the coefficient information is not stored in the restart\n  file, since it is tabulated in the potential files.  Thus, pair_coeff\n  commands do need to be specified in the restart input script.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "pair_style multi/lucy/rx style N keyword ...\n  \n  \n  \n  style = lookup or linear = method of interpolation\n  N = use N values in lookup, linear tables\n  weighting = fractional or molecular (optional)\n  \n  ",
    "examples": "pair_style multi/lucy/rx linear 1000\n  pair_style multi/lucy/rx linear 1000 fractional\n  pair_style multi/lucy/rx linear 1000 molecular\n  pair_coeff * * multibody.table ENTRY1 h2o h2o 7.0\n  pair_coeff * * multibody.table ENTRY1 h2o 1fluid 7.0\n  \n  \n  ",
    "restrictions": "This command is part of the USER-DPD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style nb3b/harmonic",
    "description": "This pair style computes a non-bonded 3-body harmonic potential for the\n  energy E of a system of atoms as\n  \n  \\[E = K (\\theta - \\theta_0)^2\\]\n  where \\(\\theta_0\\) is the equilibrium value of the angle and K is a\n  prefactor. Note that the usual 1/2 factor is included in K. The form\n  of the potential is identical to that used in angle_style harmonic,\n  but in this case, the atoms do not need to be explicitly bonded.\n  Only a single pair_coeff command is used with this style which\n  specifies a potential file with parameters for specified elements.\n  These are mapped to LAMMPS atom types by specifying N additional\n  arguments after the filename in the pair_coeff command, where N is the\n  number of LAMMPS atom types:\n  \n  filename\n  N element names = mapping of elements to atom types\n  \n  See the pair_coeff doc page for alternate ways\n  to specify the path for the potential file.\n  As an example, imagine a file SiC.nb3b.harmonic has potential values\n  for Si and C.  If your LAMMPS simulation has 4 atoms types and you\n  want the 1st 3 to be Si, and the 4th to be C, you would use the\n  following pair_coeff command:\n  pair_coeff * * SiC.nb3b.harmonic Si Si Si C\n  \n  \n  The 1st 2 arguments must be * * so as to span all LAMMPS atom types.\n  The first three Si arguments map LAMMPS atom types 1,2,3 to the Si\n  element in the potential file.  The final C argument maps LAMMPS atom\n  type 4 to the C element in the potential file.  If a mapping value is\n  specified as NULL, the mapping is not performed.  This can be used\n  when the potential is used as part of the hybrid pair style.  The\n  NULL values are placeholders for atom types that will be used with\n  other potentials. An example of a pair_coeff command for use with the\n  hybrid pair style is:\n  pair_coeff * * nb3b/harmonic MgOH.nb3b.harmonic Mg O H\n  \n  \n  Three-body non-bonded harmonic files in the potentials directory of\n  the LAMMPS distribution have a “.nb3b.harmonic” suffix.  Lines that\n  are not blank or comments (starting with #) define parameters for a\n  triplet of elements.\n  Each entry has six arguments. The first three are atom types as\n  referenced in the LAMMPS input file. The first argument specifies the\n  central atom. The fourth argument indicates the K parameter. The\n  fifth argument indicates \\(\\theta_0\\). The sixth argument indicates a\n  separation cutoff in Angstroms.\n  For a given entry, if the second and third arguments are identical,\n  then the entry is for a cutoff for the distance between types 1 and 2\n  (values for K and \\(\\theta_0\\) are irrelevant in this case).\n  For a given entry, if the first three arguments are all different, then\n  the entry is for the K and \\(\\theta_0\\) parameters (the cutoff in\n  this case is irrelevant).\n  It is required that the potential file contains entries for all\n  permutations of the elements listed in the pair_coeff command.\n  If certain combinations are not parameterized the corresponding\n  parameters should be set to zero. The potential file can also\n  contain entries for additional elements which are not used in\n  a particular simulation; LAMMPS ignores those entries.\n  ",
    "syntax": "pair_style nb3b/harmonic\n  \n  \n  ",
    "examples": "pair_style nb3b/harmonic\n  pair_coeff * * MgOH.nb3bharmonic Mg O H\n  \n  \n  ",
    "restrictions": "This pair style can only be used if LAMMPS was built with the MANYBODY\n  package.  See the Build package doc page for more\n  info.\n  "
},
{
    "command": "pair_style nm/cut",
    "description": "Style nm computes site-site interactions based on the N-M potential\n  by Clarke, mainly used for ionic liquids.  A site can\n  represent a single atom or a united-atom site.  The energy of an\n  interaction has the following form:\n  \n  \\[E = \\frac{E_0}{(n-m)} \\left[ m \\left(\\frac{r_0}{r}\\right)^n - n\n  \\left(\\frac{r_0}{r}\\right)^m \\right] \\qquad r < r_c\\]\n  where \\(r_c\\) is the cutoff.\n  Style nm/cut/coul/cut adds a Coulombic pairwise interaction given by\n  \n  \\[E = \\frac{C q_i q_j}{\\epsilon  r} \\qquad r < r_c\\]\n  where \\(C\\) is an energy-conversion constant, \\(q_i\\) and \\(q_j\\)\n  are the charges on the 2 atoms, and epsilon is the dielectric constant which can\n  be set by the dielectric command.  If one cutoff is\n  specified in the pair_style command, it is used for both the N-M and Coulombic\n  terms.  If two cutoffs are specified, they are used as cutoffs for the N-M and\n  Coulombic terms respectively.\n  Styles nm/cut/coul/long compute the same\n  Coulombic interactions as style nm/cut/coul/cut except that an\n  additional damping factor is applied to the Coulombic term so it can\n  be used in conjunction with the kspace_style\n  command and its ewald or pppm option.  The Coulombic cutoff\n  specified for this style means that pairwise interactions within this\n  distance are computed directly; interactions outside that distance are\n  computed in reciprocal space.\n  For all of the nm pair styles, the following coefficients must\n  be defined for each pair of atoms types\n  via the pair_coeff command as in the\n  examples above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands.\n  \n  \\(E_0\\) (energy units)\n  \\(r_0\\) (distance units)\n  \\(n\\) (unitless)\n  \\(m\\) (unitless)\n  cutoff1 (distance units)\n  cutoff2 (distance units)\n  \n  The latter 2 coefficients are optional.  If not specified, the global\n  N-M and Coulombic cutoffs specified in the pair_style command are used.\n  If only one cutoff is specified, it is used as the cutoff for both N-M\n  and Coulombic interactions for this type pair.  If both coefficients\n  are specified, they are used as the N-M and Coulombic cutoffs for this\n  type pair.  You cannot specify 2 cutoffs for style nm, since it\n  has no Coulombic terms.\n  For nm/cut/coul/long only the N-M cutoff can be specified since a\n  Coulombic cutoff cannot be specified for an individual I,J type pair.\n  All type pairs use the same global Coulombic cutoff specified in the\n  pair_style command.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  These pair styles do not support mixing. Thus, coefficients for all\n  I,J pairs must be specified explicitly.\n  All of the nm pair styles supports the\n  pair_modify shift option for the energy of the pair\n  interaction.\n  The nm/cut/coul/long pair styles support the\n  pair_modify table option since they can tabulate\n  the short-range portion of the long-range Coulombic interaction.\n  All of the nm pair styles support the pair_modify\n  tail option for adding a long-range tail correction to the energy and\n  pressure for the N-M portion of the pair interaction.\n  All of the nm pair styles write their information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  All of the nm pair styles can only be used via the pair keyword of\n  the run_style respa command.  They do not support the\n  inner, middle, outer keywords.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "pair_style style args\n  \n  \n  \n  style = nm/cut or nm/cut/coul/cut or nm/cut/coul/long\n  args = list of arguments for a particular style\n  nm/cut args = cutoff\n    cutoff = global cutoff for Pair interactions (distance units)\n  nm/cut/coul/cut args = cutoff (cutoff2)\n    cutoff = global cutoff for Pair (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  nm/cut/coul/long args = cutoff (cutoff2)\n    cutoff = global cutoff for Pair (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  \n  \n  ",
    "examples": "pair_style nm/cut 12.0\n  pair_coeff * * 0.01 5.4 8.0 7.0\n  pair_coeff 1 1 0.01 4.4 7.0 6.0\n  \n  pair_style nm/cut/coul/cut 12.0 15.0\n  pair_coeff * * 0.01 5.4 8.0 7.0\n  pair_coeff 1 1 0.01 4.4 7.0 6.0\n  \n  pair_style nm/cut/coul/long 12.0 15.0\n  pair_coeff * * 0.01 5.4 8.0 7.0\n  pair_coeff 1 1 0.01 4.4 7.0 6.0\n  \n  \n  ",
    "restrictions": "These pair styles are part of the MISC package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style none",
    "description": "Using a pair style of none means pair forces and energies are not\n  computed.\n  With this choice, the force cutoff is 0.0, which means that only atoms\n  within the neighbor skin distance (see the neighbor\n  command) are communicated between processors.  You must insure the\n  skin distance is large enough to acquire atoms needed for computing\n  bonds, angles, etc.\n  A pair style of none will also prevent pairwise neighbor lists from\n  being built.  However if the neighbor style is bin,\n  data structures for binning are still allocated.  If the neighbor skin\n  distance is small, then these data structures can consume a large\n  amount of memory.  So you should either set the neighbor style to\n  nsq or set the skin distance to a larger value.\n  See the pair_style zero for a way to trigger the\n  building of a neighbor lists, but compute no pairwise interactions.\n  ",
    "syntax": "pair_style none\n  \n  \n  ",
    "examples": "pair_style none\n  \n  \n  ",
    "restrictions": "none\n  "
},
{
    "command": "pair_style oxdna/excv",
    "description": "The oxdna pair styles compute the pairwise-additive parts of the oxDNA force field\n  for coarse-grained modelling of DNA. The effective interaction between the nucleotides consists of potentials for the\n  excluded volume interaction oxdna/excv, the stacking oxdna/stk, cross-stacking oxdna/xstk\n  and coaxial stacking interaction oxdna/coaxstk as well\n  as the hydrogen-bonding interaction oxdna/hbond between complementary pairs of nucleotides on\n  opposite strands. Average sequence or sequence-dependent stacking and base-pairing strengths\n  are supported (Sulc). Quasi-unique base-pairing between nucleotides can be achieved by using\n  more complementary pairs of atom types like 5-8 and 6-7, 9-12 and 10-11, 13-16 and 14-15, etc.\n  This prevents the hybridization of in principle complementary bases within Ntypes/4 bases\n  up and down along the backbone.\n  The exact functional form of the pair styles is rather complex.\n  The individual potentials consist of products of modulation factors,\n  which themselves are constructed from a number of more basic potentials\n  (Morse, Lennard-Jones, harmonic angle and distance) as well as quadratic smoothing and modulation terms.\n  We refer to (Ouldridge-DPhil) and (Ouldridge)\n  for a detailed description of the oxDNA force field.\n  \n  Note\n  These pair styles have to be used together with the related oxDNA bond style\n  oxdna/fene for the connectivity of the phosphate backbone (see also documentation of\n  bond_style oxdna/fene). Most of the coefficients\n  in the above example have to be kept fixed and cannot be changed without reparameterizing the entire model.\n  Exceptions are the first four coefficients after oxdna/stk (seq=seqdep, T=0.1, xi=1.3448 and kappa=2.6568 in the above example)\n  and the first coefficient after oxdna/hbond (seq=seqdep in the above example).\n  When using a Langevin thermostat, e.g. through fix langevin\n  or fix nve/dotc/langevin\n  the temperature coefficients have to be matched to the one used in the fix.\n  \n  Example input and data files for DNA duplexes can be found in examples/USER/cgdna/examples/oxDNA/ and /oxDNA2/.\n  A simple python setup tool which creates single straight or helical DNA strands,\n  DNA duplexes or arrays of DNA duplexes can be found in examples/USER/cgdna/util/.\n  Please cite (Henrich) in any publication that uses\n  this implementation.  The article contains general information\n  on the model, its implementation and performance as well as the structure of\n  the data and input file. The preprint version of the article can be found\n  here.\n  Please cite also the relevant oxDNA publications\n  (Ouldridge),\n  (Ouldridge-DPhil)\n  and (Sulc).\n  ",
    "syntax": "pair_style style1\n  \n  pair_coeff * * style2 args\n  \n  \n  \n  style1 = hybrid/overlay oxdna/excv oxdna/stk oxdna/hbond oxdna/xstk oxdna/coaxstk\n  style2 = oxdna/excv or oxdna/stk or oxdna/hbond or oxdna/xstk or oxdna/coaxstk\n  args = list of arguments for these particular styles\n  \n  oxdna/stk args = seq T xi kappa 6.0 0.4 0.9 0.32 0.75 1.3 0 0.8 0.9 0 0.95 0.9 0 0.95 2.0 0.65 2.0 0.65\n    seq = seqav (for average sequence stacking strength) or seqdep (for sequence-dependent stacking strength)\n    T = temperature (oxDNA units, 0.1 = 300 K)\n    xi = 1.3448 (temperature-independent coefficient in stacking strength)\n    kappa = 2.6568 (coefficient of linear temperature dependence in stacking strength)\n  oxdna/hbond args = seq eps 8.0 0.4 0.75 0.34 0.7 1.5 0 0.7 1.5 0 0.7 1.5 0 0.7 0.46 3.141592653589793 0.7 4.0 1.5707963267948966 0.45 4.0 1.5707963267948966 0.45\n    seq = seqav (for average sequence base-pairing strength) or seqdep (for sequence-dependent base-pairing strength)\n    eps = 1.077 (between base pairs A-T and C-G) or 0 (all other pairs)\n  ",
    "examples": "pair_style hybrid/overlay oxdna/excv oxdna/stk oxdna/hbond oxdna/xstk oxdna/coaxstk\n  pair_coeff * * oxdna/excv    2.0 0.7 0.675 2.0 0.515 0.5 2.0 0.33 0.32\n  pair_coeff * * oxdna/stk     seqdep 0.1 1.3448 2.6568 6.0 0.4 0.9 0.32 0.75 1.3 0 0.8 0.9 0 0.95 0.9 0 0.95 2.0 0.65 2.0 0.65\n  pair_coeff * * oxdna/hbond   seqdep 0.0 8.0 0.4 0.75 0.34 0.7 1.5 0 0.7 1.5 0 0.7 1.5 0 0.7 0.46 3.141592653589793 0.7 4.0 1.5707963267948966 0.45 4.0 1.5707963267948966 0.45\n  pair_coeff 1 4 oxdna/hbond   seqdep 1.077 8.0 0.4 0.75 0.34 0.7 1.5 0 0.7 1.5 0 0.7 1.5 0 0.7 0.46 3.141592653589793 0.7 4.0 1.5707963267948966 0.45 4.0 1.5707963267948966 0.45\n  pair_coeff 2 3 oxdna/hbond   seqdep 1.077 8.0 0.4 0.75 0.34 0.7 1.5 0 0.7 1.5 0 0.7 1.5 0 0.7 0.46 3.141592653589793 0.7 4.0 1.5707963267948966 0.45 4.0 1.5707963267948966 0.45\n  pair_coeff * * oxdna/xstk    47.5 0.575 0.675 0.495 0.655 2.25 0.791592653589793 0.58 1.7 1.0 0.68 1.7 1.0 0.68 1.5 0 0.65 1.7 0.875 0.68 1.7 0.875 0.68\n  pair_coeff * * oxdna/coaxstk 46.0 0.4 0.6 0.22 0.58 2.0 2.541592653589793 0.65 1.3 0 0.8 0.9 0 0.95 0.9 0 0.95 2.0 -0.65 2.0 -0.65\n  \n  \n  ",
    "restrictions": "These pair styles can only be used if LAMMPS was built with the\n  USER-CGDNA package and the MOLECULE and ASPHERE package.  See the\n  Build package doc page for more info.\n  "
},
{
    "command": "pair_style oxdna2/excv",
    "description": "The oxdna2 pair styles compute the pairwise-additive parts of the oxDNA force field\n  for coarse-grained modelling of DNA. The effective interaction between the nucleotides consists of potentials for the\n  excluded volume interaction oxdna2/excv, the stacking oxdna2/stk, cross-stacking oxdna2/xstk\n  and coaxial stacking interaction oxdna2/coaxstk, electrostatic Debye-Hueckel interaction oxdna2/dh\n  as well as the hydrogen-bonding interaction oxdna2/hbond between complementary pairs of nucleotides on\n  opposite strands. Average sequence or sequence-dependent stacking and base-pairing strengths\n  are supported (Sulc). Quasi-unique base-pairing between nucleotides can be achieved by using\n  more complementary pairs of atom types like 5-8 and 6-7, 9-12 and 10-11, 13-16 and 14-15, etc.\n  This prevents the hybridization of in principle complementary bases within Ntypes/4 bases\n  up and down along the backbone.\n  The exact functional form of the pair styles is rather complex.\n  The individual potentials consist of products of modulation factors,\n  which themselves are constructed from a number of more basic potentials\n  (Morse, Lennard-Jones, harmonic angle and distance) as well as quadratic smoothing and modulation terms.\n  We refer to (Snodin) and the original oxDNA publications (Ouldridge-DPhil)\n  and  (Ouldridge) for a detailed description of the oxDNA2 force field.\n  \n  Note\n  These pair styles have to be used together with the related oxDNA2 bond style\n  oxdna2/fene for the connectivity of the phosphate backbone (see also documentation of\n  bond_style oxdna2/fene). Most of the coefficients\n  in the above example have to be kept fixed and cannot be changed without reparameterizing the entire model.\n  Exceptions are the first four coefficients after oxdna2/stk (seq=seqdep, T=0.1, xi=1.3523 and kappa=2.6717 in the above example),\n  the first coefficient after oxdna2/hbond (seq=seqdep in the above example) and the three coefficients\n  after oxdna2/dh (T=0.1, rhos=0.5, qeff=0.815 in the above example). When using a Langevin thermostat\n  e.g. through fix langevin or fix nve/dotc/langevin\n  the temperature coefficients have to be matched to the one used in the fix.\n  \n  Example input and data files for DNA duplexes can be found in examples/USER/cgdna/examples/oxDNA/ and /oxDNA2/.\n  A simple python setup tool which creates single straight or helical DNA strands,\n  DNA duplexes or arrays of DNA duplexes can be found in examples/USER/cgdna/util/.\n  Please cite (Henrich) in any publication that uses\n  this implementation.  The article contains general information\n  on the model, its implementation and performance as well as the structure of\n  the data and input file. The preprint version of the article can be found\n  here.\n  Please cite also the relevant oxDNA2 publications\n  (Snodin) and (Sulc).\n  ",
    "syntax": "pair_style style1\n  \n  pair_coeff * * style2 args\n  \n  \n  \n  style1 = hybrid/overlay oxdna2/excv oxdna2/stk oxdna2/hbond oxdna2/xstk oxdna2/coaxstk oxdna2/dh\n  style2 = oxdna2/excv or oxdna2/stk or oxdna2/hbond or oxdna2/xstk or oxdna2/coaxstk or oxdna2/dh\n  args = list of arguments for these particular styles\n  \n  oxdna2/stk args = seq T xi kappa 6.0 0.4 0.9 0.32 0.75 1.3 0 0.8 0.9 0 0.95 0.9 0 0.95 2.0 0.65 2.0 0.65\n    seq = seqav (for average sequence stacking strength) or seqdep (for sequence-dependent stacking strength)\n    T = temperature (oxDNA units, 0.1 = 300 K)\n    xi = 1.3523 (temperature-independent coefficient in stacking strength)\n    kappa = 2.6717 (coefficient of linear temperature dependence in stacking strength)\n  oxdna2/hbond args = seq eps 8.0 0.4 0.75 0.34 0.7 1.5 0 0.7 1.5 0 0.7 1.5 0 0.7 0.46 3.141592653589793 0.7 4.0 1.5707963267948966 0.45 4.0 1.5707963267948966 0.45\n    seq = seqav (for average sequence base-pairing strength) or seqdep (for sequence-dependent base-pairing strength)\n    eps = 1.0678 (between base pairs A-T and C-G) or 0 (all other pairs)\n  oxdna2/dh args = T rhos qeff\n    T = temperature (oxDNA units, 0.1 = 300 K)\n    rhos = salt concentration (mole per litre)\n    qeff = 0.815 (effective charge in elementary charges)\n  ",
    "examples": "pair_style hybrid/overlay oxdna2/excv oxdna2/stk oxdna2/hbond oxdna2/xstk oxdna2/coaxstk oxdna2/dh\n  pair_coeff * * oxdna2/excv    2.0 0.7 0.675 2.0 0.515 0.5 2.0 0.33 0.32\n  pair_coeff * * oxdna2/stk     seqdep 0.1 1.3523 2.6717 6.0 0.4 0.9 0.32 0.75 1.3 0 0.8 0.9 0 0.95 0.9 0 0.95 2.0 0.65 2.0 0.65\n  pair_coeff * * oxdna2/hbond   seqdep 0.0 8.0 0.4 0.75 0.34 0.7 1.5 0 0.7 1.5 0 0.7 1.5 0 0.7 0.46 3.141592653589793 0.7 4.0 1.5707963267948966 0.45 4.0 1.5707963267948966 0.45\n  pair_coeff 1 4 oxdna2/hbond   seqdep 1.0678 8.0 0.4 0.75 0.34 0.7 1.5 0 0.7 1.5 0 0.7 1.5 0 0.7 0.46 3.141592653589793 0.7 4.0 1.5707963267948966 0.45 4.0 1.5707963267948966 0.45\n  pair_coeff 2 3 oxdna2/hbond   seqdep 1.0678 8.0 0.4 0.75 0.34 0.7 1.5 0 0.7 1.5 0 0.7 1.5 0 0.7 0.46 3.141592653589793 0.7 4.0 1.5707963267948966 0.45 4.0 1.5707963267948966 0.45\n  pair_coeff * * oxdna2/xstk    47.5 0.575 0.675 0.495 0.655 2.25 0.791592653589793 0.58 1.7 1.0 0.68 1.7 1.0 0.68 1.5 0 0.65 1.7 0.875 0.68 1.7 0.875 0.68\n  pair_coeff * * oxdna2/coaxstk 58.5 0.4 0.6 0.22 0.58 2.0 2.891592653589793 0.65 1.3 0 0.8 0.9 0 0.95 0.9 0 0.95 40.0 3.116592653589793\n  pair_coeff * * oxdna2/dh      0.1 0.5 0.815\n  \n  \n  ",
    "restrictions": "These pair styles can only be used if LAMMPS was built with the\n  USER-CGDNA package and the MOLECULE and ASPHERE package.  See the\n  Build package doc page for more info.\n  "
},
{
    "command": "pair_style oxrna2/excv",
    "description": "The oxrna2 pair styles compute the pairwise-additive parts of the oxDNA force field\n  for coarse-grained modelling of DNA. The effective interaction between the nucleotides consists of potentials for the\n  excluded volume interaction oxrna2/excv, the stacking oxrna2/stk, cross-stacking oxrna2/xstk\n  and coaxial stacking interaction oxrna2/coaxstk, electrostatic Debye-Hueckel interaction oxrna2/dh\n  as well as the hydrogen-bonding interaction oxrna2/hbond between complementary pairs of nucleotides on\n  opposite strands. Average sequence or sequence-dependent stacking and base-pairing strengths\n  are supported (Sulc2). Quasi-unique base-pairing between nucleotides can be achieved by using\n  more complementary pairs of atom types like 5-8 and 6-7, 9-12 and 10-11, 13-16 and 14-15, etc.\n  This prevents the hybridization of in principle complementary bases within Ntypes/4 bases\n  up and down along the backbone.\n  The exact functional form of the pair styles is rather complex.\n  The individual potentials consist of products of modulation factors,\n  which themselves are constructed from a number of more basic potentials\n  (Morse, Lennard-Jones, harmonic angle and distance) as well as quadratic smoothing and modulation terms.\n  We refer to (Sulc1) and the original oxDNA publications (Ouldridge-DPhil)\n  and  (Ouldridge) for a detailed description of the oxRNA2 force field.\n  \n  Note\n  These pair styles have to be used together with the related oxDNA2 bond style\n  oxrna2/fene for the connectivity of the phosphate backbone (see also documentation of\n  bond_style oxrna2/fene). Most of the coefficients\n  in the above example have to be kept fixed and cannot be changed without reparameterizing the entire model.\n  Exceptions are the first four coefficients after oxrna2/stk (seq=seqdep, T=0.1, xi=1.40206 and kappa=2.77 in the above example),\n  the first coefficient after oxrna2/hbond (seq=seqdep in the above example) and the three coefficients\n  after oxrna2/dh (T=0.1, rhos=0.5, qeff=1.02455 in the above example). When using a Langevin thermostat\n  e.g. through fix langevin or fix nve/dotc/langevin\n  the temperature coefficients have to be matched to the one used in the fix.\n  \n  Example input and data files for DNA duplexes can be found in examples/USER/cgdna/examples/oxDNA/ and /oxDNA2/.\n  A simple python setup tool which creates single straight or helical DNA strands,\n  DNA duplexes or arrays of DNA duplexes can be found in examples/USER/cgdna/util/.\n  Please cite (Henrich) in any publication that uses\n  this implementation.  The article contains general information\n  on the model, its implementation and performance as well as the structure of\n  the data and input file. The preprint version of the article can be found\n  here.\n  Please cite also the relevant oxRNA2 publications\n  (Sulc1) and (Sulc2).\n  ",
    "syntax": "pair_style style1\n  \n  pair_coeff * * style2 args\n  \n  \n  \n  style1 = hybrid/overlay oxrna2/excv oxrna2/stk oxrna2/hbond oxrna2/xstk oxrna2/coaxstk oxrna2/dh\n  style2 = oxrna2/excv or oxrna2/stk or oxrna2/hbond or oxrna2/xstk or oxrna2/coaxstk or oxrna2/dh\n  args = list of arguments for these particular styles\n  \n  oxrna2/stk args = seq T xi kappa 6.0 0.43 0.93 0.35 0.78 0.9 0 0.95 0.9 0 0.95 1.3 0 0.8 1.3 0 0.8 2.0 0.65 2.0 0.65\n    seq = seqav (for average sequence stacking strength) or seqdep (for sequence-dependent stacking strength)\n    T = temperature (oxDNA units, 0.1 = 300 K)\n    xi = 1.40206 (temperature-independent coefficient in stacking strength)\n    kappa = 2.77 (coefficient of linear temperature dependence in stacking strength)\n  oxrna2/hbond args = seq eps 8.0 0.4 0.75 0.34 0.7 1.5 0 0.7 1.5 0 0.7 1.5 0 0.7 0.46 3.141592653589793 0.7 4.0 1.5707963267948966 0.45 4.0 1.5707963267948966 0.45\n    seq = seqav (for average sequence base-pairing strength) or seqdep (for sequence-dependent base-pairing strength)\n    eps = 0.870439 (between base pairs A-T, C-G and G-T) or 0 (all other pairs)\n  oxrna2/dh args = T rhos qeff\n    T = temperature (oxDNA units, 0.1 = 300 K)\n    rhos = salt concentration (mole per litre)\n    qeff = 1.02455 (effective charge in elementary charges)\n  ",
    "examples": "pair_style hybrid/overlay oxrna2/excv oxrna2/stk oxrna2/hbond oxrna2/xstk oxrna2/coaxstk oxrna2/dh\n  pair_coeff * * oxrna2/excv    2.0 0.7 0.675 2.0 0.515 0.5 2.0 0.33 0.32\n  pair_coeff * * oxrna2/stk     seqdep 0.1 1.40206 2.77 6.0 0.43 0.93 0.35 0.78 0.9 0 0.95 0.9 0 0.95 1.3 0 0.8 1.3 0 0.8 2.0 0.65 2.0 0.65\n  pair_coeff * * oxrna2/hbond   seqdep 0.0 8.0 0.4 0.75 0.34 0.7 1.5 0 0.7 1.5 0 0.7 1.5 0 0.7 0.46 3.141592653589793 0.7 4.0 1.5707963267948966 0.45 4.0 1.5707963267948966 0.45\n  pair_coeff 1 4 oxrna2/hbond   seqdep 0.870439 8.0 0.4 0.75 0.34 0.7 1.5 0 0.7 1.5 0 0.7 1.5 0 0.7 0.46 3.141592653589793 0.7 4.0 1.5707963267948966 0.45 4.0 1.5707963267948966 0.45\n  pair_coeff 2 3 oxrna2/hbond   seqdep 0.870439 8.0 0.4 0.75 0.34 0.7 1.5 0 0.7 1.5 0 0.7 1.5 0 0.7 0.46 3.141592653589793 0.7 4.0 1.5707963267948966 0.45 4.0 1.5707963267948966 0.45\n  pair_coeff 3 4 oxrna2/hbond   seqdep 0.870439 8.0 0.4 0.75 0.34 0.7 1.5 0 0.7 1.5 0 0.7 1.5 0 0.7 0.46 3.141592653589793 0.7 4.0 1.5707963267948966 0.45 4.0 1.5707963267948966 0.45\n  pair_coeff * * oxrna2/xstk    59.9626 0.5 0.6 0.42 0.58 2.25 0.505 0.58 1.7 1.266 0.68 1.7 1.266 0.68 1.7 0.309 0.68 1.7 0.309 0.68\n  pair_coeff * * oxrna2/coaxstk 80 0.5 0.6 0.42 0.58 2.0 2.592 0.65 1.3 0.151 0.8 0.9 0.685 0.95 0.9 0.685 0.95 2.0 -0.65 2.0 -0.65\n  pair_coeff * * oxrna2/dh      0.1 0.5 1.02455\n  \n  \n  ",
    "restrictions": "These pair styles can only be used if LAMMPS was built with the\n  USER-CGDNA package and the MOLECULE and ASPHERE package.  See the\n  Build package doc page for more info.\n  "
},
{
    "command": "pair_style peri/pmb",
    "description": "The peridynamic pair styles implement material models that can be used\n  at the mesoscopic and macroscopic scales.  See this document for an overview of LAMMPS commands\n  for Peridynamics modeling.\n  Style peri/pmb implements the Peridynamic bond-based prototype\n  microelastic brittle (PMB) model.\n  Style peri/lps implements the Peridynamic state-based linear\n  peridynamic solid (LPS) model.\n  Style peri/ves implements the Peridynamic state-based linear\n  peridynamic viscoelastic solid (VES) model.\n  Style peri/eps implements the Peridynamic state-based elastic-plastic\n  solid (EPS) model.\n  The canonical papers on Peridynamics are (Silling 2000)\n  and (Silling 2007).  The implementation of Peridynamics\n  in LAMMPS is described in (Parks).  Also see the PDLAMMPS user guide for\n  more details about its implementation.\n  The peridynamic VES and EPS models in PDLAMMPS were implemented by\n  R. Rahman and J. T. Foster at University of Texas at San Antonio.  The\n  original VES formulation is described in “(Mitchell2011)” and the\n  original EPS formulation is in “(Mitchell2011a)”.  Additional PDF docs\n  that describe the VES and EPS implementations are include in the\n  LAMMPS distribution in doc/PDF/PDLammps_VES.pdf and\n  doc/PDF/PDLammps_EPS.pdf.  For questions\n  regarding the VES and EPS models in LAMMPS you can contact R. Rahman\n  (rezwanur.rahman at utsa.edu).\n  The following coefficients must be defined for each pair of atom types\n  via the pair_coeff command as in the examples above,\n  or in the data file or restart files read by the\n  read_data or read_restart\n  commands, or by mixing as described below.\n  For the peri/pmb style:\n  \n  c (energy/distance/volume^2 units)\n  horizon (distance units)\n  s00 (unitless)\n  \\(\\alpha\\) (unitless)\n  \n  C is the effectively a spring constant for Peridynamic bonds, the\n  horizon is a cutoff distance for truncating interactions, and s00 and\n  \\(\\alpha\\) are used as a bond breaking criteria.  The units of c are such\n  that c/distance = stiffness/volume^2, where stiffness is\n  energy/distance^2 and volume is distance^3.  See the users guide for\n  more details.\n  For the peri/lps style:\n  \n  K (force/area units)\n  G (force/area units)\n  horizon (distance units)\n  s00 (unitless)\n  \\(\\alpha\\) (unitless)\n  \n  K is the bulk modulus and G is the shear modulus.  The horizon is a\n  cutoff distance for truncating interactions, and s00 and \\(\\alpha\\) are\n  used as a bond breaking criteria. See the users guide for more\n  details.\n  For the peri/ves style:\n  \n  K (force/area units)\n  G (force/area units)\n  horizon (distance units)\n  s00 (unitless)\n  \\(\\alpha\\) (unitless)\n  m_lambdai (unitless)\n  m_taubi (unitless)\n  \n  K is the bulk modulus and G is the shear modulus. The horizon is a\n  cutoff distance for truncating interactions, and s00 and \\(\\alpha\\) are\n  used as a bond breaking criteria. m_lambdai and m_taubi are the\n  viscoelastic relaxation parameter and time constant,\n  respectively. m_lambdai varies within zero to one. For very small\n  values of m_lambdai the viscoelastic model responds very similar to a\n  linear elastic model. For details please see the description in\n  “(Mtchell2011)”.\n  For the peri/eps style:\n  \n  K (force/area units)\n  G (force/area units)\n  horizon (distance units)\n  s00 (unitless)\n  \\(\\alpha\\) (unitless)\n  m_yield_stress (force/area units)\n  \n  K is the bulk modulus and G is the shear modulus. The horizon is a\n  cutoff distance and s00 and \\(\\alpha\\) are used as a bond breaking\n  criteria.  m_yield_stress is the yield stress of the material. For\n  details please see the description in “(Mtchell2011a)”.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  These pair styles do not support mixing.  Thus, coefficients for all\n  I,J pairs must be specified explicitly.\n  These pair styles do not support the pair_modify\n  shift option.\n  The pair_modify table and tail options are not\n  relevant for these pair styles.\n  These pair styles write their information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  These pair styles can only be used via the pair keyword of the\n  run_style respa command.  They do not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style style\n  \n  \n  \n  style = peri/pmb or peri/lps or peri/ves or peri/eps\n  \n  ",
    "examples": "pair_style peri/pmb\n  pair_coeff * * 1.6863e22 0.0015001 0.0005 0.25\n  \n  pair_style peri/lps\n  pair_coeff * * 14.9e9 14.9e9 0.0015001 0.0005 0.25\n  \n  pair_style peri/ves\n  pair_coeff * * 14.9e9 14.9e9 0.0015001 0.0005 0.25 0.5 0.001\n  \n  pair_style peri/eps\n  pair_coeff * * 14.9e9 14.9e9 0.0015001 0.0005 0.25 118.43\n  \n  \n  ",
    "restrictions": "All of these styles are part of the PERI package. They are only\n  enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style polymorphic",
    "description": "The polymorphic pair style computes a 3-body free-form potential\n  (Zhou) for the energy E of a system of atoms as\n  \n  \\[\\begin{split}E & = \\frac{1}{2}\\sum_{i=1}^{i=N}\\sum_{j=1}^{j=N}\\left[\\left(1-\\delta_{ij}\\right)\\cdot U_{IJ}\\left(r_{ij}\\right)-\\left(1-\\eta_{ij}\\right)\\cdot F_{IJ}\\left(r_{ij}\\right)\\cdot V_{IJ}\\left(r_{ij}\\right)\\right] \\\\\n  X_{ij} & = \\sum_{k=i_1,k\\neq i,j}^{i_N}W_{IK}\\left(r_{ik}\\right)\\cdot G_{JIK}\\left(\\theta_{jik}\\right)\\cdot P_{IK}\\left(\\Delta r_{jik}\\right) \\\\\n  \\Delta r_{jik} & = r_{ij}-\\xi_{IJ}\\cdot r_{ik}\\end{split}\\]\n  where I, J, K represent species of atoms i, j, and k, \\(i_1, ...,\n  i_N\\) represents a list of i’s neighbors, \\(\\delta_{ij}\\) is a\n  Dirac constant (i.e., \\(\\delta_{ij} = 1\\) when \\(i = j\\), and\n  \\(\\delta_{ij} = 0\\) otherwise), \\(\\eta_{ij}\\) is similar\n  constant that can be set either to \\(\\eta_{ij} = \\delta_{ij}\\) or\n  \\(\\eta_{ij} = 1 - \\delta_{ij}\\) depending on the potential type,\n  \\(U_{IJ}(r_{ij})\\), \\(V_{IJ}(r_{ij})\\), \\(W_{IK}(r_{ik})\\)\n  are pair functions, \\(G_{JIK}(\\cos(\\theta))\\) is an angular\n  function, \\(P_{IK}(\\Delta r_{jik})\\) is a function of atomic spacing\n  differential \\(\\Delta r_{jik} = r_{ij} - \\xi_{IJ} \\cdot r_{ik}\\)\n  with \\(\\xi_{IJ}\\) being a pair-dependent parameter, and\n  \\(F_{IJ}(X_{ij})\\) is a function of the local environment variable\n  \\(X_{ij}\\). This generic potential is fully defined once the\n  constants \\(\\eta_{ij}\\) and \\(\\xi_{IJ}\\), and the six functions\n  \\(U_{IJ}(r_{ij})\\), \\(V_{IJ}(r_{ij})\\), \\(W_{IK}(r_{ik})\\),\n  \\(G_{JIK}(\\cos(\\theta))\\), \\(P_{IK}(\\Delta r_{jik})\\), and\n  \\(F_{IJ}(X_{ij})\\) are given. Note that these six functions are all\n  one dimensional, and hence can be provided in an analytic or tabular\n  form. This allows users to design different potentials solely based on a\n  manipulation of these functions. For instance, the potential reduces to\n  Stillinger-Weber potential (SW) if we set\n  \n  \\[\\begin{split}\\left\\{\\begin{array}{l}\n  \\eta_{ij} = \\delta_{ij},\\xi_{IJ}=0 \\\\\n  U_{IJ}\\left(r\\right)=A_{IJ}\\cdot\\epsilon_{IJ}\\cdot \\left(\\frac{\\sigma_{IJ}}{r}\\right)^q\\cdot \\left[B_{IJ}\\cdot \\left(\\frac{\\sigma_{IJ}}{r}\\right)^{p-q}-1\\right]\\cdot exp\\left(\\frac{\\sigma_{IJ}}{r-a_{IJ}\\cdot \\sigma_{IJ}}\\right) \\\\\n  V_{IJ}\\left(r\\right)=\\sqrt{\\lambda_{IJ}\\cdot \\epsilon_{IJ}}\\cdot exp\\left(\\frac{\\gamma_{IJ}\\cdot \\sigma_{IJ}}{r-a_{IJ}\\cdot \\sigma_{IJ}}\\right) \\\\\n  F_{IJ}\\left(X\\right)=-X \\\\\n  P_{IJ}\\left(\\Delta r\\right)=1 \\\\\n  W_{IJ}\\left(r\\right)=\\sqrt{\\lambda_{IJ}\\cdot \\epsilon_{IJ}}\\cdot exp\\left(\\frac{\\gamma_{IJ}\\cdot \\sigma_{IJ}}{r-a_{IJ}\\cdot \\sigma_{IJ}}\\right) \\\\\n  G_{JIK}\\left(\\theta\\right)=\\left(cos\\theta+\\frac{1}{3}\\right)^2\n  \\end{array}\\right.\\end{split}\\]\n  The potential reduces to Tersoff types of potential\n  (Tersoff or Albe) if we set\n  \n  \\[\\begin{split}\\left\\{\\begin{array}{l}\n  \\eta_{ij}=\\delta_{ij},\\xi_{IJ}=1 \\\\\n  U_{IJ}\\left(r\\right)=\\frac{D_{e,IJ}}{S_{IJ}-1}\\cdot exp\\left[-\\beta_{IJ}\\sqrt{2S_{IJ}\\left(r-r_{e,IJ}\\right)}\\right]\\cdot f_{c,IJ}\\left(r\\right) \\\\\n  V_{IJ}\\left(r\\right)=\\frac{S_{IJ}\\cdot D_{e,IJ}}{S_{IJ}-1}\\cdot exp\\left[-\\beta_{IJ}\\sqrt{\\frac{2}{S_{IJ}}\\left(r-r_{e,IJ}\\right)}\\right]\\cdot f_{c,IJ}\\left(r\\right) \\\\\n  F_{IJ}\\left(X\\right)=\\left(1+X\\right)^{-\\frac{1}{2}} \\\\\n  P_{IJ}\\left(\\Delta r\\right)=exp\\left(2\\mu_{IK}\\cdot \\Delta r\\right) \\\\\n  W_{IJ}\\left(r\\right)=f_{c,IK}\\left(r\\right) \\\\\n  G_{JIK}\\left(\\theta\\right)=\\gamma_{IK}\\left[1+\\frac{c_{IK}^2}{d_{IK}^2}-\\frac{c_{IK}^2}{d_{IK}^2+\\left(h_{IK}+cos\\theta\\right)^2}\\right]\n  \\end{array}\\right.\\end{split}\\]\n  \n  \\[\\begin{split}f_{c,IJ}=\\left\\{\\begin{array}{lr}\n  1, & r\\leq r_{s,IJ} \\\\\n  \\frac{1}{2}+\\frac{1}{2} cos \\left[\\frac{\\pi \\left(r-r_{s,IJ}\\right)}{r_{c,IJ}-r_{s,IJ}}\\right], & r_{s,IJ}<r<r_{c,IJ} \\\\\n  0, & r \\geq r_{c,IJ} \\\\\n  \\end{array}\\right.\\end{split}\\]\n  The potential reduces to Rockett-Tersoff (Wang) type if we set\n  \n  \\[\\begin{split}\\left\\{\\begin{array}{l}\n  \\eta_{ij}=\\delta_{ij},\\xi_{IJ}=1 \\\\\n  U_{IJ}\\left(r\\right)=\\left\\{\\begin{array}{lr}\n  A_{IJ}\\cdot exp\\left(-\\lambda_{1,IJ}\\cdot r\\right)\\cdot f_{c,IJ}\\left(r\\right), & r\\leq r_{s,1,IJ} \\\\\n  A_{IJ}\\cdot exp\\left(-\\lambda_{1,IJ}\\cdot r\\right)\\cdot f_{c,IJ}\\left(r\\right)\\cdot f_{c,1,IJ}\\left(r\\right), & r_{s,1,IJ}<r<r_{c,1,IJ} \\\\\n  0, & r\\ge r_{c,1,IJ}\n  \\end{array}\\right. \\\\\n  V_{IJ}\\left(r\\right)=\\left\\{\\begin{array}{lr}\n  B_{IJ} \\cdot exp\\left(-\\lambda_{2,IJ}\\cdot r\\right)\\cdot f_{c,IJ}\\left(r\\right), & r\\le r_{s,1,IJ} \\\\\n  B_{IJ} \\cdot exp\\left(-\\lambda_{2,IJ}\\cdot r\\right)\\cdot f_{c,IJ}\\left(r\\right)+A_{IJ}\\cdot exp\\left(-\\lambda_{1,IJ}\\cdot r\\right)\\cdot & \\\\ ~~~~~~ f_{c,IJ}\\left(r\\right)\\cdot \\left[1-f_{c,1,IJ}\\left(r\\right)\\right], & r_{s,1,IJ}<r<r_{c,1,IJ} \\\\\n  B_{IJ} \\cdot exp\\left(-\\lambda_{2,IJ}\\cdot r\\right)\\cdot f_{c,IJ}\\left(r\\right)+A_{IJ}\\cdot exp\\left(-\\lambda_{1,IJ}\\cdot r\\right)\\cdot & \\\\ ~~~~~~ f_{c,IJ}\\left(r\\right) & r \\ge r_{c,1,IJ}\n  \\end{array}\\right. \\\\\n  F_{IJ}\\left(X\\right)=\\left[1+\\left(\\beta_{IJ}\\cdot X\\right)^{n_{IJ}}\\right]^{-\\frac{1}{2n_{IJ}}} \\\\\n  P_{IJ}\\left(\\Delta r\\right)=exp\\left(\\lambda_{3,IK}\\cdot \\Delta r^3\\right) \\\\\n  W_{IJ}\\left(r\\right)=f_{c,IK}\\left(r\\right) \\\\\n  G_{JIK}\\left(\\theta\\right)=1+\\frac{c_{IK}^2}{d_{IK}^2}-\\frac{c_{IK}^2}{d_{IK}^2+\\left(h_{IK}+cos\\theta\\right)^2}\n  \\end{array}\\right.\\end{split}\\]\n  \n  \\[\\begin{split}f_{c,IJ}=\\left\\{\\begin{array}{lr}\n  1, & r\\leq r_{s,IJ} \\\\\n  \\frac{1}{2}+\\frac{1}{2} cos \\left[\\frac{\\pi \\left(r-r_{s,IJ}\\right)}{r_{c,IJ}-r_{s,IJ}}\\right], & r_{s,IJ}<r<r_{c,IJ} \\\\\n  0, & r \\geq r_{c,IJ} \\\\\n  \\end{array}\\right.\\end{split}\\]\n  \n  \\[\\begin{split}f_{c,1,IJ}=\\left\\{\\begin{array}{lr}\n  1, & r\\leq r_{s,1,IJ} \\\\\n  \\frac{1}{2}+\\frac{1}{2} cos \\left[\\frac{\\pi \\left(r-r_{s,1,IJ}\\right)}{r_{c,1,IJ}-r_{s,1,IJ}}\\right], & r_{s,1,IJ}<r<r_{c,1,IJ} \\\\\n  0, & r \\geq r_{c,1,IJ} \\\\\n  \\end{array}\\right.\\end{split}\\]\n  The potential becomes embedded atom method (Daw) if we set\n  \n  \\[\\begin{split}\\left\\{\\begin{array}{l}\n  \\eta_{ij}=1-\\delta_{ij},\\xi_{IJ}=0 \\\\\n  U_{IJ}\\left(r\\right)=\\phi_{IJ}\\left(r\\right) \\\\\n  V_{IJ}\\left(r\\right)=1 \\\\\n  F_{II}\\left(X\\right)=-2F_I\\left(X\\right) \\\\\n  P_{IJ}\\left(\\Delta r\\right)=1 \\\\\n  W_{IJ}\\left(r\\right)=f_{K}\\left(r\\right) \\\\\n  G_{JIK}\\left(\\theta\\right)=1\n  \\end{array}\\right.\\end{split}\\]\n  In the embedded atom method case, \\(\\phi_{IJ}(r_{ij})\\) is the pair\n  energy, \\(F_I(X)\\) is the embedding energy, X is the local\n  electron density, and \\(f_K(r)\\) is the atomic electron density function.\n  If the tabulated functions are created using the parameters of sw,\n  tersoff, and eam potentials, the polymorphic pair style will produce\n  the same global properties (energies and stresses) and the same forces\n  as the sw, tersoff, and eam pair styles. The polymorphic pair style\n  also produces the same atom properties (energies and stresses) as the\n  corresponding tersoff and eam pair styles. However, due to a different\n  partition of global properties to atom properties, the polymorphic\n  pair style will produce different atom properties (energies and\n  stresses) as the sw pair style. This does not mean that polymorphic\n  pair style is different from the sw pair style in this case. It just\n  means that the definitions of the atom energies and atom stresses are\n  different.\n  Only a single pair_coeff command is used with the polymorphic style\n  which specifies an potential file for all needed elements. These are\n  mapped to LAMMPS atom types by specifying N additional arguments after\n  the filename in the pair_coeff command, where N is the number of\n  LAMMPS atom types:\n  \n  filename\n  N element names = mapping of Tersoff elements to atom types\n  \n  See the pair_coeff doc page for alternate ways to specify the path for\n  the potential file.  Several files for polymorphic potentials are\n  included in the potentials directory of the LAMMPS distribution.  They\n  have a “poly” suffix.\n  As an example, imagine the SiC_tersoff.poly file has tabulated\n  functions for Si-C tersoff potential. If your LAMMPS simulation has 4\n  atoms types and you want the 1st 3 to be Si, and the 4th to be C, you\n  would use the following pair_coeff command:\n  pair_coeff * * SiC_tersoff.poly Si Si Si C\n  \n  \n  The 1st 2 arguments must be * * so as to span all LAMMPS atom\n  types. The first three Si arguments map LAMMPS atom types 1,2,3 to the\n  Si element in the polymorphic file. The final C argument maps LAMMPS\n  atom type 4 to the C element in the polymorphic file. If a mapping\n  value is specified as NULL, the mapping is not performed. This can be\n  used when an polymorphic potential is used as part of the hybrid pair\n  style. The NULL values are placeholders for atom types that will be\n  used with other potentials.\n  Potential files in the potentials directory of the LAMMPS distribution\n  have a “.poly” suffix. At the beginning of the files, an unlimited\n  number of lines starting with ‘#’ are used to describe the potential\n  and are ignored by LAMMPS. The next line lists two numbers:\n  ntypes \\(\\eta\\)\n  Here ntypes represent total number of species defined in the potential\n  file, and \\(\\eta = 0\\) or 1. The number ntypes must equal the total\n  number of different species defined in the pair_coeff command. When\n  \\(\\eta = 1\\), :math:eta_{ij}` defined in the potential functions\n  above is set to \\(1 - \\delta_{ij}\\), otherwise \\(\\eta_{ij}\\) is\n  set to \\(\\delta_{ij}\\). The next ntypes lines each lists two numbers\n  and a character string representing atomic number, atomic mass, and name\n  of the species of the ntypes elements:\n  atomic_number atomic-mass element (1)\n  atomic_number atomic-mass element (2)\n  ...\n  atomic_number atomic-mass element (ntypes)\n  \n  \n  The next ntypes*(ntypes+1)/2 lines contain two numbers:\n  cut \\(xi\\) (1)\n  cut \\(xi\\) (2)\n  ...\n  cut \\(xi\\) (ntypes*(ntypes+1)/2)\n  Here cut means the cutoff distance of the pair functions, \\(\\xi\\) is\n  the same as defined in the potential functions above. The\n  ntypes*(ntypes+1)/2 lines are related to the pairs according to the\n  sequence of first ii (self) pairs, i = 1, 2, …, ntypes, and then then\n  ij (cross) pairs, i = 1, 2, …, ntypes-1, and j = i+1, i+2, …, ntypes\n  (i.e., the sequence of the ij pairs follows 11, 22, …, 12, 13, 14,\n  …, 23, 24, …).\n  The final blocks of the potential file are the U, V, W, P, G, and F\n  functions are listed sequentially. First, U functions are given for\n  each of the ntypes*(ntypes+1)/2 pairs according to the sequence\n  described above. For each of the pairs, nr values are listed. Next,\n  similar arrays are given for V, W, and P functions. Then G functions\n  are given for all the ntypes*ntypes*ntypes ijk triplets in a natural\n  sequence i from 1 to ntypes, j from 1 to ntypes, and k from 1 to\n  ntypes (i.e., ijk = 111, 112, 113, …, 121, 122, 123 …, 211, 212,\n  …). Each of the ijk functions contains ng values. Finally, the F\n  functions are listed for all ntypes*(ntypes+1)/2 pairs, each\n  containing nx values. Either analytic or tabulated functions can be\n  specified. Currently, constant, exponential, sine and cosine analytic\n  functions are available which are specified with: constant c1 , where\n  f(x) = c1 exponential c1 c2 , where f(x) = c1 exp(c2*x) sine c1 c2 ,\n  where f(x) = c1 sin(c2*x) cos c1 c2 , where f(x) = c1 cos(c2*x)\n  Tabulated functions are specified by spline n x1 x2, where n=number of\n  point, (x1,x2)=range and then followed by n values evaluated uniformly\n  over these argument ranges.  The valid argument ranges of the\n  functions are between 0 <= r <= cut for the U(r), V(r), W(r)\n  functions, -cutmax <= delta_r <= cutmax for the P(delta_r) functions,\n  -1 <= \\(\\cos\\theta\\) <= 1 for the G(\\(\\cos\\theta\\)) functions,\n  and 0 <= X <= maxX for the F(X) functions.\n  Mixing, shift, table tail correction, restart:\n  This pair styles does not support the pair_modify\n  shift, table, and tail options.\n  This pair style does not write their information to binary restart files, since it is stored in potential files. Thus, you\n  need to re-specify the pair_style and pair_coeff commands in an input\n  script that reads a restart file.\n  ",
    "syntax": "pair_style polymorphic\n  \n  \n  style = polymorphic\n  ",
    "examples": "pair_style polymorphic\n  pair_coeff * * TlBr_msw.polymorphic Tl Br\n  pair_coeff * * AlCu_eam.polymorphic Al Cu\n  pair_coeff * * GaN_tersoff.polymorphic Ga N\n  pair_coeff * * GaN_sw.polymorphic GaN\n  \n  \n  ",
    "restrictions": "If using create_atoms command, atomic masses must be defined in the\n  input script. If using read_data, atomic masses must be defined in the\n  atomic structure data file.\n  This pair style is part of the MANYBODY package. It is only enabled if\n  LAMMPS was built with that package. See the Build package doc page for more info.\n  This pair potential requires the newtion setting to be\n  “on” for pair interactions.\n  The potential files provided with LAMMPS (see the potentials\n  directory) are parameterized for metal units. You can use\n  any LAMMPS units, but you would need to create your own potential\n  files.\n  "
},
{
    "command": "pair_style python",
    "description": "The python pair style provides a way to define pairwise additive\n  potential functions as python script code that is loaded into LAMMPS\n  from a python file which must contain specific python class definitions.\n  This allows to rapidly evaluate different potential functions without\n  having to modify and re-compile LAMMPS. Due to python being an\n  interpreted language, however, the performance of this pair style is\n  going to be significantly slower (often between 20x and 100x) than\n  corresponding compiled code. This penalty can be significantly reduced\n  through generating tabulations from the python code through the\n  pair_write command, which is supported by this style.\n  Only a single pair_coeff command is used with the python pair style\n  which specifies a python class inside a python module or file that\n  LAMMPS will look up in the current directory, the folder pointed to by\n  the LAMMPS_POTENTIALS environment variable or somewhere in your python\n  path.  A single python module can hold multiple python pair class\n  definitions. The class definitions itself have to follow specific\n  rules that are explained below.\n  Atom types in the python class are specified through symbolic\n  constants, typically strings. These are mapped to LAMMPS atom types by\n  specifying N additional arguments after the class name in the\n  pair_coeff command, where N must be the number of currently defined\n  atom types:\n  As an example, imagine a file py_pot.py has a python potential class\n  names LJCutMelt with parameters and potential functions for a two\n  Lennard-Jones atom types labeled as ‘LJ1’ and ‘LJ2’. In your LAMMPS\n  input and you would have defined 3 atom types, out of which the first\n  two are supposed to be using the ‘LJ1’ parameters and the third the\n  ‘LJ2’ parameters, then you would use the following pair_coeff command:\n  pair_coeff * * py_pot.LJCutMelt LJ1 LJ1 LJ2\n  \n  \n  The first two arguments must be * * so as to span all LAMMPS atom\n  types.  The first two LJ1 arguments map LAMMPS atom types 1 and 2 to\n  the LJ1 atom type in the LJCutMelt class of the py_pot.py file.  The\n  final LJ2 argument maps LAMMPS atom type 3 to the LJ2 atom type the\n  python file.  If a mapping value is specified as NULL, the mapping is\n  not performed, any pair interaction with this atom type will be\n  skipped. This can be used when a python potential is used as part of\n  the hybrid or hybrid/overlay pair style. The NULL values are then\n  placeholders for atom types that will be used with other potentials.\n  \n  The python potential file has to start with the following code:\n  from __future__ import print_function\n  \n  class LAMMPSPairPotential(object):\n      def __init__(self):\n          self.pmap=dict()\n          self.units='lj'\n      def map_coeff(self,name,ltype):\n          self.pmap[ltype]=name\n      def check_units(self,units):\n          if (units != self.units):\n             raise Exception(\"Conflicting units: %s vs. %s\" % (self.units,units))\n  \n  \n  Any classes with definitions of specific potentials have to be derived\n  from this class and should be initialize in a similar fashion to the\n  example given below.\n  \n  Note\n  The class constructor has to set up a data structure containing\n  the potential parameters supported by this class.  It should also\n  define a variable self.units containing a string matching one of the\n  options of LAMMPS’ units command, which is used to\n  verify, that the potential definition in the python class and in the\n  LAMMPS input match.\n  \n  Here is an example for a single type Lennard-Jones potential class\n  LJCutMelt in reduced units, which defines an atom type lj for\n  which the parameters epsilon and sigma are both 1.0:\n  class LJCutMelt(LAMMPSPairPotential):\n      def __init__(self):\n          super(LJCutMelt,self).__init__()\n          # set coeffs: 48*eps*sig**12, 24*eps*sig**6,\n          #              4*eps*sig**12,  4*eps*sig**6\n          self.units = 'lj'\n          self.coeff = {'lj'  : {'lj'  : (48.0,24.0,4.0,4.0)}}\n  \n  \n  The class also has to provide two methods for the computation of the\n  potential energy and forces, which have be named compute_force,\n  and compute_energy, which both take 3 numerical arguments:\n  \n  rsq   = the square of the distance between a pair of atoms (float)\n  itype = the (numerical) type of the first atom\n  jtype = the (numerical) type of the second atom\n  \n  This functions need to compute the force and the energy, respectively,\n  and use the result as return value. The functions need to use the\n  pmap dictionary to convert the LAMMPS atom type number to the symbolic\n  value of the internal potential parameter data structure. Following\n  the LJCutMelt example, here are the two functions:\n  def compute_force(self,rsq,itype,jtype):\n       coeff = self.coeff[self.pmap[itype]][self.pmap[jtype]]\n       r2inv  = 1.0/rsq\n       r6inv  = r2inv*r2inv*r2inv\n       lj1 = coeff[0]\n       lj2 = coeff[1]\n       return (r6inv * (lj1*r6inv - lj2))*r2inv\n  \n   def compute_energy(self,rsq,itype,jtype):\n       coeff = self.coeff[self.pmap[itype]][self.pmap[jtype]]\n       r2inv  = 1.0/rsq\n       r6inv  = r2inv*r2inv*r2inv\n       lj3 = coeff[2]\n       lj4 = coeff[3]\n       return (r6inv * (lj3*r6inv - lj4))\n  \n  \n  \n  Note\n  for consistency with the C++ pair styles in LAMMPS, the\n  compute_force function follows the conventions of the Pair::single()\n  methods and does not return the full force, but the force scaled by\n  the distance between the two atoms, so this value only needs to be\n  multiplied by delta x, delta y, and delta z to conveniently obtain the\n  three components of the force vector between these two atoms.\n  \n  \n  \n  Note\n  The evaluation of scripted python code will slow down the\n  computation pair-wise interactions quite significantly. However, this\n  can be largely worked around through using the python pair style not\n  for the actual simulation, but to generate tabulated potentials on the\n  fly using the pair_write command. Please see below\n  for an example LAMMPS input of how to build a table file:\n  \n  pair_style python 2.5\n  pair_coeff * * py_pot.LJCutMelt lj\n  shell rm -f melt.table\n  pair_write  1 1 2000 rsq 0.01 2.5 lj1_lj2.table lj\n  \n  \n  Note that it is strongly recommended to try to delete the potential\n  table file before generating it. Since the pair_write command will\n  always append to a table file, while pair style table will use the\n  first match. Thus when changing the potential function in the python\n  class, the table pair style will still read the old variant unless the\n  table file is first deleted.\n  After switching the pair style to table, the potential tables need\n  to be assigned to the LAMMPS atom types like this:\n  pair_style      table linear 2000\n  pair_coeff      1  1  melt.table lj\n  \n  \n  This can also be done for more complex systems.  Please see the\n  examples/python folders for a few more examples.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  Mixing of potential parameters has to be handled inside the provided\n  python module. The python pair style simply assumes that force and\n  energy computation can be correctly performed for all pairs of atom\n  types as they are mapped to the atom type labels inside the python\n  potential class.\n  This pair style does not support the pair_modify\n  shift, table, and tail options.\n  This pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\n  need to re-specify the pair_style and pair_coeff commands in an input\n  script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style python cutoff\n  \n  \n  cutoff = global cutoff for interactions in python potential classes\n  ",
    "examples": "pair_style python 2.5\n  pair_coeff * * py_pot.LJCutMelt lj\n  \n  pair_style hybrid/overlay coul/long 12.0 python 12.0\n  pair_coeff * * coul/long\n  pair_coeff * * python py_pot.LJCutSPCE OW NULL\n  \n  \n  ",
    "restrictions": "This pair style is part of the PYTHON package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style quip",
    "description": "Style quip provides an interface for calling potential routines from\n  the QUIP package. QUIP is built separately, and then linked to\n  LAMMPS. The most recent version of the QUIP package can be downloaded\n  from GitHub:\n  https://github.com/libAtoms/QUIP. The\n  interface is chiefly intended to be used to run Gaussian Approximation\n  Potentials (GAP), which are described in the following publications:\n  (Bartok et al) and (PhD thesis of Bartok).\n  Only a single pair_coeff command is used with the quip style that\n  specifies a QUIP potential file containing the parameters of the\n  potential for all needed elements in XML format. This is followed by a\n  QUIP initialization string. Finally, the QUIP elements are mapped to\n  LAMMPS atom types by specifying N atomic numbers, where N is the\n  number of LAMMPS atom types:\n  \n  QUIP filename\n  QUIP initialization string\n  N atomic numbers = mapping of QUIP elements to atom types\n  \n  See the pair_coeff doc page for alternate ways\n  to specify the path for the potential file.\n  A QUIP potential is fully specified by the filename which contains the\n  parameters of the potential in XML format, the initialization string,\n  and the map of atomic numbers.\n  GAP potentials can be obtained from the Data repository section of\n  http://www.libatoms.org, where the\n  appropriate initialization strings are also advised. The list of\n  atomic numbers must be matched to the LAMMPS atom types specified in\n  the LAMMPS data file or elsewhere.\n  Two examples input scripts are provided in the examples/USER/quip\n  directory.\n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This pair style does not support the pair_modify\n  mix, shift, table, and tail options.\n  This pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\n  need to re-specify the pair_style and pair_coeff commands in an input\n  script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style quip\n  \n  \n  ",
    "examples": "pair_style      quip\n  pair_coeff      * * gap_example.xml \"Potential xml_label=GAP_2014_5_8_60_17_10_38_466\" 14\n  pair_coeff      * * sw_example.xml \"IP SW\" 14\n  \n  \n  ",
    "restrictions": "This pair style is part of the USER-QUIP package.  It is only enabled\n  if LAMMPS was built with that package.  See the Build package doc page for more info.\n  QUIP potentials are parameterized in electron-volts and Angstroms and\n  therefore should be used with LAMMPS metal units.\n  QUIP potentials are generally not designed to work with the scaling\n  factors set by the special_bonds command.  The\n  recommended setting in molecular systems is to include all\n  interactions, i.e. to use special_bonds lj/coul 1.0 1.0 1.0. Scaling\n  factors > 0.0 will be ignored and treated as 1.0. The only exception\n  to this rule is if you know that your QUIP potential needs to exclude\n  bonded, 1-3, or 1-4 interactions and does not already do this exclusion\n  within QUIP. Then a factor 0.0 needs to be used which will remove such\n  pairs from the neighbor list. This needs to be very carefully tested,\n  because it may remove pairs from the neighbor list that are still\n  required.\n  "
},
{
    "command": "pair_style reax/c",
    "description": "Style reax/c computes the ReaxFF potential of van Duin, Goddard and\n  co-workers.  ReaxFF uses distance-dependent bond-order functions to\n  represent the contributions of chemical bonding to the potential\n  energy. There is more than one version of ReaxFF. The version\n  implemented in LAMMPS uses the functional forms documented in the\n  supplemental information of the following paper: (Chenoweth et al., 2008).  The version integrated into LAMMPS matches\n  the most up-to-date version of ReaxFF as of summer 2010.  For more\n  technical details about the pair reax/c implementation of ReaxFF, see\n  the (Aktulga) paper. The reax/c style was initially\n  implemented as a stand-alone C code and is now integrated into LAMMPS\n  as a package.\n  The reax/c/kk style is a Kokkos version of the ReaxFF potential that\n  is derived from the reax/c style. The Kokkos version can run on GPUs\n  and can also use OpenMP multithreading. For more information about the\n  Kokkos package, see Packages details and\n  Speed kokkos doc pages.  One important\n  consideration when using the reax/c/kk style is the choice of either\n  half or full neighbor lists. This setting can be changed using the\n  Kokkos package command.\n  The reax/c style differs from the (obsolete) “pair_style reax”\n  command in the implementation details.  The reax style was a\n  Fortran library, linked to LAMMPS.  The reax style has been removed\n  from LAMMPS after the 12 December 2018 version.\n  LAMMPS provides several different versions of ffield.reax in its\n  potentials dir, each called potentials/ffield.reax.label.  These are\n  documented in potentials/README.reax.  The default ffield.reax\n  contains parameterizations for the following elements: C, H, O, N.\n  The format of these files is identical to that used originally by van\n  Duin.  We have tested the accuracy of pair_style reax/c potential\n  against the original ReaxFF code for the systems mentioned above.  You\n  can use other ffield files for specific chemical systems that may be\n  available elsewhere (but note that their accuracy may not have been\n  tested).\n  \n  Note\n  We do not distribute a wide variety of ReaxFF force field files\n  with LAMMPS.  Adri van Duin’s group at PSU is the central repository\n  for this kind of data as they are continuously deriving and updating\n  parameterizations for different classes of materials.  You can submit\n  a contact request at the Materials Computation Center (MCC) website\n  https://www.mri.psu.edu/materials-computation-center/connect-mcc,\n  describing the material(s) you are interested in modeling with ReaxFF.\n  They can tell you what is currently available or what it would take to\n  create a suitable ReaxFF parameterization.\n  \n  The cfile setting can be specified as NULL, in which case default\n  settings are used. A control file can be specified which defines\n  values of control variables. Some control variables are\n  global parameters for the ReaxFF potential. Others define certain\n  performance and output settings.\n  Each line in the control file specifies the value for\n  a control variable.  The format of the control file is described\n  below.\n  \n  Note\n  The LAMMPS default values for the ReaxFF global parameters\n  correspond to those used by Adri van Duin’s stand-alone serial\n  code. If these are changed by setting control variables in the control\n  file, the results from LAMMPS and the serial code will not agree.\n  \n  Examples using pair_style reax/c are provided in the examples/reax\n  sub-directory.\n  Use of this pair style requires that a charge be defined for every\n  atom.  See the atom_style and\n  read_data commands for details on how to specify\n  charges.\n  The ReaxFF parameter files provided were created using a charge\n  equilibration (QEq) model for handling the electrostatic interactions.\n  Therefore, by default, LAMMPS requires that the fix qeq/reax command be used with pair_style reax/c\n  when simulating a ReaxFF model, to equilibrate charge each timestep.\n  Using the keyword checkqeq with the value no\n  turns off the check for fix qeq/reax,\n  allowing a simulation to be run without charge equilibration.\n  In this case, the static charges you\n  assign to each atom will be used for computing the electrostatic\n  interactions in the system.\n  See the fix qeq/reax command for details.\n  Using the optional keyword lgvdw with the value yes turns on the\n  low-gradient correction of the ReaxFF/C for long-range London\n  Dispersion, as described in the (Liu) paper. Force field\n  file ffield.reax.lg is designed for this correction, and is trained\n  for several energetic materials (see “Liu”). When using lg-correction,\n  recommended value for parameter thb is 0.01, which can be set in the\n  control file.  Note: Force field files are different for the original\n  or lg corrected pair styles, using wrong ffield file generates an\n  error message.\n  Using the optional keyword enobonds with the value yes, the energy\n  of atoms with no bonds (i.e. isolated atoms) is included in the total\n  potential energy and the per-atom energy of that atom.  If the value\n  no is specified then the energy of atoms with no bonds is set to\n  zero.  The latter behavior is usual not desired, as it causes\n  discontinuities in the potential energy when the bonding of an atom\n  drops to zero.\n  Optional keywords safezone and mincap are used for allocating\n  reax/c arrays.  Increasing these values can avoid memory problems,\n  such as segmentation faults and bondchk failed errors, that could\n  occur under certain conditions. These keywords are not used by the\n  Kokkos version, which instead uses a more robust memory allocation\n  scheme that checks if the sizes of the arrays have been exceeded and\n  automatically allocates more memory.\n  The thermo variable evdwl stores the sum of all the ReaxFF potential\n  energy contributions, with the exception of the Coulombic and charge\n  equilibration contributions which are stored in the thermo variable\n  ecoul.  The output of these quantities is controlled by the\n  thermo command.\n  This pair style tallies a breakdown of the total ReaxFF potential\n  energy into sub-categories, which can be accessed via the compute pair command as a vector of values of length 14.\n  The 14 values correspond to the following sub-categories (the variable\n  names in italics match those used in the original FORTRAN ReaxFF\n  code):\n  \n  eb = bond energy\n  ea = atom energy\n  elp = lone-pair energy\n  emol = molecule energy (always 0.0)\n  ev = valence angle energy\n  epen = double-bond valence angle penalty\n  ecoa = valence angle conjugation energy\n  ehb = hydrogen bond energy\n  et = torsion energy\n  eco = conjugation energy\n  ew = van der Waals energy\n  ep = Coulomb energy\n  efi = electric field energy (always 0.0)\n  eqeq = charge equilibration energy\n  \n  To print these quantities to the log file (with descriptive column\n  headings) the following commands could be included in an input script:\n  compute reax all pair reax/c\n  variable eb      equal c_reax[1]\n  variable ea      equal c_reax[2]\n  [...]\n  variable eqeq    equal c_reax[14]\n  thermo_style custom step temp epair v_eb v_ea [...] v_eqeq\n  \n  \n  Only a single pair_coeff command is used with the reax/c style which\n  specifies a ReaxFF potential file with parameters for all needed\n  elements.  These are mapped to LAMMPS atom types by specifying N\n  additional arguments after the filename in the pair_coeff command,\n  where N is the number of LAMMPS atom types:\n  \n  filename\n  N indices = ReaxFF elements\n  \n  The filename is the ReaxFF potential file.\n  In the ReaxFF potential file, near the top, after the general\n  parameters, is the atomic parameters section that contains element\n  names, each with a couple dozen numeric parameters.  If there are M\n  elements specified in the ffield file, think of these as numbered 1\n  to M. Each of the N indices you specify for the N atom types of LAMMPS\n  atoms must be an integer from 1 to M.  Atoms with LAMMPS type 1 will\n  be mapped to whatever element you specify as the first index value,\n  etc.  If a mapping value is specified as NULL, the mapping is not\n  performed.  This can be used when the reax/c style is used as part\n  of the hybrid pair style.  The NULL values are placeholders for atom\n  types that will be used with other potentials.\n  As an example, say your LAMMPS simulation has 4 atom types and the\n  elements are ordered as C, H, O, N in the ffield file.  If you want\n  the LAMMPS atom type 1 and 2 to be C, type 3 to be N, and type 4 to be\n  H, you would use the following pair_coeff command:\n  pair_coeff * * ffield.reax C C N H\n  \n  \n  \n  The format of a line in the control file is as follows:\n  variable_name value\n  \n  \n  and it may be followed by an “!” character and a trailing comment.\n  If the value of a control variable is not specified, then default\n  values are used.  What follows is the list of variables along with a\n  brief description of their use and default values.\n  simulation_name: Output files produced by pair_style reax/c carry\n  this name + extensions specific to their contents.  Partial energies\n  are reported with a “.pot” extension, while the trajectory file has\n  “.trj” extension.\n  tabulate_long_range: To improve performance, long range interactions\n  can optionally be tabulated (0 means no tabulation). Value of this\n  variable denotes the size of the long range interaction table.  The\n  range from 0 to long range cutoff (defined in the ffield file) is\n  divided into tabulate_long_range points.  Then at the start of\n  simulation, we fill in the entries of the long range interaction table\n  by computing the energies and forces resulting from van der Waals and\n  Coulomb interactions between every possible atom type pairs present in\n  the input system.  During the simulation we consult to the long range\n  interaction table to estimate the energy and forces between a pair of\n  atoms. Linear interpolation is used for estimation. (default value =\n  0)\n  energy_update_freq: Denotes the frequency (in number of steps) of\n  writes into the partial energies file. (default value = 0)\n  nbrhood_cutoff: Denotes the near neighbors cutoff (in Angstroms)\n  regarding the bonded interactions. (default value = 5.0)\n  hbond_cutoff: Denotes the cutoff distance (in Angstroms) for hydrogen\n  bond interactions.(default value = 7.5. A value of 0.0 turns off\n  hydrogen bonds)\n  bond_graph_cutoff: is the threshold used in determining what is a\n  physical bond, what is not. Bonds and angles reported in the\n  trajectory file rely on this cutoff. (default value = 0.3)\n  thb_cutoff: cutoff value for the strength of bonds to be considered in\n  three body interactions. (default value = 0.001)\n  thb_cutoff_sq: cutoff value for the strength of bond order products\n  to be considered in three body interactions. (default value = 0.00001)\n  write_freq: Frequency of writes into the trajectory file. (default\n  value = 0)\n  traj_title: Title of the trajectory - not the name of the trajectory\n  file.\n  atom_info: 1 means print only atomic positions + charge (default = 0)\n  atom_forces: 1 adds net forces to atom lines in the trajectory file\n  (default = 0)\n  atom_velocities: 1 adds atomic velocities to atoms line (default = 0)\n  bond_info: 1 prints bonds in the trajectory file (default = 0)\n  angle_info: 1 prints angles in the trajectory file (default = 0)\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This pair style does not support the pair_modify\n  mix, shift, table, and tail options.\n  This pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\n  need to re-specify the pair_style and pair_coeff commands in an input\n  script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "pair_style reax/c cfile keyword value\n  \n  \n  \n  cfile = NULL or name of a control file\n  zero or more keyword/value pairs may be appended\n  keyword = checkqeq or lgvdw or safezone or mincap\n    checkqeq value = yes or no = whether or not to require qeq/reax fix\n    enobonds value = yes or no = whether or not to tally energy of atoms with no bonds\n    lgvdw value = yes or no = whether or not to use a low gradient vdW correction\n    safezone = factor used for array allocation\n    mincap = minimum size for array allocation\n  \n  \n  ",
    "examples": "pair_style reax/c NULL\n  pair_style reax/c controlfile checkqeq no\n  pair_style reax/c NULL lgvdw yes\n  pair_style reax/c NULL safezone 1.6 mincap 100\n  pair_coeff * * ffield.reax C H O N\n  \n  \n  ",
    "restrictions": "This pair style is part of the USER-REAXC package.  It is only enabled\n  if LAMMPS was built with that package.  See the Build package doc page for more info.\n  The ReaxFF potential files provided with LAMMPS in the potentials\n  directory are parameterized for real units.  You can use\n  the ReaxFF potential with any LAMMPS units, but you would need to\n  create your own potential file with coefficients listed in the\n  appropriate units if your simulation does not use “real” units.\n  "
},
{
    "command": "pair_style resquared",
    "description": "Style resquared computes the RE-squared anisotropic interaction\n  (Everaers), (Babadi) between pairs of\n  ellipsoidal and/or spherical Lennard-Jones particles.  For ellipsoidal\n  interactions, the potential considers the ellipsoid as being comprised\n  of small spheres of size \\(\\sigma\\).  LJ particles are a single sphere of\n  size \\(\\sigma\\).  The distinction is made to allow the pair style to make\n  efficient calculations of ellipsoid/solvent interactions.\n  Details for the equations used are given in the references below and\n  in this supplementary document.\n  Use of this pair style requires the NVE, NVT, or NPT fixes with the\n  asphere extension (e.g. fix nve/asphere) in\n  order to integrate particle rotation.  Additionally, atom_style ellipsoid should be used since it defines the\n  rotational state and the size and shape of each ellipsoidal particle.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands:\n  \n  A12 = Energy Prefactor/Hamaker constant (energy units)\n  \\(\\sigma\\) = atomic interaction diameter (distance units)\n  \\(\\epsilon_{i,a}\\) = relative well depth of type I for side-to-side interactions\n  \\(\\epsilon_{i,b}\\) = relative well depth of type I for face-to-face interactions\n  \\(\\epsilon_{i,c}\\) = relative well depth of type I for end-to-end interactions\n  \\(\\epsilon_{j,a}\\) = relative well depth of type J for side-to-side interactions\n  \\(\\epsilon_{j,b}\\) = relative well depth of type J for face-to-face interactions\n  \\(\\epsilon_{j,c}\\) = relative well depth of type J for end-to-end interactions\n  cutoff (distance units)\n  \n  The parameters used depend on the type of the interacting particles,\n  i.e. ellipsoids or LJ spheres.  The type of a particle is determined\n  by the diameters specified for its 3 shape parameters.  If all 3 shape\n  parameters = 0.0, then the particle is treated as an LJ sphere.  The\n  \\(\\epsilon_{i,*}\\) or \\(\\epsilon_{j,*}\\) parameters are ignored\n  for LJ spheres.  If\n  the 3 shape parameters are > 0.0, then the particle is treated as an\n  ellipsoid (even if the 3 parameters are equal to each other).\n  A12 specifies the energy prefactor which depends on the types of the\n  two interacting particles.\n  For ellipsoid/ellipsoid interactions, the interaction is computed by\n  the formulas in the supplementary document referenced above.  A12 is\n  the Hamaker constant as described in (Everaers). In LJ\n  units:\n  \n  \\[A_{12} = 4\\pi^2\\epsilon_{\\mathrm{LJ}}(\\rho\\sigma^3)^2\\]\n  where \\(\\rho\\) gives the number density of the spherical particles\n  composing the ellipsoids and \\(\\epsilon_{\\mathrm{LJ}}\\) determines\n  the interaction strength of the spherical particles.\n  For ellipsoid/LJ sphere interactions, the interaction is also computed\n  by the formulas in the supplementary document referenced above.  A12\n  has a modified form (see here for\n  details):\n  \n  \\[A_{12} = 4\\pi^2\\epsilon_{\\mathrm{LJ}}(\\rho\\sigma^3)\\]\n  For ellipsoid/LJ sphere interactions, a correction to the distance-\n  of-closest approach equation has been implemented to reduce the error\n  from two particles of disparate sizes; see this supplementary document.\n  For LJ sphere/LJ sphere interactions, the interaction is computed\n  using the standard Lennard-Jones formula, which is much cheaper to\n  compute than the ellipsoidal formulas.  A12 is used as epsilon in the\n  standard LJ formula:\n  \n  \\[A_{12} = \\epsilon_{\\mathrm{LJ}}\\]\n  and the specified \\(\\sigma\\) is used as the \\(\\sigma\\) in the\n  standard LJ formula.\n  When one of both of the interacting particles are ellipsoids, then\n  \\(\\sigma\\) specifies the diameter of the continuous distribution of\n  constituent particles within each ellipsoid used to model the RE-squared\n  potential.  Note that this is a different meaning for \\(\\sigma\\)\n  than the pair_style gayberne potential uses.\n  The \\(\\epsilon_i\\) and \\(\\epsilon_j\\) coefficients are defined\n  for atom types, not for pairs of atom types.  Thus, in a series of\n  pair_coeff commands, they only need to be specified once for each atom\n  type.\n  Specifically, if any of \\(\\epsilon_{i,a}\\), \\(\\epsilon_{i,b}\\),\n  \\(\\epsilon_{i,c}\\) are non-zero, the three values are assigned to\n  atom type I.  If all the \\(\\epsilon_i\\) values are zero, they are\n  ignored.  If any of \\(\\epsilon_{j,a}\\), \\(\\epsilon_{j,b}\\),\n  \\(\\epsilon_{j,c}\\) are non-zero, the three values are assigned to\n  atom type J.  If all three \\(\\epsilon_i\\) values are zero, they are\n  ignored.  Thus the typical way to define the \\(\\epsilon_i\\) and\n  \\(\\epsilon_j\\) coefficients is to list their values in “pair_coeff\n  I J” commands when I = J, but set them to 0.0 when I != J.  If you do\n  list them when I != J, you should insure they are consistent with their\n  values in other pair_coeff commands.\n  Note that if this potential is being used as a sub-style of\n  pair_style hybrid, and there is no “pair_coeff I I”\n  setting made for RE-squared for a particular type I (because I-I\n  interactions are computed by another hybrid pair potential), then you\n  still need to insure the epsilon a,b,c coefficients are assigned to\n  that type in a “pair_coeff I J” command.\n  For large uniform molecules it has been shown that the \\(\\epsilon_{*,*}\\)\n  energy parameters are approximately representable in terms of local\n  contact curvatures (Everaers):\n  \n  \\[\\epsilon_a = \\sigma \\cdot { \\frac{a}{ b \\cdot c } }; \\epsilon_b =\n  \\sigma \\cdot { \\frac{b}{ a \\cdot c } }; \\epsilon_c = \\sigma \\cdot {\n  \\frac{c}{ a \\cdot b } }\\]\n  where a, b, and c give the particle diameters.\n  The last coefficient is optional.  If not specified, the global cutoff\n  specified in the pair_style command is used.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the epsilon and sigma coefficients\n  and cutoff distance can be mixed, but only for sphere pairs.  The\n  default mix value is geometric.  See the “pair_modify” command for\n  details.  Other type pairs cannot be mixed, due to the different\n  meanings of the energy prefactors used to calculate the interactions\n  and the implicit dependence of the ellipsoid-sphere interaction on the\n  equation for the Hamaker constant presented here.  Mixing of sigma and\n  epsilon followed by calculation of the energy prefactors using the\n  equations above is recommended.\n  This pair styles supports the pair_modify shift\n  option for the energy of the Lennard-Jones portion of the pair\n  interaction, but only for sphere-sphere interactions.  There is no\n  shifting performed for ellipsoidal interactions due to the anisotropic\n  dependence of the interaction.\n  The pair_modify table option is not relevant\n  for this pair style.\n  This pair style does not support the pair_modify\n  tail option for adding long-range tail corrections to energy and\n  pressure.\n  This pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords of the run_style command.\n  ",
    "syntax": "pair_style resquared cutoff\n  \n  \n  \n  cutoff = global cutoff for interactions (distance units)\n  \n  ",
    "examples": "pair_style resquared 10.0\n  pair_coeff * * 1.0 1.0 1.7 3.4 3.4 1.0 1.0 1.0\n  \n  \n  ",
    "restrictions": "This style is part of the ASPHERE package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  This pair style requires that atoms be ellipsoids as defined by the\n  atom_style ellipsoid command.\n  Particles acted on by the potential can be finite-size aspherical or\n  spherical particles, or point particles.  Spherical particles have all\n  3 of their shape parameters equal to each other.  Point particles have\n  all 3 of their shape parameters equal to 0.0.\n  The distance-of-closest-approach approximation used by LAMMPS becomes\n  less accurate when high-aspect ratio ellipsoids are used.\n  "
},
{
    "command": "pair_style lj/sdk",
    "description": "The lj/sdk styles compute a 9/6, 12/4, or 12/6 Lennard-Jones potential,\n  given by\n  \n  \\[\\begin{split}E = & \\frac{27}{4} \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{9} -\n                        \\left(\\frac{\\sigma}{r}\\right)^6 \\right]\n                        \\qquad r < r_c \\\\\n  E = & \\frac{3\\sqrt{3}}{2} \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -\n                        \\left(\\frac{\\sigma}{r}\\right)^4 \\right]\n                        \\qquad r < r_c \\\\\n  E = &  4 \\epsilon  \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} -\n                        \\left(\\frac{\\sigma}{r}\\right)^6 \\right]\n                        \\qquad r < r_c\\end{split}\\]\n  as required for the SDK Coarse-grained MD parameterization discussed in\n  (Shinoda) and (DeVane).  Rc is the cutoff.\n  Style lj/sdk/coul/long computes the adds Coulombic interactions\n  with an additional damping factor applied so it can be used in\n  conjunction with the kspace_style command and\n  its ewald or pppm or pppm/cg option.  The Coulombic cutoff\n  specified for this style means that pairwise interactions within\n  this distance are computed directly; interactions outside that\n  distance are computed in reciprocal space.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands, or by mixing as described below:\n  \n  cg_type (lj9_6, lj12_4, or lj12_6)\n  epsilon (energy units)\n  sigma (distance units)\n  cutoff1 (distance units)\n  \n  Note that sigma is defined in the LJ formula as the zero-crossing\n  distance for the potential, not as the energy minimum. The prefactors\n  are chosen so that the potential minimum is at -epsilon.\n  The latter 2 coefficients are optional.  If not specified, the global\n  LJ and Coulombic cutoffs specified in the pair_style command are used.\n  If only one cutoff is specified, it is used as the cutoff for both LJ\n  and Coulombic interactions for this type pair.  If both coefficients\n  are specified, they are used as the LJ and Coulombic cutoffs for this\n  type pair.\n  For lj/sdk/coul/long and lj/sdk/coul/msm only the LJ cutoff can be\n  specified since a Coulombic cutoff cannot be specified for an\n  individual I,J type pair.  All type pairs use the same global\n  Coulombic cutoff specified in the pair_style command.\n  \n  Styles with a gpu, intel, kk, omp or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP, and OPT packages respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, and rRESPA info:\n  For atom type pairs I,J and I != J, the epsilon and sigma coefficients\n  and cutoff distance for all of the lj/sdk pair styles cannot be mixed,\n  since different pairs may have different exponents. So all parameters\n  for all pairs have to be specified explicitly through the “pair_coeff”\n  command. Defining then in a data file is also not supported, due to\n  limitations of that file format.\n  All of the lj/sdk pair styles support the\n  pair_modify shift option for the energy of the\n  Lennard-Jones portion of the pair interaction.\n  The lj/sdk/coul/long pair styles support the\n  pair_modify table option since they can tabulate\n  the short-range portion of the long-range Coulombic interaction.\n  All of the lj/sdk pair styles write their information to binary restart files, so pair_style and pair_coeff commands do\n  not need to be specified in an input script that reads a restart file.\n  The lj/sdk and lj/cut/coul/long pair styles do not support\n  the use of the inner, middle, and outer keywords of the run_style respa command.\n  ",
    "syntax": "pair_style style args\n  \n  \n  \n  style = lj/sdk or lj/sdk/coul/long\n  args = list of arguments for a particular style\n  \n  lj/sdk args = cutoff\n    cutoff = global cutoff for Lennard Jones interactions (distance units)\n  lj/sdk/coul/long args = cutoff (cutoff2)\n    cutoff = global cutoff for LJ (and Coulombic if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Coulombic (optional) (distance units)\n  ",
    "examples": "pair_style lj/sdk 2.5\n  pair_coeff 1 1 lj12_6 1 1.1 2.8\n  \n  pair_style lj/sdk/coul/long 10.0\n  pair_style lj/sdk/coul/long 10.0 12.0\n  pair_coeff 1 1 lj9_6 100.0 3.5 12.0\n  \n  pair_style lj/sdk/coul/msm 10.0\n  pair_style lj/sdk/coul/msm 10.0 12.0\n  pair_coeff 1 1 lj9_6 100.0 3.5 12.0\n  \n  \n  ",
    "restrictions": "All of the lj/sdk pair styles are part of the USER-CGSDK package.  The\n  lj/sdk/coul/long style also requires the KSPACE package to be built\n  (which is enabled by default).  They are only enabled if LAMMPS was\n  built with that package.  See the Build package\n  doc page for more info.\n  "
},
{
    "command": "pair_style sdpd/taitwater/isothermal",
    "description": "The sdpd/taitwater/isothermal style computes forces between mesoscopic\n  particles according to the Smoothed Dissipative Particle Dynamics model\n  described in this paper by (Espanol and Revenga) under\n  the following assumptions:\n  \n  The temperature is constant and uniform.\n  The shear viscosity is constant and uniform.\n  The volume viscosity is negligible before the shear viscosity.\n  The Boltzmann constant is negligible before the heat capacity of a\n  single mesoscopic particle of fluid.\n  \n  The third assumption is true for water in nearly incompressible flows.\n  The fourth holds true for water for any reasonable size one can\n  imagine for a mesoscopic particle.\n  The pressure forces between particles will be computed according to\n  Tait’s equation of state:\n  \n  \\[p = B \\left[(\\frac{\\rho}{\\rho_0})^{\\gamma} - 1\\right]\\]\n  where \\(\\gamma = 7\\) and \\(B = c_0^2 \\rho_0 / \\gamma\\), with\n  \\(\\rho_0\\) being the reference density and \\(c_0\\) the reference\n  speed of sound.\n  The laminar viscosity and the random forces will be computed according\n  to formulas described in (Espanol and Revenga).\n  \n  Warning\n  Similar to brownian and\n  dpd styles, the newton setting for\n  pairwise interactions needs to be on when running LAMMPS in parallel\n  if you want to ensure linear momentum conservation. Otherwise random\n  forces generated for pairs straddling processor boundary will not be\n  equal and opposite.\n  \n  \n  Note\n  The actual random seed used will be a mix of what you specify\n  and other parameters like the MPI ranks. This is to ensure that\n  different MPI tasks have distinct seeds.\n  \n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above.\n  \n  \\(\\rho_0\\) reference density (mass/volume units)\n  \\(c_0\\) reference soundspeed (distance/time units)\n  h kernel function cutoff (distance units)\n  \n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This style does not support mixing.  Thus, coefficients for all\n  I,J pairs must be specified explicitly.\n  This style does not support the pair_modify\n  shift, table, and tail options.\n  This style does not write information to binary restart files.  Thus, you need to re-specify the pair_style and\n  pair_coeff commands in an input script that reads a restart file.\n  This style can only be used via the pair keyword of the run_style respa command.  It does not support the inner,\n  middle, outer keywords.\n  ",
    "syntax": "pair_style sdpd/taitwater/isothermal temperature viscosity seed\n  \n  \n  \n  temperature = temperature of the fluid (temperature units)\n  viscosity = dynamic viscosity of the fluid (mass*distance/time units)\n  seed = random number generator seed (positive integer, optional)\n  \n  ",
    "examples": "pair_style sdpd/taitwater/isothermal 300. 1. 28681\n  pair_coeff * * 1000.0 1430.0 2.4\n  \n  \n  ",
    "restrictions": "This pair style is part of the USER-SDPD package.  It is only enabled\n  if LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style smd/hertz",
    "description": "The smd/hertz style calculates contact forces between SPH particles\n  belonging to different physical bodies.\n  The contact forces are calculated using a Hertz potential, which\n  evaluates the overlap between two particles (whose spatial extents are\n  defined via its contact radius).  The effect is that a particles\n  cannot penetrate into each other.  The parameter <contact_stiffness>\n  has units of pressure and should equal roughly one half of the Young’s\n  modulus (or bulk modulus in the case of fluids) of the material model\n  associated with the SPH particles.\n  The parameter scale_factor can be used to scale the particles’\n  contact radii. This can be useful to control how close particles can\n  approach each other. Usually, scale_factor =1.0.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  No mixing is performed automatically.  Currently, no part of USER-SMD\n  supports restarting nor minimization.  rRESPA does not apply to this\n  pair style.\n  ",
    "syntax": "pair_style smd/hertz scale_factor\n  \n  \n  ",
    "examples": "pair_style smd/hertz 1.0\n  pair_coeff 1 1 <contact_stiffness>\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style smd/tlsph",
    "description": "The smd/tlsph style computes particle interactions according to\n  continuum mechanics constitutive laws and a Total-Lagrangian\n  Smooth-Particle Hydrodynamics algorithm.\n  This pair style is invoked with the following command:\n  pair_style smd/tlsph\n  pair_coeff i j *COMMON rho0 E nu Q1 Q2 hg Cp &\n                 *END\n  \n  \n  Here, i and j denote the LAMMPS particle types for which this\n  pair style is defined. Note that i and j must be equal, i.e., no\n  tlsph cross interactions between different particle types are\n  allowed.  In contrast to the usual LAMMPS pair coeff definitions,\n  which are given solely a number of floats and integers, the tlsph\n  pair coeff definition is organized using keywords. These keywords\n  mark the beginning of different sets of parameters for particle\n  properties, material constitutive models, and damage models. The pair\n  coeff line must be terminated with the *END keyword. The use the\n  line continuation operator & is recommended. A typical invocation of\n  the tlsph for a solid body would consist of an equation of state for\n  computing the pressure (the diagonal components of the stress tensor),\n  and a material model to compute shear stresses (the off-diagonal\n  components of the stress tensor). Damage and failure models can also\n  be added.\n  Please see the SMD user guide for a\n  complete listing of the possible keywords and material models.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  No mixing is performed automatically.  Currently, no part of USER-SMD\n  supports restarting nor minimization.  rRESPA does not apply to this\n  pair style.\n  ",
    "syntax": "pair_style smd/tlsph args\n  \n  \n  ",
    "examples": "pair_style smd/tlsph\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style smd/tri_surface",
    "description": "The smd/tri_surface style calculates contact forces between SPH\n  particles and a rigid wall boundary defined via the\n  smd/wall_surface fix.\n  The contact forces are calculated using a Hertz potential, which\n  evaluates the overlap between a particle (whose spatial extents are\n  defined via its contact radius) and the triangle.  The effect is that\n  a particle cannot penetrate into the triangular surface.  The\n  parameter <contact_stiffness> has units of pressure and should equal\n  roughly one half of the Young’s modulus (or bulk modulus in the case\n  of fluids) of the material model associated with the SPH particle\n  The parameter scale_factor can be used to scale the particles’\n  contact radii. This can be useful to control how close particles can\n  approach the triangulated surface. Usually, scale_factor =1.0.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  No mixing is performed automatically.\n  Currently, no part of USER-SMD supports restarting nor minimization.\n  rRESPA does not apply to this pair style.\n  ",
    "syntax": "pair_style smd/tri_surface scale_factor\n  \n  \n  ",
    "examples": "pair_style smd/tri_surface 1.0\n  pair_coeff 1 1 <contact_stiffness>\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style smd/ulsph",
    "description": "The smd/ulsph style computes particle interactions according to\n  continuum mechanics constitutive laws and an updated Lagrangian\n  Smooth-Particle Hydrodynamics algorithm.\n  This pair style is invoked similar to the following command:\n  pair_style smd/ulsph *DENSITY_CONTINUITY *VELOCITY_GRADIENT *NO_GRADIENT_CORRECTION\n  pair_coeff i j *COMMON rho0 c0 Q1 Cp hg &\n                 *END\n  \n  \n  Here, i and j denote the LAMMPS particle types for which this\n  pair style is defined. Note that i and j can be different, i.e.,\n  ulsph cross interactions between different particle types are\n  allowed. However, i–i respectively j–j pair_coeff lines have\n  to precede a cross interaction.  In contrast to the usual LAMMPS\n  pair coeff definitions, which are given solely a number of floats\n  and integers, the ulsph pair coeff definition is organized using\n  keywords. These keywords mark the beginning of different sets of\n  parameters for particle properties, material constitutive models, and\n  damage models. The pair coeff line must be terminated with the\n  *END keyword. The use the line continuation operator & is\n  recommended. A typical invocation of the ulsph for a solid body\n  would consist of an equation of state for computing the pressure (the\n  diagonal components of the stress tensor), and a material model to\n  compute shear stresses (the off-diagonal components of the stress\n  tensor).\n  Note that the use of *GRADIENT_CORRECTION can lead to severe numerical\n  instabilities. For a general fluid simulation, *NO_GRADIENT_CORRECTION\n  is recommended.\n  Please see the SMD user guide for a\n  complete listing of the possible keywords and material models.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  No mixing is performed automatically.  Currently, no part of USER-SMD\n  supports restarting nor minimization.  rRESPA does not apply to this\n  pair style.\n  ",
    "syntax": "pair_style smd/ulsph args\n  \n  \n  \n  these keywords must be given\n  \n  keyword = *DENSITY_SUMMATION or *DENSITY_CONTINUITY and *VELOCITY_GRADIENT or *NO_VELOCITY_GRADIENT and *GRADIENT_CORRECTION or *NO_GRADIENT_CORRECTION\n  ",
    "examples": "pair_style smd/ulsph *DENSITY_CONTINUITY *VELOCITY_GRADIENT *NO_GRADIENT_CORRECTION\n  \n  \n  ",
    "restrictions": "This fix is part of the USER-SMD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style snap",
    "description": "Pair style snap computes interactions using the spectral\n  neighbor analysis potential (SNAP) (Thompson).\n  Like the GAP framework of Bartok et al. (Bartok2010),\n  (Bartok2013) which uses bispectrum components\n  to characterize the local neighborhood of each atom\n  in a very general way. The mathematical definition of the\n  bispectrum calculation used by SNAP is identical\n  to that used by compute sna/atom.\n  In SNAP, the total energy is decomposed into a sum over\n  atom energies. The energy of atom i is\n  expressed as a weighted sum over bispectrum components.\n  \n  \\[E^i_{SNAP}(B_1^i,...,B_K^i) = \\beta^{\\alpha_i}_0 + \\sum_{k=1}^K \\beta_k^{\\alpha_i} B_k^i\\]\n  where \\(B_k^i\\) is the k-th bispectrum component of atom i,\n  and \\(\\beta_k^{\\alpha_i}\\) is the corresponding linear coefficient\n  that depends on :math:alpha_i`, the SNAP element of atom i. The\n  number of bispectrum components used and their definitions\n  depend on the value of twojmax\n  defined in the SNAP parameter file described below.\n  The bispectrum calculation is described in more detail\n  in compute sna/atom.\n  Note that unlike for other potentials, cutoffs for SNAP potentials are\n  not set in the pair_style or pair_coeff command; they are specified in\n  the SNAP potential files themselves.\n  Only a single pair_coeff command is used with the snap style which\n  specifies a SNAP coefficient file followed by a SNAP parameter file\n  and then N additional arguments specifying the mapping of SNAP\n  elements to LAMMPS atom types, where N is the number of\n  LAMMPS atom types:\n  \n  SNAP coefficient file\n  SNAP parameter file\n  N element names = mapping of SNAP elements to atom types\n  \n  As an example, if a LAMMPS indium phosphide simulation has 4 atoms\n  types, with the first two being indium and the 3rd and 4th being\n  phophorous, the pair_coeff command would look like this:\n  pair_coeff * * snap InP.snapcoeff InP.snapparam In In P P\n  \n  \n  The 1st 2 arguments must be * * so as to span all LAMMPS atom types.\n  The two filenames are for the coefficient and parameter files, respectively.\n  The two trailing ‘In’ arguments map LAMMPS atom types 1 and 2 to the\n  SNAP ‘In’ element. The two trailing ‘P’ arguments map LAMMPS atom types\n  3 and 4 to the SNAP ‘P’ element.\n  If a SNAP mapping value is\n  specified as NULL, the mapping is not performed.\n  This can be used when a snap potential is used as part of the\n  hybrid pair style.  The NULL values are placeholders for atom types\n  that will be used with other potentials.\n  The name of the SNAP coefficient file usually ends in the\n  “.snapcoeff” extension. It may contain coefficients\n  for many SNAP elements. The only requirement is that it\n  contain at least those element names appearing in the\n  LAMMPS mapping list.\n  The name of the SNAP parameter file usually ends in the “.snapparam”\n  extension. It contains a small number\n  of parameters that define the overall form of the SNAP potential.\n  See the pair_coeff doc page for alternate ways\n  to specify the path for these files.\n  Quite commonly,\n  SNAP potentials are combined with one or more other LAMMPS pair styles\n  using the hybrid/overlay pair style. As an example, the SNAP\n  tantalum potential provided in the LAMMPS potentials directory\n  combines the snap and zbl pair styles. It is invoked\n  by the following commands:\n  variable zblcutinner equal 4\n  variable zblcutouter equal 4.8\n  variable zblz equal 73\n  pair_style hybrid/overlay &\n  zbl ${zblcutinner} ${zblcutouter} snap\n  pair_coeff * * zbl 0.0\n  pair_coeff 1 1 zbl ${zblz}\n  pair_coeff * * snap Ta06A.snapcoeff Ta06A.snapparam Ta\n  \n  \n  It is convenient to keep these commands in a separate file that can\n  be inserted in any LAMMPS input script using the include\n  command.\n  The top of the SNAP coefficient file can contain any number of blank and comment lines (start with #), but follows a strict\n  format after that. The first non-blank non-comment\n  line must contain two integers:\n  \n  nelem  = Number of elements\n  ncoeff = Number of coefficients\n  \n  This is followed by one block for each of the nelem elements.\n  The first line of each block contains three entries:\n  \n  Element symbol (text string)\n  R = Element radius (distance units)\n  w = Element weight (dimensionless)\n  \n  This line is followed by ncoeff coefficients, one per line.\n  The SNAP parameter file can contain blank and comment lines (start\n  with #) anywhere. Each non-blank non-comment line must contain one\n  keyword/value pair. The required keywords are rcutfac and\n  twojmax. Optional keywords are rfac0, rmin0,\n  switchflag, bzeroflag, and chunksize.\n  The default values for these keywords are\n  \n  rfac0 = 0.99363\n  rmin0 = 0.0\n  switchflag = 0\n  bzeroflag = 1\n  quadraticflag = 1\n  chunksize = 2000\n  \n  The keyword chunksize is only applicable when using the\n  pair style snap with the KOKKOS package and is ignored otherwise.\n  This keyword controls\n  the number of atoms in each pass used to compute the bispectrum\n  components and is used to avoid running out of memory. For example\n  if there are 4000 atoms in the simulation and the chunksize\n  is set to 2000, the bispectrum calculation will be broken up\n  into two passes.\n  Detailed definitions for all the other keywords\n  are given on the compute sna/atom doc page.\n  If quadraticflag is set to 1, then the SNAP energy expression includes the quadratic term, 0.5*B^t.alpha.B, where alpha is a symmetric K by K matrix.\n  The SNAP element file should contain K(K+1)/2 additional coefficients\n  for each element, the upper-triangular elements of alpha.\n  \n  Note\n  The previously used diagonalstyle keyword was removed in 2019,\n  since all known SNAP potentials use the default value of 3.\n  \n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, where types I and J correspond to\n  two different element types, mixing is performed by LAMMPS with\n  user-specifiable parameters as described above.  You never need to\n  specify a pair_coeff command with I != J arguments for this style.\n  This pair style does not support the pair_modify\n  shift, table, and tail options.\n  This pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\n  need to re-specify the pair_style and pair_coeff commands in an input\n  script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "pair_style snap\n  \n  \n  ",
    "examples": "pair_style snap\n  pair_coeff * * InP.snapcoeff InP.snapparam In In P P\n  \n  \n  ",
    "restrictions": "This style is part of the SNAP package.  It is only enabled if LAMMPS\n  was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style soft",
    "description": "Style soft computes pairwise interactions with the formula\n  \n  \\[E = A \\left[ 1 + \\cos\\left(\\frac{\\pi r}{r_c}\\right) \\right]\n  \\qquad r < r_c\\]\n  It is useful for pushing apart overlapping atoms, since it does not\n  blow up as r goes to 0.  A is a pre-factor that can be made to vary in\n  time from the start to the end of the run (see discussion below),\n  e.g. to start with a very soft potential and slowly harden the\n  interactions over time.  Rc is the cutoff.  See the fix nve/limit command for another way to push apart\n  overlapping atoms.\n  The following coefficients must be defined for each pair of atom types\n  via the pair_coeff command as in the examples above,\n  or in the data file or restart files read by the\n  read_data or read_restart\n  commands, or by mixing as described below:\n  \n  A (energy units)\n  cutoff (distance units)\n  \n  The last coefficient is optional.  If not specified, the global soft\n  cutoff is used.\n  \n  Note\n  The syntax for pair_coeff with a single A\n  coeff is different in the current version of LAMMPS than in older\n  versions which took two values, Astart and Astop, to ramp between\n  them.  This functionality is now available in a more general form\n  through the fix adapt command, as explained below.\n  Note that if you use an old input script and specify Astart and Astop\n  without a cutoff, then LAMMPS will interpret that as A and a cutoff,\n  which is probably not what you want.\n  \n  The fix adapt command can be used to vary A for one\n  or more pair types over the course of a simulation, in which case\n  pair_coeff settings for A must still be specified, but will be\n  overridden.  For example these commands will vary the prefactor A for\n  all pairwise interactions from 0.0 at the beginning to 30.0 at the end\n  of a run:\n  variable prefactor equal ramp(0,30)\n  fix 1 all adapt 1 pair soft a * * v_prefactor\n  \n  \n  Note that a formula defined by an equal-style variable\n  can use the current timestep, elapsed time in the current run, elapsed\n  time since the beginning of a series of runs, as well as access other\n  variables.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the A coefficient and cutoff\n  distance for this pair style can be mixed.  A is always mixed via a\n  geometric rule.  The cutoff is mixed according to the pair_modify\n  mix value.  The default mix value is geometric.  See the\n  “pair_modify” command for details.\n  This pair style does not support the pair_modify\n  shift option, since the pair interaction goes to 0.0 at the cutoff.\n  The pair_modify table and tail options are not\n  relevant for this pair style.\n  This pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style soft cutoff\n  \n  \n  \n  cutoff = global cutoff for soft interactions (distance units)\n  \n  ",
    "examples": "pair_style soft 1.0\n  pair_coeff * * 10.0\n  pair_coeff 1 1 10.0 3.0\n  \n  pair_style soft 1.0\n  pair_coeff * * 0.0\n  variable prefactor equal ramp(0,30)\n  fix 1 all adapt 1 pair soft a * * v_prefactor\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "pair_style sph/heatconduction",
    "description": "The sph/heatconduction style computes heat transport between SPH particles.\n  The transport model is the diffusion equation for the internal energy.\n  See this PDF guide to using SPH in\n  LAMMPS.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above.\n  \n  D diffusion coefficient (length^2/time units)\n  h kernel function cutoff (distance units)\n  \n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This style does not support mixing.  Thus, coefficients for all\n  I,J pairs must be specified explicitly.\n  This style does not support the pair_modify\n  shift, table, and tail options.\n  This style does not write information to binary restart files.  Thus, you need to re-specify the pair_style and\n  pair_coeff commands in an input script that reads a restart file.\n  This style can only be used via the pair keyword of the run_style respa command.  It does not support the inner,\n  middle, outer keywords.\n  ",
    "syntax": "pair_style sph/heatconduction\n  \n  \n  ",
    "examples": "pair_style sph/heatconduction\n  pair_coeff * * 1.0 2.4\n  \n  \n  ",
    "restrictions": "This pair style is part of the USER-SPH package.  It is only enabled\n  if LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style sph/idealgas",
    "description": "The sph/idealgas style computes pressure forces between particles\n  according to the ideal gas equation of state:\n  \n  \\[p = (\\gamma - 1) \\rho e\\]\n  where \\(\\gamma = 1.4\\) is the heat capacity ratio, \\(\\rho\\) is\n  the local density, and e is the internal energy per unit mass.  This\n  pair style also computes Monaghan’s artificial viscosity to prevent\n  particles from interpenetrating (Monaghan).\n  See this PDF guide to using SPH in\n  LAMMPS.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above.\n  \n  \\(\\nu\\) artificial viscosity (no units)\n  h kernel function cutoff (distance units)\n  \n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This style does not support mixing.  Thus, coefficients for all\n  I,J pairs must be specified explicitly.\n  This style does not support the pair_modify\n  shift, table, and tail options.\n  This style does not write information to binary restart files.  Thus, you need to re-specify the pair_style and\n  pair_coeff commands in an input script that reads a restart file.\n  This style can only be used via the pair keyword of the run_style respa command.  It does not support the inner,\n  middle, outer keywords.\n  ",
    "syntax": "pair_style sph/idealgas\n  \n  \n  ",
    "examples": "pair_style sph/idealgas\n  pair_coeff * * 1.0 2.4\n  \n  \n  ",
    "restrictions": "This pair style is part of the USER-SPH package.  It is only enabled\n  if LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style sph/lj",
    "description": "The sph/lj style computes pressure forces between particles according\n  to the Lennard-Jones equation of state, which is computed according to\n  Ree’s 1980 polynomial fit (Ree). The Lennard-Jones parameters\n  epsilon and sigma are set to unity.  This pair style also computes\n  Monaghan’s artificial viscosity to prevent particles from\n  interpenetrating (Monaghan).\n  See this PDF guide to using SPH in\n  LAMMPS.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above.\n  \n  \\(\\nu\\) artificial viscosity (no units)\n  h kernel function cutoff (distance units)\n  \n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This style does not support mixing.  Thus, coefficients for all\n  I,J pairs must be specified explicitly.\n  This style does not support the pair_modify\n  shift, table, and tail options.\n  This style does not write information to binary restart files.  Thus, you need to re-specify the pair_style and\n  pair_coeff commands in an input script that reads a restart file.\n  This style can only be used via the pair keyword of the run_style respa command.  It does not support the inner,\n  middle, outer keywords.\n  ",
    "syntax": "pair_style sph/lj\n  \n  \n  ",
    "examples": "pair_style sph/lj\n  pair_coeff * * 1.0 2.4\n  \n  \n  ",
    "restrictions": "As noted above, the Lennard-Jones parameters epsilon and sigma are set\n  to unity.\n  This pair style is part of the USER-SPH package.  It is only enabled\n  if LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style sph/rhosum",
    "description": "The sph/rhosum style computes the local particle mass density rho for\n  SPH particles by kernel function interpolation, every Nstep timesteps.\n  See this PDF guide to using SPH in\n  LAMMPS.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above.\n  \n  h (distance units)\n  \n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This style does not support mixing.  Thus, coefficients for all\n  I,J pairs must be specified explicitly.\n  This style does not support the pair_modify\n  shift, table, and tail options.\n  This style does not write information to binary restart files.  Thus, you need to re-specify the pair_style and\n  pair_coeff commands in an input script that reads a restart file.\n  This style can only be used via the pair keyword of the run_style respa command.  It does not support the inner,\n  middle, outer keywords.\n  ",
    "syntax": "pair_style sph/rhosum Nstep\n  \n  \n  \n  Nstep = timestep interval\n  \n  ",
    "examples": "pair_style sph/rhosum 10\n  pair_coeff * * 2.4\n  \n  \n  ",
    "restrictions": "This pair style is part of the USER-SPH package.  It is only enabled\n  if LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style sph/taitwater",
    "description": "The sph/taitwater style computes pressure forces between SPH particles\n  according to Tait’s equation of state:\n  \n  \\[p = B \\biggl[\\left(\\frac{\\rho}{\\rho_0}\\right)^{\\gamma} - 1\\biggr]\\]\n  where \\(\\gamma = 7\\) and \\(B = c_0^2 \\rho_0 / \\gamma\\), with\n  \\(\\rho_0\\) being the reference density and \\(c_0\\) the reference\n  speed of sound.\n  This pair style also computes Monaghan’s artificial viscosity to\n  prevent particles from interpenetrating (Monaghan).\n  See this PDF guide to using SPH in\n  LAMMPS.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above.\n  \n  \\(\\rho_0\\) reference density (mass/volume units)\n  \\(c_0\\) reference soundspeed (distance/time units)\n  \\(\\nu\\) artificial viscosity (no units)\n  h kernel function cutoff (distance units)\n  \n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This style does not support mixing.  Thus, coefficients for all\n  I,J pairs must be specified explicitly.\n  This style does not support the pair_modify\n  shift, table, and tail options.\n  This style does not write information to binary restart files.  Thus, you need to re-specify the pair_style and\n  pair_coeff commands in an input script that reads a restart file.\n  This style can only be used via the pair keyword of the run_style respa command.  It does not support the inner,\n  middle, outer keywords.\n  ",
    "syntax": "pair_style sph/taitwater\n  \n  \n  ",
    "examples": "pair_style sph/taitwater\n  pair_coeff * * 1000.0 1430.0 1.0 2.4\n  \n  \n  ",
    "restrictions": "This pair style is part of the USER-SPH package.  It is only enabled\n  if LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style sph/taitwater/morris",
    "description": "The sph/taitwater/morris style computes pressure forces between SPH\n  particles according to Tait’s equation of state:\n  \n  \\[p = B \\biggl[\\left(\\frac{\\rho}{\\rho_0}\\right)^{\\gamma} - 1\\biggr]\\]\n  where \\(\\gamma = 7\\) and \\(B = c_0^2 \\rho_0 / \\gamma\\), with\n  \\(\\rho_0\\) being the reference density and \\(c_0\\) the reference\n  speed of sound.\n  This pair style also computes laminar viscosity (Morris).\n  See this PDF guide to using SPH in\n  LAMMPS.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above.\n  \n  \\(\\rho_0\\) reference density (mass/volume units)\n  \\(c_0\\) reference soundspeed (distance/time units)\n  \\(\\nu\\) dynamic viscosity (mass*distance/time units)\n  h kernel function cutoff (distance units)\n  \n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This style does not support mixing.  Thus, coefficients for all\n  I,J pairs must be specified explicitly.\n  This style does not support the pair_modify\n  shift, table, and tail options.\n  This style does not write information to binary restart files.  Thus, you need to re-specify the pair_style and\n  pair_coeff commands in an input script that reads a restart file.\n  This style can only be used via the pair keyword of the run_style respa command.  It does not support the inner,\n  middle, outer keywords.\n  ",
    "syntax": "pair_style sph/taitwater/morris\n  \n  \n  ",
    "examples": "pair_style sph/taitwater/morris\n  pair_coeff * * 1000.0 1430.0 1.0 2.4\n  \n  \n  ",
    "restrictions": "This pair style is part of the USER-SPH package.  It is only enabled\n  if LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style spin/dipole/cut",
    "description": "Style spin/dipole/cut computes a short-range dipole-dipole\n  interaction between pairs of magnetic particles that each\n  have a magnetic spin.\n  The magnetic dipole-dipole interactions are computed by the\n  following formulas for the magnetic energy, magnetic precession\n  vector omega and mechanical force between particles I and J.\n  \n  \\[\\begin{split}\\mathcal{H}_{\\rm long} & =\n  -\\frac{\\mu_{0} \\left( \\mu_B\\right)^2}{4\\pi}\n  \\sum_{i,j,i\\neq j}^{N}\n   \\frac{g_i g_j}{r_{ij}^3}\n   \\biggl(3\n   \\left(\\vec{e}_{ij}\\cdot \\vec{s}_{i}\\right)\n   \\left(\\vec{e}_{ij}\\cdot \\vec{s}_{j}\\right)\n   -\\vec{s}_i\\cdot\\vec{s}_j \\biggr) \\\\\n   \\mathbf{\\omega}_i & =\n   \\frac{\\mu_0 (\\mu_B)^2}{4\\pi\\hbar}\\sum_{j}\n   \\frac{g_i g_j}{r_{ij}^3}\n   \\, \\biggl(\n   3\\,(\\vec{e}_{ij}\\cdot\\vec{s}_{j})\\vec{e}_{ij}\n   -\\vec{s}_{j} \\biggr) \\\\\n   \\mathbf{F}_i & =\n   \\frac{3\\, \\mu_0 (\\mu_B)^2}{4\\pi} \\sum_j\n   \\frac{g_i g_j}{r_{ij}^4}\n   \\biggl[\\bigl( (\\vec{s}_i\\cdot\\vec{s}_j)\n   -5(\\vec{e}_{ij}\\cdot\\vec{s}_i)\n   (\\vec{e}_{ij}\\cdot\\vec{s}_j)\\bigr) \\vec{e}_{ij}+\n   \\bigl(\n   (\\vec{e}_{ij}\\cdot\\vec{s}_i)\\vec{s}_j+\n   (\\vec{e}_{ij}\\cdot\\vec{s}_j)\\vec{s}_i\n   \\bigr)\n   \\biggr]\\end{split}\\]\n  where \\(\\vec{s}_i\\) and \\(\\vec{s}_j\\) are the spin on two magnetic\n  particles, r is their separation distance, and the vector \\(\\vec{e}_{ij}\n  = \\frac{r_i - r_j}{\\left| r_i - r_j \\right|}\\) is the direction vector\n  between the two particles.\n  Style spin/dipole/long computes long-range magnetic dipole-dipole\n  interaction.\n  A kspace_style must be defined to\n  use this pair style.  Currently, kspace_style ewald/dipole/spin and kspace_style pppm/dipole/spin support long-range magnetic\n  dipole-dipole interactions.\n  \n  The pair_modify table option is not relevant\n  for this pair style.\n  This pair style does not support the pair_modify\n  tail option for adding long-range tail corrections to energy and\n  pressure.\n  This pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  ",
    "syntax": "pair_style spin/dipole/cut cutoff\n  pair_style spin/dipole/long cutoff\n  \n  \n  \n  cutoff = global cutoff for magnetic dipole energy and forces\n  (optional) (distance units)\n  \n  ",
    "examples": "pair_style spin/dipole/cut 10.0\n  pair_coeff * * 10.0\n  pair_coeff 2 3 8.0\n  \n  pair_style spin/dipole/long 9.0\n  pair_coeff * * 10.0\n  pair_coeff 2 3 6.0\n  \n  \n  ",
    "restrictions": "The spin/dipole/cut and spin/dipole/long styles are part of\n  the SPIN package.  They are only enabled if LAMMPS was built with that\n  package.  See the Build package doc page for more\n  info.\n  Using dipole/spin pair styles with electron units is not\n  currently supported.\n  "
},
{
    "command": "pair_style spin/dmi",
    "description": "Style spin/dmi computes the Dzyaloshinskii-Moriya (DM) interaction\n  between pairs of magnetic spins.\n  According to the expression reported in (Rohart), one has\n  the following DM energy:\n  \n  \\[\\mathbf{H}_{dm} = \\sum_{{ i,j}=1,i\\neq j}^{N}\n  \\left( \\vec{e}_{ij} \\times \\vec{D} \\right)\n  \\cdot\\left(\\vec{s}_{i}\\times \\vec{s}_{j}\\right),\\]\n  where \\(\\vec{s}_i\\) and \\(\\vec{s}_j\\) are two neighboring magnetic spins of\n  two particles, \\(\\vec{e}_ij = \\frac{r_i - r_j}{\\left| r_i - r_j \\right|}\\)\n  is the unit vector between sites i and j, and \\(\\vec{D}\\) is the\n  DM vector defining the intensity (in eV) and the direction of the\n  interaction.\n  In (Rohart), \\(\\vec{D}\\) is defined as the direction normal to the film oriented\n  from the high spin-orbit layer to the magnetic ultra-thin film.\n  The application of a spin-lattice Poisson bracket to this energy (as described\n  in (Tranchida)) allows to derive a magnetic torque omega, and a\n  mechanical force F (for spin-lattice calculations only) for each magnetic\n  particle i:\n  \n  \\[\\vec{\\omega}_i = -\\frac{1}{\\hbar} \\sum_{j}^{Neighb} \\vec{s}_{j}\\times \\left(\\vec{e}_{ij}\\times \\vec{D} \\right)\n  ~~{\\rm and}~~\n  \\vec{F}_i = -\\sum_{j}^{Neighb} \\frac{1}{r_{ij}} \\vec{D} \\times \\left( \\vec{s}_{i}\\times \\vec{s}_{j} \\right)\\]\n  More details about the derivation of these torques/forces are reported in\n  (Tranchida).\n  For the spin/dmi pair style, the following coefficients must be defined for\n  each pair of atoms types via the pair_coeff command as in\n  the examples above, or in the data file or restart files read by the\n  read_data or read_restart commands, and\n  set in the following order:\n  \n  rc (distance units)\n  |D| (energy units)\n  Dx, Dy, Dz  (direction of D)\n  \n  Note that rc is the radius cutoff of the considered DM interaction, |D| is\n  the norm of the DM vector (in eV), and Dx, Dy and Dz define its direction.\n  None of those coefficients is optional.  If not specified, the spin/dmi\n  pair style cannot be used.\n  ",
    "syntax": "pair_style spin/dmi cutoff\n  \n  \n  \n  cutoff = global cutoff pair (distance in metal units)\n  \n  ",
    "examples": "pair_style spin/dmi 4.0\n  pair_coeff * * dmi 2.6 0.001 1.0 0.0 0.0\n  pair_coeff 1 2 dmi 4.0 0.00109 0.0 0.0 1.0\n  \n  \n  ",
    "restrictions": "All the pair/spin styles are part of the SPIN package.  These styles\n  are only enabled if LAMMPS was built with this package, and if the\n  atom_style “spin” was declared.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style spin/exchange",
    "description": "Style spin/exchange computes the exchange interaction between\n  pairs of magnetic spins:\n  \n  \\[H_{ex} = -\\sum_{i,j}^N J_{ij} (r_{ij}) \\,\\vec{s}_i \\cdot \\vec{s}_j\\]\n  where \\(\\vec{s}_i\\) and \\(\\vec{s}_j\\) are two neighboring magnetic spins of two particles,\n  \\(r_{ij} = \\vert \\vec{r}_i - \\vec{r}_j \\vert\\) is the inter-atomic distance between the two\n  particles. The summation is over pairs of nearest neighbors.\n  \\(J(r_{ij})\\) is a function defining the intensity and the sign of the exchange\n  interaction for different neighboring shells. This function is defined as:\n  \n  \\[{J}\\left( r_{ij} \\right) = 4 a \\left( \\frac{r_{ij}}{d}  \\right)^2 \\left( 1 - b \\left( \\frac{r_{ij}}{d}  \\right)^2 \\right) e^{-\\left( \\frac{r_{ij}}{d} \\right)^2 }\\Theta (R_c - r_{ij})\\]\n  where \\(a\\), \\(b\\) and \\(d\\) are the three constant coefficients defined in the associated\n  “pair_coeff” command, and \\(R_c\\) is the radius cutoff associated to\n  the pair interaction (see below for more explanations).\n  The coefficients \\(a\\), \\(b\\), and \\(d\\) need to be fitted so that the function above matches with\n  the value of the exchange interaction for the \\(N\\) neighbor shells taken into account.\n  Examples and more explanations about this function and its parameterization are reported\n  in (Tranchida).\n  From this exchange interaction, each spin \\(i\\) will be submitted\n  to a magnetic torque \\(\\vec{\\omega}\\), and its associated atom can be submitted to a\n  force \\(\\vec{F}\\) for spin-lattice calculations (see fix nve/spin),\n  such as:\n  \n  \\[\\vec{\\omega}_{i} = \\frac{1}{\\hbar} \\sum_{j}^{Neighb} {J}\n  \\left(r_{ij} \\right)\\,\\vec{s}_{j}\n  ~~{\\rm and}~~\n  \\vec{F}_{i} = \\sum_{j}^{Neighb} \\frac{\\partial {J} \\left(r_{ij} \\right)}{ \\partial r_{ij}} \\left( \\vec{s}_{i}\\cdot \\vec{s}_{j} \\right) \\vec{e}_{ij}\\]\n  with \\(\\hbar\\) the Planck constant (in metal units), and \\(\\vec{e}_{ij} = \\frac{\\vec{r}_i - \\vec{r}_j}{\\vert \\vec{r}_i-\\vec{r}_j \\vert}\\) the unit\n  vector between sites \\(i\\) and \\(j\\).\n  More details about the derivation of these torques/forces are reported in\n  (Tranchida).\n  For the spin/exchange pair style, the following coefficients must be defined\n  for each pair of atoms types via the pair_coeff command as in\n  the examples above, or in the data file or restart files read by the\n  read_data or read_restart commands, and\n  set in the following order:\n  \n  \\(R_c\\) (distance units)\n  \\(a\\)  (energy units)\n  \\(b\\)  (adim parameter)\n  \\(d\\)  (distance units)\n  \n  Note that \\(R_c\\) is the radius cutoff of the considered exchange interaction,\n  and \\(a\\), \\(b\\) and \\(d\\) are the three coefficients performing the parameterization\n  of the function \\(J(r_{ij})\\) defined above.\n  None of those coefficients is optional. If not specified, the\n  spin/exchange pair style cannot be used.\n  ",
    "syntax": "pair_style spin/exchange cutoff\n  \n  \n  \n  cutoff = global cutoff pair (distance in metal units)\n  \n  ",
    "examples": "pair_style spin/exchange 4.0\n  pair_coeff * * exchange 4.0 0.0446928 0.003496 1.4885\n  pair_coeff 1 2 exchange 6.0 -0.01575 0.0 1.965\n  \n  \n  ",
    "restrictions": "All the pair/spin styles are part of the SPIN package.  These styles\n  are only enabled if LAMMPS was built with this package, and if the\n  atom_style “spin” was declared.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style spin/magelec",
    "description": "Style spin/me computes a magneto-electric interaction between\n  pairs of magnetic spins. According to the derivation reported in\n  (Katsura), this interaction is defined as:\n  \n  \\[\\begin{split}\\vec{\\omega}_i & = -\\frac{1}{\\hbar} \\sum_{j}^{Neighb} \\vec{s}_{j}\\times\\vec{D}(r_{ij}) \\\\\n  \\vec{F}_i & = -\\sum_{j}^{Neighb} \\frac{\\partial D(r_{ij})}{\\partial r_{ij}} \\left(\\vec{s}_{i}\\times \\vec{s}_{j} \\right) \\cdot \\vec{r}_{ij}\\end{split}\\]\n  where \\(\\vec{s}_i\\) and \\(\\vec{s}_j\\) are neighboring magnetic\n  spins of two particles.\n  From this magneto-electric interaction, each spin i will be submitted\n  to a magnetic torque omega, and its associated atom can be submitted to a\n  force F for spin-lattice calculations (see fix nve/spin),\n  such as:\n  \n  \\[\\begin{split}\\vec{F}^{i} & = -\\sum_{j}^{Neighbor} \\left( \\vec{s}_{i}\\times \\vec{s}_{j} \\right) \\times \\vec{E} \\\\\n  \\vec{\\omega}^{i} = -\\frac{1}{\\hbar} \\sum_{j}^{Neighbor} \\vec{s}_j \\times \\left(\\vec{E}\\times r_{ij} \\right)\\end{split}\\]\n  with h the Planck constant (in metal units) and \\(\\vec{E}\\) an\n  electric polarization vector.  The norm and direction of E are giving\n  the intensity and the direction of a screened dielectric atomic\n  polarization (in eV).\n  More details about the derivation of these torques/forces are reported in\n  (Tranchida).\n  ",
    "syntax": "pair_style spin/magelec cutoff\n  \n  \n  \n  cutoff = global cutoff pair (distance in metal units)\n  \n  ",
    "examples": "pair_style spin/magelec 4.5\n  pair_coeff * * magelec 4.5 0.00109 1.0 1.0 1.0\n  \n  \n  ",
    "restrictions": "All the pair/spin styles are part of the SPIN package.  These styles\n  are only enabled if LAMMPS was built with this package, and if the\n  atom_style “spin” was declared.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style spin/neel",
    "description": "Style spin/neel computes the Neel pair anisotropy model\n  between pairs of magnetic spins:\n  \n  \\[\\mathcal{H}_{N\\acute{e}el}=-\\sum_{{ i,j=1,i\\neq j}}^N g_1(r_{ij})\\left(({\\mathbf{e}}_{ij}\\cdot {\\mathbf{s}}_{i})({\\mathbf{e}}_{ij}\n  \\cdot {\\mathbf{s}}_{j})-\\frac{{\\mathbf{s}}_{i}\\cdot{\\mathbf{s}}_{j}}{3} \\right)\n  +q_1(r_{ij})\\left( ({\\mathbf{e}}_{ij}\\cdot {\\mathbf{s}}_{i})^2 -\\frac{{\\mathbf{s}}_{i}\\cdot{\\mathbf{s}}_{j}}{3}\\right)\n  \\left( ({\\mathbf{e}}_{ij}\\cdot {\\mathbf{s}}_{i})^2 -\\frac{{\\mathbf{s}}_{i}\\cdot{\\mathbf{s}}_{j}}{3} \\right)\n  + q_2(r_{ij}) \\Big( ({\\mathbf{e}}_{ij}\\cdot {\\mathbf{s}}_{i}) ({\\mathbf{e}}_{ij}\\cdot {\\mathbf{s}}_{j})^3 + ({\\mathbf{e}}_{ij}\\cdot\n  {\\mathbf{s}}_{j}) ({\\mathbf{e}}_{ij}\\cdot {\\mathbf{s}}_{i})^3\\Big)\\]\n  where \\(\\mathbf{s}_i\\) and \\(\\mathbf{s}_j\\) are two neighboring magnetic spins of two particles,\n  \\(r_{ij} = \\vert \\mathbf{r}_i - \\mathbf{r}_j \\vert\\) is the inter-atomic distance between the two particles,\n  \\(\\mathbf{e}_{ij} = \\frac{\\mathbf{r}_i - \\mathbf{r}_j}{\\vert \\mathbf{r}_i - \\mathbf{r}_j\\vert}\\) is their normalized separation vector and \\(g_1\\),\n  \\(q_1\\) and \\(q_2\\) are three functions defining the intensity of the dipolar\n  and quadrupolar contributions, with:\n  \n  \\[\\begin{split}g_1(r_{ij}) &= g(r_{ij}) + \\frac{12}{35} q(r_{ij}) \\\\\n  q_1(r_{ij}) &= \\frac{9}{5} q(r_{ij}) \\\\\n  q_2(r_{ij}) &= - \\frac{2}{5} q(r_{ij})\\end{split}\\]\n  With the functions \\(g(r_{ij})\\) and \\(q(r_{ij})\\) defined and fitted according to\n  the same Bethe-Slater function used to fit the exchange interaction:\n  \n  \\[{J}\\left( r_{ij} \\right) = 4 a \\left( \\frac{r_{ij}}{d}  \\right)^2 \\left( 1 - b \\left( \\frac{r_{ij}}{d}  \\right)^2 \\right) e^{-\\left( \\frac{r_{ij}}{d} \\right)^2 }\\Theta (R_c - r_{ij})\\]\n  where \\(a\\), \\(b\\) and \\(d\\) are the three constant coefficients defined in the\n  associated “pair_coeff” command.\n  The coefficients \\(a\\), \\(b\\), and \\(d\\) need to be fitted so that the function\n  above matches with the values of the magneto-elastic constant of the\n  materials at stake.\n  Examples and more explanations about this function and its\n  parameterization are reported in (Tranchida). More\n  examples of parameterization will be provided in future work.\n  From this DM interaction, each spin \\(i\\) will be submitted to a magnetic\n  torque \\(\\mathbf{\\omega}\\) and its associated atom to a force \\(\\mathbf{F}\\) (for spin-lattice\n  calculations only).\n  More details about the derivation of these torques/forces are reported\n  in (Tranchida).\n  ",
    "syntax": "pair_style spin/neel cutoff\n  \n  \n  \n  cutoff = global cutoff pair (distance in metal units)\n  \n  ",
    "examples": "pair_style spin/neel 4.0\n  pair_coeff * * neel 4.0 0.0048 0.234 1.168 2.6905 0.705 0.652\n  pair_coeff 1 2 neel 4.0 0.0048 0.234 1.168 0.0 0.0 1.0\n  \n  \n  ",
    "restrictions": "All the pair/spin styles are part of the SPIN package.  These styles\n  are only enabled if LAMMPS was built with this package, and if the\n  atom_style “spin” was declared.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style srp",
    "description": "Style srp computes a soft segmental repulsive potential (SRP) that\n  acts between pairs of bonds. This potential is useful for preventing\n  bonds from passing through one another when a soft non-bonded\n  potential acts between beads in, for example, DPD polymer chains.  An\n  example input script that uses this command is provided in\n  examples/USER/srp.\n  Bonds of specified type btype interact with one another through a\n  bond-pairwise potential, such that the force on bond i due to bond\n  j is as follows\n  \n  \\[F^{\\mathrm{SRP}}_{ij} = C(1-r/r_c)\\hat{r}_{ij} \\qquad r < r_c\\]\n  where r and \\(\\hat{r}_{ij}\\) are the distance and unit vector\n  between the two bonds.  Note that btype can be specified as an\n  asterisk “*”, which case the interaction is applied to all bond types.\n  The mid option computes r and \\(\\hat{r}_{ij}\\) from the midpoint\n  distance between bonds. The min option computes r and\n  \\(\\hat{r}_{ij}\\) from the minimum distance between bonds. The force\n  acting on a bond is mapped onto the two bond atoms according to the\n  lever rule,\n  \n  \\[\\begin{split}F_{i1}^{\\mathrm{SRP}} & = F^{\\mathrm{SRP}}_{ij}(L) \\\\\n  F_{i2}^{\\mathrm{SRP}} & = F^{\\mathrm{SRP}}_{ij}(1-L)\\end{split}\\]\n  where L is the normalized distance from the atom to the point of\n  closest approach of bond i and j. The mid option takes L as\n  0.5 for each interaction as described in (Sirk).\n  The following coefficients must be defined via the\n  pair_coeff command as in the examples above, or in\n  the data file or restart file read by the read_data\n  or read_restart commands:\n  \n  C (force units)\n  \\(r_c\\) (distance units)\n  \n  The last coefficient is optional. If not specified, the global cutoff\n  is used.\n  \n  Note\n  Pair style srp considers each bond of type btype to be a\n  fictitious “particle” of type bptype, where bptype is either the\n  largest atom type in the system, or the type set by the bptype flag.\n  Any actual existing particles with this atom type will be deleted at\n  the beginning of a run. This means you must specify the number of\n  types in your system accordingly; usually to be one larger than what\n  would normally be the case, e.g. via the create_box\n  or by changing the header in your data file.  The\n  fictitious “bond particles” are inserted at the beginning of the run,\n  and serve as placeholders that define the position of the bonds.  This\n  allows neighbor lists to be constructed and pairwise interactions to\n  be computed in almost the same way as is done for actual particles.\n  Because bonds interact only with other bonds, pair_style hybrid should be used to turn off interactions\n  between atom type bptype and all other types of atoms.  An error\n  will be flagged if pair_style hybrid is not used.\n  \n  The optional exclude keyword determines if forces are computed\n  between first neighbor (directly connected) bonds.  For a setting of\n  no, first neighbor forces are computed; for yes they are not\n  computed. A setting of no cannot be used with the min option for\n  distance calculation because the minimum distance between directly\n  connected bonds is zero.\n  Pair style srp turns off normalization of thermodynamic properties\n  by particle number, as if the command thermo_modify norm no had been issued.\n  The pairwise energy associated with style srp is shifted to be zero\n  at the cutoff distance \\(r_c\\).\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This pair styles does not support mixing.\n  This pair style does not support the pair_modify\n  shift option for the energy of the pair interaction. Note that as\n  discussed above, the energy term is already shifted to be 0.0 at the\n  cutoff distance \\(r_c\\).\n  The pair_modify table option is not relevant for\n  this pair style.\n  This pair style does not support the pair_modify\n  tail option for adding long-range tail corrections to energy and\n  pressure.\n  This pair style writes global and per-atom information to binary restart files. Pair srp should be used with pair_style hybrid, thus the pair_coeff commands need to be\n  specified in the input script when reading a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style srp cutoff btype dist keyword value ...\n  \n  \n  \n  cutoff = global cutoff for SRP interactions (distance units)\n  btype = bond type to apply SRP interactions to (can be wildcard, see below)\n  distance = min or mid\n  zero or more keyword/value pairs may be appended\n  keyword = exclude\n  bptype value = atom type for bond particles\n  exclude value = yes or no\n  \n  \n  ",
    "examples": "pair_style hybrid dpd 1.0 1.0 12345 srp 0.8 1 mid exclude yes\n  pair_coeff 1 1 dpd 60.0 4.5 1.0\n  pair_coeff 1 2 none\n  pair_coeff 2 2 srp 100.0 0.8\n  \n  pair_style hybrid dpd 1.0 1.0 12345 srp 0.8 * min exclude yes\n  pair_coeff 1 1 dpd 60.0 50 1.0\n  pair_coeff 1 2 none\n  pair_coeff 2 2 srp 40.0\n  \n  pair_style hybrid srp 0.8 2 mid\n  pair_coeff 1 1 none\n  pair_coeff 1 2 none\n  pair_coeff 2 2 srp 100.0 0.8\n  \n  \n  ",
    "restrictions": "This pair style is part of the USER-MISC package. It is only enabled\n  if LAMMPS was built with that package. See the Making LAMMPS section\n  for more info.\n  This pair style must be used with pair_style hybrid.\n  This pair style requires the newton command to be on\n  for non-bonded interactions.\n  This pair style is not compatible with rigid body integrators\n  "
},
{
    "command": "pair_style sw",
    "description": "The sw style computes a 3-body Stillinger-Weber\n  potential for the energy E of a system of atoms as\n  \n  \\[\\begin{split} E & =  \\sum_i \\sum_{j > i} \\phi_2 (r_{ij}) +\n          \\sum_i \\sum_{j \\neq i} \\sum_{k > j}\n          \\phi_3 (r_{ij}, r_{ik}, \\theta_{ijk}) \\\\\n  \\phi_2(r_{ij}) & =  A_{ij} \\epsilon_{ij} \\left[ B_{ij} (\\frac{\\sigma_{ij}}{r_{ij}})^{p_{ij}} -\n                    (\\frac{\\sigma_{ij}}{r_{ij}})^{q_{ij}} \\right]\n                    \\exp \\left( \\frac{\\sigma_{ij}}{r_{ij} - a_{ij} \\sigma_{ij}} \\right) \\\\\n  \\phi_3(r_{ij},r_{ik},\\theta_{ijk}) & = \\lambda_{ijk} \\epsilon_{ijk} \\left[ \\cos \\theta_{ijk} -\n                    \\cos \\theta_{0ijk} \\right]^2\n                    \\exp \\left( \\frac{\\gamma_{ij} \\sigma_{ij}}{r_{ij} - a_{ij} \\sigma_{ij}} \\right)\n                    \\exp \\left( \\frac{\\gamma_{ik} \\sigma_{ik}}{r_{ik} - a_{ik} \\sigma_{ik}} \\right)\\end{split}\\]\n  where \\(\\phi_2\\) is a two-body term and \\(\\phi_3\\) is a\n  three-body term.  The summations in the formula are over all neighbors J\n  and K of atom I within a cutoff distance \\(a \\).\n  Only a single pair_coeff command is used with the sw style which\n  specifies a Stillinger-Weber potential file with parameters for all\n  needed elements.  These are mapped to LAMMPS atom types by specifying\n  N additional arguments after the filename in the pair_coeff command,\n  where N is the number of LAMMPS atom types:\n  \n  filename\n  N element names = mapping of SW elements to atom types\n  \n  See the pair_coeff doc page for alternate ways\n  to specify the path for the potential file.\n  As an example, imagine a file SiC.sw has Stillinger-Weber values for\n  Si and C.  If your LAMMPS simulation has 4 atoms types and you want\n  the 1st 3 to be Si, and the 4th to be C, you would use the following\n  pair_coeff command:\n  pair_coeff * * SiC.sw Si Si Si C\n  \n  \n  The 1st 2 arguments must be * * so as to span all LAMMPS atom types.\n  The first three Si arguments map LAMMPS atom types 1,2,3 to the Si\n  element in the SW file.  The final C argument maps LAMMPS atom type 4\n  to the C element in the SW file.  If a mapping value is specified as\n  NULL, the mapping is not performed.  This can be used when a sw\n  potential is used as part of the hybrid pair style.  The NULL values\n  are placeholders for atom types that will be used with other\n  potentials.\n  Stillinger-Weber files in the potentials directory of the LAMMPS\n  distribution have a “.sw” suffix.  Lines that are not blank or\n  comments (starting with #) define parameters for a triplet of\n  elements.  The parameters in a single entry correspond to the two-body\n  and three-body coefficients in the formula above:\n  \n  element 1 (the center atom in a 3-body interaction)\n  element 2\n  element 3\n  \\(\\epsilon\\) (energy units)\n  \\(\\sigma\\) (distance units)\n  a\n  \\(\\lambda\\)\n  \\(\\gamma\\)\n  \\(\\cos\\theta_0\\)\n  A\n  B\n  p\n  q\n  tol\n  \n  The A, B, p, and q parameters are used only for two-body interactions.\n  The \\(\\lambda\\) and \\(\\cos\\theta_0\\) parameters are used only\n  for three-body interactions. The \\(\\epsilon\\), \\(\\sigma\\) and\n  a parameters are used for both two-body and three-body\n  interactions. \\(\\gamma\\) is used only in the three-body\n  interactions, but is defined for pairs of atoms.  The non-annotated\n  parameters are unitless.\n  LAMMPS introduces an additional performance-optimization parameter tol\n  that is used for both two-body and three-body interactions.  In the\n  Stillinger-Weber potential, the interaction energies become negligibly\n  small at atomic separations substantially less than the theoretical\n  cutoff distances.  LAMMPS therefore defines a virtual cutoff distance\n  based on a user defined tolerance tol.  The use of the virtual cutoff\n  distance in constructing atom neighbor lists can significantly reduce\n  the neighbor list sizes and therefore the computational cost.  LAMMPS\n  provides a tol value for each of the three-body entries so that they\n  can be separately controlled. If tol = 0.0, then the standard\n  Stillinger-Weber cutoff is used.\n  The Stillinger-Weber potential file must contain entries for all the\n  elements listed in the pair_coeff command.  It can also contain\n  entries for additional elements not being used in a particular\n  simulation; LAMMPS ignores those entries.\n  For a single-element simulation, only a single entry is required\n  (e.g. SiSiSi).  For a two-element simulation, the file must contain 8\n  entries (for SiSiSi, SiSiC, SiCSi, SiCC, CSiSi, CSiC, CCSi, CCC), that\n  specify SW parameters for all permutations of the two elements\n  interacting in three-body configurations.  Thus for 3 elements, 27\n  entries would be required, etc.\n  As annotated above, the first element in the entry is the center atom\n  in a three-body interaction.  Thus an entry for SiCC means a Si atom\n  with 2 C atoms as neighbors.  The parameter values used for the\n  two-body interaction come from the entry where the 2nd and 3rd\n  elements are the same.  Thus the two-body parameters for Si\n  interacting with C, comes from the SiCC entry.  The three-body\n  parameters can in principle be specific to the three elements of the\n  configuration. In the literature, however, the three-body parameters\n  are usually defined by simple formulas involving two sets of pair-wise\n  parameters, corresponding to the ij and ik pairs, where i is the\n  center atom. The user must ensure that the correct combining rule is\n  used to calculate the values of the three-body parameters for\n  alloys. Note also that the function \\(\\phi_3\\) contains two exponential\n  screening factors with parameter values from the ij pair and ik\n  pairs. So \\(\\phi_3\\) for a C atom bonded to a Si atom and a second C atom\n  will depend on the three-body parameters for the CSiC entry, and also\n  on the two-body parameters for the CCC and CSiSi entries. Since the\n  order of the two neighbors is arbitrary, the three-body parameters for\n  entries CSiC and CCSi should be the same.  Similarly, the two-body\n  parameters for entries SiCC and CSiSi should also be the same.  The\n  parameters used only for two-body interactions (A, B, p, and q) in\n  entries whose 2nd and 3rd element are different (e.g. SiCSi) are not\n  used for anything and can be set to 0.0 if desired.\n  This is also true for the parameters in \\(\\phi_3\\) that are\n  taken from the ij and ik pairs (\\(\\sigma\\), a, \\(\\gamma\\))\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  When using the USER-INTEL package with this style, there is an\n  additional 5 to 10 percent performance improvement when the\n  Stillinger-Weber parameters p and q are set to 4 and 0 respectively.\n  These parameters are common for modeling silicon and water.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, where types I and J correspond to\n  two different element types, mixing is performed by LAMMPS as\n  described above from values in the potential file.\n  This pair style does not support the pair_modify\n  shift, table, and tail options.\n  This pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\n  need to re-specify the pair_style and pair_coeff commands in an input\n  script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style sw\n  \n  \n  ",
    "examples": "pair_style sw\n  pair_coeff * * si.sw Si\n  pair_coeff * * GaN.sw Ga N Ga\n  \n  \n  ",
    "restrictions": "This pair style is part of the MANYBODY package.  It is only enabled\n  if LAMMPS was built with that package.  See the Build package doc page for more info.\n  This pair style requires the newton setting to be “on”\n  for pair interactions.\n  The Stillinger-Weber potential files provided with LAMMPS (see the\n  potentials directory) are parameterized for metal units.\n  You can use the SW potential with any LAMMPS units, but you would need\n  to create your own SW potential file with coefficients listed in the\n  appropriate units if your simulation does not use “metal” units.\n  "
},
{
    "command": "pair_style table",
    "description": "Style table creates interpolation tables from potential energy and\n  force values listed in a file(s) as a function of distance.  When\n  performing dynamics or minimization, the interpolation tables are used\n  to evaluate energy and forces for pairwise interactions between\n  particles, similar to how analytic formulas are used for other pair\n  styles.\n  The interpolation tables are created as a pre-computation by fitting\n  cubic splines to the file values and interpolating energy and force\n  values at each of N distances.  During a simulation, the tables are\n  used to interpolate energy and force values as needed for each pair of\n  particles separated by a distance R.  The interpolation is done in\n  one of 4 styles: lookup, linear, spline, or bitmap.\n  For the lookup style, the distance R is used to find the nearest\n  table entry, which is the energy or force.\n  For the linear style, the distance R is used to find the 2\n  surrounding table values from which an energy or force is computed by\n  linear interpolation.\n  For the spline style, a cubic spline coefficients are computed and\n  stored for each of the N values in the table, one set of splines for\n  energy, another for force.  Note that these splines are different than\n  the ones used to pre-compute the N values.  Those splines were fit\n  to the Nfile values in the tabulated file, where often Nfile <\n  N.  The distance R is used to find the appropriate set of spline\n  coefficients which are used to evaluate a cubic polynomial which\n  computes the energy or force.\n  For the bitmap style, the specified N is used to create\n  interpolation tables that are 2^N in length.  The distance R is used\n  to index into the table via a fast bit-mapping technique due to\n  (Wolff), and a linear interpolation is performed between\n  adjacent table values.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above.\n  \n  filename\n  keyword\n  cutoff (distance units)\n  \n  The filename specifies a file containing tabulated energy and force\n  values.  The keyword specifies a section of the file.  The cutoff is\n  an optional coefficient.  If not specified, the outer cutoff in the\n  table itself (see below) will be used to build an interpolation table\n  that extend to the largest tabulated distance.  If specified, only\n  file values up to the cutoff are used to create the interpolation\n  table.  The format of this file is described below.\n  If your tabulated potential(s) are designed to be used as the\n  short-range part of one of the long-range solvers specified by the\n  kspace_style command, then you must use one or\n  more of the optional keywords listed above for the pair_style command.\n  These are ewald or pppm or msm or dispersion or tip4p.  This\n  is so LAMMPS can insure the short-range potential and long-range\n  solver are compatible with each other, as it does for other\n  short-range pair styles, such as pair_style lj/cut/coul/long.  Note that it is up to you to insure\n  the tabulated values for each pair of atom types has the correct\n  functional form to be compatible with the matching long-range solver.\n  \n  Here are some guidelines for using the pair_style table command to\n  best effect:\n  \n  Vary the number of table points; you may need to use more than you think\n  to get good resolution.\n  Always use the pair_write command to produce a plot\n  of what the final interpolated potential looks like.  This can show up\n  interpolation “features” you may not like.\n  Start with the linear style; it’s the style least likely to have problems.\n  Use N in the pair_style command equal to the “N” in the tabulation\n  file, and use the “RSQ” or “BITMAP” parameter, so additional interpolation\n  is not needed.  See discussion below.\n  Make sure that your tabulated forces and tabulated energies are\n  consistent (dE/dr = -F) over the entire range of r values.  LAMMPS\n  will warn if this is not the case.\n  Use as large an inner cutoff as possible.  This avoids fitting splines\n  to very steep parts of the potential.\n  \n  \n  The format of a tabulated file is a series of one or more sections,\n  defined as follows (without the parenthesized comments):\n  # Morse potential for Fe   (one or more comment or blank lines)\n  \n  MORSE_FE                   (keyword is first text on line)\n  N 500 R 1.0 10.0           (N, R, RSQ, BITMAP, FPRIME parameters)\n                             (blank)\n  1 1.0 25.5 102.34          (index, r, energy, force)\n  2 1.02 23.4 98.5\n  ...\n  500 10.0 0.001 0.003\n  \n  \n  A section begins with a non-blank line whose 1st character is not a\n  “#”; blank lines or lines starting with “#” can be used as comments\n  between sections.  The first line begins with a keyword which\n  identifies the section.  The line can contain additional text, but the\n  initial text must match the argument specified in the pair_coeff\n  command.  The next line lists (in any order) one or more parameters\n  for the table.  Each parameter is a keyword followed by one or more\n  numeric values.\n  The parameter “N” is required and its value is the number of table\n  entries that follow.  Note that this may be different than the N\n  specified in the pair_style table command.  Let\n  Ntable = N in the pair_style command, and Nfile = “N” in the\n  tabulated file.  What LAMMPS does is a preliminary interpolation by\n  creating splines using the Nfile tabulated values as nodal points.  It\n  uses these to interpolate energy and force values at Ntable different\n  points.  The resulting tables of length Ntable are then used as\n  described above, when computing energy and force for individual pair\n  distances.  This means that if you want the interpolation tables of\n  length Ntable to match exactly what is in the tabulated file (with\n  effectively no preliminary interpolation), you should set Ntable =\n  Nfile, and use the “RSQ” or “BITMAP” parameter.  This is because the\n  internal table abscissa is always RSQ (separation distance squared),\n  for efficient lookup.\n  All other parameters are optional.  If “R” or “RSQ” or “BITMAP” does\n  not appear, then the distances in each line of the table are used\n  as-is to perform spline interpolation.  In this case, the table values\n  can be spaced in r uniformly or however you wish to position table\n  values in regions of large gradients.\n  If used, the parameters “R” or “RSQ” are followed by 2 values rlo\n  and rhi.  If specified, the distance associated with each energy and\n  force value is computed from these 2 values (at high accuracy), rather\n  than using the (low-accuracy) value listed in each line of the table.\n  The distance values in the table file are ignored in this case.\n  For “R”, distances uniformly spaced between rlo and rhi are\n  computed; for “RSQ”, squared distances uniformly spaced between\n  rlo*rlo and rhi*rhi are computed.\n  \n  Note\n  If you use “R” or “RSQ”, the tabulated distance values in the\n  file are effectively ignored, and replaced by new values as described\n  in the previous paragraph.  If the distance value in the table is not\n  very close to the new value (i.e. round-off difference), then you will\n  be assigning energy/force values to a different distance, which is\n  probably not what you want.  LAMMPS will warn if this is occurring.\n  \n  If used, the parameter “BITMAP” is also followed by 2 values rlo and\n  rhi.  These values, along with the “N” value determine the ordering\n  of the N lines that follow and what distance is associated with each.\n  This ordering is complex, so it is not documented here, since this\n  file is typically produced by the pair_write command\n  with its bitmap option.  When the table is in BITMAP format, the “N”\n  parameter in the file must be equal to 2^M where M is the value\n  specified in the pair_style command.  Also, a cutoff parameter cannot\n  be used as an optional 3rd argument in the pair_coeff command; the\n  entire table extent as specified in the file must be used.\n  If used, the parameter “FPRIME” is followed by 2 values fplo and\n  fphi which are the derivative of the force at the innermost and\n  outermost distances listed in the table.  These values are needed by\n  the spline construction routines.  If not specified by the “FPRIME”\n  parameter, they are estimated (less accurately) by the first 2 and\n  last 2 force values in the table.  This parameter is not used by\n  BITMAP tables.\n  Following a blank line, the next N lines list the tabulated values.\n  On each line, the 1st value is the index from 1 to N, the 2nd value is\n  r (in distance units), the 3rd value is the energy (in energy units),\n  and the 4th is the force (in force units).  The r values must increase\n  from one line to the next (unless the BITMAP parameter is specified).\n  Note that one file can contain many sections, each with a tabulated\n  potential.  LAMMPS reads the file section by section until it finds\n  one that matches the specified keyword.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This pair style does not support mixing.  Thus, coefficients for all\n  I,J pairs must be specified explicitly.\n  The pair_modify shift, table, and tail options are\n  not relevant for this pair style.\n  This pair style writes the settings for the “pair_style table” command\n  to binary restart files, so a pair_style command does\n  not need to specified in an input script that reads a restart file.\n  However, the coefficient information is not stored in the restart\n  file, since it is tabulated in the potential files.  Thus, pair_coeff\n  commands do need to be specified in the restart input script.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style table style N keyword ...\n  \n  \n  \n  style = lookup or linear or spline or bitmap = method of interpolation\n  N = use N values in lookup, linear, spline tables\n  N = use 2^N values in bitmap tables\n  zero or more keywords may be appended\n  keyword = ewald or pppm or msm or dispersion or tip4p\n  \n  ",
    "examples": "pair_style table linear 1000\n  pair_style table linear 1000 pppm\n  pair_style table bitmap 12\n  pair_coeff * 3 morse.table ENTRY1\n  pair_coeff * 3 morse.table ENTRY1 7.0\n  \n  \n  ",
    "restrictions": "none\n  "
},
{
    "command": "pair_style table/rx",
    "description": "Style table/rx is used in reaction DPD simulations,where the\n  coarse-grained (CG) particles are composed of m species whose\n  reaction rate kinetics are determined from a set of n reaction rate\n  equations through the fix rx command.  The species of\n  one CG particle can interact with a species in a neighboring CG\n  particle through a site-site interaction potential model. Style\n  table/rx creates interpolation tables of length N from pair\n  potential and force values listed in a file(s) as a function of\n  distance.  The files are read by the pair_coeff\n  command.\n  The interpolation tables are created by fitting cubic splines to the\n  file values and interpolating energy and force values at each of N\n  distances.  During a simulation, these tables are used to interpolate\n  energy and force values as needed.  The interpolation is done in one\n  of 4 styles: lookup, linear, spline, or bitmap.\n  For the lookup style, the distance between 2 atoms is used to find\n  the nearest table entry, which is the energy or force.\n  For the linear style, the pair distance is used to find 2\n  surrounding table values from which an energy or force is computed by\n  linear interpolation.\n  For the spline style, a cubic spline coefficients are computed and\n  stored at each of the N values in the table.  The pair distance is\n  used to find the appropriate set of coefficients which are used to\n  evaluate a cubic polynomial which computes the energy or force.\n  For the bitmap style, the N means to create interpolation tables\n  that are 2^N in length.  The pair distance is used to index into the\n  table via a fast bit-mapping technique (Wolff) and a linear\n  interpolation is performed between adjacent table values.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above.\n  \n  filename\n  keyword\n  species1\n  species2\n  cutoff (distance units)\n  \n  The filename specifies a file containing tabulated energy and force\n  values.  The keyword specifies a section of the file.  The cutoff is\n  an optional coefficient.  If not specified, the outer cutoff in the\n  table itself (see below) will be used to build an interpolation table\n  that extend to the largest tabulated distance.  If specified, only\n  file values up to the cutoff are used to create the interpolation\n  table.  The format of this file is described below.\n  The species tags define the site-site interaction potential between\n  two species contained within two different particles.  The species\n  tags must either correspond to the species defined in the reaction\n  kinetics files specified with the fix rx command or they\n  must correspond to the tag “1fluid”, signifying interaction with a\n  product species mixture determined through a one-fluid approximation.\n  The interaction potential is weighted by the geometric average of\n  either the mole fraction concentrations or the number of molecules\n  associated with the interacting coarse-grained particles (see the\n  fractional or molecular weighting pair style options). The coarse-grained potential is\n  stored before and after the reaction kinetics solver is applied, where\n  the difference is defined to be the internal chemical energy (uChem).\n  \n  Here are some guidelines for using the pair_style table/rx command to\n  best effect:\n  \n  Vary the number of table points; you may need to use more than you think\n  to get good resolution.\n  Always use the pair_write command to produce a plot\n  of what the final interpolated potential looks like.  This can show up\n  interpolation “features” you may not like.\n  Start with the linear style; it’s the style least likely to have problems.\n  Use N in the pair_style command equal to the “N” in the tabulation\n  file, and use the “RSQ” or “BITMAP” parameter, so additional interpolation\n  is not needed.  See discussion below.\n  Make sure that your tabulated forces and tabulated energies are consistent\n  (dE/dr = -F) along the entire range of r values.\n  Use as large an inner cutoff as possible.  This avoids fitting splines\n  to very steep parts of the potential.\n  \n  \n  The format of a tabulated file is a series of one or more sections,\n  defined as follows (without the parenthesized comments):\n  # Morse potential for Fe   (one or more comment or blank lines)\n  \n  MORSE_FE                   (keyword is first text on line)\n  N 500 R 1.0 10.0           (N, R, RSQ, BITMAP, FPRIME parameters)\n                             (blank)\n  1 1.0 25.5 102.34          (index, r, energy, force)\n  2 1.02 23.4 98.5\n  ...\n  500 10.0 0.001 0.003\n  \n  \n  A section begins with a non-blank line whose 1st character is not a\n  “#”; blank lines or lines starting with “#” can be used as comments\n  between sections.  The first line begins with a keyword which\n  identifies the section.  The line can contain additional text, but the\n  initial text must match the argument specified in the pair_coeff\n  command.  The next line lists (in any order) one or more parameters\n  for the table.  Each parameter is a keyword followed by one or more\n  numeric values.\n  The parameter “N” is required and its value is the number of table\n  entries that follow.  Note that this may be different than the N\n  specified in the pair_style table/rx command.  Let\n  Ntable = N in the pair_style command, and Nfile = “N” in the\n  tabulated file.  What LAMMPS does is a preliminary interpolation by\n  creating splines using the Nfile tabulated values as nodal points.  It\n  uses these to interpolate as needed to generate energy and force\n  values at Ntable different points.  The resulting tables of length\n  Ntable are then used as described above, when computing energy and\n  force for individual pair distances.  This means that if you want the\n  interpolation tables of length Ntable to match exactly what is in the\n  tabulated file (with effectively no preliminary interpolation), you\n  should set Ntable = Nfile, and use the “RSQ” or “BITMAP” parameter.\n  The internal table abscissa is RSQ (separation distance squared).\n  All other parameters are optional.  If “R” or “RSQ” or “BITMAP” does\n  not appear, then the distances in each line of the table are used\n  as-is to perform spline interpolation.  In this case, the table values\n  can be spaced in r uniformly or however you wish to position table\n  values in regions of large gradients.\n  If used, the parameters “R” or “RSQ” are followed by 2 values rlo\n  and rhi.  If specified, the distance associated with each energy and\n  force value is computed from these 2 values (at high accuracy), rather\n  than using the (low-accuracy) value listed in each line of the table.\n  The distance values in the table file are ignored in this case.\n  For “R”, distances uniformly spaced between rlo and rhi are\n  computed; for “RSQ”, squared distances uniformly spaced between\n  rlo*rlo and rhi*rhi are computed.\n  If used, the parameter “BITMAP” is also followed by 2 values rlo and\n  rhi.  These values, along with the “N” value determine the ordering\n  of the N lines that follow and what distance is associated with each.\n  This ordering is complex, so it is not documented here, since this\n  file is typically produced by the pair_write command\n  with its bitmap option.  When the table is in BITMAP format, the “N”\n  parameter in the file must be equal to 2^M where M is the value\n  specified in the pair_style command.  Also, a cutoff parameter cannot\n  be used as an optional 3rd argument in the pair_coeff command; the\n  entire table extent as specified in the file must be used.\n  If used, the parameter “FPRIME” is followed by 2 values fplo and\n  fphi which are the derivative of the force at the innermost and\n  outermost distances listed in the table.  These values are needed by\n  the spline construction routines.  If not specified by the “FPRIME”\n  parameter, they are estimated (less accurately) by the first 2 and\n  last 2 force values in the table.  This parameter is not used by\n  BITMAP tables.\n  Following a blank line, the next N lines list the tabulated values.\n  On each line, the 1st value is the index from 1 to N, the 2nd value is\n  r (in distance units), the 3rd value is the energy (in energy units),\n  and the 4th is the force (in force units).  The r values must increase\n  from one line to the next (unless the BITMAP parameter is specified).\n  Note that one file can contain many sections, each with a tabulated\n  potential.  LAMMPS reads the file section by section until it finds\n  one that matches the specified keyword.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This pair style does not support mixing.  Thus, coefficients for all\n  I,J pairs must be specified explicitly.\n  The pair_modify shift, table, and tail options are\n  not relevant for this pair style.\n  This pair style writes the settings for the “pair_style table/rx” command\n  to binary restart files, so a pair_style command does\n  not need to specified in an input script that reads a restart file.\n  However, the coefficient information is not stored in the restart\n  file, since it is tabulated in the potential files.  Thus, pair_coeff\n  commands do need to be specified in the restart input script.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "pair_style table style N ...\n  \n  \n  \n  style = lookup or linear or spline or bitmap = method of interpolation\n  N = use N values in lookup, linear, spline tables\n  weighting = fractional or molecular (optional)\n  \n  ",
    "examples": "pair_style table/rx linear 1000\n  pair_style table/rx linear 1000 fractional\n  pair_style table/rx linear 1000 molecular\n  pair_coeff * * rxn.table ENTRY1 h2o h2o 10.0\n  pair_coeff * * rxn.table ENTRY1 1fluid 1fluid 10.0\n  pair_coeff * 3 rxn.table ENTRY1 h2o no2 10.0\n  \n  \n  ",
    "restrictions": "This command is part of the USER-DPD package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  "
},
{
    "command": "pair_style tersoff",
    "description": "The tersoff style computes a 3-body Tersoff potential\n  (Tersoff_1) for the energy E of a system of atoms as\n  \n  \\[\\begin{split}E & = \\frac{1}{2} \\sum_i \\sum_{j \\neq i} V_{ij} \\\\\n  V_{ij} & = f_C(r_{ij}) \\left[ f_R(r_{ij}) + b_{ij} f_A(r_{ij}) \\right] \\\\\n  f_C(r) & = \\left\\{ \\begin{array} {r@{\\quad:\\quad}l}\n    1 & r < R - D \\\\\n    \\frac{1}{2} - \\frac{1}{2} \\sin \\left( \\frac{\\pi}{2} \\frac{r-R}{D} \\right) &\n      R-D < r < R + D \\\\\n    0 & r > R + D\n    \\end{array} \\right. \\\\\n  f_R(r) & =  A \\exp (-\\lambda_1 r) \\\\\n  f_A(r) & =  -B \\exp (-\\lambda_2 r) \\\\\n  b_{ij} & =  \\left( 1 + \\beta^n {\\zeta_{ij}}^n \\right)^{-\\frac{1}{2n}} \\\\\n  \\zeta_{ij} & =  \\sum_{k \\neq i,j} f_C(r_{ik}) g(\\theta_{ijk})\n                   \\exp \\left[ {\\lambda_3}^m (r_{ij} - r_{ik})^m \\right] \\\\\n  g(\\theta) & =  \\gamma_{ijk} \\left( 1 + \\frac{c^2}{d^2} -\n                  \\frac{c^2}{\\left[ d^2 + (\\cos \\theta - \\cos \\theta_0)^2\\right]} \\right)\\end{split}\\]\n  where \\(f_R\\) is a two-body term and \\(f_A\\) includes three-body\n  interactions.  The summations in the formula are over all neighbors\n  J and K of atom I within a cutoff distance = R + D.\n  The tersoff/table style uses tabulated forms for the two-body,\n  environment and angular functions. Linear interpolation is performed\n  between adjacent table entries. The table length is chosen to be\n  accurate within 10^-6 with respect to the tersoff style energy.\n  The tersoff/table should give better performance in terms of speed.\n  Only a single pair_coeff command is used with the tersoff style\n  which specifies a Tersoff potential file with parameters for all\n  needed elements.  These are mapped to LAMMPS atom types by specifying\n  N additional arguments after the filename in the pair_coeff command,\n  where N is the number of LAMMPS atom types:\n  \n  filename\n  N element names = mapping of Tersoff elements to atom types\n  \n  See the pair_coeff doc page for alternate ways\n  to specify the path for the potential file.\n  As an example, imagine the SiC.tersoff file has Tersoff values for Si\n  and C.  If your LAMMPS simulation has 4 atoms types and you want the\n  1st 3 to be Si, and the 4th to be C, you would use the following\n  pair_coeff command:\n  pair_coeff * * SiC.tersoff Si Si Si C\n  \n  \n  The 1st 2 arguments must be * * so as to span all LAMMPS atom types.\n  The first three Si arguments map LAMMPS atom types 1,2,3 to the Si\n  element in the Tersoff file.  The final C argument maps LAMMPS atom\n  type 4 to the C element in the Tersoff file.  If a mapping value is\n  specified as NULL, the mapping is not performed.  This can be used\n  when a tersoff potential is used as part of the hybrid pair style.\n  The NULL values are placeholders for atom types that will be used with\n  other potentials.\n  Tersoff files in the potentials directory of the LAMMPS distribution\n  have a “.tersoff” suffix.  Lines that are not blank or comments\n  (starting with #) define parameters for a triplet of elements.  The\n  parameters in a single entry correspond to coefficients in the formula\n  above:\n  \n  element 1 (the center atom in a 3-body interaction)\n  element 2 (the atom bonded to the center atom)\n  element 3 (the atom influencing the 1-2 bond in a bond-order sense)\n  m\n  \\(\\gamma\\)\n  \\(\\lambda_3\\) (1/distance units)\n  c\n  d\n  \\(\\cos\\theta_0\\) (can be a value < -1 or > 1)\n  n\n  \\(\\beta\\)\n  \\(\\lambda_2\\) (1/distance units)\n  B (energy units)\n  R (distance units)\n  D (distance units)\n  \\(\\lambda_1\\) (1/distance units)\n  A (energy units)\n  \n  The n, \\(\\beta\\), \\(\\lambda_2\\), B, \\(\\lambda_1\\), and A\n  parameters are only used for\n  two-body interactions.  The m, \\(\\gamma\\), \\(\\lambda_3\\), c, d,\n  and \\(\\cos\\theta_0\\)\n  parameters are only used for three-body interactions. The R and D\n  parameters are used for both two-body and three-body interactions. The\n  non-annotated parameters are unitless.  The value of m must be 3 or 1.\n  The Tersoff potential file must contain entries for all the elements\n  listed in the pair_coeff command.  It can also contain entries for\n  additional elements not being used in a particular simulation; LAMMPS\n  ignores those entries.\n  For a single-element simulation, only a single entry is required\n  (e.g. SiSiSi).  For a two-element simulation, the file must contain 8\n  entries (for SiSiSi, SiSiC, SiCSi, SiCC, CSiSi, CSiC, CCSi, CCC), that\n  specify Tersoff parameters for all permutations of the two elements\n  interacting in three-body configurations.  Thus for 3 elements, 27\n  entries would be required, etc.\n  As annotated above, the first element in the entry is the center atom\n  in a three-body interaction and it is bonded to the 2nd atom and the\n  bond is influenced by the 3rd atom.  Thus an entry for SiCC means Si\n  bonded to a C with another C atom influencing the bond.  Thus\n  three-body parameters for SiCSi and SiSiC entries will not, in\n  general, be the same.  The parameters used for the two-body\n  interaction come from the entry where the 2nd element is repeated.\n  Thus the two-body parameters for Si interacting with C, comes from the\n  SiCC entry.\n  The parameters used for a particular\n  three-body interaction come from the entry with the corresponding\n  three elements.  The parameters used only for two-body interactions\n  (n, \\(\\beta\\), \\(\\lambda_2\\), B, \\(\\lambda_1\\), and A)\n  in entries whose 2nd and 3rd\n  element are different (e.g. SiCSi) are not used for anything and can\n  be set to 0.0 if desired.\n  Note that the twobody parameters in entries such as SiCC and CSiSi\n  are often the same, due to the common use of symmetric mixing rules,\n  but this is not always the case. For example, the beta and n parameters in\n  Tersoff_2 (Tersoff_2) are not symmetric.\n  We chose the above form so as to enable users to define all commonly\n  used variants of the Tersoff potential.  In particular, our form\n  reduces to the original Tersoff form when m = 3 and gamma = 1, while\n  it reduces to the form of Albe et al. when beta = 1 and m = 1.\n  Note that in the current Tersoff implementation in LAMMPS, m must be\n  specified as either 3 or 1.  Tersoff used a slightly different but\n  equivalent form for alloys, which we will refer to as Tersoff_2\n  potential (Tersoff_2).\n  The tersoff/table style implements\n  Tersoff_2 parameterization only.\n  LAMMPS parameter values for Tersoff_2 can be obtained as follows:\n  \\(\\gamma_{ijk} = \\omega_{ik}\\), \\(\\lambda_3 = 0\\) and the value of\n  m has no effect.  The parameters for species i and j can be calculated\n  using the Tersoff_2 mixing rules:\n  \n  \\[\\begin{split}\\lambda_1^{i,j} & = \\frac{1}{2}(\\lambda_1^i + \\lambda_1^j)\\\\\n  \\lambda_2^{i,j} & = \\frac{1}{2}(\\lambda_2^i + \\lambda_2^j)\\\\\n  A_{i,j} & = (A_{i}A_{j})^{1/2}\\\\\n  B_{i,j} & = \\chi_{ij}(B_{i}B_{j})^{1/2}\\\\\n  R_{i,j} & = (R_{i}R_{j})^{1/2}\\\\\n  S_{i,j} & = (S_{i}S_{j})^{1/2}\\end{split}\\]\n  Tersoff_2 parameters R and S must be converted to the LAMMPS\n  parameters R and D (R is different in both forms), using the following\n  relations: R=(R’+S’)/2 and D=(S’-R’)/2, where the primes indicate the\n  Tersoff_2 parameters.\n  In the potentials directory, the file SiCGe.tersoff provides the\n  LAMMPS parameters for Tersoff’s various versions of Si, as well as his\n  alloy parameters for Si, C, and Ge. This file can be used for pure Si,\n  (three different versions), pure C, pure Ge, binary SiC, and binary\n  SiGe.  LAMMPS will generate an error if this file is used with any\n  combination involving C and Ge, since there are no entries for the GeC\n  interactions (Tersoff did not publish parameters for this\n  cross-interaction.)  Tersoff files are also provided for the SiC alloy\n  (SiC.tersoff) and the GaN (GaN.tersoff) alloys.\n  Many thanks to Rutuparna Narulkar, David Farrell, and Xiaowang Zhou\n  for helping clarify how Tersoff parameters for alloys have been\n  defined in various papers.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, where types I and J correspond to\n  two different element types, mixing is performed by LAMMPS as\n  described above from values in the potential file.\n  This pair style does not support the pair_modify\n  shift, table, and tail options.\n  This pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\n  need to re-specify the pair_style and pair_coeff commands in an input\n  script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style style\n  \n  \n  \n  style = tersoff or tersoff/table or tersoff/gpu or tersoff/omp or tersoff/table/omp\n  \n  ",
    "examples": "pair_style tersoff\n  pair_coeff * * Si.tersoff Si\n  pair_coeff * * SiC.tersoff Si C Si\n  \n  pair_style tersoff/table\n  pair_coeff * * SiCGe.tersoff Si(D)\n  \n  \n  ",
    "restrictions": "This pair style is part of the MANYBODY package.  It is only enabled\n  if LAMMPS was built with that package.  See the Build package doc page for more info.\n  This pair style requires the newton setting to be “on”\n  for pair interactions.\n  The Tersoff potential files provided with LAMMPS (see the potentials\n  directory) are parameterized for metal units.  You can\n  use the Tersoff potential with any LAMMPS units, but you would need to\n  create your own Tersoff potential file with coefficients listed in the\n  appropriate units if your simulation does not use “metal” units.\n  "
},
{
    "command": "pair_style tersoff/mod",
    "description": "The tersoff/mod and tersoff/mod/c styles computes a bond-order type\n  interatomic potential (Kumagai) based on a 3-body Tersoff\n  potential (Tersoff_1), (Tersoff_2) with\n  modified cutoff function and angular-dependent term, giving the energy\n  E of a system of atoms as\n  \n  \\[\\begin{split}E & = \\frac{1}{2} \\sum_i \\sum_{j \\neq i} V_{ij} \\\\\n  V_{ij} & = f_C(r_{ij}) \\left[ f_R(r_{ij}) + b_{ij} f_A(r_{ij}) \\right] \\\\\n  f_C(r) & = \\left\\{ \\begin{array} {r@{\\quad:\\quad}l}\n    1 & r < R - D \\\\\n    \\frac{1}{2} - \\frac{9}{16} \\sin \\left( \\frac{\\pi}{2} \\frac{r-R}{D} \\right) - \\frac{1}{16} \\sin \\left( \\frac{3\\pi}{2} \\frac{r-R}{D} \\right) &\n      R-D < r < R + D \\\\\n    0 & r > R + D\n    \\end{array} \\right. \\\\\n  f_R(r) & = A \\exp (-\\lambda_1 r) \\\\\n  f_A(r) & = -B \\exp (-\\lambda_2 r) \\\\\n  b_{ij} & = \\left( 1 + {\\zeta_{ij}}^\\eta \\right)^{-\\frac{1}{2n}} \\\\\n  \\zeta_{ij} & = \\sum_{k \\neq i,j} f_C(r_{ik}) g(\\theta_{ijk})\n                   \\exp \\left[ \\alpha (r_{ij} - r_{ik})^\\beta \\right] \\\\\n  g(\\theta) & = c_1 + g_o(\\theta) g_a(\\theta) \\\\\n  g_o(\\theta) & = \\frac{c_2 (h - \\cos \\theta)^2}{c_3 + (h - \\cos \\theta)^2} \\\\\n  g_a(\\theta) & = 1 + c_4 \\exp \\left[ -c_5 (h - \\cos \\theta)^2 \\right] \\\\\\end{split}\\]\n  where \\(f_R\\) is a two-body term and \\(f_A\\) includes three-body interactions.\n  The summations in the formula are over all neighbors J and K of atom I\n  within a cutoff distance = R + D.\n  The tersoff/mod/c style differs from tersoff/mod only in the\n  formulation of the V_ij term, where it contains an additional c0 term.\n  \n  \\[V_{ij}  & = f_C(r_{ij}) \\left[ f_R(r_{ij}) + b_{ij} f_A(r_{ij}) + c_0 \\right]\\]\n  The modified cutoff function \\(f_C\\) proposed by (Murty) and\n  having a continuous second-order differential is employed. The\n  angular-dependent term \\(g(\\theta)\\) was modified to increase the\n  flexibility of the potential.\n  The tersoff/mod potential is fitted to both the elastic constants\n  and melting point by employing the modified Tersoff potential function\n  form in which the angular-dependent term is improved. The model\n  performs extremely well in describing the crystalline, liquid, and\n  amorphous phases (Schelling).\n  Only a single pair_coeff command is used with the tersoff/mod style\n  which specifies a Tersoff/MOD potential file with parameters for all\n  needed elements.  These are mapped to LAMMPS atom types by specifying\n  N additional arguments after the filename in the pair_coeff command,\n  where N is the number of LAMMPS atom types:\n  \n  filename\n  N element names = mapping of Tersoff/MOD elements to atom types\n  \n  As an example, imagine the Si.tersoff_mod file has Tersoff values for Si.\n  If your LAMMPS simulation has 3 Si atoms types, you would use the following\n  pair_coeff command:\n  pair_coeff * * Si.tersoff_mod Si Si Si\n  \n  \n  The 1st 2 arguments must be * * so as to span all LAMMPS atom types.\n  The three Si arguments map LAMMPS atom types 1,2,3 to the Si element\n  in the Tersoff/MOD file. If a mapping value is specified as NULL, the\n  mapping is not performed.  This can be used when a tersoff/mod\n  potential is used as part of the hybrid pair style. The NULL values\n  are placeholders for atom types that will be used with other\n  potentials.\n  Tersoff/MOD file in the potentials directory of the LAMMPS\n  distribution have a “.tersoff.mod” suffix. Potential files for the\n  tersoff/mod/c style have the suffix “.tersoff.modc”. Lines that are\n  not blank or comments (starting with #) define parameters for a triplet\n  of elements.  The parameters in a single entry correspond to\n  coefficients in the formulae above:\n  \n  element 1 (the center atom in a 3-body interaction)\n  element 2 (the atom bonded to the center atom)\n  element 3 (the atom influencing the 1-2 bond in a bond-order sense)\n  \\(\\beta\\)\n  \\(\\alpha\\)\n  h\n  \\(\\eta\\)\n  \\(\\beta_{ters}\\) = 1 (dummy parameter)\n  \\(\\lambda_2\\) (1/distance units)\n  B (energy units)\n  R (distance units)\n  D (distance units)\n  \\(\\lambda_1\\) (1/distance units)\n  A (energy units)\n  n\n  c1\n  c2\n  c3\n  c4\n  c5\n  c0 (energy units, tersoff/mod/c only):ul\n  \n  The n, \\(\\eta\\), \\(\\lambda_2\\), B, \\(\\lambda_1\\), and A parameters are only used for\n  two-body interactions.  The \\(\\beta\\), \\(\\alpha\\), c1, c2, c3, c4, c5, h\n  parameters are only used for three-body interactions. The R and D\n  parameters are used for both two-body and three-body interactions.\n  The c0 term applies to tersoff/mod/c only. The non-annotated\n  parameters are unitless.\n  The Tersoff/MOD potential file must contain entries for all the elements\n  listed in the pair_coeff command.  It can also contain entries for\n  additional elements not being used in a particular simulation; LAMMPS\n  ignores those entries.\n  For a single-element simulation, only a single entry is required\n  (e.g. SiSiSi). As annotated above, the first element in the entry is\n  the center atom in a three-body interaction and it is bonded to the\n  2nd atom and the bond is influenced by the 3rd atom.  Thus an entry\n  for SiSiSi means Si bonded to a Si with another Si atom influencing the bond.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  This pair style does not support the pair_modify\n  shift, table, and tail options.\n  This pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\n  need to re-specify the pair_style and pair_coeff commands in an input\n  script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style tersoff/mod\n  \n  pair_style tersoff/mod/c\n  \n  \n  ",
    "examples": "pair_style tersoff/mod\n  pair_coeff * * Si.tersoff.mod Si Si\n  \n  pair_style tersoff/mod/c\n  pair_coeff * * Si.tersoff.modc Si Si\n  \n  \n  ",
    "restrictions": "This pair style is part of the MANYBODY package.  It is only enabled\n  if LAMMPS was built with that package.  See the Build package doc page for more info.\n  This pair style requires the newton setting to be “on”\n  for pair interactions.\n  The Tersoff/MOD potential files provided with LAMMPS (see the potentials\n  directory) are parameterized for metal units.  You can\n  use the Tersoff/MOD potential with any LAMMPS units, but you would need to\n  create your own Tersoff/MOD potential file with coefficients listed in the\n  appropriate units if your simulation does not use “metal” units.\n  "
},
{
    "command": "pair_style tersoff/zbl",
    "description": "The tersoff/zbl style computes a 3-body Tersoff potential\n  (Tersoff_1) with a close-separation pairwise modification\n  based on a Coulomb potential and the Ziegler-Biersack-Littmark\n  universal screening function (ZBL), giving the energy E of a\n  system of atoms as\n  \n  \\[\\begin{split} E & = \\frac{1}{2} \\sum_i \\sum_{j \\neq i} V_{ij} \\\\\n   V_{ij} & =  (1 - f_F(r_{ij})) V^{ZBL}_{ij} + f_F(r_{ij}) V^{Tersoff}_{ij} \\\\\n   f_F(r_{ij}) & =  \\frac{1}{1 + e^{-A_F(r_{ij} - r_C)}}\\\\\n   \\\\\n   \\\\\n   V^{ZBL}_{ij} & = \\frac{1}{4\\pi\\epsilon_0} \\frac{Z_1 Z_2 \\,e^2}{r_{ij}} \\phi(r_{ij}/a) \\\\\n  a & = \\frac{0.8854\\,a_0}{Z_{1}^{0.23} + Z_{2}^{0.23}}\\\\\n  \\phi(x) & =  0.1818e^{-3.2x} + 0.5099e^{-0.9423x} + 0.2802e^{-0.4029x} + 0.02817e^{-0.2016x}\\\\\n  \\\\\n  \\\\\n  V^{Tersoff}_{ij} & = f_C(r_{ij}) \\left[ f_R(r_{ij}) + b_{ij} f_A(r_{ij}) \\right] \\\\\n  f_C(r) & = \\left\\{ \\begin{array} {r@{\\quad:\\quad}l}\n    1 & r < R - D \\\\\n    \\frac{1}{2} - \\frac{1}{2} \\sin \\left( \\frac{\\pi}{2} \\frac{r-R}{D} \\right) &\n      R-D < r < R + D \\\\\n    0 & r > R + D\n    \\end{array} \\right. \\\\\n  f_R(r) & = A \\exp (-\\lambda_1 r) \\\\\n  f_A(r) & = -B \\exp (-\\lambda_2 r) \\\\\n  b_{ij} & = \\left( 1 + \\beta^n {\\zeta_{ij}}^n \\right)^{-\\frac{1}{2n}} \\\\\n  \\zeta_{ij} & = \\sum_{k \\neq i,j} f_C(r_{ik}) g(\\theta_{ijk})\n                   \\exp \\left[ {\\lambda_3}^m (r_{ij} - r_{ik})^m \\right] \\\\\n  g(\\theta) & =  \\gamma_{ijk} \\left( 1 + \\frac{c^2}{d^2} -\n                  \\frac{c^2}{\\left[ d^2 + (\\cos \\theta - \\cos \\theta_0)^2\\right]} \\right)\\end{split}\\]\n  The \\(f_F\\) term is a fermi-like function used to smoothly connect the ZBL\n  repulsive potential with the Tersoff potential.  There are 2\n  parameters used to adjust it: \\(A_F\\) and \\(r_C\\).  \\(A_F\\)\n  controls how “sharp”\n  the transition is between the two, and \\(r_C\\) is essentially the cutoff\n  for the ZBL potential.\n  For the ZBL portion, there are two terms. The first is the Coulomb\n  repulsive term, with Z1, Z2 as the number of protons in each nucleus,\n  e as the electron charge (1 for metal and real units) and \\(\\epsilon_0\\)\n  as the permittivity of vacuum.  The second part is the ZBL universal\n  screening function, with a0 being the Bohr radius (typically 0.529\n  Angstroms), and the remainder of the coefficients provided by the\n  original paper.  This screening function should be applicable to most\n  systems.  However, it is only accurate for small separations\n  (i.e. less than 1 Angstrom).\n  For the Tersoff portion, \\(f_R\\) is a two-body term and \\(f_A\\)\n  includes\n  three-body interactions. The summations in the formula are over all\n  neighbors J and K of atom I within a cutoff distance = R + D.\n  Only a single pair_coeff command is used with the tersoff/zbl style\n  which specifies a Tersoff/ZBL potential file with parameters for all\n  needed elements.  These are mapped to LAMMPS atom types by specifying\n  N additional arguments after the filename in the pair_coeff command,\n  where N is the number of LAMMPS atom types:\n  \n  filename\n  N element names = mapping of Tersoff/ZBL elements to atom types\n  \n  See the pair_coeff doc page for alternate ways\n  to specify the path for the potential file.\n  As an example, imagine the SiC.tersoff.zbl file has Tersoff/ZBL values\n  for Si and C.  If your LAMMPS simulation has 4 atoms types and you\n  want the 1st 3 to be Si, and the 4th to be C, you would use the\n  following pair_coeff command:\n  pair_coeff * * SiC.tersoff Si Si Si C\n  \n  \n  The 1st 2 arguments must be * * so as to span all LAMMPS atom types.\n  The first three Si arguments map LAMMPS atom types 1,2,3 to the Si\n  element in the Tersoff/ZBL file.  The final C argument maps LAMMPS\n  atom type 4 to the C element in the Tersoff/ZBL file.  If a mapping\n  value is specified as NULL, the mapping is not performed.  This can be\n  used when a tersoff/zbl potential is used as part of the hybrid\n  pair style.  The NULL values are placeholders for atom types that will\n  be used with other potentials.\n  Tersoff/ZBL files in the potentials directory of the LAMMPS\n  distribution have a “.tersoff.zbl” suffix.  Lines that are not blank\n  or comments (starting with #) define parameters for a triplet of\n  elements.  The parameters in a single entry correspond to coefficients\n  in the formula above:\n  \n  element 1 (the center atom in a 3-body interaction)\n  element 2 (the atom bonded to the center atom)\n  element 3 (the atom influencing the 1-2 bond in a bond-order sense)\n  m\n  \\(\\gamma\\)\n  \\(\\lambda_3\\) (1/distance units)\n  c\n  d\n  \\(\\cos\\theta_0\\) (can be a value < -1 or > 1)\n  n\n  \\(\\beta\\)\n  \\(\\lambda_2\\) (1/distance units)\n  B (energy units)\n  R (distance units)\n  D (distance units)\n  \\(\\lambda_1\\) (1/distance units)\n  A (energy units)\n  \\(Z_i\\)\n  \\(Z_j\\)\n  ZBLcut (distance units)\n  ZBLexpscale (1/distance units)\n  \n  The n, \\(\\beta\\), \\(\\lambda_2\\), B, \\(\\lambda_1\\), and A\n  parameters are only used for\n  two-body interactions.  The m, \\(\\gamma\\), \\(\\lambda_3\\), c, d,\n  and \\(\\cos\\theta_0\\)\n  parameters are only used for three-body interactions. The R and D\n  parameters are used for both two-body and three-body interactions. The\n  \\(Z_i\\), \\(Z_j\\), ZBLcut, ZBLexpscale parameters are used in the\n  ZBL repulsive\n  portion of the potential and in the Fermi-like function.  The\n  non-annotated parameters are unitless.  The value of m must be 3 or 1.\n  The Tersoff/ZBL potential file must contain entries for all the\n  elements listed in the pair_coeff command.  It can also contain\n  entries for additional elements not being used in a particular\n  simulation; LAMMPS ignores those entries.\n  For a single-element simulation, only a single entry is required\n  (e.g. SiSiSi).  For a two-element simulation, the file must contain 8\n  entries (for SiSiSi, SiSiC, SiCSi, SiCC, CSiSi, CSiC, CCSi, CCC), that\n  specify Tersoff parameters for all permutations of the two elements\n  interacting in three-body configurations.  Thus for 3 elements, 27\n  entries would be required, etc.\n  As annotated above, the first element in the entry is the center atom\n  in a three-body interaction and it is bonded to the 2nd atom and the\n  bond is influenced by the 3rd atom.  Thus an entry for SiCC means Si\n  bonded to a C with another C atom influencing the bond.  Thus\n  three-body parameters for SiCSi and SiSiC entries will not, in\n  general, be the same.  The parameters used for the two-body\n  interaction come from the entry where the 2nd element is repeated.\n  Thus the two-body parameters for Si interacting with C, comes from the\n  SiCC entry.\n  The parameters used for a particular\n  three-body interaction come from the entry with the corresponding\n  three elements.  The parameters used only for two-body interactions\n  (n, \\(\\beta\\), \\(\\lambda_2\\), B, \\(\\lambda_1\\), and A)\n  in entries whose 2nd and 3rd\n  element are different (e.g. SiCSi) are not used for anything and can\n  be set to 0.0 if desired.\n  Note that the twobody parameters in entries such as SiCC and CSiSi\n  are often the same, due to the common use of symmetric mixing rules,\n  but this is not always the case. For example, the beta and n parameters in\n  Tersoff_2 (Tersoff_2) are not symmetric.\n  We chose the above form so as to enable users to define all commonly\n  used variants of the Tersoff portion of the potential.  In particular,\n  our form reduces to the original Tersoff form when m = 3 and gamma =\n  1, while it reduces to the form of Albe et al. when beta = 1\n  and m = 1.  Note that in the current Tersoff implementation in LAMMPS,\n  m must be specified as either 3 or 1.  Tersoff used a slightly\n  different but equivalent form for alloys, which we will refer to as\n  Tersoff_2 potential (Tersoff_2).\n  LAMMPS parameter values for Tersoff_2 can be obtained as follows:\n  \\(\\gamma = \\omega_{ijk}\\), \\(\\lambda_3 = 0\\) and the value of\n  m has no effect.  The parameters for species i and j can be calculated\n  using the Tersoff_2 mixing rules:\n  \n  \\[\\begin{split}\\lambda_1^{i,j} & = \\frac{1}{2}(\\lambda_1^i + \\lambda_1^j)\\\\\n  \\lambda_2^{i,j} & = \\frac{1}{2}(\\lambda_2^i + \\lambda_2^j)\\\\\n  A_{i,j} & = (A_{i}A_{j})^{1/2}\\\\\n  B_{i,j} & = \\chi_{ij}(B_{i}B_{j})^{1/2}\\\\\n  R_{i,j} & = (R_{i}R_{j})^{1/2}\\\\\n  S_{i,j} & = (S_{i}S_{j})^{1/2}\\\\\\end{split}\\]\n  Tersoff_2 parameters R and S must be converted to the LAMMPS\n  parameters R and D (R is different in both forms), using the following\n  relations: R=(R’+S’)/2 and D=(S’-R’)/2, where the primes indicate the\n  Tersoff_2 parameters.\n  In the potentials directory, the file SiCGe.tersoff provides the\n  LAMMPS parameters for Tersoff’s various versions of Si, as well as his\n  alloy parameters for Si, C, and Ge. This file can be used for pure Si,\n  (three different versions), pure C, pure Ge, binary SiC, and binary\n  SiGe.  LAMMPS will generate an error if this file is used with any\n  combination involving C and Ge, since there are no entries for the GeC\n  interactions (Tersoff did not publish parameters for this\n  cross-interaction.)  Tersoff files are also provided for the SiC alloy\n  (SiC.tersoff) and the GaN (GaN.tersoff) alloys.\n  Many thanks to Rutuparna Narulkar, David Farrell, and Xiaowang Zhou\n  for helping clarify how Tersoff parameters for alloys have been\n  defined in various papers.  Also thanks to Ram Devanathan for\n  providing the base ZBL implementation.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, where types I and J correspond to\n  two different element types, mixing is performed by LAMMPS as\n  described above from values in the potential file.\n  This pair style does not support the pair_modify\n  shift, table, and tail options.\n  This pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\n  need to re-specify the pair_style and pair_coeff commands in an input\n  script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style tersoff/zbl\n  \n  \n  ",
    "examples": "pair_style tersoff/zbl\n  pair_coeff * * SiC.tersoff.zbl Si C Si\n  \n  \n  ",
    "restrictions": "This pair style is part of the MANYBODY package.  It is only enabled\n  if LAMMPS was built with that package.  See the Build package doc page for more info.\n  This pair style requires the newton setting to be “on”\n  for pair interactions.\n  The Tersoff/ZBL potential files provided with LAMMPS (see the\n  potentials directory) are parameterized for metal units.\n  You can use the Tersoff potential with any LAMMPS units, but you would\n  need to create your own Tersoff potential file with coefficients\n  listed in the appropriate units if your simulation does not use “metal”\n  units.\n  "
},
{
    "command": "pair_style thole",
    "description": "The thole pair styles are meant to be used with force fields that\n  include explicit polarization through Drude dipoles.  This link\n  describes how to use the thermalized Drude oscillator model in LAMMPS and polarizable models in LAMMPS are\n  discussed on the Howto polarizable doc page.\n  The thole pair style should be used as a sub-style within in the\n  pair_style hybrid/overlay command, in conjunction with a\n  main pair style including Coulomb interactions, i.e. any pair style\n  containing coul/cut or coul/long in its style name.\n  The lj/cut/thole/long pair style is equivalent to, but more convenient that\n  the frequent combination hybrid/overlay lj/cut/coul/long cutoff thole damp\n  cutoff2. It is not only a shorthand for this pair_style combination, but\n  it also allows for mixing pair coefficients instead of listing them all.\n  The lj/cut/thole/long pair style is also a bit faster because it avoids an\n  overlay and can benefit from OMP acceleration. Moreover, it uses a more\n  precise approximation of the direct Coulomb interaction at short range similar\n  to coul/long/cs, which stabilizes the temperature of\n  Drude particles.\n  The thole pair styles compute the Coulomb interaction damped at\n  short distances by a function\n  \n  \\[T_{ij}(r_{ij}) = 1 - \\left( 1 +\n  \\frac{s_{ij} r_{ij} }{2} \\right)\n  \\exp \\left( - s_{ij} r_{ij} \\right)\\]\n  This function results from an adaptation to point charges\n  (Noskov) of the dipole screening scheme originally proposed\n  by Thole. The scaling coefficient \\(s_{ij}\\) is determined\n  by the polarizability of the atoms, \\(\\alpha_i\\), and by a Thole\n  damping parameter \\(a\\).  This Thole damping parameter usually takes\n  a value of 2.6, but in certain force fields the value can depend upon\n  the atom types. The mixing rule for Thole damping parameters is the\n  arithmetic average, and for polarizabilities the geometric average\n  between the atom-specific values.\n  \n  \\[s_{ij} = \\frac{ a_{ij} }{\n  (\\alpha_{ij})^{1/3} } = \\frac{ (a_i + a_j)/2 }{\n  [(\\alpha_i\\alpha_j)^{1/2}]^{1/3} }\\]\n  The damping function is only applied to the interactions between the\n  point charges representing the induced dipoles on polarizable sites,\n  that is, charges on Drude particles, \\(q_{D,i}\\), and opposite\n  charges, \\(-q_{D,i}\\), located on the respective core particles\n  (to which each Drude particle is bonded). Therefore, Thole screening\n  is not applied to the full charge of the core particle \\(q_i\\), but\n  only to the \\(-q_{D,i}\\) part of it.\n  The interactions between core charges are subject to the weighting\n  factors set by the special_bonds command. The\n  interactions between Drude particles and core charges or\n  non-polarizable atoms are also subject to these weighting factors. The\n  Drude particles inherit the 1-2, 1-3 and 1-4 neighbor relations from\n  their respective cores.\n  For pair_style thole, the following coefficients must be defined for\n  each pair of atoms types via the pair_coeff command\n  as in the example above.\n  \n  \\(\\alpha\\) (distance units^3)\n  damp\n  cutoff (distance units)\n  \n  The last two coefficients are optional.  If not specified the global\n  Thole damping parameter or global cutoff specified in the pair_style\n  command are used. In order to specify a cutoff (third argument) a damp\n  parameter (second argument) must also be specified.\n  For pair style lj/cut/thole/long, the following coefficients must be\n  defined for each pair of atoms types via the pair_coeff\n  command.\n  \n  \\(\\epsilon\\) (energy units)\n  \\(\\sigma\\) (length units)\n  \\(\\alpha\\) (distance units^3)\n  damp\n  LJ cutoff (distance units)\n  \n  The last two coefficients are optional and default to the global values from\n  the pair_style command line.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  Mixing:\n  The thole pair style does not support mixing.  Thus, coefficients\n  for all I,J pairs must be specified explicitly.\n  The lj/cut/thole/long pair style does support mixing. Mixed coefficients\n  are defined using\n  \n  \\[\\begin{split}\\alpha_{ij} = & \\sqrt{\\alpha_i\\alpha_j} \\\\\n  & \\\\\n  a_{ij} = & \\frac 1 2 (a_i + a_j)\\end{split}\\]\n  ",
    "syntax": "pair_style style args\n  \n  \n  \n  style = thole or lj/cut/thole/long or lj/cut/thole/long/omp\n  args = list of arguments for a particular style\n  \n  thole args = damp cutoff\n    damp = global damping parameter\n    cutoff = global cutoff (distance units)\n  lj/cut/thole/long or lj/cut/thole/long/omp args = damp cutoff (cutoff2)\n    damp = global damping parameter\n    cutoff = global cutoff for LJ (and Thole if only 1 arg) (distance units)\n    cutoff2 = global cutoff for Thole (optional) (distance units)\n  ",
    "examples": "pair_style hybrid/overlay ... thole 2.6 12.0\n  pair_coeff 1 1 thole 1.0\n  pair_coeff 1 2 thole 1.0 2.6 10.0\n  pair_coeff * 2 thole 1.0 2.6\n  \n  pair_style lj/cut/thole/long 2.6 12.0\n  \n  \n  ",
    "restrictions": "These pair styles are part of the USER-DRUDE package. They are only\n  enabled if LAMMPS was built with that package. See the Build package doc page for more info.\n  This pair_style should currently not be used with the charmm dihedral style if the latter has non-zero 1-4 weighting\n  factors. This is because the thole pair style does not know which\n  pairs are 1-4 partners of which dihedrals.\n  The lj/cut/thole/long pair style should be used with a Kspace solver\n  like PPPM or Ewald, which is only enabled if LAMMPS was built with the kspace\n  package.\n  "
},
{
    "command": "pair_style tri/lj",
    "description": "Style tri/lj treats particles which are triangles as a set of small\n  spherical particles that tile the triangle surface as explained below.\n  Interactions between two triangles, each with N1 and N2 spherical\n  particles, are calculated as the pairwise sum of N1*N2 Lennard-Jones\n  interactions.  Interactions between a triangle with N spherical\n  particles and a point particle are treated as the pairwise sum of N\n  Lennard-Jones interactions.  See the pair_style lj/cut\n  doc page for the definition of Lennard-Jones interactions.\n  The cutoff distance for an interaction between 2 triangles, or between\n  a triangle and a point particle, is calculated from the position of\n  the triangle (its centroid), not between pairs of individual spheres\n  comprising the triangle.  Thus an interaction is either calculated in\n  its entirety or not at all.\n  The set of non-overlapping spherical particles that represent a\n  triangle, for purposes of this pair style, are generated in the\n  following manner.  Assume the triangle is of type I, and sigma_II has\n  been specified.  We want a set of spheres with centers in the plane of\n  the triangle, none of them larger in diameter than sigma_II, which\n  completely cover the triangle’s area, but with minimal overlap and a\n  minimal total number of spheres.  This is done in a recursive manner.\n  Place a sphere at the centroid of the original triangle.  Calculate\n  what diameter it must have to just cover all 3 corner points of the\n  triangle.  If that diameter is equal to or smaller than sigma_II, then\n  include a sphere of the calculated diameter in the set of covering\n  spheres.  It the diameter is larger than sigma_II, then split the\n  triangle into 2 triangles by bisecting its longest side.  Repeat the\n  process on each sub-triangle, recursing as far as needed to generate a\n  set of covering spheres.  When finished, the original criteria are\n  met, and the set of covering spheres should be near minimal in number\n  and overlap, at least for input triangles with a reasonable\n  aspect-ratio.\n  The LJ interaction between 2 spheres on different triangles of types\n  I,J is computed with an arithmetic mixing of the sigma values of the 2\n  spheres and using the specified epsilon value for I,J atom types.\n  Note that because the sigma values for triangles spheres is computed\n  using only sigma_II values, specific to the triangles’s type, this\n  means that any specified sigma_IJ values (for I != J) are effectively\n  ignored.\n  For style tri/lj, the following coefficients must be defined for\n  each pair of atoms types via the pair_coeff command\n  as in the examples above, or in the data file or restart files read by\n  the read_data or read_restart\n  commands:\n  \n  epsilon (energy units)\n  sigma (distance units)\n  cutoff (distance units)\n  \n  The last coefficient is optional.  If not specified, the global cutoff\n  is used.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the epsilon and sigma coefficients\n  and cutoff distance for all of this pair style can be mixed.  The\n  default mix value is geometric.  See the “pair_modify” command for\n  details.\n  This pair style does not support the pair_modify\n  shift, table, and tail options.\n  This pair style does not write its information to binary restart files.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style tri/lj cutoff\n  \n  \n  cutoff = global cutoff for interactions (distance units)\n  ",
    "examples": "pair_style tri/lj 3.0\n  pair_coeff * * 1.0 1.0\n  pair_coeff 1 1 1.0 1.5 2.5\n  \n  \n  ",
    "restrictions": "This style is part of the ASPHERE package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  Defining particles to be triangles so they participate in tri/tri or\n  tri/particle interactions requires the use the atom_style tri command.\n  "
},
{
    "command": "pair_style ufm",
    "description": "Style ufm computes pairwise interactions using the Uhlenbeck-Ford model (UFM) potential (Paula Leite2016) which is given by\n  \n  \\[\\begin{split}E & = -\\varepsilon\\, \\ln{\\left[1-\\exp{\\left(-r^{2}/\\sigma^{2}\\right)}\\right]} \\qquad  r < r_c \\\\\n  \\varepsilon & = p\\,k_B\\,T\\end{split}\\]\n  where \\(r_c\\) is the cutoff, \\(\\sigma\\) is a distance-scale and\n  \\(\\epsilon\\) is an energy-scale, i.e., a product of Boltzmann constant\n  \\(k_B\\), temperature T and the Uhlenbeck-Ford p-parameter which\n  is responsible\n  to control the softness of the interactions (Paula Leite2017).\n  This model is useful as a reference system for fluid-phase free-energy calculations (Paula Leite2016).\n  The following coefficients must be defined for each pair of atom types\n  via the pair_coeff command as in the examples above,\n  or in the data file or restart files read by the\n  read_data or read_restart\n  commands, or by mixing as described below:\n  \n  \\(\\epsilon\\) (energy units)\n  \\(\\sigma\\) (distance units)\n  cutoff (distance units)\n  \n  The last coefficient is optional.  If not specified, the global ufm\n  cutoff is used.\n  The fix adapt command can be used to vary epsilon and sigma for this pair style over the course of a simulation, in which case\n  pair_coeff settings for epsilon and sigma must still be specified, but will be\n  overridden.  For example these commands will vary the prefactor epsilon for\n  all pairwise interactions from 10.0 at the beginning to 100.0 at the end\n  of a run:\n  variable prefactor equal ramp(10,100)\n  fix 1 all adapt 1 pair ufm epsilon * * v_prefactor\n  \n  \n  \n  Note\n  The thermodynamic integration procedure can be performed with this\n  potential using fix adapt. This command will\n  rescale the force on each atom by varying a scale variable, which\n  always starts with value 1.0. The syntax is the same described above,\n  however, changing epsilon to scale. A detailed explanation of how to\n  use this command and perform nonequilibrium thermodynamic integration\n  in LAMMPS is given in the paper by (Freitas).\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the A coefficient and cutoff\n  distance for this pair style can be mixed.  A is always mixed via a\n  geometric rule.  The cutoff is mixed according to the pair_modify\n  mix value.  The default mix value is geometric.  See the\n  “pair_modify” command for details.\n  This pair style support the pair_modify shift option for the energy of the pair interaction.\n  The pair_modify table and tail are not relevant for this\n  pair style.\n  This pair style does not support the pair_modify tail option for adding long-range tail corrections to energy and pressure.\n  This pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style ufm cutoff\n  \n  \n  \n  cutoff = global cutoff for ufm interactions (distance units)\n  \n  ",
    "examples": "pair_style ufm 4.0\n  pair_coeff 1 1 100.0 1.0 2.5\n  pair_coeff * * 100.0 1.0\n  \n  pair_style ufm 4.0\n  pair_coeff * * 10.0 1.0\n  variable prefactor equal ramp(10,100)\n  fix 1 all adapt 1 pair ufm epsilon * * v_prefactor\n  \n  \n  ",
    "restrictions": "none\n  "
},
{
    "command": "pair_style vashishta",
    "description": "The vashishta and vashishta/table styles compute the combined\n  2-body and 3-body family of potentials developed in the group of Priya\n  Vashishta and collaborators.  By combining repulsive, screened\n  Coulombic, screened charge-dipole, and dispersion interactions with a\n  bond-angle energy based on the Stillinger-Weber potential, this\n  potential has been used to describe a variety of inorganic compounds,\n  including SiO2 Vashishta1990, SiC\n  Vashishta2007, and InP Branicio2009.\n  The potential for the energy U of a system of atoms is\n  \n  \\[\\begin{split}U & =  \\sum_i^N \\sum_{j > i}^N U_{ij}^{(2)} (r_{ij}) + \\sum_i^N \\sum_{j \\neq i}^N \\sum_{k > j, k \\neq i}^N U_{ijk}^{(3)} (r_{ij}, r_{ik}, \\theta_{ijk}) \\\\\n  U_{ij}^{(2)} (r) & =   \\frac{H_{ij}}{r^{\\eta_{ij}}} + \\frac{Z_i Z_j}{r}\\exp(-r/\\lambda_{1,ij}) - \\frac{D_{ij}}{r^4}\\exp(-r/\\lambda_{4,ij}) - \\frac{W_{ij}}{r^6}, r < r_{c,{ij}} \\\\\n  U_{ijk}^{(3)}(r_{ij},r_{ik},\\theta_{ijk}) & =  B_{ijk} \\frac{\\left[ \\cos \\theta_{ijk} - \\cos \\theta_{0ijk} \\right]^2} {1+C_{ijk}\\left[ \\cos \\theta_{ijk} - \\cos \\theta_{0ijk} \\right]^2} \\times \\\\\n                   &  \\exp \\left( \\frac{\\gamma_{ij}}{r_{ij} - r_{0,ij}} \\right) \\exp \\left( \\frac{\\gamma_{ik}}{r_{ik} - r_{0,ik}} \\right), r_{ij} < r_{0,ij}, r_{ik} < r_{0,ik}\\end{split}\\]\n  where we follow the notation used in Branicio2009.\n  \\(U^2\\) is a two-body term and U3 is a three-body term.  The\n  summation over two-body terms is over all neighbors J within\n  a cutoff distance = \\(r_c\\).  The twobody terms are shifted and\n  tilted by a linear function so that the energy and force are\n  both zero at \\(r_c\\). The summation over three-body terms\n  is over all neighbors i and k within a cut-off distance \\(= r_0\\),\n  where the exponential screening function becomes zero.\n  The vashishta style computes these formulas analytically.  The\n  vashishta/table style tabulates the analytic values for Ntable\n  points from cutinner to the cutoff of the potential.  The points are\n  equally spaced in R^2 space from cutinner^2 to cutoff^2.  For the\n  two-body term in the above equation, a linear interpolation for each\n  pairwise distance between adjacent points in the table.  In practice\n  the tabulated version can run 3-5x faster than the analytic version\n  with moderate to little loss of accuracy for Ntable values\n  between 10000 and 1000000. It is not recommended to use less than\n  5000 tabulation points.\n  Only a single pair_coeff command is used with either style which\n  specifies a Vashishta potential file with parameters for all needed\n  elements.  These are mapped to LAMMPS atom types by specifying N\n  additional arguments after the filename in the pair_coeff command,\n  where N is the number of LAMMPS atom types:\n  \n  filename\n  N element names = mapping of Vashishta elements to atom types\n  \n  See the pair_coeff doc page for alternate ways\n  to specify the path for the potential file.\n  As an example, imagine a file SiC.vashishta has parameters for\n  Si and C.  If your LAMMPS simulation has 4 atoms types and you want\n  the 1st 3 to be Si, and the 4th to be C, you would use the following\n  pair_coeff command:\n  pair_coeff * * SiC.vashishta Si Si Si C\n  \n  \n  The 1st 2 arguments must be * * so as to span all LAMMPS atom types.\n  The first three Si arguments map LAMMPS atom types 1,2,3 to the Si\n  element in the file.  The final C argument maps LAMMPS atom type 4\n  to the C element in the file.  If a mapping value is specified as\n  NULL, the mapping is not performed.  This can be used when a vashishta\n  potential is used as part of the hybrid pair style.  The NULL values\n  are placeholders for atom types that will be used with other\n  potentials.\n  Vashishta files in the potentials directory of the LAMMPS\n  distribution have a “.vashishta” suffix.  Lines that are not blank or\n  comments (starting with #) define parameters for a triplet of\n  elements.  The parameters in a single entry correspond to the two-body\n  and three-body coefficients in the formulae above:\n  \n  element 1 (the center atom in a 3-body interaction)\n  element 2\n  element 3\n  H (energy units)\n  \\(\\eta\\)\n  \\(Z_i\\) (electron charge units)\n  \\(Z_j\\) (electron charge units)\n  \\(\\lambda_1\\) (distance units)\n  D (energy units)\n  \\(\\lambda_4\\) (distance units)\n  W (energy units)\n  \\(r_c\\) (distance units)\n  B (energy units)\n  \\(\\gamma\\)\n  \\(r_0\\) (distance units)\n  C\n  \\(\\cos\\theta_0\\)\n  \n  The non-annotated parameters are unitless.  The Vashishta potential\n  file must contain entries for all the elements listed in the\n  pair_coeff command.  It can also contain entries for additional\n  elements not being used in a particular simulation; LAMMPS ignores\n  those entries.  For a single-element simulation, only a single entry\n  is required (e.g. SiSiSi).  For a two-element simulation, the file\n  must contain 8 entries (for SiSiSi, SiSiC, SiCSi, SiCC, CSiSi, CSiC,\n  CCSi, CCC), that specify parameters for all permutations of the two\n  elements interacting in three-body configurations.  Thus for 3\n  elements, 27 entries would be required, etc.\n  Depending on the particular version of the Vashishta potential, the\n  values of these parameters may be keyed to the identities of zero,\n  one, two, or three elements.  In order to make the input file format\n  unambiguous, general, and simple to code, LAMMPS uses a slightly\n  confusing method for specifying parameters.  All parameters are\n  divided into two classes: two-body and three-body.  Two-body and\n  three-body parameters are handled differently, as described below.\n  The two-body parameters are H, \\(\\eta\\), \\(\\lambda_1\\),\n  D, \\(\\lambda_4\\), W, \\(r_c\\), \\(\\gamma\\),\n  and \\(r_0\\).  They appear in the above formulae with two subscripts.\n  The parameters \\(Z_i\\) and \\(Z_j\\) are also classified\n  as two-body parameters, even\n  though they only have 1 subscript.  The three-body parameters are B,\n  C, \\(\\cos\\theta_0\\).  They appear in the above formulae with\n  three subscripts.  Two-body and three-body parameters are handled\n  differently, as described below.\n  The first element in each entry is the center atom in a three-body\n  interaction, while the second and third elements are two neighbor\n  atoms. Three-body parameters for a central atom I and two neighbors J\n  and K are taken from the IJK entry.  Note that even though three-body\n  parameters do not depend on the order of J and K, LAMMPS stores\n  three-body parameters for both IJK and IKJ.  The user must ensure that\n  these values are equal.  Two-body parameters for an atom I interacting\n  with atom J are taken from the IJJ entry, where the 2nd and 3rd\n  elements are the same. Thus the two-body parameters for Si interacting\n  with C come from the SiCC entry. Note that even though two-body\n  parameters (except possibly gamma and r0 in U3) do not depend on the\n  order of the two elements, LAMMPS will get the Si-C value from the\n  SiCC entry and the C-Si value from the CSiSi entry. The user must\n  ensure that these values are equal. Two-body parameters appearing in\n  entries where the 2nd and 3rd elements are different are stored but\n  never used. It is good practice to enter zero for these values. Note\n  that the three-body function U3 above contains the two-body parameters\n  \\(\\gamma\\) and \\(r_0\\). So U3 for a central C atom bonded to\n  an Si atom and a\n  second C atom will take three-body parameters from the CSiC entry, but\n  two-body parameters from the CCC and CSiSi entries.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, where types I and J correspond to\n  two different element types, mixing is performed by LAMMPS as\n  described above from values in the potential file.\n  This pair style does not support the pair_modify\n  shift, table, and tail options.\n  This pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\n  need to re-specify the pair_style and pair_coeff commands in an input\n  script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style style args\n  \n  \n  \n  style = vashishta or vashishta/table or vashishta/omp or vashishta/table/omp\n  args = list of arguments for a particular style\n  \n  vashishta or vashishta/omp args = none\n  vashishta/table or vashishta/table/omp args = Ntable cutinner\n    Ntable = # of tabulation points\n    cutinner = tablulate from cutinner to cutoff\n  ",
    "examples": "pair_style vashishta\n  pair_coeff * * SiC.vashishta Si C\n  \n  pair_style vashishta/table 100000 0.2\n  pair_coeff * * SiC.vashishta Si C\n  \n  \n  ",
    "restrictions": "These pair style are part of the MANYBODY package.  They is only\n  enabled if LAMMPS was built with that package.  See the Build package doc page for more info.\n  These pair styles requires the newton setting to be “on”\n  for pair interactions.\n  The Vashishta potential files provided with LAMMPS (see the potentials\n  directory) are parameterized for metal units.  You can\n  use the Vashishta potential with any LAMMPS units, but you would need\n  to create your own potential file with coefficients listed in the\n  appropriate units if your simulation does not use “metal” units.\n  "
},
{
    "command": "pair_style yukawa",
    "description": "Style yukawa computes pairwise interactions with the formula\n  \n  \\[E = A \\frac{e^{- \\kappa r}}{r} \\qquad r < r_c\\]\n  \\(r_c\\) is the cutoff.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands, or by mixing as described below:\n  \n  A (energy*distance units)\n  cutoff (distance units)\n  \n  The last coefficient is optional.  If not specified, the global yukawa\n  cutoff is used.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the A coefficient and cutoff\n  distance for this pair style can be mixed.  A is an energy value mixed\n  like a LJ epsilon.  The default mix value is geometric.  See the\n  “pair_modify” command for details.\n  This pair style supports the pair_modify shift\n  option for the energy of the pair interaction.\n  The pair_modify table option is not relevant\n  for this pair style.\n  This pair style does not support the pair_modify\n  tail option for adding long-range tail corrections to energy and\n  pressure.\n  This pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style yukawa kappa cutoff\n  \n  \n  \n  kappa = screening length (inverse distance units)\n  cutoff = global cutoff for Yukawa interactions (distance units)\n  \n  ",
    "examples": "pair_style yukawa 2.0 2.5\n  pair_coeff 1 1 100.0 2.3\n  pair_coeff * * 100.0\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "pair_style yukawa/colloid",
    "description": "Style yukawa/colloid computes pairwise interactions with the formula\n  \n  \\[E = \\frac{A}{\\kappa} e^{- \\kappa (r - (r_i + r_j))} \\qquad r < r_c\\]\n  where \\(r_i\\) and \\(r_j\\) are the radii of the two particles\n  and \\(r_c\\) is the cutoff.\n  In contrast to pair_style yukawa, this functional\n  form arises from the Coulombic interaction between two colloid\n  particles, screened due to the presence of an electrolyte, see the\n  book by Safran for a derivation in the context of DLVO\n  theory.  Pair_style yukawa is a screened Coulombic\n  potential between two point-charges and uses no such approximation.\n  This potential applies to nearby particle pairs for which the Derjagin\n  approximation holds, meaning \\(h << r_i + r_j\\), where h is the\n  surface-to-surface separation of the two particles.\n  When used in combination with pair_style colloid,\n  the two terms become the so-called DLVO potential, which combines\n  electrostatic repulsion and van der Waals attraction.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands, or by mixing as described below:\n  \n  A (energy/distance units)\n  cutoff (distance units)\n  \n  The prefactor A is determined from the relationship between surface\n  charge and surface potential due to the presence of electrolyte.  Note\n  that the A for this potential style has different units than the A\n  used in pair_style yukawa.  For low surface\n  potentials, i.e. less than about 25 mV, A can be written as:\n  \n  \\[A = 2 \\pi R\\varepsilon\\varepsilon_0 \\kappa \\psi^2\\]\n  where\n  \n  R = colloid radius (distance units)\n  \\(\\varepsilon_0\\) = permittivity of free space (charge^2/energy/distance units)\n  \\(\\varepsilon\\) = relative permittivity of fluid medium (dimensionless)\n  \\(\\kappa\\) = inverse screening length (1/distance units)\n  \\(\\psi\\) = surface potential (energy/charge units)\n  \n  The last coefficient is optional.  If not specified, the global\n  yukawa/colloid cutoff is used.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, the A coefficient and cutoff\n  distance for this pair style can be mixed.  A is an energy value mixed\n  like a LJ epsilon.  The default mix value is geometric.  See the\n  “pair_modify” command for details.\n  This pair style supports the pair_modify shift\n  option for the energy of the pair interaction.\n  The pair_modify table option is not relevant\n  for this pair style.\n  This pair style does not support the pair_modify\n  tail option for adding long-range tail corrections to energy and\n  pressure.\n  This pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style yukawa/colloid kappa cutoff\n  \n  \n  \n  kappa = screening length (inverse distance units)\n  cutoff = global cutoff for colloidal Yukawa interactions (distance units)\n  \n  ",
    "examples": "pair_style yukawa/colloid 2.0 2.5\n  pair_coeff 1 1 100.0 2.3\n  pair_coeff * * 100.0\n  \n  \n  ",
    "restrictions": "This style is part of the COLLOID package.  It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  This pair style requires that atoms be finite-size spheres with a\n  diameter, as defined by the atom_style sphere\n  command.\n  Per-particle polydispersity is not yet supported by this pair style;\n  per-type polydispersity is allowed.  This means all particles of the\n  same type must have the same diameter.  Each type can have a different\n  diameter.\n  "
},
{
    "command": "pair_style zbl",
    "description": "Style zbl computes the Ziegler-Biersack-Littmark (ZBL) screened nuclear\n  repulsion for describing high-energy collisions between atoms.\n  (Ziegler). It includes an additional switching function\n  that ramps the energy, force, and curvature smoothly to zero\n  between an inner and outer cutoff. The potential\n  energy due to a pair of atoms at a distance r_ij is given by:\n  \n  \\[\\begin{split}E^{ZBL}_{ij} & = \\frac{1}{4\\pi\\epsilon_0} \\frac{Z_i Z_j \\,e^2}{r_{ij}} \\phi(r_{ij}/a)+ S(r_{ij})\\\\\n  a & =  \\frac{0.46850}{Z_{i}^{0.23} + Z_{j}^{0.23}}\\\\\n  \\phi(x) & =  0.18175e^{-3.19980x} + 0.50986e^{-0.94229x} + 0.28022e^{-0.40290x} + 0.02817e^{-0.20162x}\\\\\\end{split}\\]\n  where e is the electron charge, \\(\\epsilon_0\\) is the electrical\n  permittivity of vacuum, and \\(Z_i\\) and \\(Z_j\\) are the nuclear\n  charges of the\n  two atoms.  The switching function \\(S(r)\\) is identical to that used by\n  pair_style lj/gromacs.  Here, the inner and outer\n  cutoff are the same for all pairs of atom types.\n  The following coefficients must be defined for each pair of atom types\n  via the pair_coeff command as in the examples above,\n  or in the LAMMPS data file.\n  \n  \\(Z_i\\) (atomic number for first atom type, e.g. 13.0 for aluminum)\n  \\(Z_j\\) (ditto for second atom type)\n  \n  The values of \\(Z_i\\) and \\(Z_j\\) are normally equal to the atomic\n  numbers of the two atom types. Thus, the user may optionally\n  specify only the coefficients for each \\(i==i\\) pair, and rely\n  on the obvious mixing rule for cross interactions (see below).\n  Note that when \\(i==i\\) it is required that \\(Z_i == Z_j\\).\n  When used with hybrid/overlay and pairs are\n  assigned\n  to more than one sub-style, the mixing rule is not used and\n  each pair of types interacting with the ZBL sub-style must\n  be included in a pair_coeff command.\n  \n  Note\n  The numerical values of the exponential decay constants in the\n  screening function depend on the unit of distance. In the above\n  equation they are given for units of angstroms. LAMMPS will\n  automatically convert these values to the distance unit of the\n  specified LAMMPS units setting.  The values of Z should\n  always be given as multiples of a proton’s charge, e.g. 29.0 for\n  copper.\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs i,j and \\(i \\neq i\\), the \\(Z_i\\) and\n  \\(Z_j\\) coefficients\n  can be mixed by taking \\(Z_i\\) and \\(Z_j\\) from the values\n  specified for\n  \\(i == i\\) and \\(j == j\\) cases. When used\n  with hybrid/overlay and pairs are assigned\n  to more than one sub-style, the mixing rule is not used and\n  each pair of types interacting with the ZBL sub-style\n  must be included in a pair_coeff command.\n  The pair_modify mix option has no effect on\n  the mixing behavior\n  The ZBL pair style does not support the pair_modify\n  shift option, since the ZBL interaction is already smoothed to 0.0 at\n  the cutoff.\n  The pair_modify table option is not relevant for\n  this pair style.\n  This pair style does not support the pair_modify\n  tail option for adding long-range tail corrections to energy and\n  pressure, since there are no corrections for a potential that goes to\n  0.0 at the cutoff.\n  This pair style does not write information to binary restart files, so pair_style and pair_coeff commands must be\n  specified in an input script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style zbl inner outer\n  \n  \n  \n  inner = distance where switching function begins\n  outer = global cutoff for ZBL interaction\n  \n  ",
    "examples": "pair_style zbl 3.0 4.0\n  pair_coeff * * 73.0 73.0\n  pair_coeff 1 1 14.0 14.0\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "pair_style zero",
    "description": "Define a global or per-type cutoff length for the purpose of\n  building a neighbor list and acquiring ghost atoms, but do\n  not compute any pairwise forces or energies.\n  This can be useful for fixes or computes which require a neighbor list\n  to enumerate pairs of atoms within some cutoff distance, but when\n  pairwise forces are not otherwise needed.  Examples are the fix bond/create, compute rdf,\n  compute voronoi/atom commands.\n  Note that the comm_modify cutoff command can be\n  used to insure communication of ghost atoms even when a pair style is\n  not defined, but it will not trigger neighbor list generation.\n  The optional nocoeff flag allows to read data files with a PairCoeff\n  section for any pair style. Similarly, any pair_coeff commands\n  will only be checked for the atom type numbers and the rest ignored.\n  In this case, only the global cutoff will be used.\n  The following coefficients must be defined for each pair of atoms\n  types via the pair_coeff command as in the examples\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands, or by mixing as described below:\n  \n  cutoff (distance units)\n  \n  This coefficient is optional.  If not specified, the global cutoff\n  specified in the pair_style command is used. If the pair_style has\n  been specified with the optional nocoeff flag, then a cutoff\n  pair coefficient is ignored.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  The cutoff distance for this pair style can be mixed.  The default mix\n  value is geometric.  See the “pair_modify” command for details.\n  This pair style does not support the pair_modify\n  shift, table, and tail options.\n  This pair style writes its information to binary restart files, so pair_style and pair_coeff commands do not need\n  to be specified in an input script that reads a restart file.\n  This pair style supports the use of the inner, middle,\n  and outer keywords of the run_style respa command.\n  ",
    "syntax": "pair_style zero cutoff [nocoeff]\n  \n  \n  \n  zero = style name of this pair style\n  cutoff = global cutoff (distance units)\n  nocoeff = ignore all pair_coeff parameters (optional)\n  \n  ",
    "examples": "pair_style zero 10.0\n  pair_style zero 5.0 nocoeff\n  pair_coeff * *\n  pair_coeff 1 2*4 3.0\n  \n  \n  ",
    "restrictions": "none\n  "
},
{
    "command": "pair_style gw",
    "description": "The gw style computes a 3-body Gao-Weber potential;\n  similarly gw/zbl combines this potential with a modified\n  repulsive ZBL core function in a similar fashion as implemented\n  in the tersoff/zbl pair style.\n  Unfortunately the author of this contributed code has not been\n  able to submit a suitable documentation explaining the details\n  of the potentials. The LAMMPS developers thus have finally decided\n  to release the code anyway with only the technical explanations.\n  For details of the model and the parameters, please refer to the\n  linked publication.\n  Only a single pair_coeff command is used with the gw and gw/zbl\n  styles which specifies a Gao-Weber potential file with parameters\n  for all needed elements.  These are mapped to LAMMPS atom types by\n  specifying N additional arguments after the filename in the pair_coeff\n  command, where N is the number of LAMMPS atom types:\n  \n  filename\n  N element names = mapping of GW elements to atom types\n  \n  See the pair_coeff doc page for alternate ways\n  to specify the path for the potential file.\n  As an example, imagine a file SiC.gw has Gao-Weber values for Si and C.\n  If your LAMMPS simulation has 4 atoms types and you want the first 3 to\n  be Si, and the 4th to be C, you would use the following pair_coeff command:\n  pair_coeff * * SiC.gw Si Si Si C\n  \n  \n  The first 2 arguments must be * * so as to span all LAMMPS atom types.\n  The first three Si arguments map LAMMPS atom types 1,2,3 to the Si\n  element in the GW file.  The final C argument maps LAMMPS atom type 4\n  to the C element in the GW file.  If a mapping value is specified as\n  NULL, the mapping is not performed.  This can be used when a gw\n  potential is used as part of the hybrid pair style.  The NULL values\n  are placeholders for atom types that will be used with other\n  potentials.\n  Gao-Weber files in the potentials directory of the LAMMPS\n  distribution have a “.gw” suffix.  Gao-Weber with ZBL files\n  have a “.gz.zbl” suffix. The structure of the potential files\n  is similar to other many-body potentials supported by LAMMPS.\n  You have to refer to the comments in the files and the literature\n  to learn more details.\n  \n  Mixing, shift, table, tail correction, restart, rRESPA info:\n  For atom type pairs I,J and I != J, where types I and J correspond to\n  two different element types, mixing is performed by LAMMPS as\n  described above from values in the potential file.\n  This pair style does not support the pair_modify\n  shift, table, and tail options.\n  This pair style does not write its information to binary restart files, since it is stored in potential files.  Thus, you\n  need to re-specify the pair_style and pair_coeff commands in an input\n  script that reads a restart file.\n  This pair style can only be used via the pair keyword of the\n  run_style respa command.  It does not support the\n  inner, middle, outer keywords.\n  ",
    "syntax": "pair_style style\n  \n  \n  \n  style = gw or gw/zbl\n  \n  ",
    "examples": "pair_style gw\n  pair_coeff * * SiC.gw Si C C\n  \n  pair_style gw/zbl\n  pair_coeff * * SiC.gw.zbl C Si\n  \n  \n  ",
    "restrictions": "This pair style is part of the MANYBODY package. It is only enabled if\n  LAMMPS was built with that package.  See the Build package doc page for more info.\n  This pair style requires the newton setting to be “on”\n  for pair interactions.\n  The Gao-Weber potential files provided with LAMMPS (see the\n  potentials directory) are parameterized for metal units.\n  You can use the GW potential with any LAMMPS units, but you would need\n  to create your own GW potential file with coefficients listed in the\n  appropriate units if your simulation does not use “metal” units.\n  "
},
{
    "command": "angle_style charmm",
    "description": "The charmm angle style uses the potential\n  \n  \\[E = K (\\theta - \\theta_0)^2 + K_{ub} (r - r_{ub})^2\\]\n  with an additional Urey_Bradley term based on the distance \\(r\\) between\n  the 1st and 3rd atoms in the angle.  \\(K\\), \\(\\theta_0\\),\n  \\(K_{ub}\\), and \\(R_{ub}\\) are coefficients defined for each angle\n  type.\n  See (MacKerell) for a description of the CHARMM force\n  field.\n  The following coefficients must be defined for each angle type via the\n  angle_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(K\\) (energy/radian^2)\n  \\(\\theta_0\\) (degrees)\n  \\(K_{ub}\\) (energy/distance^2)\n  \\(r_{ub}\\) (distance)\n  \n  \\(\\theta_0\\) is specified in degrees, but LAMMPS converts it to radians\n  internally; hence the units of \\(K\\) are in energy/radian^2.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "angle_style charmm\n  \n  \n  ",
    "examples": "angle_style charmm\n  angle_coeff 1 300.0 107.0 50.0 3.0\n  \n  \n  ",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\n  MOLECULE package.  See the Build package doc page\n  for more info.\n  "
},
{
    "command": "angle_style class2",
    "description": "The class2 angle style uses the potential\n  \n  \\[\\begin{split}E & = E_a + E_{bb} + E_{ba} \\\\\n  E_a & = K_2 (\\theta - \\theta_0)^2 + K_3 (\\theta - \\theta_0)^3 + K_4(\\theta - \\theta_0)^4 \\\\\n  E_{bb} & = M (r_{ij} - r_1) (r_{jk} - r_2) \\\\\n  E_{ba} & = N_1 (r_{ij} - r_1) (\\theta - \\theta_0) + N_2(r_{jk} - r_2)(\\theta - \\theta_0)\\end{split}\\]\n  where \\(E_a\\) is the angle term, \\(E_{bb}\\) is a bond-bond term, and \\(E_{ba}\\) is a\n  bond-angle term.  \\(\\theta_0\\) is the equilibrium angle and \\(r_1\\) and \\(r_2\\) are\n  the equilibrium bond lengths.\n  See (Sun) for a description of the COMPASS class2 force field.\n  Coefficients for the \\(E_a\\), \\(E_{bb}\\), and \\(E_{ba}\\) formulas must be defined for\n  each angle type via the angle_coeff command as in\n  the example above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands.\n  These are the 4 coefficients for the \\(E_a\\) formula:\n  \n  \\(\\theta_0\\) (degrees)\n  \\(K_2\\) (energy/radian^2)\n  \\(K_3\\) (energy/radian^3)\n  \\(K_4\\) (energy/radian^4)\n  \n  \\(\\theta_0\\) is specified in degrees, but LAMMPS converts it to radians\n  internally; hence the units of the various \\(K\\) are in per-radian.\n  For the \\(E_{bb}\\) formula, each line in a angle_coeff\n  command in the input script lists 4 coefficients, the first of which\n  is “bb” to indicate they are BondBond coefficients.  In a data file,\n  these coefficients should be listed under a “BondBond Coeffs” heading\n  and you must leave out the “bb”, i.e. only list 3 coefficients after\n  the angle type.\n  \n  bb\n  \\(M\\) (energy/distance^2)\n  \\(r_1\\) (distance)\n  \\(r_2\\) (distance)\n  \n  For the \\(E_{ba}\\) formula, each line in a angle_coeff\n  command in the input script lists 5 coefficients, the first of which\n  is “ba” to indicate they are BondAngle coefficients.  In a data file,\n  these coefficients should be listed under a “BondAngle Coeffs” heading\n  and you must leave out the “ba”, i.e. only list 4 coefficients after\n  the angle type.\n  \n  ba\n  \\(N_1\\) (energy/distance^2)\n  \\(N_2\\) (energy/distance^2)\n  \\(r_1\\) (distance)\n  \\(r_2\\) (distance)\n  \n  The \\(\\theta_0\\) value in the \\(E_{ba}\\) formula is not specified,\n  since it is the same value from the \\(E_a\\) formula.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  The class2/p6 angle style uses the class2 potential expanded to sixth order:\n  \n  \\[E_{a} = K_2\\left(\\theta - \\theta_0\\right)^2 + K_3\\left(\\theta - \\theta_0\\right)^3 + K_4\\left(\\theta - \\theta_0\\right)^4 + K_5\\left(\\theta - \\theta_0\\right)^5 + K_6\\left(\\theta - \\theta_0\\right)^6\\]\n  In this expanded term 6 coefficients for the \\(E_a\\) formula need to be set:\n  \n  \\(\\theta_0\\) (degrees)\n  \\(K_2\\) (energy/radian^2)\n  \\(K_3\\) (energy/radian^3)\n  \\(K_4\\) (energy/radian^4)\n  \\(K_5\\) (energy/radian^5)\n  \\(K_6\\) (energy/radian^6)\n  \n  The bond-bond and bond-angle terms remain unchanged.\n  ",
    "syntax": "angle_style class2\n  \n  \n  ",
    "examples": "angle_style class2\n  angle_coeff * 75.0\n  angle_coeff 1 bb 10.5872 1.0119 1.5228\n  angle_coeff * ba 3.6551 24.895 1.0119 1.5228\n  \n  \n  ",
    "restrictions": "This angle style can only be used if LAMMPS was built with the CLASS2\n  package.  For the class2/p6 style LAMMPS needs to be built with the\n  USER-MOFFF package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "angle_style cosine",
    "description": "The cosine angle style uses the potential\n  \n  \\[E = K [1 + \\cos(\\theta)]\\]\n  where \\(K\\) is defined for each angle type.\n  The following coefficients must be defined for each angle type via the\n  angle_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(K\\) (energy)\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "angle_style cosine\n  \n  \n  ",
    "examples": "angle_style cosine\n  angle_coeff * 75.0\n  \n  \n  ",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\n  MOLECULE package.  See the Build package doc page\n  for more info.\n  "
},
{
    "command": "angle_style cosine/buck6d",
    "description": "The cosine/buck6d angle style uses the potential\n  \n  \\[E = K \\left[ 1 + \\cos(n\\theta - \\theta_0)\\right]\\]\n  where \\(K\\) is the energy constant, \\(n\\) is the periodic multiplicity and\n  \\(\\theta_0\\) is the equilibrium angle.\n  The coefficients must be defined for each angle type via the\n  angle_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands in the following order:\n  \n  \\(K\\) (energy)\n  \\(n\\)\n  \\(\\theta_0\\) (degrees)\n  \n  \\(\\theta_0\\) is specified in degrees, but LAMMPS converts it to radians\n  internally.\n  Additional to the cosine term the cosine/buck6d angle style computes\n  the short range (vdW) interaction belonging to the\n  pair_style buck6d between the end atoms of the\n  angle.  For this reason this angle style only works in combination\n  with the pair_style buck6d styles and needs\n  the special_bonds 1-3 interactions to be weighted\n  0.0 to prevent double counting.\n  ",
    "syntax": "angle_style cosine/buck6d\n  \n  \n  ",
    "examples": "angle_style cosine/buck6d\n  angle_coeff 1  cosine/buck6d  1.978350  4  180.000000\n  \n  \n  ",
    "restrictions": "cosine/buck6d can only be used in combination with the\n  pair_style buck6d style and with a\n  special_bonds 0.0 weighting of 1-3 interactions.\n  This angle style can only be used if LAMMPS was built with the\n  USER-MOFFF package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "angle_style cosine/delta",
    "description": "The cosine/delta angle style uses the potential\n  \n  \\[E = K [1 - \\cos(\\theta - \\theta_0)]\\]\n  where \\(\\theta_0\\) is the equilibrium value of the angle, and \\(K\\) is a\n  prefactor.  Note that the usual 1/2 factor is included in \\(K\\).\n  The following coefficients must be defined for each angle type via the\n  angle_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(K\\) (energy)\n  \\(\\theta_0\\) (degrees)\n  \n  \\(\\theta_0\\) is specified in degrees, but LAMMPS converts it to radians\n  internally.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "angle_style cosine/delta\n  \n  \n  ",
    "examples": "angle_style cosine/delta\n  angle_coeff 2*4 75.0 100.0\n  \n  \n  ",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\n  MOLECULE package.  See the Build package doc page\n  for more info.\n  "
},
{
    "command": "angle_style cosine/periodic",
    "description": "The cosine/periodic angle style uses the following potential, which\n  is commonly used in the DREIDING force field,\n  particularly for organometallic systems where \\(n\\) = 4 might be used\n  for an octahedral complex and \\(n\\) = 3 might be used for a trigonal\n  center:\n  \n  \\[E = C \\left[ 1 - B(-1)^n\\cos\\left( n\\theta\\right) \\right]\\]\n  where \\(C\\), \\(B\\) and \\(n\\) are coefficients defined for each angle type.\n  See (Mayo) for a description of the DREIDING force field\n  The following coefficients must be defined for each angle type via the\n  angle_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(C\\) (energy)\n  \\(B\\) = 1 or -1\n  \\(n\\) = 1, 2, 3, 4, 5 or 6 for periodicity\n  \n  Note that the prefactor \\(C\\) is specified and not the overall force\n  constant \\(K = \\frac{C}{n^2}\\).  When \\(B = 1\\), it leads to a minimum for the\n  linear geometry.  When \\(B = -1\\), it leads to a maximum for the linear\n  geometry.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "angle_style cosine/periodic\n  \n  \n  ",
    "examples": "angle_style cosine/periodic\n  angle_coeff * 75.0 1 6\n  \n  \n  ",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\n  MOLECULE package.  See the Build package doc page\n  for more info.\n  "
},
{
    "command": "angle_style cosine/shift",
    "description": "The cosine/shift angle style uses the potential\n  \n  \\[E = -\\frac{U_{\\text{min}}}{2} \\left[ 1 + \\cos(\\theta-\\theta_0) \\right]\\]\n  where \\(\\theta_0\\) is the equilibrium angle. The potential is bounded\n  between \\(-U_{\\text{min}}\\) and zero. In the neighborhood of the minimum\n  \\(E = - U_{\\text{min}} + U_{\\text{min}}/4(\\theta - \\theta_0)^2\\) hence\n  the spring constant is \\(\\frac{U_{\\text{min}}}{2}\\).\n  The following coefficients must be defined for each angle type via the\n  angle_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(U_{\\text{min}}\\) (energy)\n  \\(\\theta\\) (angle)\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "angle_style cosine/shift\n  \n  \n  ",
    "examples": "angle_style cosine/shift\n  angle_coeff * 10.0 45.0\n  \n  \n  ",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\n  USER-MISC package.\n  "
},
{
    "command": "angle_style cosine/shift/exp",
    "description": "The cosine/shift/exp angle style uses the potential\n  \n  \\[E = -U_{\\text{min}} \\frac{e^{-a U(\\theta,\\theta_0)}-1}{e^a-1} \\quad \\text{with} \\quad U(\\theta,\\theta_0) = -0.5 \\left(1+\\cos(\\theta-\\theta_0) \\right)\\]\n  where \\(U_{\\text{min}}\\), \\(\\theta\\), and \\(a\\) are defined for each angle type.\n  The potential is bounded between \\([-U_{\\text{min}}, 0]\\) and the minimum is\n  located at the angle \\(\\theta_0\\). The a parameter can be both positive or\n  negative and is used to control the spring constant at the\n  equilibrium.\n  The spring constant is given by \\(k = A \\exp(A) U_{\\text{min}} / [2 (\\exp(a)-1)]\\).\n  For \\(a > 3\\), \\(\\frac{k}{U_{\\text{min}}} = \\frac{a}{2}\\) to better than 5% relative error. For negative\n  values of the \\(a\\) parameter, the spring constant is essentially zero,\n  and anharmonic terms takes over. The potential is furthermore well\n  behaved in the limit \\(a \\rightarrow 0\\), where it has been implemented to linear\n  order in \\(a\\) for \\(a < 0.001\\). In this limit the potential reduces to the\n  cosineshifted potential.\n  The following coefficients must be defined for each angle type via the\n  angle_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(U_min\\) (energy)\n  \\(\\theta\\) (angle)\n  \\(A\\) (real number)\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "angle_style cosine/shift/exp\n  \n  \n  ",
    "examples": "angle_style cosine/shift/exp\n  angle_coeff * 10.0 45.0 2.0\n  \n  \n  ",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\n  USER-MISC package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "angle_style cosine/squared",
    "description": "The cosine/squared angle style uses the potential\n  \n  \\[E = K [\\cos(\\theta) - \\cos(\\theta_0)]^2\\]\n  where \\(\\theta_0\\) is the equilibrium value of the angle, and \\(K\\) is a\n  prefactor.  Note that the usual 1/2 factor is included in \\(K\\).\n  The following coefficients must be defined for each angle type via the\n  angle_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(K\\) (energy)\n  \\(\\theta_0\\) (degrees)\n  \n  \\(\\theta_0\\) is specified in degrees, but LAMMPS converts it to radians\n  internally.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "angle_style cosine/squared\n  \n  \n  ",
    "examples": "angle_style cosine/squared\n  angle_coeff 2*4 75.0 100.0\n  \n  \n  ",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\n  MOLECULE package.  See the Build package doc page\n  for more info.\n  "
},
{
    "command": "angle_style cross",
    "description": "The cross angle style uses a potential that couples the bond stretches of\n  a bend with the angle stretch of that bend:\n  \n  \\[E = K_{SS} \\left(r_{12}-r_{12,0}\\right)\\left(r_{32}-r_{32,0}\\right) + K_{BS0}\\left(r_{12}-r_{12,0}\\right)\\left(\\theta-\\theta_0\\right) + K_{BS1}\\left(r_{32}-r_{32,0}\\right)\\left(\\theta-\\theta_0\\right)\\]\n  where \\(r_{12,0}\\) is the rest value of the bond length between atom 1 and 2,\n  \\(r_{32,0}\\) is the rest value of the bond length between atom 3 and 2,\n  and \\(\\theta_0\\) is the rest value of the angle. \\(K_{SS}\\) is the force constant of\n  the bond stretch-bond stretch term and \\(K_{BS0}\\) and \\(K_{BS1}\\) are the force constants\n  of the bond stretch-angle stretch terms.\n  The following coefficients must be defined for each angle type via the\n  angle_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(K_{SS}\\) (energy/distance^2)\n  \\(K_{BS0}\\) (energy/distance/rad)\n  \\(K_{BS1}\\) (energy/distance/rad)\n  \\(r_{12,0}\\) (distance)\n  \\(r_{32,0}\\) (distance)\n  \\(\\theta_0\\) (degrees)\n  \n  \\(\\theta_0\\) is specified in degrees, but LAMMPS converts it to radians\n  internally; hence the units of \\(K_{BS0}\\) and \\(K_{BS1}\\) are in energy/distance/radian.\n  ",
    "syntax": "angle_style cross\n  \n  \n  ",
    "examples": "angle_style cross\n  angle_coeff 1 200.0 100.0 100.0 1.25 1.25 107.0\n  \n  \n  ",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\n  USER_YAFF package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "angle_style dipole",
    "description": "The dipole angle style is used to control the orientation of a dipolar\n  atom within a molecule (Orsi). Specifically, the dipole angle\n  style restrains the orientation of a point dipole \\(\\mu_j\\) (embedded in atom\n  \\(j\\)) with respect to a reference (bond) vector\n  \\(\\vec{r_{ij}} = \\vec{r_i} - \\vec{r_j}\\), where \\(i\\) is another atom of\n  the same molecule (typically, \\(i\\) and \\(j\\) are also covalently bonded).\n  It is convenient to define an angle gamma between the ‘free’ vector \\(\\vec{\\mu_j}\\)\n  and the reference (bond) vector \\(\\vec{r_{ij}}\\):\n  \n  \\[\\cos\\gamma = \\frac{\\vec{\\mu_j}\\cdot\\vec{r_{ij}}}{\\mu_j\\,r_{ij}}\\]\n  The dipole angle style uses the potential:\n  \n  \\[E = K (\\cos\\gamma - \\cos\\gamma_0)^2\\]\n  where \\(K\\) is a rigidity constant and gamma0 is an equilibrium (reference)\n  angle.\n  The torque on the dipole can be obtained by differentiating the\n  potential using the ‘chain rule’ as in appendix C.3 of\n  (Allen):\n  \n  \\[\\vec{T_j} = \\frac{2K(\\cos\\gamma - \\cos\\gamma_0)}{\\mu_j\\,r_{ij}}\\, \\vec{r_{ij}} \\times \\vec{\\mu_j}\\]\n  Example: if \\(\\gamma_0\\) is set to 0 degrees, the torque generated by\n  the potential will tend to align the dipole along the reference\n  direction defined by the (bond) vector \\(\\vec{r_{ij}}\\) (in other words, \\(\\vec{\\mu_j}\\) is\n  restrained to point towards atom \\(i\\)).\n  The dipolar torque \\(\\vec{T_j}\\) must be counterbalanced in order to conserve\n  the local angular momentum. This is achieved via an additional force\n  couple generating a torque equivalent to the opposite of \\(\\vec{T_j}\\):\n  \n  \\[\\begin{split}-\\vec{T_j} & = \\vec{r_{ij}} \\times \\vec{F_i} \\\\\n  \\vec{F_j}  & = -\\vec{F_i}\\end{split}\\]\n  where \\(\\vec{F_i}\\) and \\(\\vec{F_j}\\) are applied on atoms \\(i\\)\n  and \\(j\\), respectively.\n  The following coefficients must be defined for each angle type via the\n  angle_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(K\\) (energy)\n  \\(\\gamma_0\\) (degrees)\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "angle_style dipole\n  \n  \n  ",
    "examples": "angle_style dipole\n  angle_coeff 6 2.1 180.0\n  \n  \n  ",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\n  USER-MISC package.  See the Build package doc\n  page for more info.\n  \n  Note\n  In the “Angles” section of the data file, the atom ID \\(j\\)\n  defining the direction of the dipole vector to restrain must come\n  before the atom ID of the reference atom \\(i\\). A third atom ID \\(k\\) must\n  also be provided to comply with the requirement of a valid angle\n  definition. This atom ID \\(k\\) should be chosen to be that of an atom\n  bonded to atom \\(i\\) to avoid errors with “lost angle atoms” when running\n  in parallel. Since the LAMMPS code checks for valid angle definitions,\n  cannot use the same atom ID of either \\(i\\) or \\(j\\) (this was allowed\n  and recommended with older LAMMPS versions).\n  \n  The newton command for intramolecular interactions must be “on”\n  (which is the default except when using some accelerator packages).\n  This angle style should not be used with SHAKE.\n  "
},
{
    "command": "angle_style fourier",
    "description": "The fourier angle style uses the potential\n  \n  \\[E = K [C_0 + C_1 \\cos ( \\theta) + C_2 \\cos( 2 \\theta) ]\\]\n  The following coefficients must be defined for each angle type via the\n  angle_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(K\\) (energy)\n  \\(C_0\\) (real)\n  \\(C_1\\) (real)\n  \\(C_2\\) (real)\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "angle_style fourier\n  \n  \n  ",
    "examples": "angle_style fourier\n  angle_coeff 75.0 1.0 1.0 1.0\n  \n  \n  ",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\n  USER_MISC package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "angle_style fourier/simple",
    "description": "The fourier/simple angle style uses the potential\n  \n  \\[E = K [ 1.0 + c \\cos ( n \\theta) ]\\]\n  The following coefficients must be defined for each angle type via the\n  angle_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(K\\) (energy)\n  \\(c\\) (real)\n  \\(n\\) (real)\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "angle_style fourier/simple\n  \n  \n  ",
    "examples": "angle_style fourier/simple\n  angle_coeff 100.0 -1.0 1.0\n  \n  \n  ",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\n  USER_MISC package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "angle_style harmonic",
    "description": "The harmonic angle style uses the potential\n  \n  \\[E = K (\\theta - \\theta_0)^2\\]\n  where \\(\\theta_0\\) is the equilibrium value of the angle, and \\(K\\) is a\n  prefactor.  Note that the usual 1/2 factor is included in \\(K\\).\n  The following coefficients must be defined for each angle type via the\n  angle_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(K\\) (energy/radian^2)\n  \\(\\theta_0\\) (degrees)\n  \n  \\(\\theta_0\\) is specified in degrees, but LAMMPS converts it to radians\n  internally; hence the units of \\(K\\) are in energy/radian^2.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "angle_style harmonic\n  \n  \n  ",
    "examples": "angle_style harmonic\n  angle_coeff 1 300.0 107.0\n  \n  \n  ",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\n  MOLECULE package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "angle_style hybrid",
    "description": "The hybrid style enables the use of multiple angle styles in one\n  simulation.  An angle style is assigned to each angle type.  For\n  example, angles in a polymer flow (of angle type 1) could be computed\n  with a harmonic potential and angles in the wall boundary (of angle\n  type 2) could be computed with a cosine potential.  The assignment\n  of angle type to style is made via the angle_coeff\n  command or in the data file.\n  In the angle_coeff commands, the name of an angle style must be added\n  after the angle type, with the remaining coefficients being those\n  appropriate to that style.  In the example above, the 2 angle_coeff\n  commands set angles of angle type 1 to be computed with a harmonic\n  potential with coefficients 80.0, 30.0 for \\(K\\), \\(\\theta_0\\).  All other angle\n  types \\((2 - N)\\) are computed with a cosine potential with coefficient\n  50.0 for \\(K\\).\n  If angle coefficients are specified in the data file read via the\n  read_data command, then the same rule applies.\n  E.g. “harmonic” or “cosine”, must be added after the angle type, for each\n  line in the “Angle Coeffs” section, e.g.\n  Angle Coeffs\n  \n  1 harmonic 80.0 30.0\n  2 cosine 50.0\n  ...\n  \n  \n  If class2 is one of the angle hybrid styles, the same rule holds for\n  specifying additional BondBond (and BondAngle) coefficients either via\n  the input script or in the data file.  I.e. class2 must be added to\n  each line after the angle type.  For lines in the BondBond (or\n  BondAngle) section of the data file for angle types that are not\n  class2, you must use an angle style of skip as a placeholder, e.g.\n  BondBond Coeffs\n  \n  1 skip\n  2 class2 3.6512 1.0119 1.0119\n  ...\n  \n  \n  Note that it is not necessary to use the angle style skip in the\n  input script, since BondBond (or BondAngle) coefficients need not be\n  specified at all for angle types that are not class2.\n  An angle style of none with no additional coefficients can be used\n  in place of an angle style, either in a input script angle_coeff\n  command or in the data file, if you desire to turn off interactions\n  for specific angle types.\n  ",
    "syntax": "angle_style hybrid style1 style2 ...\n  \n  \n  \n  style1,style2 = list of one or more angle styles\n  \n  ",
    "examples": "angle_style hybrid harmonic cosine\n  angle_coeff 1 harmonic 80.0 30.0\n  angle_coeff 2* cosine 50.0\n  \n  \n  ",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\n  MOLECULE package.  See the Build package doc page\n  for more info.\n  Unlike other angle styles, the hybrid angle style does not store angle\n  coefficient info for individual sub-styles in a binary restart files.  Thus when restarting a simulation from a restart\n  file, you need to re-specify angle_coeff commands.\n  "
},
{
    "command": "angle_style mm3",
    "description": "The mm3 angle style uses the potential that is anharmonic in the angle\n  as defined in (Allinger)\n  \n  \\[E = K (\\theta - \\theta_0)^2 \\left[ 1 - 0.014(\\theta - \\theta_0) + 5.6(10)^{-5} (\\theta - \\theta_0)^2 - 7.0(10)^{-7} (\\theta - \\theta_0)^3 + 9(10)^{-10} (\\theta - \\theta_0)^4 \\right]\\]\n  where \\(\\theta_0\\) is the equilibrium value of the angle, and \\(K\\) is a\n  prefactor. The anharmonic prefactors have units \\(\\deg^{-n}\\), for example\n  \\(-0.014 \\deg^{-1}\\), \\(5.6 \\cdot 10^{-5} \\deg^{-2}\\), …\n  The following coefficients must be defined for each angle type via the\n  angle_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(K\\) (energy/radian^2)\n  \\(\\theta_0\\) (degrees)\n  \n  \\(\\theta_0\\) is specified in degrees, but LAMMPS converts it to radians\n  internally; hence the units of \\(K\\) are in energy/radian^2.\n  ",
    "syntax": "angle_style mm3\n  \n  \n  ",
    "examples": "angle_style mm3\n  angle_coeff 1 100.0 107.0\n  \n  \n  ",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\n  USER_YAFF package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "angle_style quartic",
    "description": "The quartic angle style uses the potential\n  \n  \\[E = K_2 (\\theta - \\theta_0)^2 + K_3 (\\theta - \\theta_0)^3 + K_4 (\\theta - \\theta_0)^4\\]\n  where \\(\\theta_0\\) is the equilibrium value of the angle, and \\(K\\) is a\n  prefactor.  Note that the usual 1/2 factor is included in \\(K\\).\n  The following coefficients must be defined for each angle type via the\n  angle_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(\\theta_0\\) (degrees)\n  \\(K_2\\) (energy/radian^2)\n  \\(K_3\\) (energy/radian^3)\n  \\(K_4\\) (energy/radian^4)\n  \n  \\(\\theta_0\\) is specified in degrees, but LAMMPS converts it to radians\n  internally; hence the units of \\(K\\) are in energy/radian^2.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "angle_style quartic\n  \n  \n  ",
    "examples": "angle_style quartic\n  angle_coeff 1 129.1948 56.8726 -25.9442 -14.2221\n  \n  \n  ",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\n  USER_MISC package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "angle_style sdk",
    "description": "The sdk angle style is a combination of the harmonic angle potential,\n  \n  \\[E = K (\\theta - \\theta_0)^2\\]\n  where \\(\\theta_0\\) is the equilibrium value of the angle and\n  \\(K\\) a prefactor, with the repulsive part of the non-bonded\n  lj/sdk pair style between the atoms 1 and 3.  This angle potential is\n  intended for coarse grained MD simulations with the CMM parameterization\n  using the pair_style lj/sdk.  Relative to the\n  pair_style lj/sdk, however, the energy is shifted by\n  \\(\\epsilon\\), to avoid sudden jumps.  Note that the usual 1/2 factor\n  is included in \\(K\\).\n  The following coefficients must be defined for each angle type via the\n  angle_coeff command as in the example above:\n  \n  \\(K\\) (energy/radian^2)\n  \\(\\theta_0\\) (degrees)\n  \n  \\(\\theta_0\\) is specified in degrees, but LAMMPS converts it to radians\n  internally; hence the units of \\(K\\) are in energy/radian^2.\n  The also required lj/sdk parameters will be extracted automatically\n  from the pair_style.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "angle_style sdk\n  \n  angle_style sdk/omp\n  \n  \n  ",
    "examples": "angle_style sdk\n  angle_coeff 1 300.0 107.0\n  \n  \n  ",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\n  USER-CGSDK package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "angle_style table",
    "description": "Style table creates interpolation tables of length N from angle\n  potential and derivative values listed in a file(s) as a function of\n  angle The files are read by the angle_coeff\n  command.\n  The interpolation tables are created by fitting cubic splines to the\n  file values and interpolating energy and derivative values at each of\n  N angles.  During a simulation, these tables are used to interpolate\n  energy and force values on individual atoms as needed.  The\n  interpolation is done in one of 2 styles: linear or spline.\n  For the linear style, the angle is used to find 2 surrounding table\n  values from which an energy or its derivative is computed by linear\n  interpolation.\n  For the spline style, a cubic spline coefficients are computed and\n  stored at each of the N values in the table.  The angle is used to\n  find the appropriate set of coefficients which are used to evaluate a\n  cubic polynomial which computes the energy or derivative.\n  The following coefficients must be defined for each angle type via the\n  angle_coeff command as in the example above.\n  \n  filename\n  keyword\n  \n  The filename specifies a file containing tabulated energy and\n  derivative values.  The keyword specifies a section of the file.  The\n  format of this file is described below.\n  \n  The format of a tabulated file is as follows (without the\n  parenthesized comments):\n  # Angle potential for harmonic (one or more comment or blank lines)\n  \n  HAM                           (keyword is the first text on line)\n  N 181 FP 0 0 EQ 90.0          (N, FP, EQ parameters)\n                                (blank line)\n  N 181 FP 0 0                  (N, FP parameters)\n  1 0.0 200.5 2.5               (index, angle, energy, derivative)\n  2 1.0 198.0 2.5\n  ...\n  181 180.0 0.0 0.0\n  \n  \n  A section begins with a non-blank line whose 1st character is not a\n  “#”; blank lines or lines starting with “#” can be used as comments\n  between sections.  The first line begins with a keyword which\n  identifies the section.  The line can contain additional text, but the\n  initial text must match the argument specified in the\n  angle_coeff command.  The next line lists (in any\n  order) one or more parameters for the table.  Each parameter is a\n  keyword followed by one or more numeric values.\n  The parameter “N” is required and its value is the number of table\n  entries that follow.  Note that this may be different than the N\n  specified in the angle_style table command.  Let\n  Ntable = N in the angle_style command, and Nfile = “N” in the\n  tabulated file.  What LAMMPS does is a preliminary interpolation by\n  creating splines using the Nfile tabulated values as nodal points.  It\n  uses these to interpolate as needed to generate energy and derivative\n  values at Ntable different points.  The resulting tables of length\n  Ntable are then used as described above, when computing energy and\n  force for individual angles and their atoms.  This means that if you\n  want the interpolation tables of length Ntable to match exactly what\n  is in the tabulated file (with effectively no preliminary\n  interpolation), you should set Ntable = Nfile.\n  The “FP” parameter is optional.  If used, it is followed by two values\n  fplo and fphi, which are the 2nd derivatives at the innermost and\n  outermost angle settings.  These values are needed by the spline\n  construction routines.  If not specified by the “FP” parameter, they\n  are estimated (less accurately) by the first two and last two\n  derivative values in the table.\n  The “EQ” parameter is also optional.  If used, it is followed by a the\n  equilibrium angle value, which is used, for example, by the fix shake command.  If not used, the equilibrium angle is\n  set to 180.0.\n  Following a blank line, the next N lines list the tabulated values.\n  On each line, the 1st value is the index from 1 to N, the 2nd value is\n  the angle value (in degrees), the 3rd value is the energy (in energy\n  units), and the 4th is -dE/d(theta) (also in energy units).  The 3rd\n  term is the energy of the 3-atom configuration for the specified\n  angle.  The last term is the derivative of the energy with respect to\n  the angle (in degrees, not radians).  Thus the units of the last term\n  are still energy, not force.  The angle values must increase from one\n  line to the next.  The angle values must also begin with 0.0 and end\n  with 180.0, i.e. span the full range of possible angles.\n  Note that one file can contain many sections, each with a tabulated\n  potential.  LAMMPS reads the file section by section until it finds\n  one that matches the specified keyword.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Restart info:\n  This angle style writes the settings for the “angle_style table”\n  command to binary restart files, so a angle_style\n  command does not need to specified in an input script that reads a\n  restart file.  However, the coefficient information is not stored in\n  the restart file, since it is tabulated in the potential files.  Thus,\n  angle_coeff commands do need to be specified in the restart input\n  script.\n  ",
    "syntax": "angle_style table style N\n  \n  \n  \n  style = linear or spline = method of interpolation\n  N = use N values in table\n  \n  ",
    "examples": "angle_style table linear 1000\n  angle_coeff 3 file.table ENTRY1\n  \n  \n  ",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\n  MOLECULE package.  See the Build package doc page\n  for more info.\n  "
},
{
    "command": "angle_style zero",
    "description": "Using an angle style of zero means angle forces and energies are not\n  computed, but the geometry of angle triplets is still accessible to\n  other commands.\n  As an example, the compute angle/local\n  command can be used to compute the theta values for the list of\n  triplets of angle atoms listed in the data file read by the\n  read_data command.  If no angle style is defined,\n  this command cannot be used.\n  The optional nocoeff flag allows to read data files with AngleCoeff\n  section for any angle style. Similarly, any angle_coeff commands\n  will only be checked for the angle type number and the rest ignored.\n  Note that the angle_coeff command must be used for\n  all angle types. If specified, there can be only one value, which is\n  going to be used to assign an equilibrium angle, e.g. for use with\n  fix shake.\n  ",
    "syntax": "angle_style zero *nocoeff*\n  \n  \n  ",
    "examples": "angle_style zero\n  angle_style zero nocoeff\n  angle_coeff *\n  angle_coeff * 120.0\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "fix_modify AtC add_molecule",
    "description": "Associates a tag with all molecules corresponding to a specified group.\n  ",
    "syntax": "fix_modify <AtC fixID> add_molecule <small|large> <tag> <group-ID>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  add_molecule = name of the AtC sub-command\n  small or large = can be small if molecule size < cutoff radius, must be large otherwise\n  tag = tag for tracking a molecule\n  group-ID = LAMMPS defined group-ID\n  \n  ",
    "examples": "group WATERGROUP type 1 2\n  fix_modify AtC add_molecule small water WATERGROUP\n  \n  \n  ",
    "restrictions": "None.\n  "
},
{
    "command": "fix_modify AtC add_species",
    "description": "Associates a tag with all atoms of a specified type or within a specified group.\n  ",
    "syntax": "fix_modify <AtC fixID> add_species <tag> <group|type> <ID>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  add_species = name of the AtC sub-command\n  tag = tag for tracking a species\n  group or type = LAMMPS defined group or type of atoms\n  ID = name of group or type number\n  \n  ",
    "examples": "fix_modify AtC add_species gold type 1\n  group GOLDGROUP type 1\n  fix_modify AtC add_species gold group GOLDGROUP\n  \n  \n  ",
    "restrictions": "None.\n  "
},
{
    "command": "fix_modify AtC atom_element_map",
    "description": "Changes frame of reference from eulerian to lagrangian or vice versa\n  and sets the frequency for which the map from atoms to elements is\n  reformed and all the attendant data is recalculated.\n  ",
    "syntax": "fix_modify <AtC fixID> atom_element_map <eulerian|lagrangian> [<frequency>]\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  atom_element_map = name of the AtC sub-command\n  eulerian or lagrangian = frame of reference\n  frequency = frequency of updating atom-to-continuum maps based on the current configuration - (only for eulerian)\n  \n  ",
    "examples": "fix_modify AtC atom_element_map eulerian 100\n  \n  \n  ",
    "restrictions": "Cannot change map type after initialization.\n  "
},
{
    "command": "fix_modify AtC atom_weight",
    "description": "Command for assigning the value of atomic weights used for atomic\n  integration in atom-continuum coupled simulations.\n  ",
    "syntax": "fix_modify <AtC fixID> atom_weight <method> <args>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  atom_weight = name of the AtC sub-command\n  method = constant or lattice or element or region or group or read_in\n  \n  constant <group-ID> <value>: atoms in specified group are assigned the constant value given\n  lattice: volume per atom for specified lattice type (e.g. fcc) and parameter\n  element: element volume divided among atoms within element\n  region: volume per atom determined based on the atom count in the MD regions and their volumes. Note: meaningful only if atoms completely fill all the regions.\n  group: volume per atom determined based on the atom count in a group and its volume\n  node: (undocumented)\n  node_element: (undocumented)\n  read_in<filename>: list of values for atoms are read-in from specified file\n  \n  \n  \n  ",
    "examples": "fix_modify AtC atom_weight constant myatoms 11.8\n  fix_modify AtC atom_weight lattice\n  fix_modify AtC atom_weight read-in atm_wt_file.txt\n  \n  \n  ",
    "restrictions": "The use of the lattice option requires a lattice type and parameter is already specified.\n  "
},
{
    "command": "fix_modify AtC atomic_charge",
    "description": "Determines whether AtC tracks the total charge as a finite element\n  field.\n  ",
    "syntax": "fix_modify <AtC fixID> <include|omit> atomic_charge\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  include or omit = switch to activate/deactivate inclusion of intrinsic atomic charge in ATC\n  atomic_charge = name of the AtC sub-command\n  \n  ",
    "examples": "fix_modify AtC include atomic_charge\n  \n  \n  ",
    "restrictions": "Required for: electrostatics\n  "
},
{
    "command": "fix_modify AtC boundary_dynamics",
    "description": "Sets different schemes for controlling boundary atoms.  on will integrate\n  the boundary atoms using the velocity-verlet algorithm.  damped_harmonic\n  uses a mass/spring/dashpot for the boundary atoms with added arguments\n  of the damping and spring constants followed by the ratio of the\n  boundary type mass to the desired mass.  prescribed forces the boundary\n  atoms to follow the finite element displacement.  coupled does the same.\n  ",
    "syntax": "fix_modify <AtC fixID> boundary_dynamics <on|damped_harmonic|prescribed|coupled|none>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  boundary_dynamics = name of the AtC sub-command\n  on or damped_harmonic prescribed coupled none\n  \n  ",
    "examples": "fix_modify AtC include atomic_charge\n  \n  \n  ",
    "restrictions": "Boundary atoms must be specified.  When using swaps between internal and\n  boundary atoms, the initial configuration must have already correctly\n  partitioned the two.\n  "
},
{
    "command": "fix_modify AtC boundary_faceset",
    "description": "This command species the faceset name when using a faceset to compute\n  the MD/FE boundary fluxes. The faceset must already exist.\n  ",
    "syntax": "fix_modify <AtC fixID> boundary_faceset <is|add> <faceset_name>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  boundary_faceset = name of the AtC sub-command\n  is or add = select whether to select or add a faceset\n  faceset_name = name of the faceset\n  \n  ",
    "examples": "fix_modify AtC boundary_faceset is obndy\n  \n  \n  ",
    "restrictions": "This is only valid when fe_md_boundary is set to faceset.\n  "
},
{
    "command": "fix_modify AtC boundary type",
    "description": "Command to define the atoms that represent the fictitious boundary\n  internal to the FE mesh. For fully overlapped MD/FE domains with\n  periodic boundary conditions no boundary atoms should be defined.\n  ",
    "syntax": "fix_modify <AtC fixID> boundary type <atom-type-id>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  boundary type = name of the AtC sub-command\n  atom-type-id =  type id for atoms that represent a fictitious boundary internal to the FE mesh\n  \n  ",
    "examples": "fix_modify AtC boundary type ghost_atoms\n  \n  \n  ",
    "restrictions": "None.\n  "
},
{
    "command": "fix_modify AtC consistent_fe_initialization",
    "description": "Determines whether AtC initializes FE intrinsic fields (e.g.,\n  temperature) to match the projected MD values. This is particularly\n  useful for fully overlapping simulations.\n  ",
    "syntax": "fix_modify <AtC fixID> consistent_fe_initialization <on|off>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  consistent_fe_initialization = name of the AtC sub-command\n  on or off = switch to activate/deactivate the initial setting of the FE intrinsic field to match the projected MD field\n  \n  ",
    "examples": "fix_modify AtC consistent_fe_initialization on\n  \n  \n  ",
    "restrictions": "Can be used with: thermal, two_temperature.\n  Cannot be used with time filtering on.\n  Does not include boundary nodes.\n  "
},
{
    "command": "fix_modify AtC control localized_lambda",
    "description": "Turns the localization algorithms on or off for control algorithms\n  to restrict the influence of FE coupling or boundary conditions to a\n  region near the boundary of the MD region.  Control algorithms will not\n  affect atoms in elements not possessing faces on the boundary of the\n  region.  Flux-based control is localized via row-sum lumping while\n  quantity control is done by solving a truncated matrix equation.\n  ",
    "syntax": "fix_modify <AtC fixID> control localized_lambda <on|off>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  control localized_lambda = name of the AtC sub-command\n  on or off = Toggles state of localization algorithm\n  \n  ",
    "examples": "fix_modify AtC control localized_lambda on\n  \n  \n  ",
    "restrictions": "None.\n  "
},
{
    "command": "fix_modify AtC control momentum",
    "description": "The general version of control sets the numerical parameters for the\n  matrix solvers used in the specified control algorithm.  Many solution\n  approaches require iterative solvers, and these methods enable users to\n  provide the maximum number of iterations and the relative tolerance.\n  The control momentum version sets the momentum exchange mechanism from\n  the finite elements to the atoms, managed through a control algorithm.\n  rescale computes a scale factor for each atom to match the finite\n  element temperature.  hoover is a Gaussian least-constraint isokinetic\n  thermostat enforces that the nodal restricted atomic temperature matches\n  the finite element temperature.  flux is a similar mode, but rather\n  adds energy to the atoms based on conservation of energy.\n  correction_max_iterations sets the maximum number of iterations to\n  compute the 2nd order in time correction term for lambda with the\n  fractional step method. The method uses the same tolerance as the\n  controller’s matrix solver.\n  ",
    "syntax": "fix_modify <AtC fixID> control <physics_type> <solution_parameter> <value>\n  fix_modify AtC control momentum none\n  fix_modify AtC control momentum rescale <frequency>\n  fix_modify AtC control momentum glc_displacement\n  fix_modify AtC control momentum glc_velocity\n  fix_modify AtC control momentum hoover\n  fix_modify AtC control momentum flux [faceset face_set_id, interpolate]\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  control = name of the AtC sub-command\n  physics_type = thermal or momentum\n  solution_parameter = max_iterations or tolerance\n  value = solution_parameter value\n  momentum option = none or rescale or glc_displacement or glc_velocity hoover or flux\n  frequency = time step frequency for applying displacement and velocity rescaling\n  faceset_id = id of boundary face set (optional, only for faceset)\n  \n  ",
    "examples": "fix_modify AtC control momentum none\n  fix_modify AtC control momentum flux faceset bndy_faces\n  fix_modify AtC control momentum glc_velocity\n  \n  \n  ",
    "restrictions": "Only for be used with the specific controllers thermal or momentum.\n  They are ignored if a lumped solution is requested.\n  control momentum is only for be used with specific transfers: elastic\n  rescale not valid with time filtering activated\n  "
},
{
    "command": "fix_modify AtC control thermal",
    "description": "The general version of control sets the numerical parameters for the\n  matrix solvers used in the specified control algorithm.  Many solution\n  approaches require iterative solvers, and these methods enable users to\n  provide the maximum number of iterations and the relative tolerance.\n  The control thermal version sets the energy exchange mechanism from\n  the finite elements to the atoms, managed through a control algorithm.\n  rescale computes a scale factor for each atom to match the finite\n  element temperature.  hoover is a Gaussian least-constraint isokinetic\n  thermostat enforces that the nodal restricted atomic temperature matches\n  the finite element temperature.  flux is a similar mode, but rather\n  adds energy to the atoms based on conservation of energy. hoover and\n  flux allow the prescription of sources or fixed temperatures on the\n  atoms.\n  correction_max_iterations sets the maximum number of iterations to\n  compute the 2nd order in time correction term for lambda with the\n  fractional step method. The method uses the same tolerance as the\n  controller’s matrix solver.\n  ",
    "syntax": "fix_modify <AtC fixID> control <physics_type> <solution_parameter> <value>\n  fix_modify <AtC fixID> control thermal <control_type> <optional_args>\n  fix_modify <AtC fixID> control thermal rescale <frequency>\n  fix_modify <AtC fixID> control thermal flux <boundary_integration_type> <faceset_id>\n  fix_modify <AtC fixID> control thermal correction_max_iterations <max_iterations>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  control = name of the AtC sub-command\n  physics_type = thermal or momentum\n  solution_parameter = max_iterations or tolerance\n  value = solution_parameter value\n  thermal control_type = none or rescale or hoover or flux\n  frequency = time step frequency for applying velocity rescaling\n  boundary_integration_type = faceset or interpolate (optional)\n  faceset_id = id of boundary face set (optional, only for faceset)\n  correction_max_iterations = maximum number of iterations that will be used by iterative matrix solvers for thermal physics type\n  \n  ",
    "examples": "fix_modify AtC control thermal none\n  fix_modify AtC control thermal rescale 10\n  fix_modify AtC control thermal hoover\n  fix_modify AtC control thermal flux\n  fix_modify AtC control thermal flux faceset bndy_faces\n  fix_modify AtC control thermal correction_max_iterations 10\n  \n  \n  ",
    "restrictions": "Only for be used with the specific controllers thermal or momentum.\n  They are ignored if a lumped solution is requested.\n  control thermal is only for be used with specific transfers: thermal (rescale, hoover, flux), two_temperature (flux).\n  rescale not valid with time filtering activated\n  correction_max_iterations is only for use with thermal physics using\n  the fractional step method.\n  "
},
{
    "command": "fix_modify AtC decomposition",
    "description": "Command for assigning the distribution of work and memory for parallel\n  runs.  With replicated_memory the nodal information is replicated on\n  each processor, and with distributed_memory only the owned nodal\n  information kept on each processor.  The replicated_memory option\n  is most appropriate for simulations were the number of nodes is much\n  smaller than the number of atoms.\n  ",
    "syntax": "fix_modify <AtC fixID> decomposition <type>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  decomposition = name of the AtC sub-command\n  type =  replicated_memory or distributed_memory\n  \n  ",
    "examples": "fix_modify AtC decomposition distributed_memory\n  \n  \n  ",
    "restrictions": "None.\n  "
},
{
    "command": "fix_modify AtC extrinsic electron_integration",
    "description": "Switches between integration schemes for the electron temperature. The\n  number of subcycling steps used to integrate the electron temperature for\n  one LAMMPS timestep can be manually adjusted to capture fast electron\n  dynamics.\n  ",
    "syntax": "fix_modify <AtC fixID> extrinsic electron_integration <integration_type> [<num_subcycle_steps>]\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  extrinsic electron_integration = name of the AtC sub-command\n  integration_type = explicit or implicit or steady\n  num_subcycle_steps = number of subcycle steps for the electron time integration (optional)\n  \n  ",
    "examples": "fix_modify AtC extrinsic electron_integration implicit\n  fix_modify AtC extrinsic electron_integration explicit 100\n  \n  \n  ",
    "restrictions": "For use only with the two_temperature type of the AtC fix (see\n  fix atc command)\n  "
},
{
    "command": "fix_modify AtC equilibrium_start",
    "description": "Starts filtered calculations assuming they start in equilibrium,\n  i.e. perfect finite element force balance.\n  ",
    "syntax": "fix_modify <AtC fixID> equilibrium_start <on|off>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  equilibrium_start = name of the AtC sub-command\n  exponential or step or no_filter = select type of filter\n  \n  ",
    "examples": "fix_modify AtC equilibrium_start on\n  \n  \n  ",
    "restrictions": "Only for use with these specific transfers: thermal, two_temperature\n  "
},
{
    "command": "fix_modify AtC extrinsic exchange",
    "description": "Switches energy exchange between the MD system and the electron system\n  on or off\n  ",
    "syntax": "fix_modify <AtC fixID> extrinsic exchange <on|off>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  extrinsic exchange = name of the AtC sub-command\n  on or off = set state of energy exchange\n  \n  ",
    "examples": "fix_modify AtC extrinsic exchange on\n  \n  \n  ",
    "restrictions": "For use only with the two_temperature type of the AtC fix (see\n  fix atc command)\n  "
},
{
    "command": "fix_modify AtC fe_md_boundary",
    "description": "Specifies different methods for computing fluxes between between the MD\n  and FE integration regions.  Faceset defines a faceset separating the MD\n  and FE regions and uses finite element face quadrature to compute the\n  flux.  Interpolate uses a reconstruction scheme to approximate the flux,\n  which is more robust but less accurate if the MD/FE boundary does\n  correspond to a faceset.  No boundary results in no fluxes between the\n  systems being computed.\n  ",
    "syntax": "fix_modify <AtC fixID> fe_md_boundary <faceset|interpolate|no_boundary>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  fe_md_boundary = name of the AtC sub-command\n  faceset or interpolate or no_boundary\n  \n  ",
    "examples": "fix_modify AtC fe_md_boundary interpolate\n  \n  \n  ",
    "restrictions": "If faceset is used, all the AtC non-boundary atoms must lie within and\n  completely fill the domain enclosed by the faceset.\n  "
},
{
    "command": "fix_modify AtC filter scale",
    "description": "Sets the time scale for MD dynamics filter to construct a more\n  appropriate continuous field.\n  ",
    "syntax": "fix_modify <AtC fixID> filter scale <scale>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  filter scale = name of the AtC sub-command\n  scale = characteristic times scale of the filter\n  \n  ",
    "examples": "fix_modify AtC filter scale 10.0\n  \n  \n  ",
    "restrictions": "Only for use with these specific transfers: thermal, two_temperature\n  "
},
{
    "command": "fix_modify AtC filter type",
    "description": "Specifies the type of time filter used.\n  ",
    "syntax": "fix_modify <AtC fixID> filter type <exponential|step|no_filter>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  filter type = name of the AtC sub-command\n  exponential or step or no_filter = select type of filter\n  \n  ",
    "examples": "fix_modify AtC filter type exponential\n  \n  \n  ",
    "restrictions": "Only for use with these specific transfers: thermal, two_temperature\n  "
},
{
    "command": "fix_modify AtC fix",
    "description": "Creates a constraint on the values of the specified field at specified nodes.\n  ",
    "syntax": "fix_modify <AtC fixID> fix <field> <nodeset> <constant|function>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  fix = name of the AtC sub-command\n  field = field kind name valid for type of physics: temperature or electron_temperature\n  nodeset = name of set of nodes to apply boundary condition\n  constant or function = value or name of function followed by its parameters\n  \n  ",
    "examples": "fix_modify AtC fix temperature groupNAME 10.\n  fix_modify AtC fix temperature groupNAME 0 0 0 10.0 0 0 1.0\n  \n  \n  ",
    "restrictions": "The keyword all is reserved and thus not available as nodeset name.\n  "
},
{
    "command": "fix_modify AtC fix_flux",
    "description": "Command for fixing normal fluxes e.g. heat_flux. This command only\n  prescribes the normal component of the physical flux, e.g. heat (energy)\n  flux. The units are in AtC units, i.e. derived from the LAMMPS length,\n  time, and mass scales.\n  ",
    "syntax": "fix_modify <AtC fixID> fix_flux <field> <face_set> <value|function>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  fix_flux = name of the AtC sub-command\n  field = field kind name valid for type of physics: temperature or electron_temperature\n  face_set = name of set of element faces\n  value or function = value or name of function followed by its parameters\n  \n  ",
    "examples": "fix_modify AtC fix_flux temperature faceSet 10.0\n  \n  \n  ",
    "restrictions": "Only normal fluxes (Neumann data) can be prescribed.\n  "
},
{
    "command": "fix_modify AtC computes",
    "description": "Calculates continuum fields corresponding to specified per-atom\n  computes created by LAMMPS.\n  ",
    "syntax": "fix_modify <AtC fixID> computes <add|delete> <per-atom compute-ID> <volume|number>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  computes = name of the AtC sub-command\n  add or delete = add or delete the calculation of an equivalent continuum field for the specified per-atom compute as volume or number density quantity\n  per-atom compute-ID = ID of a per-atom compute; fields can be calculated for all per-atom computes available in LAMMPS\n  volume or number = select whether the created field is a per-unit-volume quantity or a per-atom quantity as weighted by kernel functions\n  \n  ",
    "examples": "compute virial all stress/atom\n  fix_modify AtC computes add virial volume\n  fix_modify AtC computes delete virial\n  \n  compute centrosymmetry all centro/atom\n  fix_modify AtC computes add centrosymmetry number\n  \n  \n  ",
    "restrictions": "Must be used with fix atc hardy.  The per-atom compute\n  must be specified before the corresponding continuum field can be\n  requested.\n  "
},
{
    "command": "fix_modify AtC fields",
    "description": "Allows modification of the fields calculated and output by the AtC\n  transfer class.  The commands are cumulative, e.g.:\n  fix_modify AtC fields none\n  fix_modify AtC fields add velocity temperature\n  \n  \n  will only output the velocity and temperature fields.\n  ",
    "syntax": "fix_modify <AtC fixID> fields <all|none>\n  fix_modify <AtC fixID> fields <add|delete> <list_of_fields>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  fields = name of the AtC sub-command\n  all or none = output all or no fields\n  add or delete = add or delete the listed output fields\n  list_of_fields = one or more of the fields listed below:\n  \n  density : mass per unit volume\n  displacement : displacement vector\n  momentum : momentum per unit volume\n  velocity : defined by momentum divided by density\n  projected_velocity : simple kernel estimation of atomic velocities\n  temperature : temperature derived from the relative atomic kinetic energy\n  kinetic_temperature : temperature derived from the full kinetic energy\n  number_density : simple kernel estimation of number of atoms per unit volume\n  stress : Cauchy stress tensor for eulerian analysis (atom_element_map), or 1st Piola-Kirchhoff stress tensor for lagrangian analysis\n  transformed_stress : 1st Piola-Kirchhoff stress tensor for eulerian analysis (atom_element_map), or Cauchy stress tensor for lagrangian analysis\n  heat_flux : spatial heat flux vector for eulerian, or referential heat flux vector for lagrangian\n  potential_energy : potential energy per unit volume\n  kinetic_energy : kinetic energy per unit volume\n  thermal_energy : thermal energy (kinetic energy - continuum kinetic energy) per unit volume\n  internal_energy : total internal energy (potential + thermal) per unit volume\n  energy : total energy (potential + kinetic) per unit volume\n  number_density : number of atoms per unit volume\n  eshelby_stress : configurational stress (energy-momentum) tensor defined by [Eshelby]\n  vacancy_concentration : volume fraction of vacancy content\n  type_concentration : volume fraction of a specific atom type\n  \n  \n  \n  ",
    "examples": "fix_modify AtC fields add velocity temperature\n  \n  \n  ",
    "restrictions": "Must be used with fix atc hardy.  Currently, the stress\n  and heat flux formulas are only correct for central force potentials,\n  e.g. Lennard-Jones and EAM but not Stillinger-Weber.\n  "
},
{
    "command": "fix_modify AtC gradients",
    "description": "Requests calculation and output of gradients of the fields from the AtC\n  transfer class.  These gradients will be with regard to spatial or\n  material coordinate for Eulerian or Lagrangian analysis, respectively,\n  as specified by fix_modify AtC atom_element_map\n  ",
    "syntax": "fix_modify <AtC fixID> gradients <add|delete> <list_of_fields>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  gradients = name of the AtC sub-command\n  add or delete = select whether to add or delete calculation of gradients for the listed output fields\n  list_of_fields = one or more of the fields listed below:\n  \n  density : mass per unit volume\n  displacement : displacement vector\n  momentum : momentum per unit volume\n  velocity : defined by momentum divided by density\n  projected_velocity : simple kernel estimation of atomic velocities\n  temperature : temperature derived from the relative atomic kinetic energy\n  kinetic_temperature : temperature derived from the full kinetic energy\n  number_density : simple kernel estimation of number of atoms per unit volume\n  stress : Cauchy stress tensor for eulerian analysis (atom_element_map), or 1st Piola-Kirchhoff stress tensor for lagrangian analysis\n  transformed_stress : 1st Piola-Kirchhoff stress tensor for eulerian analysis (atom_element_map), or Cauchy stress tensor for lagrangian analysis\n  heat_flux : spatial heat flux vector for eulerian, or referential heat flux vector for lagrangian\n  potential_energy : potential energy per unit volume\n  kinetic_energy : kinetic energy per unit volume\n  thermal_energy : thermal energy (kinetic energy - continuum kinetic energy) per unit volume\n  internal_energy : total internal energy (potential + thermal) per unit volume\n  energy : total energy (potential + kinetic) per unit volume\n  number_density : number of atoms per unit volume\n  eshelby_stress : configurational stress (energy-momentum) tensor defined by [Eshelby]\n  vacancy_concentration : volume fraction of vacancy content\n  type_concentration : volume fraction of a specific atom type\n  \n  \n  \n  ",
    "examples": "fix_modify AtC gradients add temperature velocity stress\n  fix_modify AtC gradients delete velocity\n  \n  \n  ",
    "restrictions": "Must be used with fix atc hardy.\n  "
},
{
    "command": "fix_modify AtC kernel",
    "description": "Sets the localization kernel type and parameters for fix atc hardy.\n  ",
    "syntax": "fix_modify <AtC fixID> kernel <type> <parameters>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  kernel = name of the AtC sub-command\n  type = step or cell or cubic_bar or cubic_cylinder or\n  cubic_sphere or quartic_bar or quartic_cylinder or\n  quartic_sphere\n  the following parameter(s) are required for each kernel:\n  \n  step : <radius>\n  cell : <hx> <hy> <hz> or <h>\n  cubic_bar : <half_width>\n  cubic_cylinder : <radius>\n  cubic_sphere : <radius>\n  quartic_bar : <half_width>\n  quartic_cylinder : <radius>\n  quartic_sphere : <radius>\n  \n  \n  \n  ",
    "examples": "fix_modify AtC kernel cell 1.0 1.0 1.0\n  fix_modify AtC kernel quartic_sphere 10.0\n  \n  \n  ",
    "restrictions": "Must be used with fix atc hardy.  For bar kernel types,\n  half-width oriented along x-direction.  For cylinder kernel types,\n  cylindrical axis is assumed to be in z-direction.\n  "
},
{
    "command": "fix_modify AtC on_the_fly",
    "description": "Overrides normal mode of pre-calculating and storing bond pair-to-node a\n  nd kernel atom-to-node matrices. If activated, it will calculate elements\n  of these matrices during repeated calls of field computations\n  (i.e. “on-the-fly”) and not store them for future use.  The on flag is\n  optional - if omitted, on_the_fly will be activated for the specified\n  matrix.  Can be deactivated using the off flag.\n  ",
    "syntax": "fix_modify <AtC fixID> on_the_fly <bond|kernel> <on|off>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  on_the_fly = name of the AtC sub-command\n  bond or kernel = specifies on-the-fly calculation of bond or kernel matrix elements\n  on or off = activate or discontinue on-the-fly mode\n  \n  ",
    "examples": "fix_modify AtC on_the_fly bond on\n  fix_modify AtC on_the_fly kernel\n  fix_modify AtC on_the_fly kernel off\n  \n  \n  ",
    "restrictions": "Must be used with fix atc hardy.\n  "
},
{
    "command": "fix_modify AtC rates",
    "description": "Requests calculation and output of rates (time derivatives) of the\n  fields from the AtC transfer class.  For Eulerian analysis (see\n  fix_modify AtC atom_element_map) these\n  rates are the partial time derivatives of the nodal fields, not the full\n  (material) time derivatives.\n  ",
    "syntax": "fix_modify <AtC fixID> rates <add|delete> <list_of_fields>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  rates = name of the AtC sub-command\n  add or delete = select whether to add or delete calculation of rates for the listed output fields\n  list_of_fields = one or more of the fields listed below:\n  \n  density : mass per unit volume\n  displacement : displacement vector\n  momentum : momentum per unit volume\n  velocity : defined by momentum divided by density\n  projected_velocity : simple kernel estimation of atomic velocities\n  temperature : temperature derived from the relative atomic kinetic energy\n  kinetic_temperature : temperature derived from the full kinetic energy\n  number_density : simple kernel estimation of number of atoms per unit volume\n  stress : Cauchy stress tensor for eulerian analysis (atom_element_map), or 1st Piola-Kirchhoff stress tensor for lagrangian analysis\n  transformed_stress : 1st Piola-Kirchhoff stress tensor for eulerian analysis (atom_element_map), or Cauchy stress tensor for lagrangian analysis\n  heat_flux : spatial heat flux vector for eulerian, or referential heat flux vector for lagrangian\n  potential_energy : potential energy per unit volume\n  kinetic_energy : kinetic energy per unit volume\n  thermal_energy : thermal energy (kinetic energy - continuum kinetic energy) per unit volume\n  internal_energy : total internal energy (potential + thermal) per unit volume\n  energy : total energy (potential + kinetic) per unit volume\n  number_density : number of atoms per unit volume\n  eshelby_stress : configurational stress (energy-momentum) tensor defined by [Eshelby]\n  vacancy_concentration : volume fraction of vacancy content\n  type_concentration : volume fraction of a specific atom type\n  \n  \n  \n  ",
    "examples": "fix_modify AtC rates add temperature velocity stress\n  fix_modify AtC rates delete stress\n  \n  \n  ",
    "restrictions": "Must be used with fix atc hardy.\n  "
},
{
    "command": "fix_modify AtC initial",
    "description": "Sets the initial values for the specified field at the specified nodes.\n  ",
    "syntax": "fix_modify <AtC fixID> initial <field> <nodeset> <constant|function>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  initial = name of the AtC sub-command\n  field = field kind name valid for type of physics: temperature or electron_temperature\n  nodeset = name of set of nodes to apply initial condition\n  constant or function = value or name of function followed by its parameters\n  \n  ",
    "examples": "fix_modify AtC initial temperature groupNAME 10.\n  \n  \n  ",
    "restrictions": "The keyword all is reserved and thus not available as nodeset name.\n  "
},
{
    "command": "fix_modify AtC internal_element_set",
    "description": "Enables AtC to base the region for internal atoms to be an element\n  set. If no ghost atoms are used, all the AtC atoms must be constrained\n  to remain in this element set by the user, e.g., with walls. If boundary\n  atoms are used in conjunction with Eulerian atom maps AtC will partition\n  all atoms of a boundary or internal type to be of type internal if they\n  are in the internal region or to be of type boundary otherwise.\n  ",
    "syntax": "fix_modify <AtC fixID> internal_element_set <element_set_name>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  internal_element_set = name of the AtC sub-command\n  element_set_name = name of element set defining internal region, or off\n  \n  ",
    "examples": "fix_modify AtC internal_element_set myElementSet\n  fix_modify AtC internal_element_set off\n  \n  \n  ",
    "restrictions": "If boundary atoms are used in conjunction with Eulerian atom maps, the\n  Eulerian reset frequency must be an integer multiple of the Lammps\n  reneighbor frequency.\n  "
},
{
    "command": "fix_modify AtC kernel_bandwidth",
    "description": "Sets a maximum parallel bandwidth for the kernel functions during\n  parallel communication. If the command is not issued, the default will\n  be to assume the bandwidth of the kernel matrix corresponds to the\n  number of sampling locations.\n  ",
    "syntax": "fix_modify <AtC fixID> kernel_bandwidth <value>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  kernel_bandwidth = name of the AtC sub-command\n  value = new bandwidth value\n  \n  ",
    "examples": "fix_modify AtC kernel_bandwidth 8\n  \n  \n  ",
    "restrictions": "Only is used if kernel functions are being used.\n  "
},
{
    "command": "fix_modify AtC control lumped_lambda_solve",
    "description": "Command select whether to use or not use lumped matrix for lambda solve.\n  ",
    "syntax": "fix_modify <AtC fixID> control lumped_lambda_solve <on|off>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  control lumped_lambda_solve = name of the AtC sub-command\n  on or off = Toggles state of lumped matrix\n  \n  ",
    "examples": "fix_modify AtC control lumped_lambda_solve on\n  \n  \n  ",
    "restrictions": "None.\n  "
},
{
    "command": "fix_modify AtC control mask_direction",
    "description": "Command to mask out certain dimensions from the atomic regulator\n  ",
    "syntax": "fix_modify <AtC fixID> control mask_direction <direction> <on|off>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  control mask_direction = name of the AtC sub-command\n  direction = select direction\n  on or off = Toggles state\n  \n  ",
    "examples": "fix_modify AtC control mask_direction 0 on\n  \n  \n  ",
    "restrictions": "None.\n  "
},
{
    "command": "fix_modify AtC mass_matrix",
    "description": "Determines whether AtC uses the FE mass matrix based on Gaussian\n  quadrature or based on atomic quadrature in the MD region. This is\n  useful for fully overlapping simulations to improve efficiency.\n  ",
    "syntax": "fix_modify <AtC fixID> mass_matrix <fe|md_fe>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  mass_matrix = name of the AtC sub-command\n  fe or md_fe = activate/deactivate using the FE mass matrix in the MD region\n  \n  ",
    "examples": "fix_modify AtC mass_matrix fe\n  \n  \n  ",
    "restrictions": "Should not be used unless the FE region is contained within the MD\n  region, otherwise the method will be unstable and inaccurate.\n  "
},
{
    "command": "fix_modify AtC material",
    "description": "Sets the material model in elementset_name to be of type material_id.\n  ",
    "syntax": "fix_modify <AtC fixID> material <elementset_name> <material_id>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  material = name of the AtC sub-command\n  elementset_name = name of the elementset\n  material_id = ID of the material\n  \n  ",
    "examples": "fix_modify AtC material gap_region 1\n  \n  \n  ",
    "restrictions": "The element set must already be created and the material must be\n  specified in the material file given the the atc fix on construction\n  "
},
{
    "command": "fix_modify AtC mesh add_to_nodeset",
    "description": "Command to add nodes to an already existing FE nodeset.\n  ",
    "syntax": "fix_modify <AtC fixID> mesh add_to_nodeset <id> <xmin> <xmax> <ymin> <ymax> <zmin> <zmax>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  mesh create_nodeset = name of the AtC sub-command\n  id = id to assign to the collection of FE nodes\n  <xmin> <xmax> <ymin> <ymax> <zmin> <zmax> = coordinates of the bounding box that contains the desired nodes to be added\n  \n  ",
    "examples": "fix_modify AtC mesh add_to_nodeset lbc -12.1 -11.9 -12 12 -12 12\n  \n  \n  ",
    "restrictions": "None\n  "
},
{
    "command": "fix_modify AtC mesh create",
    "description": "Creates a uniform mesh in a rectangular region.\n  ",
    "syntax": "fix_modify <AtC fixID> mesh create <nx> <ny> <nz> <region-ID> <f|p> <f|p> <f|p>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  mesh create = name of the AtC sub-command\n  nx ny nz = number of elements in x-, y-, and z-direction\n  region-ID = ID of region that is to be meshed\n  f or p = periodicity flags for x-, y-, and z-direction\n  \n  ",
    "examples": "fix_modify AtC mesh create 10 1 1 feRegion p p p\n  \n  \n  ",
    "restrictions": "Creates only uniform rectangular grids in a rectangular region\n  "
},
{
    "command": "fix_modify AtC mesh create_elementset",
    "description": "Command to assign an id to a set of FE elements to be used subsequently\n  in defining material and mesh-based operations.\n  ",
    "syntax": "fix_modify <AtC fixID> mesh create_elementset <id> <xmin> <xmax> <ymin> <ymax> <zmin> <zmax>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  mesh create_elementset = name of the AtC sub-command\n  id = id to assign to the collection of FE nodes\n  <xmin> <xmax> <ymin> <ymax> <zmin> <zmax> = coordinates of the bounding box that contains only the desired elements\n  \n  ",
    "examples": "fix_modify AtC mesh create_elementset middle -4.1 4.1 -100 100 -100 1100\n  \n  \n  ",
    "restrictions": "Only viable for rectangular grids.\n  "
},
{
    "command": "fix_modify AtC mesh create_faceset box",
    "description": "Command to assign an id to a set of FE faces.\n  ",
    "syntax": "fix_modify <AtC fixID> mesh create_faceset <id> box <xmin> <xmax> <ymin> <ymax> <zmin> <zmax> <in|out> [units]\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  mesh create_faceset = name of the AtC sub-command\n  id = id to assign to the collection of FE faces\n  box = use bounding box to define FE faces\n  <xmin> <xmax> <ymin> <ymax> <zmin> <zmax> = coordinates of the bounding box that is coincident with the desired FE faces\n  <in|out> = “in” gives inner faces to the box, “out” gives the outer faces to the box\n  units = option to specify real as opposed to lattice units\n  \n  ",
    "examples": "fix_modify AtC mesh create_faceset obndy box -4.0 4.0 -12 12 -12 12 out\n  \n  \n  ",
    "restrictions": "Only viable for rectangular grids.\n  "
},
{
    "command": "fix_modify AtC mesh create_faceset plane",
    "description": "Command to assign an id to a set of FE faces.\n  ",
    "syntax": "fix_modify <AtC fixID> mesh create_faceset <id> plane <x|y|z> <val1> <x|y|z> <lval2> <uval2> [units]\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  mesh create_faceset = name of the AtC sub-command\n  id = id to assign to the collection of FE faces\n  plane = use plane to define faceset\n  <val1>,<lval2>,<uval2> = plane is specified as the x|y|z=val1 plane bounded by the segments x|y|z = [lval2,uval2]\n  units = option to specify real as opposed to lattice units\n  \n  ",
    "examples": "fix_modify AtC mesh create_faceset xyplane plane y 0 x -4 0\n  \n  \n  ",
    "restrictions": "Only viable for rectangular grids.\n  "
},
{
    "command": "fix_modify AtC mesh create_nodeset",
    "description": "Command to assign an id to a set of FE nodes to be used subsequently in\n  defining boundary conditions.\n  ",
    "syntax": "fix_modify <AtC fixID> mesh create_nodeset <id> <xmin> <xmax> <ymin> <ymax> <zmin> <zmax>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  mesh create_nodeset = name of the AtC sub-command\n  id = id to assign to the collection of FE nodes\n  <xmin> <xmax> <ymin> <ymax> <zmin> <zmax> = coordinates of the bounding box that contains only the desired nodes\n  \n  ",
    "examples": "fix_modify AtC mesh create_nodeset lbc -12.1 -11.9 -12 12 -12 12\n  \n  \n  ",
    "restrictions": "None\n  "
},
{
    "command": "fix_modify AtC mesh delete_elements",
    "description": "Deletes a group of elements from the mesh.\n  ",
    "syntax": "fix_modify <AtC fixID> mesh delete_elements <id>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  mesh create_elementset = name of the AtC sub-command\n  id = id of the element set\n  \n  ",
    "examples": "fix_modify AtC mesh delete_elements gap\n  \n  \n  ",
    "restrictions": "None.\n  "
},
{
    "command": "fix_modify AtC mesh nodeset_to_elementset",
    "description": "Command to create an elementset from an existing nodeset. Either the\n  minimal element set of elements with all nodes in the set, or maximal\n  element set with all elements with at least one node in the set, can be\n  created.\n  ",
    "syntax": "fix_modify <AtC fixID> mesh nodeset_to_elementset <nodeset_id> <elementset_id> <max/min>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  mesh nodeset_to_elementset = name of the AtC sub-command\n  nodeset_id = id of desired nodeset from which to create the elementset\n  elementset_id = id to assign to the collection of FE elements\n  <max/min> = flag to choose either the maximal or minimal elementset\n  \n  ",
    "examples": "fix_modify AtC mesh nodeset_to_elementset myNodeset myElementset min\n  \n  \n  ",
    "restrictions": "None.\n  "
},
{
    "command": "fix_modify AtC mesh output",
    "description": "Command to output mesh and associated data: nodesets, facesets, and\n  elementsets. This data is only output once upon initialization since\n  currently the mesh is static. Creates binary (EnSight, “gold” format)\n  output of mesh data.\n  ",
    "syntax": "fix_modify <AtC fixID> mesh output <file_prefix>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  mesh output = name of the AtC sub-command\n  file_prefix = prefix of various generated output files\n  \n  ",
    "examples": "fix_modify AtC mesh output meshData\n  \n  \n  ",
    "restrictions": "None.\n  "
},
{
    "command": "fix_modify AtC mesh quadrature",
    "description": "(Re-)assigns the quadrature style for an existing mesh.  When a mesh is\n  created its quadrature method defaults to gauss2.  Use this call to\n  change it after the fact.\n  ",
    "syntax": "fix_modify <AtC fixID> mesh quatrature <quad>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  mesh quadrature = name of the AtC sub-command\n  quad = nodal or gauss1 or gauss2 or gauss3 or face\n  \n  ",
    "examples": "fix_modify AtC mesh quadrature face\n  \n  \n  ",
    "restrictions": "None.\n  "
},
{
    "command": "fix_modify AtC mesh read",
    "description": "Reads a mesh from a text or exodus file, and assigns periodic boundary\n  conditions if needed.\n  ",
    "syntax": "fix_modify <AtC fixID> mesh read <f|p> <f|p> <f|p>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  mesh read = name of the AtC sub-command\n  filename = name of the file containing the mesh to be read\n  f or p = periodicity flags for x-, y-, and z-direction (optional)\n  \n  ",
    "examples": "fix_modify AtC mesh read myComponent.mesh p p p\n  fix_modify AtC mesh read myOtherComponent.exo\n  \n  \n  ",
    "restrictions": "None\n  "
},
{
    "command": "fix_modify AtC mesh write",
    "description": "Writes a mesh to a text file.\n  ",
    "syntax": "fix_modify <AtC fixID> mesh write <f|p> <f|p> <f|p>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  mesh write = name of the AtC sub-command\n  filename = name of the file containing the mesh to be write\n  \n  ",
    "examples": "fix_modify AtC mesh write myMesh.mesh\n  \n  \n  ",
    "restrictions": "None\n  "
},
{
    "command": "fix_modify AtC output",
    "description": "Creates text and/or binary (EnSight, “gold” format) output of nodal/mesh\n  data which is transfer/physics specific. Output indexing by step or time\n  is possible.\n  ",
    "syntax": "fix_modify <AtC fixID> output <filename_prefix> <frequency> [text|full_text|binary|vector_components|tensor_components]\n  fix_modify <AtC fixID> output index [step|time]\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  output or output index = name of the AtC sub-command\n  filename_prefix = prefix for data files (for output)\n  frequency = frequency of output in time-steps (for output)\n  optional keywords for output:\n  \n  text = creates text output of index, step and nodal variable values for unique nodes\n  full_text = creates text output index, nodal id, step, nodal coordinates and nodal variable values for unique and image nodes\n  binary = creates binary EnSight output\n  vector_components = outputs vectors as scalar components\n  tensor_components = outputs tensor as scalar components (for use with ParaView)\n  \n  \n  step or time = index output by step or by time (for output index)\n  \n  ",
    "examples": "fix_modify AtC output heatFE 100\n  fix_modify AtC output hardyFE 1 text tensor_components\n  fix_modify AtC output hardyFE 10 text binary tensor_components\n  fix_modify AtC output index step\n  \n  \n  ",
    "restrictions": "None.\n  "
},
{
    "command": "fix_modify AtC output boundary_integral",
    "description": "Calculates a surface integral of the given field dotted with the outward\n  normal of the faces and puts output in the “GLOBALS” file.\n  ",
    "syntax": "fix_modify <AtC fixID> output boundary_integral <fieldname> faceset [name]\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  output boundary_integral = name of the AtC sub-command\n  fieldname = name of hardy field\n  faceset = required keyword\n  name= name of faceset\n  \n  ",
    "examples": "fix_modify AtC output boundary_integral stress faceset loop1\n  \n  \n  ",
    "restrictions": "Must be used with the hardy/field type of fix atc\n  "
},
{
    "command": "fix_modify AtC output contour_integral",
    "description": "Calculates a surface integral of the given field dotted with the outward\n  normal of the faces and puts output in the “GLOBALS” file.\n  ",
    "syntax": "fix_modify <AtC fixID> output contour_integral <fieldname> faceset <name> [axis [x|y|z]]\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  output contour_integral = name of the AtC sub-command\n  fieldname = name of hardy field\n  faceset = required keyword\n  name = name of faceset\n  axis x or axis y or axis z = (optional)\n  \n  ",
    "examples": "fix_modify AtC output contour_integral stress faceset loop1\n  \n  \n  ",
    "restrictions": "Must be used with the hardy/field type of fix atc\n  "
},
{
    "command": "fix_modify AtC output nodeset",
    "description": "Performs operation over the nodes belonging to specified nodeset and\n  outputs resulting variable values to GLOBALS file.\n  ",
    "syntax": "fix_modify <AtC fixID> output nodeset <nodeset_name> <operation>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  output nodeset = name of the AtC sub-command\n  nodeset_name= name of nodeset to be operated on\n  operation = sum\n  \n  sum = creates nodal sum over nodes in specified nodeset\n  \n  \n  \n  ",
    "examples": "fix_modify AtC output nodeset nset1 sum\n  \n  \n  ",
    "restrictions": "None.\n  "
},
{
    "command": "fix_modify AtC output volume_integral",
    "description": "Performs volume integration of specified field over elementset and\n  outputs resulting variable values to GLOBALS file.\n  ",
    "syntax": "fix_modify <AtC fixID> output volume_integral <elementset_name> <field>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  output volume_integral = name of the AtC sub-command\n  elementset_name= name of elementset to be integrated over\n  fieldname = name of field to integrate\n  \n  ",
    "examples": "fix_modify AtC output volume_integral eset1 mass_density\n  \n  \n  ",
    "restrictions": "None.\n  "
},
{
    "command": "fix_modify AtC pair_interactions",
    "description": "Include bonds and/or pairs in stress and heat flux computations.\n  ",
    "syntax": "fix_modify <AtC fixID> pair_interactions <on|off>\n  fix_modify <AtC fixID> bond_interactions <on|off>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  pair_interactions or bond_interactions = name of the AtC sub-command\n  on or off = activate or deactivate\n  \n  ",
    "examples": "fix_modify AtC pair_interactions off\n  fix_modify AtC bond_interactions on\n  \n  \n  ",
    "restrictions": "None.\n  "
},
{
    "command": "fix_modify AtC poisson_solver",
    "description": "Creates a uniform mesh in a rectangular region.\n  ",
    "syntax": "fix_modify <AtC fixID> poisson_solver mesh create <nx> <ny> <nz> <region-ID> <f|p> <f|p> <f|p>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  poisson_solver = name of the AtC sub-command\n  nx ny nz = number of elements in x, y, and z\n  region-id = id of region to be meshed\n  f or p = periodicity flags for x, y, and z\n  \n  ",
    "examples": "fix_modify AtC poisson_solver mesh create 10 1 1 feRegion p p p\n  \n  \n  ",
    "restrictions": "Creates only uniform rectangular grids in rectangular regions.\n  "
},
{
    "command": "fix_modify AtC read_restart",
    "description": "Reads the current state of the AtC fields from a named text-based restart file.\n  ",
    "syntax": "fix_modify <AtC fixID> read_restart <file_name>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  read_restart = name of the AtC sub-command\n  file_name = name of AtC restart file\n  \n  ",
    "examples": "fix_modify AtC read_restart restart.mydata.AtC\n  \n  \n  ",
    "restrictions": "The restart file only contains fields and their time derivatives.  The\n  reference positions of the atoms and the commands that initialize the\n  fix are not saved e.g. an identical mesh containing the same atoms will\n  have to be recreated.\n  "
},
{
    "command": "fix_modify AtC remove_molecule",
    "description": "Removes tag designated for tracking a specified set of molecules.\n  ",
    "syntax": "fix_modify <AtC fixID> remove_molecule <tag>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  remove_molecule = name of the AtC sub-command\n  tag = tag for tracking a molecule\n  \n  ",
    "examples": "fix_modify AtC remove_molecule water\n  \n  \n  ",
    "restrictions": "None.\n  "
},
{
    "command": "fix_modify AtC remove_source",
    "description": "Remove a domain source.\n  ",
    "syntax": "fix_modify <AtC fixID> remove_source <field> <element_set>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  remove_source = name of the AtC sub-command\n  field = field kind name valid for type of physics: temperature or electron_temperature\n  element_set = name of set of elements\n  \n  ",
    "examples": "fix_modify AtC remove_source temperature groupNAME\n  \n  \n  ",
    "restrictions": "The keyword all is reserved and thus not available as element_set name.\n  "
},
{
    "command": "fix_modify AtC reset_atomic_reference_positions",
    "description": "Resets the atomic positions ATC uses to perform point to field\n  operations. In can be used to use perfect lattice sites in ATC but a\n  thermalized or deformed lattice in LAMMPS.\n  ",
    "syntax": "fix_modify <AtC fixID> reset_atomic_reference_positions\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  reset_atomic_reference_positions = name of the AtC sub-command\n  \n  ",
    "examples": "fix_modify AtC reset_atomic_reference_positions\n  \n  \n  ",
    "restrictions": "None.\n  "
},
{
    "command": "fix_modify AtC reset_time",
    "description": "Resets the simulation time counter.\n  ",
    "syntax": "fix_modify <AtC fixID> reset_time <value>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  reset_time = name of the AtC sub-command\n  value = new time value\n  \n  ",
    "examples": "fix_modify AtC reset_time 0.0\n  \n  \n  ",
    "restrictions": "None.\n  "
},
{
    "command": "fix_modify AtC sample_frequency",
    "description": "Specifies a frequency at which fields are computed for the case where\n  time filters are being applied.\n  ",
    "syntax": "fix_modify <AtC fixID> sample_frequency <freq>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  sample_frequency = name of the AtC sub-command\n  freq = frequency to sample fields in number of steps\n  \n  ",
    "examples": "fix_modify AtC sample_frequency 10\n  \n  \n  ",
    "restrictions": "Must be used with fix atc hardy and is only relevant when time filters are being used.\n  "
},
{
    "command": "fix_modify AtC set reference_potential_energy",
    "description": "Used to set various quantities for the post-processing algorithms. It\n  sets the zero point for the potential energy density using the value\n  provided for all nodes, or from the current configuration of the lattice\n  if no value is provided, or values provided within the specified\n  filename.\n  ",
    "syntax": "fix_modify <AtC fixID> set reference_potential_energy [<value|filename>]\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  set reference_potential_energy = name of the AtC sub-command\n  value = optional user specified zero point for PE in native LAMMPS energy units\n  filename = optional user specified string for file of nodal PE values to be read-in\n  \n  ",
    "examples": "fix_modify AtC set reference_potential_energy\n  fix_modify AtC set reference_potential_energy -0.05\n  fix_modify AtC set reference_potential_energy myPEvalues\n  \n  \n  ",
    "restrictions": "Must be used with fix atc hardy or fix atc field.\n  "
},
{
    "command": "fix_modify AtC source",
    "description": "Add domain sources to the mesh. The units are consistent with LAMMPS’s\n  units for mass, length and time and are defined by the PDE being solved,\n  e.g. for thermal transfer the balance equation is for energy and source\n  is energy per time.\n  ",
    "syntax": "fix_modify <AtC fixID> source <field> <element_set> <value|function>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  source = name of the AtC sub-command\n  field = field kind name valid for type of physics: temperature or electron_temperature\n  element_set = name of set of elements\n  value or function = value or name of function followed by its parameters\n  \n  ",
    "examples": "fix_modify AtC source temperature middle temporal_ramp 10.0 0.0\n  \n  \n  ",
    "restrictions": "The keyword all is reserved and thus not available as element_set name.\n  "
},
{
    "command": "fix_modify AtC source_integration",
    "description": "(undocumented)\n  ",
    "syntax": "fix_modify <AtC fixID> source_integration <fe|atom>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  source_integration = name of the AtC sub-command\n  fe or atom = (undocumented)\n  \n  ",
    "examples": "fix_modify AtC source_integration atom\n  \n  \n  ",
    "restrictions": "None.\n  "
},
{
    "command": "fix_modify AtC temperature_definition",
    "description": "Change the definition for the atomic temperature used to create the\n  finite element temperature.  The kinetic option is based only on the\n  kinetic energy of the atoms while the total option uses the total energy\n  (kinetic + potential) of an atom.\n  ",
    "syntax": "fix_modify <AtC fixID> temperature_definition <kinetic|total>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  temperature_definition = name of the AtC sub-command\n  kinetic or total = (undocumented)\n  \n  ",
    "examples": "fix_modify AtC temperature_definition kinetic\n  \n  \n  ",
    "restrictions": "This command is only valid when using thermal coupling.  Also, while not\n  a formal restriction, the user should ensure that associating a\n  potential energy with each atom makes physical sense for the total\n  option to be meaningful.\n  "
},
{
    "command": "fix_modify AtC filter",
    "description": "Filters the MD dynamics to construct a more appropriate continuous\n  field. Equilibrating first filters the time derivatives without changing\n  the dynamics to provide a better initial condition to the filtered\n  dynamics.\n  ",
    "syntax": "fix_modify <AtC fixID> filter <on|off|equilibrate>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  filter = name of the AtC sub-command\n  on or off or equilibrate = Select state of filter\n  \n  ",
    "examples": "fix_modify AtC filter on\n  \n  \n  ",
    "restrictions": "Only for use with these specific transfers: thermal, two_temperature\n  "
},
{
    "command": "fix_modify AtC time_integration",
    "description": "Command to select the thermal or momentum time integration.\n  \n  Options for thermal time integration:\n  \n  gearatomic velocity update with 2nd order Verlet, nodal temperature update\n  with 3rd or 4th order Gear, thermostats based on controlling power\n  \n  fractional_stepatomic velocity update with 2nd order Verlet, mixed nodal temperature\n  update, 3/4 Gear for continuum and 2 Verlet for atomic contributions,\n  thermostats based on controlling discrete energy changes\n  \n  \n  \n  Options for momentum time integration:\n  \n  verletatomic velocity update with 2nd order Verlet, nodal temperature update\n  with 2nd order Verlet, kinetostats based on controlling force\n  \n  fractional_stepatomic velocity update with 2nd order Verlet, mixed nodal momentum\n  update, 2nd order Verlet for continuum and exact 2nd order Verlet for\n  atomic contributions, kinetostats based on controlling discrete\n  momentum changes\n  \n  gearatomic velocity update with 2nd order Verlet, nodal temperature update\n  with 3rd or 4th order Gear, kinetostats based on controlling power.\n  \n  \n  ",
    "syntax": "fix_modify <AtC fixID> time_integration <descriptor>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  time_integration = name of the AtC sub-command\n  descriptor =  gear or fractional_step or verlet\n  \n  ",
    "examples": "fix_modify AtC time_integration fractional_step\n  \n  \n  ",
    "restrictions": "None.\n  "
},
{
    "command": "fix_modify AtC track_displacement",
    "description": "Determines whether displacement is tracked or not. For solids problems\n  this is a useful quantity, but for fluids it is not relevant.\n  ",
    "syntax": "fix_modify <AtC fixID> track_displacement <on|off>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  track_displacement = name of the AtC sub-command\n  on or off = (undocumented)\n  \n  ",
    "examples": "fix_modify AtC track_displacement on\n  \n  \n  ",
    "restrictions": "Some constitutive models require the displacement field.\n  "
},
{
    "command": "fix_modify AtC unfix",
    "description": "Removes constraint on field values for specified nodes.\n  ",
    "syntax": "fix_modify <AtC fixID> unfix <field> <nodeset>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  unfix = name of the AtC sub-command\n  field = field kind name valid for type of physics: temperature or electron_temperature\n  nodeset = name of set of nodes to apply boundary condition\n  \n  ",
    "examples": "fix_modify AtC unfix temperature groupNAME\n  \n  \n  ",
    "restrictions": "The keyword all is reserved and thus not available as nodeset name.\n  "
},
{
    "command": "fix_modify AtC unfix_flux",
    "description": "Command for removing prescribed normal fluxes e.g. heat_flux, stress.\n  ",
    "syntax": "fix_modify <AtC fixID> unfix_flux <field> <face_set> <value|function>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  unfix_flux = name of the AtC sub-command\n  field = field kind name valid for type of physics: temperature or electron_temperature\n  face_set = name of set of element faces\n  \n  ",
    "examples": "fix_modify AtC unfix_flux temperature faceSet\n  \n  \n  ",
    "restrictions": "None.\n  "
},
{
    "command": "fix_modify AtC write_atom_weights",
    "description": "Command for writing the values of atomic weights to a specified file.\n  ",
    "syntax": "fix_modify <AtC fixID> write_atom_weights <filename> <frequency>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  write_atom_weights = name of the AtC sub-command\n  filename = name of file that atomic weights are written to\n  frequency = how often writes will occur\n  \n  ",
    "examples": "fix_modify AtC write_atom_weights atm_wt_file.txt 10\n  \n  \n  ",
    "restrictions": "None.\n  "
},
{
    "command": "fix_modify AtC write_restart",
    "description": "Dumps the current state of the fields to a named text-based restart\n  file.  This done when the command is invoked and not repeated, unlike\n  the otherwise similar LAMMPS command.\n  ",
    "syntax": "fix_modify <AtC fixID> write_restart <file_name>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  write_restart = name of the AtC sub-command\n  file_name = name of AtC restart file\n  \n  ",
    "examples": "fix_modify AtC write_restart restart.mydata.AtC\n  \n  \n  ",
    "restrictions": "None.\n  "
},
{
    "command": "fix_modify AtC remove_species",
    "description": "Removes tag designated for tracking a specified species.\n  ",
    "syntax": "fix_modify <AtC fixID> remove_species <tag>\n  \n  \n  \n  AtC fixID = ID of fix atc instance\n  remove_species = name of the AtC sub-command\n  tag = tag for tracking a species\n  \n  ",
    "examples": "fix_modify AtC remove_species gold\n  \n  \n  ",
    "restrictions": "None.\n  "
},
{
    "command": "dump image",
    "description": "Dump a high-quality rendered image of the atom configuration every N\n  timesteps and save the images either as a sequence of JPEG or PNG or\n  PPM files, or as a single movie file.  The options for this command as\n  well as the dump_modify command control what is\n  included in the image or movie and how it appears.  A series of such\n  images can easily be manually converted into an animated movie of your\n  simulation or the process can be automated without writing the\n  intermediate files using the dump movie style; see further details\n  below.  Other dump styles store snapshots of numerical data associated\n  with atoms in various formats, as discussed on the dump\n  doc page.\n  Note that a set of images or a movie can be made after a simulation\n  has been run, using the rerun command to read snapshots\n  from an existing dump file, and using these dump commands in the rerun\n  script to generate the images/movie.\n  Here are two sample images, rendered as 1024x1024 JPEG files.\n  Click to see the full-size images: \n  Only atoms in the specified group are rendered in the image.  The\n  dump_modify region and thresh commands can also\n  alter what atoms are included in the image.\n  The filename suffix determines whether a JPEG, PNG, or PPM file is\n  created with the image dump style.  If the suffix is “.jpg” or\n  “.jpeg”, then a JPEG format file is created, if the suffix is “.png”,\n  then a PNG format is created, else a PPM (aka NETPBM) format file is\n  created.  The JPEG and PNG files are binary; PPM has a text mode\n  header followed by binary data. JPEG images have lossy compression;\n  PNG has lossless compression; and PPM files are uncompressed but can\n  be compressed with gzip, if LAMMPS has been compiled with\n  -DLAMMPS_GZIP and a “.gz” suffix is used.\n  Similarly, the format of the resulting movie is chosen with the\n  movie dump style. This is handled by the underlying FFmpeg converter\n  and thus details have to be looked up in the FFmpeg documentation.\n  Typical examples are: .avi, .mpg, .m4v, .mp4, .mkv, .flv, .mov, .gif\n  Additional settings of the movie compression like bitrate and\n  framerate can be set using the dump_modify command.\n  To write out JPEG and PNG format files, you must build LAMMPS with\n  support for the corresponding JPEG or PNG library. To convert images\n  into movies, LAMMPS has to be compiled with the -DLAMMPS_FFMPEG\n  flag. See the Build settings doc page for\n  details.\n  \n  Note\n  Because periodic boundary conditions are enforced only on\n  timesteps when neighbor lists are rebuilt, the coordinates of an atom\n  in the image may be slightly outside the simulation box.\n  \n  \n  Dumps are performed on timesteps that are a multiple of N (including\n  timestep 0) and on the last timestep of a minimization if the\n  minimization converges.  Note that this means a dump will not be\n  performed on the initial timestep after the dump command is invoked,\n  if the current timestep is not a multiple of N.  This behavior can be\n  changed via the dump_modify first command, which\n  can be useful if the dump command is invoked after a minimization\n  ended on an arbitrary timestep.  N can be changed between runs by\n  using the dump_modify every command.\n  Dump image filenames must contain a wildcard character “*”, so that\n  one image file per snapshot is written.  The “*” character is replaced\n  with the timestep value.  For example, tmp.dump.*.jpg becomes\n  tmp.dump.0.jpg, tmp.dump.10000.jpg, tmp.dump.20000.jpg, etc.  Note\n  that the dump_modify pad command can be used to\n  insure all timestep numbers are the same length (e.g. 00010), which\n  can make it easier to convert a series of images into a movie in the\n  correct ordering.\n  Dump movie filenames on the other hand, must not have any wildcard\n  character since only one file combining all images into a single\n  movie will be written by the movie encoder.\n  \n  The color and diameter settings determine the color and size of\n  atoms rendered in the image.  They can be any atom attribute defined\n  for the dump custom command, including type and\n  element.  This includes per-atom quantities calculated by a\n  compute, fix, or variable,\n  which are prefixed by “c_”, “f_”, or “v_” respectively.  Note that the\n  diameter setting can be overridden with a numeric value applied to\n  all atoms by the optional adiam keyword.\n  If type is specified for the color setting, then the color of each\n  atom is determined by its atom type.  By default the mapping of types\n  to colors is as follows:\n  \n  type 1 = red\n  type 2 = green\n  type 3 = blue\n  type 4 = yellow\n  type 5 = aqua\n  type 6 = cyan\n  \n  and repeats itself for types > 6.  This mapping can be changed by the\n  dump_modify acolor command.\n  If type is specified for the diameter setting then the diameter of\n  each atom is determined by its atom type.  By default all types have\n  diameter 1.0.  This mapping can be changed by the dump_modify adiam command.\n  If element is specified for the color and/or diameter setting,\n  then the color and/or diameter of each atom is determined by which\n  element it is, which in turn is specified by the element-to-type\n  mapping specified by the “dump_modify element” command.  By default\n  every atom type is C (carbon).  Every element has a color and diameter\n  associated with it, which is the same as the colors and sizes used by\n  the AtomEye visualization package.\n  If other atom attributes are used for the color or diameter\n  settings, they are interpreted in the following way.\n  If “vx”, for example, is used as the color setting, then the color\n  of the atom will depend on the x-component of its velocity.  The\n  association of a per-atom value with a specific color is determined by\n  a “color map”, which can be specified via the\n  dump_modify command.  The basic idea is that the\n  atom-attribute will be within a range of values, and every value\n  within the range is mapped to a specific color.  Depending on how the\n  color map is defined, that mapping can take place via interpolation so\n  that a value of -3.2 is halfway between “red” and “blue”, or\n  discretely so that the value of -3.2 is “orange”.\n  If “vx”, for example, is used as the diameter setting, then the atom\n  will be rendered using the x-component of its velocity as the\n  diameter.  If the per-atom value <= 0.0, them the atom will not be\n  drawn.  Note that finite-size spherical particles, as defined by\n  atom_style sphere define a per-particle radius or\n  diameter, which can be used as the diameter setting.\n  \n  The various keywords listed above control how the image is rendered.\n  As listed below, all of the keywords have defaults, most of which you\n  will likely not need to change.  The dump modify\n  also has options specific to the dump image style, particularly for\n  assigning colors to atoms, bonds, and other image features.\n  \n  The atom keyword allow you to turn off the drawing of all atoms, if\n  the specified value is no.  Note that this will not turn off the\n  drawing of particles that are represented as lines, triangles, or\n  bodies, as discussed below.  These particles can be drawn separately\n  if the line, tri, or body keywords are used.\n  The adiam keyword allows you to override the diameter setting to\n  set a single numeric size.  All atoms will be drawn with that\n  diameter, e.g. 1.5, which is in whatever distance units\n  the input script defines, e.g. Angstroms.\n  \n  The bond keyword allows to you to alter how bonds are drawn.  A bond\n  is only drawn if both atoms in the bond are being drawn due to being\n  in the specified group and due to other selection criteria\n  (e.g. region, threshold settings of the\n  dump_modify command).  By default, bonds are drawn\n  if they are defined in the input data file as read by the\n  read_data command.  Using none for both the bond\n  color and width value will turn off the drawing of all bonds.\n  If atom is specified for the bond color value, then each bond is\n  drawn in 2 halves, with the color of each half being the color of the\n  atom at that end of the bond.\n  If type is specified for the color value, then the color of each\n  bond is determined by its bond type.  By default the mapping of bond\n  types to colors is as follows:\n  \n  type 1 = red\n  type 2 = green\n  type 3 = blue\n  type 4 = yellow\n  type 5 = aqua\n  type 6 = cyan\n  \n  and repeats itself for bond types > 6.  This mapping can be changed by\n  the dump_modify bcolor command.\n  The bond width value can be a numeric value or atom or type (or\n  none as indicated above).\n  If a numeric value is specified, then all bonds will be drawn as\n  cylinders with that diameter, e.g. 1.0, which is in whatever distance\n  units the input script defines, e.g. Angstroms.\n  If atom is specified for the width value, then each bond\n  will be drawn with a width corresponding to the minimum diameter\n  of the 2 atoms in the bond.\n  If type is specified for the width value then the diameter of each\n  bond is determined by its bond type.  By default all types have\n  diameter 0.5.  This mapping can be changed by the dump_modify bdiam command.\n  \n  The line keyword can be used when atom_style line\n  is used to define particles as line segments, and will draw them as\n  lines.  If this keyword is not used, such particles will be drawn as\n  spheres, the same as if they were regular atoms.  The only setting\n  currently allowed for the color value is type, which will color\n  the lines according to the atom type of the particle.  By default the\n  mapping of types to colors is as follows:\n  \n  type 1 = red\n  type 2 = green\n  type 3 = blue\n  type 4 = yellow\n  type 5 = aqua\n  type 6 = cyan\n  \n  and repeats itself for types > 6.  There is not yet an option to\n  change this via the dump_modify command.\n  The line width can only be a numeric value, which specifies that all\n  lines will be drawn as cylinders with that diameter, e.g. 1.0, which\n  is in whatever distance units the input script defines,\n  e.g. Angstroms.\n  \n  The tri keyword can be used when atom_style tri is\n  used to define particles as triangles, and will draw them as triangles\n  or edges (3 lines) or both, depending on the setting for tflag.  If\n  edges are drawn, the width setting determines the diameters of the\n  line segments.  If this keyword is not used, triangle particles will\n  be drawn as spheres, the same as if they were regular atoms.  The only\n  setting currently allowed for the color value is type, which will\n  color the triangles according to the atom type of the particle.  By\n  default the mapping of types to colors is as follows:\n  \n  type 1 = red\n  type 2 = green\n  type 3 = blue\n  type 4 = yellow\n  type 5 = aqua\n  type 6 = cyan\n  \n  and repeats itself for types > 6.  There is not yet an option to\n  change this via the dump_modify command.\n  \n  The body keyword can be used when atom_style body\n  is used to define body particles with internal state\n  (e.g. sub-particles), and will drawn them in a manner specific to the\n  body style.  If this keyword is not used, such particles will be drawn\n  as spheres, the same as if they were regular atoms.\n  The Howto body doc page describes the body styles\n  LAMMPS currently supports, and provides more details as to the kind of\n  body particles they represent and how they are drawn by this dump\n  image command.  For all the body styles, individual atoms can be\n  either a body particle or a usual point (non-body) particle.  Non-body\n  particles will be drawn the same way they would be as a regular atom.\n  The bflag1 and bflag2 settings are numerical values which are\n  passed to the body style to affect how the drawing of a body particle\n  is done.  See the Howto body doc page for a\n  description of what these parameters mean for each body style.\n  The only setting currently allowed for the color value is type,\n  which will color the body particles according to the atom type of the\n  particle.  By default the mapping of types to colors is as follows:\n  \n  type 1 = red\n  type 2 = green\n  type 3 = blue\n  type 4 = yellow\n  type 5 = aqua\n  type 6 = cyan\n  \n  and repeats itself for types > 6.  There is not yet an option to\n  change this via the dump_modify command.\n  \n  The fix keyword can be used with a fix that produces\n  objects to be drawn.\n  The fflag1 and fflag2 settings are numerical values which are\n  passed to the fix to affect how the drawing of its objects is done.\n  See the individual fix doc page for a description of what these\n  parameters mean for a particular fix.\n  The only setting currently allowed for the color value is type,\n  which will color the fix objects according to their type.  By default\n  the mapping of types to colors is as follows:\n  \n  type 1 = red\n  type 2 = green\n  type 3 = blue\n  type 4 = yellow\n  type 5 = aqua\n  type 6 = cyan\n  \n  and repeats itself for types > 6.  There is not yet an option to\n  change this via the dump_modify command.\n  \n  The size keyword sets the width and height of the created images,\n  i.e. the number of pixels in each direction.\n  \n  The view, center, up, zoom, and persp values determine how\n  3d simulation space is mapped to the 2d plane of the image.  Basically\n  they control how the simulation box appears in the image.\n  All of the view, center, up, zoom, and persp values can be\n  specified as numeric quantities, whose meaning is explained below.\n  Any of them can also be specified as an equal-style variable, by using v_name as the value, where “name” is\n  the variable name.  In this case the variable will be evaluated on the\n  timestep each image is created to create a new value.  If the\n  equal-style variable is time-dependent, this is a means of changing\n  the way the simulation box appears from image to image, effectively\n  doing a pan or fly-by view of your simulation.\n  The view keyword determines the viewpoint from which the simulation\n  box is viewed, looking towards the center point.  The theta value\n  is the vertical angle from the +z axis, and must be an angle from 0 to\n  180 degrees.  The phi value is an azimuthal angle around the z axis\n  and can be positive or negative.  A value of 0.0 is a view along the\n  +x axis, towards the center point.  If theta or phi are\n  specified via variables, then the variable values should be in\n  degrees.\n  The center keyword determines the point in simulation space that\n  will be at the center of the image.  Cx, Cy, and Cz are\n  specified as fractions of the box dimensions, so that (0.5,0.5,0.5) is\n  the center of the simulation box.  These values do not have to be\n  between 0.0 and 1.0, if you want the simulation box to be offset from\n  the center of the image.  Note, however, that if you choose strange\n  values for Cx, Cy, or Cz you may get a blank image.  Internally,\n  Cx, Cy, and Cz are converted into a point in simulation space.\n  If flag is set to “s” for static, then this conversion is done once,\n  at the time the dump command is issued.  If flag is set to “d” for\n  dynamic then the conversion is performed every time a new image is\n  created.  If the box size or shape is changing, this will adjust the\n  center point in simulation space.\n  The up keyword determines what direction in simulation space will be\n  “up” in the image.  Internally it is stored as a vector that is in the\n  plane perpendicular to the view vector implied by the theta and\n  pni values, and which is also in the plane defined by the view\n  vector and user-specified up vector.  Thus this internal vector is\n  computed from the user-specified up vector as\n  up_internal = view cross (up cross view)\n  \n  \n  This means the only restriction on the specified up vector is that\n  it cannot be parallel to the view vector, implied by the theta and\n  phi values.\n  The zoom keyword scales the size of the simulation box as it appears\n  in the image.  The default zfactor value of 1 should display an\n  image mostly filled by the atoms in the simulation box.  A zfactor >\n  1 will make the simulation box larger; a zfactor < 1 will make it\n  smaller.  Zfactor must be a value > 0.0.\n  The persp keyword determines how much depth perspective is present\n  in the image.  Depth perspective makes lines that are parallel in\n  simulation space appear non-parallel in the image.  A pfactor value\n  of 0.0 means that parallel lines will meet at infinity (1.0/pfactor),\n  which is an orthographic rendering with no perspective.  A pfactor\n  value between 0.0 and 1.0 will introduce more perspective.  A pfactor\n  value > 1 will create a highly skewed image with a large amount of\n  perspective.\n  \n  Note\n  The persp keyword is not yet supported as an option.\n  \n  \n  The box keyword determines if and how the simulation box boundaries\n  are rendered as thin cylinders in the image.  If no is set, then the\n  box boundaries are not drawn and the diam setting is ignored.  If\n  yes is set, the 12 edges of the box are drawn, with a diameter that\n  is a fraction of the shortest box length in x,y,z (for 3d) or x,y (for\n  2d).  The color of the box boundaries can be set with the dump_modify boxcolor command.\n  The axes keyword determines if and how the coordinate axes are\n  rendered as thin cylinders in the image.  If no is set, then the\n  axes are not drawn and the length and diam settings are ignored.\n  If yes is set, 3 thin cylinders are drawn to represent the x,y,z\n  axes in colors red,green,blue.  The origin of these cylinders will be\n  offset from the lower left corner of the box by 10%.  The length\n  setting determines how long the cylinders will be as a fraction of the\n  respective box lengths.  The diam setting determines their thickness\n  as a fraction of the shortest box length in x,y,z (for 3d) or x,y (for\n  2d).\n  The subbox keyword determines if and how processor sub-domain\n  boundaries are rendered as thin cylinders in the image.  If no is\n  set (default), then the sub-domain boundaries are not drawn and the\n  diam setting is ignored.  If yes is set, the 12 edges of each\n  processor sub-domain are drawn, with a diameter that is a fraction of\n  the shortest box length in x,y,z (for 3d) or x,y (for 2d).  The color\n  of the sub-domain boundaries can be set with the dump_modify boxcolor command.\n  \n  The shiny keyword determines how shiny the objects rendered in the\n  image will appear.  The sfactor value must be a value 0.0 <=\n  sfactor <= 1.0, where sfactor = 1 is a highly reflective surface\n  and sfactor = 0 is a rough non-shiny surface.\n  The ssao keyword turns on/off a screen space ambient occlusion\n  (SSAO) model for depth shading.  If yes is set, then atoms further\n  away from the viewer are darkened via a randomized process, which is\n  perceived as depth.  The calculation of this effect can increase the\n  cost of computing the image by roughly 2x.  The strength of the effect\n  can be scaled by the dfactor parameter.  If no is set, no depth\n  shading is performed.\n  \n  A series of JPEG, PNG, or PPM images can be converted into a movie\n  file and then played as a movie using commonly available tools. Using\n  dump style movie automates this step and avoids the intermediate\n  step of writing (many) image snapshot file. But LAMMPS has to be\n  compiled with -DLAMMPS_FFMPEG and an FFmpeg executable have to be\n  installed.\n  To manually convert JPEG, PNG or PPM files into an animated GIF or\n  MPEG or other movie file you can use:\n  \n  \n  Use the ImageMagick convert program.\n  \n  % convert *.jpg foo.gif\n  % convert -loop 1 *.ppm foo.mpg\n  \n  \n  Animated GIF files from ImageMagick are not optimized. You can use\n  a program like gifsicle to optimize and thus massively shrink them.\n  MPEG files created by ImageMagick are in MPEG-1 format with a rather\n  inefficient compression and low quality compared to more modern\n  compression styles like MPEG-4, H.264, VP8, VP9, H.265 and so on.\n  \n  \n  Use QuickTime.\n  \n  Select “Open Image Sequence” under the File menu Load the images into\n  QuickTime to animate them Select “Export” under the File menu Save the\n  movie as a QuickTime movie (*.mov) or in another format.  QuickTime\n  can generate very high quality and efficiently compressed movie\n  files. Some of the supported formats require to buy a license and some\n  are not readable on all platforms until specific runtime libraries are\n  installed.\n  \n  \n  Use FFmpeg\n  \n  FFmpeg is a command line tool that is available on many platforms and\n  allows extremely flexible encoding and decoding of movies.\n  cat snap.*.jpg | ffmpeg -y -f image2pipe -c:v mjpeg -i - -b:v 2000k movie.m4v\n  cat snap.*.ppm | ffmpeg -y -f image2pipe -c:v ppm -i - -b:v 2400k movie.avi\n  \n  \n  Front ends for FFmpeg exist for multiple platforms. For more\n  information see the FFmpeg homepage\n  \n  \n  \n  Play the movie:\n  \n  \n  Use your browser to view an animated GIF movie.\n  \n  Select “Open File” under the File menu\n  Load the animated GIF file\n  \n  b) Use the freely available mplayer or ffplay tool to view a\n  movie. Both are available for multiple OSes and support a large\n  variety of file formats and decoders.\n  % mplayer foo.mpg\n  % ffplay bar.avi\n  \n  \n  \n  c) Use the Pizza.py\n  animate tool,\n  which works directly on a series of image files.\n  a = animate(\"foo*.jpg\")\n  \n  \n  \n  d) QuickTime and other Windows- or MacOS-based media players can\n  obviously play movie files directly. Similarly for corresponding tools\n  bundled with Linux desktop environments.  However, due to licensing\n  issues with some file formats, the formats may require installing\n  additional libraries, purchasing a license, or may not be\n  supported.\n  \n  \n  See the Modify doc page for information on how to add\n  new compute and fix styles to LAMMPS to calculate per-atom quantities\n  which could then be output into dump files.\n  ",
    "syntax": "dump ID group-ID style N file color diameter keyword value ...\n  \n  \n  \n  ID = user-assigned name for the dump\n  group-ID = ID of the group of atoms to be imaged\n  style = image or movie = style of dump command (other styles atom or cfg or dcd or xtc or xyz or local or custom are discussed on the dump doc page)\n  N = dump every this many timesteps\n  file = name of file to write image to\n  color = atom attribute that determines color of each atom\n  diameter = atom attribute that determines size of each atom\n  zero or more keyword/value pairs may be appended\n  keyword = atom or adiam or bond or line or tri or body or fix or size or view or center or up or zoom or persp or box or axes or subbox or shiny or ssao\n  atom = yes/no = do or do not draw atoms\n  adiam size = numeric value for atom diameter (distance units)\n  bond values = color width = color and width of bonds\n    color = atom or type or none\n    width = number or atom or type or none\n      number = numeric value for bond width (distance units)\n  line = color width\n    color = type\n    width = numeric value for line width (distance units)\n  tri = color tflag width\n    color = type\n    tflag = 1 for just triangle, 2 for just tri edges, 3 for both\n    width = numeric value for tringle edge width (distance units)\n  body = color bflag1 bflag2\n    color = type\n    bflag1,bflag2 = 2 numeric flags to affect how bodies are drawn\n  fix = fixID color fflag1 fflag2\n    fixID = ID of fix that generates objects to dray\n    color = type\n    fflag1,fflag2 = 2 numeric flags to affect how fix objects are drawn\n  size values = width height = size of images\n    width = width of image in # of pixels\n    height = height of image in # of pixels\n  view values = theta phi = view of simulation box\n    theta = view angle from +z axis (degrees)\n    phi = azimuthal view angle (degrees)\n    theta or phi can be a variable (see below)\n  center values = flag Cx Cy Cz = center point of image\n    flag = \"s\" for static, \"d\" for dynamic\n    Cx,Cy,Cz = center point of image as fraction of box dimension (0.5 = center of box)\n    Cx,Cy,Cz can be variables (see below)\n  up values = Ux Uy Uz = direction that is \"up\" in image\n    Ux,Uy,Uz = components of up vector\n    Ux,Uy,Uz can be variables (see below)\n  zoom value = zfactor = size that simulation box appears in image\n    zfactor = scale image size by factor > 1 to enlarge, factor < 1 to shrink\n    zfactor can be a variable (see below)\n  persp value = pfactor = amount of \"perspective\" in image\n    pfactor = amount of perspective (0 = none, < 1 = some, > 1 = highly skewed)\n    pfactor can be a variable (see below)\n  box values = yes/no diam = draw outline of simulation box\n    yes/no = do or do not draw simulation box lines\n    diam = diameter of box lines as fraction of shortest box length\n  axes values = yes/no length diam = draw xyz axes\n    yes/no = do or do not draw xyz axes lines next to simulation box\n    length = length of axes lines as fraction of respective box lengths\n    diam = diameter of axes lines as fraction of shortest box length\n  subbox values = yes/no diam = draw outline of processor sub-domains\n    yes/no = do or do not draw sub-domain lines\n    diam = diameter of sub-domain lines as fraction of shortest box length\n  shiny value = sfactor = shinyness of spheres and cylinders\n    sfactor = shinyness of spheres and cylinders from 0.0 to 1.0\n  ssao value = yes/no seed dfactor = SSAO depth shading\n    yes/no = turn depth shading on/off\n    seed = random # seed (positive integer)\n    dfactor = strength of shading from 0.0 to 1.0\n  \n  \n  ",
    "examples": "dump d0 all image 100 dump.\\*.jpg type type\n  dump d1 mobile image 500 snap.\\*.png element element ssao yes 4539 0.6\n  dump d2 all image 200 img-\\*.ppm type type zoom 2.5 adiam 1.5 size 1280 720\n  dump m0 all movie 1000 movie.mpg type type size 640 480\n  dump m1 all movie 1000 movie.avi type type size 640 480\n  dump m2 all movie 100 movie.m4v type type zoom 1.8 adiam v_value size 1280 720\n  \n  \n  ",
    "restrictions": "To write JPEG images, you must use the -DLAMMPS_JPEG switch when\n  building LAMMPS and link with a JPEG library. To write PNG images, you\n  must use the -DLAMMPS_PNG switch when building LAMMPS and link with a\n  PNG library.\n  To write movie dumps, you must use the -DLAMMPS_FFMPEG switch when\n  building LAMMPS and have the FFmpeg executable available on the\n  machine where LAMMPS is being run.  Typically it’s name is lowercase,\n  i.e. ffmpeg.\n  See the Build settings doc page for details.\n  Note that since FFmpeg is run as an external program via a pipe,\n  LAMMPS has limited control over its execution and no knowledge about\n  errors and warnings printed by it. Those warnings and error messages\n  will be printed to the screen only. Due to the way image data is\n  communicated to FFmpeg, it will often print the message\n  pipe:: Input/output error\n  \n  \n  which can be safely ignored. Other warnings\n  and errors have to be addressed according to the FFmpeg documentation.\n  One known issue is that certain movie file formats (e.g. MPEG level 1\n  and 2 format streams) have video bandwidth limits that can be crossed\n  when rendering too large of image sizes. Typical warnings look like\n  this:\n  [mpeg @ 0x98b5e0] packet too large, ignoring buffer limits to mux it\n  [mpeg @ 0x98b5e0] buffer underflow st=0 bufi=281407 size=285018\n  [mpeg @ 0x98b5e0] buffer underflow st=0 bufi=283448 size=285018\n  \n  \n  In this case it is recommended to either reduce the size of the image\n  or encode in a different format that is also supported by your copy of\n  FFmpeg, and which does not have this limitation (e.g. .avi, .mkv,\n  mp4).\n  "
},
{
    "command": "dihedral_style charmm",
    "description": "The charmm and charmmfsw dihedral styles use the potential\n  \n  \\[E = K [ 1 + \\cos (n \\phi - d) ]\\]\n  See (MacKerell) for a description of the CHARMM\n  force field.  This dihedral style can also be used for the AMBER force\n  field (see comment on weighting factors below).  See\n  (Cornell) for a description of the AMBER force\n  field.\n  \n  Note\n  The newer charmmfsw style was released in March 2017.  We\n  recommend it be used instead of the older charmm style when running\n  a simulation with the CHARMM force field, either with long-range\n  Coulombics or a Coulombic cutoff, via the pair_style lj/charmmfsw/coul/long and pair_style lj/charmmfsw/coul/charmmfsh commands respectively.\n  Otherwise the older charmm style is fine to use.  See the discussion\n  below and more details on the pair_style charmm doc\n  page.\n  \n  The following coefficients must be defined for each dihedral type via the\n  dihedral_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(K\\) (energy)\n  \\(n\\) (integer >= 0)\n  \\(d\\) (integer value of degrees)\n  weighting factor (1.0, 0.5, or 0.0)\n  \n  The weighting factor is required to correct for double counting\n  pairwise non-bonded Lennard-Jones interactions in cyclic systems or\n  when using the CHARMM dihedral style with non-CHARMM force fields.\n  With the CHARMM dihedral style, interactions between the 1st and 4th\n  atoms in a dihedral are skipped during the normal non-bonded force\n  computation and instead evaluated as part of the dihedral using\n  special epsilon and sigma values specified with the\n  pair_coeff command of pair styles that contain\n  “lj/charmm” (e.g. pair_style lj/charmm/coul/long)\n  In 6-membered rings, the same 1-4 interaction would be computed twice\n  (once for the clockwise 1-4 pair in dihedral 1-2-3-4 and once in the\n  counterclockwise dihedral 1-6-5-4) and thus the weighting factor has\n  to be 0.5 in this case.  In 4-membered or 5-membered rings, the 1-4\n  dihedral also is counted as a 1-2 or 1-3 interaction when going around\n  the ring in the opposite direction and thus the weighting factor is\n  0.0, as the 1-2 and 1-3 exclusions take precedence.\n  Note that this dihedral weighting factor is unrelated to the scaling\n  factor specified by the special bonds command\n  which applies to all 1-4 interactions in the system.  For CHARMM force\n  fields, the special_bonds 1-4 interaction scaling factor should be set\n  to 0.0. Since the corresponding 1-4 non-bonded interactions are\n  computed with the dihedral.  This means that if any of the weighting\n  factors defined as dihedral coefficients (4th coeff above) are\n  non-zero, then you must use a pair style with “lj/charmm” and set the\n  special_bonds 1-4 scaling factor to 0.0 (which is the\n  default). Otherwise 1-4 non-bonded interactions in dihedrals will be\n  computed twice.\n  For simulations using the CHARMM force field with a Coulombic cutoff,\n  the difference between the charmm and charmmfsw styles is in the\n  computation of the 1-4 non-bond interactions, though only if the\n  distance between the two atoms is within the switching region of the\n  pairwise potential defined by the corresponding CHARMM pair style,\n  i.e. within the outer cutoff specified for the pair style.  The\n  charmmfsw style should only be used when using the corresponding\n  pair_style lj/charmmfsw/coul/charmmfsw or\n  pair_style lj/charmmfsw/coul/long commands.  Use\n  the charmm style with the older pair_style\n  commands that have just “charmm” in their style name.  See the\n  discussion on the CHARMM pair_style doc page for\n  details.\n  Note that for AMBER force fields, which use pair styles with “lj/cut”,\n  the special_bonds 1-4 scaling factor should be set to the AMBER\n  defaults (1/2 and 5/6) and all the dihedral weighting factors (4th\n  coeff above) must be set to 0.0. In this case, you can use any pair\n  style you wish, since the dihedral does not need any Lennard-Jones\n  parameter information and will not compute any 1-4 non-bonded\n  interactions.  Likewise the charmm or charmmfsw styles are\n  identical in this case since no 1-4 non-bonded interactions are\n  computed.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "dihedral_style style\n  \n  \n  \n  style = charmm or charmmfsw\n  \n  ",
    "examples": "dihedral_style charmm\n  dihedral_style charmmfsw\n  dihedral_coeff  1 0.2 1 180 1.0\n  dihedral_coeff  2 1.8 1   0 1.0\n  dihedral_coeff  1 3.1 2 180 0.5\n  \n  \n  ",
    "restrictions": "When using run_style respa, these dihedral styles\n  must be assigned to the same r-RESPA level as pair or outer.\n  When used in combination with CHARMM pair styles, the 1-4\n  special_bonds scaling factors must be set to 0.0.\n  Otherwise non-bonded contributions for these 1-4 pairs will be\n  computed multiple times.\n  These dihedral styles can only be used if LAMMPS was built with the\n  MOLECULE package.  See the Build package doc page\n  for more info.\n  "
},
{
    "command": "dihedral_style class2",
    "description": "The class2 dihedral style uses the potential\n  \n  \\[\\begin{split}E        = & E_d + E_{mbt} + E_{ebt} + E_{at} + E_{aat} + E_{bb13} \\\\\n  E_d      = & \\sum_{n=1}^{3} K_n [ 1 - \\cos (n \\phi - \\phi_n) ] \\\\\n  E_{mbt}  = & (r_{jk} - r_2) [ A_1 \\cos (\\phi) + A_2 \\cos (2\\phi) + A_3 \\cos (3\\phi) ] \\\\\n  E_{ebt}  = & (r_{ij} - r_1) [ B_1 \\cos (\\phi) + B_2 \\cos (2\\phi) + B_3 \\cos (3\\phi) ] + \\\\\n             & (r_{kl} - r_3) [ C_1 \\cos (\\phi) + C_2 \\cos (2\\phi) + C_3 \\cos (3\\phi) ] \\\\\n  E_{at}   = & (\\theta_{ijk} - \\theta_1) [ D_1 \\cos (\\phi) + D_2 \\cos (2\\phi) + D_3 \\cos (3\\phi) ] + \\\\\n             & (\\theta_{jkl} - \\theta_2) [ E_1 \\cos (\\phi) + E_2 \\cos (2\\phi) + E_3 \\cos (3\\phi) ] \\\\\n  E_{aat}  = & M (\\theta_{ijk} - \\theta_1) (\\theta_{jkl} - \\theta_2) \\cos (\\phi) \\\\\n  E_{bb13} = & N (r_{ij} - r_1) (r_{kl} - r_3)\\end{split}\\]\n  where \\(E_d\\) is the dihedral term, \\(E_{mbt}\\) is a middle-bond-torsion term,\n  \\(E_{ebt}\\) is an end-bond-torsion term, \\(E_{at}\\) is an angle-torsion term, \\(E_{aat}\\)\n  is an angle-angle-torsion term, and \\(E_{bb13}\\) is a bond-bond-13 term.\n  \\(\\theta_1\\) and \\(\\theta_2\\) are equilibrium angles and \\(r_1\\), \\(r_2\\), and\n  \\(r_3\\) are equilibrium bond lengths.\n  See (Sun) for a description of the COMPASS class2 force field.\n  Coefficients for the \\(E_d\\), \\(E_{mbt}\\), \\(E_{ebt}\\),\n  \\(E_{at}\\), \\(E_{aat}\\), and \\(E_{bb13}\\) formulas must be\n  defined for each dihedral type via the dihedral_coeff\n  command as in the example above, or in the data file\n  or restart files read by the read_data or\n  read_restart commands.\n  These are the 6 coefficients for the \\(E_d\\) formula:\n  \n  \\(K_1\\) (energy)\n  \\(\\phi_1\\) (degrees)\n  \\(K_2\\) (energy)\n  \\(\\phi_2\\) (degrees)\n  \\(K_3\\) (energy)\n  \\(phi_3\\) (degrees)\n  \n  For the \\(E_{mbt}\\) formula, each line in a\n  dihedral_coeff command in the input script lists\n  5 coefficients, the first of which is mbt to indicate they are\n  MiddleBondTorsion coefficients.  In a data file, these coefficients\n  should be listed under a MiddleBondTorsion Coeffs heading and you\n  must leave out the mbt, i.e. only list 4 coefficients after the\n  dihedral type.\n  \n  mbt\n  \\(A_1\\) (energy/distance)\n  \\(A_2\\) (energy/distance)\n  \\(A_3\\) (energy/distance)\n  \\(r_2\\) (distance)\n  \n  For the \\(E_{ebt}\\) formula, each line in a\n  dihedral_coeff command in the input script lists\n  9 coefficients, the first of which is ebt to indicate they are\n  EndBondTorsion coefficients.  In a data file, these coefficients\n  should be listed under a EndBondTorsion Coeffs heading and you must\n  leave out the ebt, i.e. only list 8 coefficients after the dihedral\n  type.\n  \n  ebt\n  \\(B_1\\) (energy/distance)\n  \\(B_2\\) (energy/distance)\n  \\(B_3\\) (energy/distance)\n  \\(C_1\\) (energy/distance)\n  \\(C_2\\) (energy/distance)\n  \\(C_3\\) (energy/distance)\n  \\(r_1\\) (distance)\n  \\(r_3\\) (distance)\n  \n  For the \\(E_{at}\\) formula, each line in a\n  dihedral_coeff command in the input script lists\n  9 coefficients, the first of which is at to indicate they are\n  AngleTorsion coefficients.  In a data file, these coefficients should\n  be listed under a AngleTorsion Coeffs heading and you must leave out\n  the at, i.e. only list 8 coefficients after the dihedral type.\n  \n  at\n  \\(D_1\\) (energy/radian)\n  \\(D_2\\) (energy/radian)\n  \\(D_3\\) (energy/radian)\n  \\(E_1\\) (energy/radian)\n  \\(E_2\\) (energy/radian)\n  \\(E_3\\) (energy/radian)\n  \\(\\theta_1\\) (degrees)\n  \\(\\theta_2\\) (degrees)\n  \n  \\(\\theta_1\\) and \\(\\theta_2\\) are specified in degrees, but LAMMPS converts\n  them to radians internally; hence the units of \\(D\\) and \\(E\\) are in\n  energy/radian.\n  For the \\(E_{aat}\\) formula, each line in a\n  dihedral_coeff command in the input script lists\n  4 coefficients, the first of which is aat to indicate they are\n  AngleAngleTorsion coefficients.  In a data file, these coefficients\n  should be listed under a AngleAngleTorsion Coeffs heading and you\n  must leave out the aat, i.e. only list 3 coefficients after the\n  dihedral type.\n  \n  aat\n  \\(M\\) (energy/radian^2)\n  \\(\\theta_1\\) (degrees)\n  \\(\\theta_2\\) (degrees)\n  \n  \\(\\theta_1\\) and \\(\\theta_2\\) are specified in degrees, but LAMMPS converts\n  them to radians internally; hence the units of M are in energy/radian^2.\n  For the \\(E_{bb13}\\) formula, each line in a\n  dihedral_coeff command in the input script lists\n  4 coefficients, the first of which is bb13 to indicate they are\n  BondBond13 coefficients.  In a data file, these coefficients should be\n  listed under a BondBond13 Coeffs heading and you must leave out the\n  bb13, i.e. only list 3 coefficients after the dihedral type.\n  \n  bb13\n  \\(N\\) (energy/distance^2)\n  \\(r_1\\) (distance)\n  \\(r_3\\) (distance)\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "dihedral_style class2\n  \n  \n  ",
    "examples": "dihedral_style class2\n  dihedral_coeff 1 100 75 100 70 80 60\n  dihedral_coeff * mbt 3.5945 0.1704 -0.5490 1.5228\n  dihedral_coeff * ebt 0.3417 0.3264 -0.9036 0.1368 0.0 -0.8080 1.0119 1.1010\n  dihedral_coeff 2 at 0.0 -0.1850 -0.7963 -2.0220 0.0 -0.3991 110.2453 105.1270\n  dihedral_coeff * aat -13.5271 110.2453 105.1270\n  dihedral_coeff * bb13 0.0 1.0119 1.1010\n  \n  \n  ",
    "restrictions": "This dihedral style can only be used if LAMMPS was built with the\n  CLASS2 package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "dihedral_style cosine/shift/exp",
    "description": "The cosine/shift/exp dihedral style uses the potential\n  \n  \\[E = -U_{min}\\frac{e^{-a U(\\theta,\\theta_0)}-1}{e^a-1} \\quad\\mbox{with}\\quad U(\\theta,\\theta_0)=-0.5 \\left(1+\\cos(\\theta-\\theta_0) \\right)\\]\n  where \\(U_{min}\\), \\(\\theta\\), and \\(a\\) are defined for\n  each dihedral type.\n  The potential is bounded between \\(\\left[-U_{min}:0\\right]\\) and the minimum is located\n  at the angle \\(\\theta_0\\). The a parameter can be both positive or negative\n  and is used to control the spring constant at the equilibrium.\n  The spring constant is given by \\(k=a e^a \\frac{U_{min}}{2 \\left(e^a-1\\right)}\\).\n  For \\(a>3\\) and  \\(\\frac{k}{U_{min}} = \\frac{a}{2}\\) to better than 5% relative error. For negative\n  values of the a parameter, the spring constant is essentially zero,\n  and anharmonic terms takes over. The potential is furthermore well\n  behaved in the limit \\(a \\rightarrow 0\\), where it has been implemented to linear\n  order in \\(a\\) for \\(a < 0.001\\).\n  The following coefficients must be defined for each dihedral type via\n  the dihedral_coeff command as in the example\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands:\n  \n  \\(U_{min}\\) (energy)\n  \\(\\theta\\) (angle)\n  \\(a\\) (real number)\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "dihedral_style cosine/shift/exp\n  \n  \n  ",
    "examples": "dihedral_style cosine/shift/exp\n  dihedral_coeff 1 10.0 45.0 2.0\n  \n  \n  ",
    "restrictions": "This dihedral style can only be used if LAMMPS was built with the\n  USER-MISC package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "dihedral_style harmonic",
    "description": "The harmonic dihedral style uses the potential\n  \n  \\[E = K [ 1 + d  \\cos (n \\phi) ]\\]\n  The following coefficients must be defined for each dihedral type via the\n  dihedral_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(K\\) (energy)\n  \\(d\\) (+1 or -1)\n  \\(n\\) (integer >= 0)\n  \n  \n  Note\n  Here are important points to take note of when defining LAMMPS\n  dihedral coefficients for the harmonic style, so that they are\n  compatible with how harmonic dihedrals are defined by other force\n  fields:\n  \n  \n  The LAMMPS convention is that the trans position = 180 degrees, while\n  in some force fields trans = 0 degrees.\n  Some force fields reverse the sign convention on \\(d\\).\n  Some force fields let \\(n\\) be positive or negative which corresponds to\n  \\(d = 1\\) or \\(d = -1\\) for the harmonic style.\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "dihedral_style harmonic\n  \n  \n  ",
    "examples": "dihedral_style harmonic\n  dihedral_coeff 1 80.0 1 2\n  \n  \n  ",
    "restrictions": "This dihedral style can only be used if LAMMPS was built with the\n  MOLECULE package.  See the Build package doc page\n  for more info.\n  "
},
{
    "command": "dihedral_style helix",
    "description": "The helix dihedral style uses the potential\n  \n  \\[E = A [1 - \\cos(\\theta)] + B [1 + \\cos(3 \\theta)] +\n      C [1 + \\cos(\\theta + \\frac{\\pi}{4})]\\]\n  This coarse-grain dihedral potential is described in (Guo).\n  For dihedral angles in the helical region, the energy function is\n  represented by a standard potential consisting of three minima, one\n  corresponding to the trans (t) state and the other to gauche states\n  (g+ and g-).  The paper describes how the \\(A\\), \\(B\\) and,\n  \\(C\\) parameters are chosen so as to balance secondary (largely\n  driven by local interactions) and\n  tertiary structure (driven by long-range interactions).\n  The following coefficients must be defined for each dihedral type via the\n  dihedral_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(A\\) (energy)\n  \\(B\\) (energy)\n  \\(C\\) (energy)\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "dihedral_style helix\n  \n  \n  ",
    "examples": "dihedral_style helix\n  dihedral_coeff 1 80.0 100.0 40.0\n  \n  \n  ",
    "restrictions": "This dihedral style can only be used if LAMMPS was built with the\n  MOLECULE package.  See the Build package doc page\n  for more info.\n  "
},
{
    "command": "dihedral_style hybrid",
    "description": "The hybrid style enables the use of multiple dihedral styles in one\n  simulation.  An dihedral style is assigned to each dihedral type.  For\n  example, dihedrals in a polymer flow (of dihedral type 1) could be\n  computed with a harmonic potential and dihedrals in the wall\n  boundary (of dihedral type 2) could be computed with a helix\n  potential.  The assignment of dihedral type to style is made via the\n  dihedral_coeff command or in the data file.\n  In the dihedral_coeff commands, the name of a dihedral style must be\n  added after the dihedral type, with the remaining coefficients being\n  those appropriate to that style.  In the example above, the 2\n  dihedral_coeff commands set dihedrals of dihedral type 1 to be\n  computed with a harmonic potential with coefficients 6.0, 1, 3 for\n  K, d, n.  All other dihedral types (2-N) are computed with a helix\n  potential with coefficients 10, 10, 10 for A, B, C.\n  If dihedral coefficients are specified in the data file read via the\n  read_data command, then the same rule applies.\n  E.g. “harmonic” or “helix”, must be added after the dihedral type, for\n  each line in the “Dihedral Coeffs” section, e.g.\n  Dihedral Coeffs\n  \n  1 harmonic 6.0 1 3\n  2 helix 10 10 10\n  ...\n  \n  \n  If class2 is one of the dihedral hybrid styles, the same rule holds\n  for specifying additional AngleTorsion (and EndBondTorsion, etc)\n  coefficients either via the input script or in the data file.\n  I.e. class2 must be added to each line after the dihedral type.  For\n  lines in the AngleTorsion (or EndBondTorsion, etc) section of the data\n  file for dihedral types that are not class2, you must use an\n  dihedral style of skip as a placeholder, e.g.\n  AngleTorsion Coeffs\n  \n  1 skip\n  2 class2 1.0 1.0 1.0 3.0 3.0 3.0 30.0 50.0\n  ...\n  \n  \n  Note that it is not necessary to use the dihedral style skip in the\n  input script, since AngleTorsion (or EndBondTorsion, etc) coefficients\n  need not be specified at all for dihedral types that are not class2.\n  A dihedral style of none with no additional coefficients can be used\n  in place of a dihedral style, either in a input script dihedral_coeff\n  command or in the data file, if you desire to turn off interactions\n  for specific dihedral types.\n  ",
    "syntax": "dihedral_style hybrid style1 style2 ...\n  \n  \n  \n  style1,style2 = list of one or more dihedral styles\n  \n  ",
    "examples": "dihedral_style hybrid harmonic helix\n  dihedral_coeff 1 harmonic 6.0 1 3\n  dihedral_coeff 2* helix 10 10 10\n  \n  \n  ",
    "restrictions": "This dihedral style can only be used if LAMMPS was built with the\n  MOLECULE package.  See the Build package doc page\n  for more info.\n  Unlike other dihedral styles, the hybrid dihedral style does not store\n  dihedral coefficient info for individual sub-styles in a binary restart files.  Thus when restarting a simulation from a\n  restart file, you need to re-specify dihedral_coeff commands.\n  "
},
{
    "command": "dihedral_style multi/harmonic",
    "description": "The multi/harmonic dihedral style uses the potential\n  \n  \\[E = \\sum_{n=1,5} A_n  \\cos^{n-1}(\\phi)\\]\n  The following coefficients must be defined for each dihedral type via the\n  dihedral_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(A_1\\) (energy)\n  \\(A_2\\) (energy)\n  \\(A_3\\) (energy)\n  \\(A_4\\) (energy)\n  \\(A_5\\) (energy)\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "dihedral_style multi/harmonic\n  \n  \n  ",
    "examples": "dihedral_style multi/harmonic\n  dihedral_coeff 1 20 20 20 20 20\n  \n  \n  ",
    "restrictions": "This dihedral style can only be used if LAMMPS was built with the\n  MOLECULE package.  See the Build package doc page\n  for more info.\n  "
},
{
    "command": "dihedral_style nharmonic",
    "description": "The nharmonic dihedral style uses the potential:\n  \n  \\[E = \\sum_{n=1,n} A_n  \\cos^{n-1}(\\phi)\\]\n  The following coefficients must be defined for each dihedral type via the\n  dihedral_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(n\\) (integer >=1)\n  \\(A_1\\) (energy)\n  \\(A_2\\) (energy)\n  …\n  \\(A_n\\) (energy)\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "dihedral_style nharmonic\n  \n  \n  ",
    "examples": "dihedral_style nharmonic\n  dihedral_coeff * 3 10.0 20.0 30.0\n  \n  \n  ",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\n  USER_MISC package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "dihedral_style none",
    "description": "Using a dihedral style of none means dihedral forces and energies are\n  not computed, even if quadruplets of dihedral atoms were listed in the\n  data file read by the read_data command.\n  See the dihedral_style zero command for a way to\n  calculate dihedral statistics, but compute no dihedral interactions.\n  ",
    "syntax": "dihedral_style none\n  \n  \n  ",
    "examples": "dihedral_style none\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "dihedral_style opls",
    "description": "The opls dihedral style uses the potential\n  \n  \\[\\begin{split}E = & \\frac{1}{2} K_1 [1 + \\cos(\\phi)] + \\frac{1}{2} K_2 [1 - \\cos(2 \\phi)] + \\\\\n      & \\frac{1}{2} K_3 [1 + \\cos(3 \\phi)] + \\frac{1}{2} K_4 [1 - \\cos(4 \\phi)]\\end{split}\\]\n  Note that the usual 1/2 factor is not included in the K values.\n  This dihedral potential is used in the OPLS force field and is\n  described in (Watkins).\n  The following coefficients must be defined for each dihedral type via the\n  dihedral_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(K_1\\) (energy)\n  \\(K_2\\) (energy)\n  \\(K_3\\) (energy)\n  \\(K_4\\) (energy)\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "dihedral_style opls\n  \n  \n  ",
    "examples": "dihedral_style opls\n  dihedral_coeff 1 1.740 -0.157 0.279 0.00   # CT-CT-CT-CT\n  dihedral_coeff 2 0.000 0.000 0.366 0.000   # CT-CT-CT-HC\n  dihedral_coeff 3 0.000 0.000 0.318 0.000   # HC-CT-CT-HC\n  \n  \n  ",
    "restrictions": "This dihedral style can only be used if LAMMPS was built with the\n  MOLECULE package.  See the Build package doc page\n  for more info.\n  "
},
{
    "command": "dihedral_style quadratic",
    "description": "The quadratic dihedral style uses the potential:\n  \n  \\[E = K (\\phi - \\phi_0)^2\\]\n  This dihedral potential can be used to keep a dihedral in a predefined\n  value (cis=zero, right-hand convention is used).\n  The following coefficients must be defined for each dihedral type via\n  the dihedral_coeff command as in the example\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands:\n  \n  \\(K\\) (energy/radian^2)\n  \\(\\phi_0\\) (degrees)\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "dihedral_style quadratic\n  \n  \n  ",
    "examples": "dihedral_style quadratic\n  dihedral_coeff 100.0 80.0\n  \n  \n  ",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\n  USER_MISC package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "dihedral_style spherical",
    "description": "The spherical dihedral style uses the potential:\n  \n  \n  \\[\\begin{split}E(\\phi,\\theta_1,\\theta_2) & = \\sum_{i=1}^N\\nolimits\\ C_i\\ \\Phi_i(\\phi)\\ \\Theta_{1i}(\\theta_1)\\ \\Theta_{2i}(\\theta_2) \\\\\n  \\Phi_{i}(\\phi)            & = u_i - \\mathrm{cos}((\\phi   - a_i)K_i) \\\\\n  \\Theta_{1i}(\\theta_1)     & = v_i - \\mathrm{cos}((\\theta_1-b_i)L_i) \\\\\n  \\Theta_{2i}(\\theta_2)     & = w_i - \\mathrm{cos}((\\theta_2-c_i)M_i)\\end{split}\\]\n  For this dihedral style, the energy can be any function that combines the\n  4-body dihedral-angle (\\(\\phi\\)) and the two 3-body bond-angles\n  (\\(\\theta_1\\), \\(\\theta_2\\)).\n  For this reason, there is usually no need to define 3-body “angle” forces\n  separately for the atoms participating in these interactions.\n  It is probably more efficient to incorporate 3-body angle forces into\n  the dihedral interaction even if it requires adding additional terms to\n  the expansion (as was done in the second example).  A careful choice of\n  parameters can prevent singularities that occur with traditional\n  force-fields whenever theta1 or theta2 approach 0 or 180 degrees.\n  The last example above corresponds to an interaction with a single energy\n  minima located near \\(\\phi=93.9\\), \\(\\theta_1=74.4\\),\n  \\(\\theta_2=48.1\\) degrees, and it remains numerically stable at all\n  angles (\\(\\phi\\), \\(\\theta_1\\), \\(\\theta_2\\)). In this example,\n  the coefficients 49.1, and 25.2 can be physically interpreted as the\n  harmonic spring constants for theta1 and theta2 around their minima.\n  The coefficient 69.3 is the harmonic spring constant for phi after\n  division by sin(74.4)*sin(48.1) (the minima positions for theta1 and theta2).\n  The following coefficients must be defined for each dihedral type via the\n  dihedral_coeff command as in the example above, or in\n  the Dihedral Coeffs section of a data file read by the\n  read_data command:\n  \n  \\(n\\) (integer >= 1)\n  \\(C_1\\) (energy)\n  \\(K_1\\) (typically an integer)\n  \\(a_1\\) (degrees)\n  \\(u_1\\) (typically 0.0 or 1.0)\n  \\(L_1\\) (typically an integer)\n  \\(b_1\\) (degrees, typically 0.0 or 90.0)\n  \\(v_1\\) (typically 0.0 or 1.0)\n  \\(M_1\\) (typically an integer)\n  \\(c_1\\) (degrees, typically 0.0 or 90.0)\n  \\(w_1\\) (typically 0.0 or 1.0)\n  […]\n  \\(C_n\\) (energy)\n  \\(K_n\\) (typically an integer)\n  \\(a_n\\) (degrees)\n  \\(u_n\\) (typically 0.0 or 1.0)\n  \\(L_n\\) (typically an integer)\n  \\(b_n\\) (degrees, typically 0.0 or 90.0)\n  \\(v_n\\) (typically 0.0 or 1.0)\n  \\(M_n\\) (typically an integer)\n  \\(c_n\\) (degrees, typically 0.0 or 90.0)\n  \\(w_n\\) (typically 0.0 or 1.0)\n  \n  ",
    "syntax": "dihedral_style spherical\n  \n  \n  ",
    "examples": "dihedral_coeff 1 1  286.1  1 124  1    1 90.0 0    1 90.0 0\n  dihedral_coeff 1 3  69.3   1 93.9 1    1 90   0    1 90   0  &\n                      49.1   0 0.00 0    1 74.4 1    0 0.00 0  &\n                      25.2   0 0.00 0    0 0.00 0    1 48.1 1\n  \n  \n  ",
    "restrictions": "This dihedral style can only be used if LAMMPS was built with the\n  USER_MISC package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "dihedral_style table",
    "description": "The table dihedral style creates interpolation tables of length\n  Ntable from dihedral potential and derivative values listed in a\n  file(s) as a function of the dihedral angle “phi”.  The files are read\n  by the dihedral_coeff command.\n  The interpolation tables are created by fitting cubic splines to the\n  file values and interpolating energy and derivative values at each of\n  Ntable dihedral angles. During a simulation, these tables are used\n  to interpolate energy and force values on individual atoms as\n  needed. The interpolation is done in one of 2 styles: linear or\n  spline.\n  For the linear style, the dihedral angle (phi) is used to find 2\n  surrounding table values from which an energy or its derivative is\n  computed by linear interpolation.\n  For the spline style, cubic spline coefficients are computed and\n  stored at each of the Ntable evenly-spaced values in the\n  interpolated table.  For a given dihedral angle (phi), the appropriate\n  coefficients are chosen from this list, and a cubic polynomial is used\n  to compute the energy and the derivative at this angle.\n  The following coefficients must be defined for each dihedral type via\n  the dihedral_coeff command as in the example\n  above.\n  \n  filename\n  keyword\n  \n  The filename specifies a file containing tabulated energy and\n  derivative values. The keyword specifies a section of the file.  The\n  format of this file is described below.\n  \n  The format of a tabulated file is as follows (without the\n  parenthesized comments).  It can begin with one or more comment\n  or blank lines.\n  # Table of the potential and its negative derivative\n  \n  DIH_TABLE1                   (keyword is the first text on line)\n  N 30 DEGREES                 (N, NOF, DEGREES, RADIANS, CHECKU/F)\n                               (blank line)\n  1 -168.0 -1.40351172223 0.0423346818422\n  2 -156.0 -1.70447981034 0.00811786522531\n  3 -144.0 -1.62956100432 -0.0184129719987\n  ...\n  30 180.0 -0.707106781187 0.0719306095245\n  \n  # Example 2: table of the potential. Forces omitted\n  \n  DIH_TABLE2\n  N 30 NOF CHECKU testU.dat CHECKF testF.dat\n  \n  1 -168.0 -1.40351172223\n  2 -156.0 -1.70447981034\n  3 -144.0 -1.62956100432\n  ...\n  30 180.0 -0.707106781187\n  \n  \n  A section begins with a non-blank line whose 1st character is not a\n  “#”; blank lines or lines starting with “#” can be used as comments\n  between sections. The first line begins with a keyword which\n  identifies the section. The line can contain additional text, but the\n  initial text must match the argument specified in the\n  dihedral_coeff command. The next line lists (in\n  any order) one or more parameters for the table. Each parameter is a\n  keyword followed by one or more numeric values.\n  Following a blank line, the next N lines list the tabulated values. On\n  each line, the 1st value is the index from 1 to N, the 2nd value is\n  the angle value, the 3rd value is the energy (in energy units), and\n  the 4th is -dE/d(phi) also in energy units). The 3rd term is the\n  energy of the 4-atom configuration for the specified angle.  The 4th\n  term (when present) is the negative derivative of the energy with\n  respect to the angle (in degrees, or radians depending on whether the\n  user selected DEGREES or RADIANS).  Thus the units of the last term\n  are still energy, not force. The dihedral angle values must increase\n  from one line to the next.\n  Dihedral table splines are cyclic.  There is no discontinuity at 180\n  degrees (or at any other angle).  Although in the examples above, the\n  angles range from -180 to 180 degrees, in general, the first angle in\n  the list can have any value (positive, zero, or negative).  However\n  the range of angles represented in the table must be strictly less\n  than 360 degrees (2pi radians) to avoid angle overlap.  (You may not\n  supply entries in the table for both 180 and -180, for example.)  If\n  the user’s table covers only a narrow range of dihedral angles,\n  strange numerical behavior can occur in the large remaining gap.\n  Parameters:\n  The parameter “N” is required and its value is the number of table\n  entries that follow. Note that this may be different than the N\n  specified in the dihedral_style table command.\n  Let Ntable is the number of table entries requested dihedral_style\n  command, and let Nfile be the parameter following “N” in the\n  tabulated file (“30” in the sparse example above).  What LAMMPS does\n  is a preliminary interpolation by creating splines using the Nfile\n  tabulated values as nodal points.  It uses these to interpolate as\n  needed to generate energy and derivative values at Ntable different\n  points (which are evenly spaced over a 360 degree range, even if the\n  angles in the file are not).  The resulting tables of length Ntable\n  are then used as described above, when computing energy and force for\n  individual dihedral angles and their atoms.  This means that if you\n  want the interpolation tables of length Ntable to match exactly what\n  is in the tabulated file (with effectively nopreliminary\n  interpolation), you should set Ntable = Nfile.  To insure the\n  nodal points in the user’s file are aligned with the interpolated\n  table entries, the angles in the table should be integer multiples of\n  360/Ntable degrees, or 2*PI/Ntable radians (depending on your\n  choice of angle units).\n  The optional “NOF” keyword allows the user to omit the forces\n  (negative energy derivatives) from the table file (normally located in\n  the 4th column).  In their place, forces will be calculated\n  automatically by differentiating the potential energy function\n  indicated by the 3rd column of the table (using either linear or\n  spline interpolation).\n  The optional “DEGREES” keyword allows the user to specify angles in\n  degrees instead of radians (default).\n  The optional “RADIANS” keyword allows the user to specify angles in\n  radians instead of degrees.  (Note: This changes the way the forces\n  are scaled in the 4th column of the data file.)\n  The optional “CHECKU” keyword is followed by a filename.  This allows\n  the user to save all of the Ntable different entries in the\n  interpolated energy table to a file to make sure that the interpolated\n  function agrees with the user’s expectations.  (Note: You can\n  temporarily increase the Ntable parameter to a high value for this\n  purpose.  “Ntable” is explained above.)\n  The optional “CHECKF” keyword is analogous to the “CHECKU” keyword.\n  It is followed by a filename, and it allows the user to check the\n  interpolated force table.  This option is available even if the user\n  selected the “NOF” option.\n  Note that one file can contain many sections, each with a tabulated\n  potential. LAMMPS reads the file section by section until it finds one\n  that matches the specified keyword.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  Restart info:\n  This dihedral style writes the settings for the “dihedral_style table”\n  command to binary restart files, so a dihedral_style\n  command does not need to specified in an input script that reads a\n  restart file.  However, the coefficient information is not stored in\n  the restart file, since it is tabulated in the potential files.  Thus,\n  dihedral_coeff commands do need to be specified in the restart input\n  script.\n  ",
    "syntax": "dihedral_style table style Ntable\n  \n  \n  \n  style = linear or spline = method of interpolation\n  Ntable = size of the internal lookup table\n  \n  ",
    "examples": "dihedral_style table spline 400\n  dihedral_style table linear 1000\n  dihedral_coeff 1 file.table DIH_TABLE1\n  dihedral_coeff 2 file.table DIH_TABLE2\n  \n  \n  ",
    "restrictions": "This dihedral style can only be used if LAMMPS was built with the\n  USER-MISC package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "dihedral_style table/cut",
    "description": "The table/cut dihedral style creates interpolation tables of length\n  Ntable from dihedral potential and derivative values listed in a\n  file(s) as a function of the dihedral angle “phi”.  In addition, an\n  analytic cutoff that is quadratic in the bond-angle (theta) is applied\n  in order to regularize the dihedral interaction.  The dihedral table\n  files are read by the dihedral_coeff command.\n  The interpolation tables are created by fitting cubic splines to the\n  file values and interpolating energy and derivative values at each of\n  Ntable dihedral angles. During a simulation, these tables are used\n  to interpolate energy and force values on individual atoms as\n  needed. The interpolation is done in one of 2 styles: linear or\n  spline.\n  For the linear style, the dihedral angle (phi) is used to find 2\n  surrounding table values from which an energy or its derivative is\n  computed by linear interpolation.\n  For the spline style, cubic spline coefficients are computed and\n  stored at each of the Ntable evenly-spaced values in the\n  interpolated table.  For a given dihedral angle (phi), the appropriate\n  coefficients are chosen from this list, and a cubic polynomial is used\n  to compute the energy and the derivative at this angle.\n  The following coefficients must be defined for each dihedral type via\n  the dihedral_coeff command as in the example\n  above.\n  \n  style (aat)\n  cutoff prefactor\n  cutoff angle1\n  cutoff angle2\n  filename\n  keyword\n  \n  The cutoff dihedral style uses a tabulated dihedral interaction with a\n  cutoff function:\n  \n  \\[\\begin{split}f(\\theta) & = K \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad \\theta < \\theta_1 \\\\\n  f(\\theta) & = K \\left(1-\\frac{(\\theta - \\theta_1)^2}{(\\theta_2 - \\theta_1)^2}\\right) \\qquad \\theta_1 < \\theta < \\theta_2\\end{split}\\]\n  The cutoff specifies an prefactor to the cutoff function.  While this value\n  would ordinarily equal 1 there may be situations where the value should change.\n  The cutoff \\(\\theta_1\\) specifies the angle (in degrees) below which the dihedral\n  interaction is unmodified, i.e. the cutoff function is 1.\n  The cutoff function is applied between \\(\\theta_1\\) and \\(\\theta_2\\), which is\n  the angle at which the cutoff function drops to zero.  The value of zero effectively\n  “turns off” the dihedral interaction.\n  The filename specifies a file containing tabulated energy and\n  derivative values. The keyword specifies a section of the file.  The\n  format of this file is described below.\n  \n  The format of a tabulated file is as follows (without the\n  parenthesized comments).  It can begin with one or more comment\n  or blank lines.\n  # Table of the potential and its negative derivative\n  \n  DIH_TABLE1                   (keyword is the first text on line)\n  N 30 DEGREES                 (N, NOF, DEGREES, RADIANS, CHECKU/F)\n                               (blank line)\n  1 -168.0 -1.40351172223 0.0423346818422\n  2 -156.0 -1.70447981034 0.00811786522531\n  3 -144.0 -1.62956100432 -0.0184129719987\n  ...\n  30 180.0 -0.707106781187 0.0719306095245\n  \n  # Example 2: table of the potential. Forces omitted\n  \n  DIH_TABLE2\n  N 30 NOF CHECKU testU.dat CHECKF testF.dat\n  \n  1 -168.0 -1.40351172223\n  2 -156.0 -1.70447981034\n  3 -144.0 -1.62956100432\n  ...\n  30 180.0 -0.707106781187\n  \n  \n  A section begins with a non-blank line whose 1st character is not a\n  “#”; blank lines or lines starting with “#” can be used as comments\n  between sections. The first line begins with a keyword which\n  identifies the section. The line can contain additional text, but the\n  initial text must match the argument specified in the\n  dihedral_coeff command. The next line lists (in\n  any order) one or more parameters for the table. Each parameter is a\n  keyword followed by one or more numeric values.\n  Following a blank line, the next N lines list the tabulated values. On\n  each line, the 1st value is the index from 1 to N, the 2nd value is\n  the angle value, the 3rd value is the energy (in energy units), and\n  the 4th is -dE/d(phi) also in energy units). The 3rd term is the\n  energy of the 4-atom configuration for the specified angle.  The 4th\n  term (when present) is the negative derivative of the energy with\n  respect to the angle (in degrees, or radians depending on whether the\n  user selected DEGREES or RADIANS).  Thus the units of the last term\n  are still energy, not force. The dihedral angle values must increase\n  from one line to the next.\n  Dihedral table splines are cyclic.  There is no discontinuity at 180\n  degrees (or at any other angle).  Although in the examples above, the\n  angles range from -180 to 180 degrees, in general, the first angle in\n  the list can have any value (positive, zero, or negative).  However\n  the range of angles represented in the table must be strictly less\n  than 360 degrees (2pi radians) to avoid angle overlap.  (You may not\n  supply entries in the table for both 180 and -180, for example.)  If\n  the user’s table covers only a narrow range of dihedral angles,\n  strange numerical behavior can occur in the large remaining gap.\n  Parameters:\n  The parameter “N” is required and its value is the number of table\n  entries that follow. Note that this may be different than the N\n  specified in the dihedral_style table command.\n  Let Ntable is the number of table entries requested dihedral_style\n  command, and let Nfile be the parameter following “N” in the\n  tabulated file (“30” in the sparse example above).  What LAMMPS does\n  is a preliminary interpolation by creating splines using the Nfile\n  tabulated values as nodal points.  It uses these to interpolate as\n  needed to generate energy and derivative values at Ntable different\n  points (which are evenly spaced over a 360 degree range, even if the\n  angles in the file are not).  The resulting tables of length Ntable\n  are then used as described above, when computing energy and force for\n  individual dihedral angles and their atoms.  This means that if you\n  want the interpolation tables of length Ntable to match exactly what\n  is in the tabulated file (with effectively nopreliminary\n  interpolation), you should set Ntable = Nfile.  To insure the\n  nodal points in the user’s file are aligned with the interpolated\n  table entries, the angles in the table should be integer multiples of\n  360/Ntable degrees, or 2*PI/Ntable radians (depending on your\n  choice of angle units).\n  The optional “NOF” keyword allows the user to omit the forces\n  (negative energy derivatives) from the table file (normally located in\n  the 4th column).  In their place, forces will be calculated\n  automatically by differentiating the potential energy function\n  indicated by the 3rd column of the table (using either linear or\n  spline interpolation).\n  The optional “DEGREES” keyword allows the user to specify angles in\n  degrees instead of radians (default).\n  The optional “RADIANS” keyword allows the user to specify angles in\n  radians instead of degrees.  (Note: This changes the way the forces\n  are scaled in the 4th column of the data file.)\n  The optional “CHECKU” keyword is followed by a filename.  This allows\n  the user to save all of the Ntable different entries in the\n  interpolated energy table to a file to make sure that the interpolated\n  function agrees with the user’s expectations.  (Note: You can\n  temporarily increase the Ntable parameter to a high value for this\n  purpose.  “Ntable” is explained above.)\n  The optional “CHECKF” keyword is analogous to the “CHECKU” keyword.\n  It is followed by a filename, and it allows the user to check the\n  interpolated force table.  This option is available even if the user\n  selected the “NOF” option.\n  Note that one file can contain many sections, each with a tabulated\n  potential. LAMMPS reads the file section by section until it finds one\n  that matches the specified keyword.\n  Restart info:\n  This dihedral style writes the settings for the “dihedral_style table/cut”\n  command to binary restart files, so a dihedral_style\n  command does not need to specified in an input script that reads a\n  restart file.  However, the coefficient information is not stored in\n  the restart file, since it is tabulated in the potential files.  Thus,\n  dihedral_coeff commands do need to be specified in the restart input\n  script.\n  ",
    "syntax": "dihedral_style table/cut style Ntable\n  \n  \n  \n  style = linear or spline = method of interpolation\n  Ntable = size of the internal lookup table\n  \n  ",
    "examples": "dihedral_style table/cut spline 400\n  dihedral_style table/cut linear 1000\n  dihedral_coeff 1 aat 1.0 177 180 file.table DIH_TABLE1\n  dihedral_coeff 2 aat 0.5 170 180 file.table DIH_TABLE2\n  \n  \n  ",
    "restrictions": "This dihedral style can only be used if LAMMPS was built with the\n  USER-MISC package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "dihedral_style zero",
    "description": "Using a dihedral style of zero means dihedral forces and energies are\n  not computed, but the geometry of dihedral quadruplets is still\n  accessible to other commands.\n  As an example, the compute dihedral/local command can be used to\n  compute the theta values for the list of quadruplets of dihedral atoms\n  listed in the data file read by the read_data\n  command.  If no dihedral style is defined, this command cannot be\n  used.\n  The optional nocoeff flag allows to read data files with a DihedralCoeff\n  section for any dihedral style. Similarly, any dihedral_coeff commands\n  will only be checked for the dihedral type number and the rest ignored.\n  Note that the dihedral_coeff command must be\n  used for all dihedral types, though no additional values are\n  specified.\n  ",
    "syntax": "dihedral_style zero [nocoeff]\n  \n  \n  ",
    "examples": "dihedral_style zero\n  dihedral_style zero nocoeff\n  dihedral_coeff *\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  Related commands: none\n  dihedral_style none\n  Default: none\n  "
},
{
    "command": "improper_style class2",
    "description": "The class2 improper style uses the potential\n  \n  \\[\\begin{split}E      = & E_i + E_{aa} \\\\\n  E_i    = & K [ \\frac{\\chi_{ijkl} + \\chi_{kjli} + \\chi_{ljik}}{3} - \\chi_0 ]^2 \\\\\n  E_{aa} = & M_1 (\\theta_{ijk} - \\theta_1) (\\theta_{kjl} - \\theta_3) + \\\\\n           & M_2 (\\theta_{ijk} - \\theta_1) (\\theta_{ijl} - \\theta_2) + \\\\\n           & M_3 (\\theta_{ijl} - \\theta_2) (\\theta_{kjl} - \\theta_3)\\end{split}\\]\n  where \\(E_i\\) is the improper term and \\(E_{aa}\\) is an\n  angle-angle term.  The 3 \\(\\chi\\) terms in \\(E_i\\) are an\n  average over 3 out-of-plane angles.\n  The 4 atoms in an improper quadruplet (listed in the data file read by\n  the read_data command) are ordered I,J,K,L.\n  \\(\\chi_{ijkl}\\) refers to the angle between the plane of I,J,K and\n  the plane of J,K,L, and the bond JK lies in both planes.  Similarly for\n  \\(\\chi_{kjli}\\) and \\(\\chi_{ljik}\\).\n  Note that atom J appears in the common bonds (JI, JK, JL) of all 3 X\n  terms.  Thus J (the 2nd atom in the quadruplet) is the atom of\n  symmetry in the 3 \\(\\chi\\) angles.\n  The subscripts on the various \\(\\theta\\)s refer to different\n  combinations of 3 atoms (I,J,K,L) used to form a particular angle.\n  E.g. \\(\\theta_{ijl}\\) is the angle formed by atoms I,J,L with J\n  in the middle.  \\(\\theta_1\\), \\(\\theta_2\\), \\(\\theta_3\\)\n  are the equilibrium positions of those angles.  Again,\n  atom J (the 2nd atom in the quadruplet) is the atom of symmetry in the\n  theta angles, since it is always the center atom.\n  Since atom J is the atom of symmetry, normally the bonds J-I, J-K, J-L\n  would exist for an improper to be defined between the 4 atoms, but\n  this is not required.\n  See (Sun) for a description of the COMPASS class2 force field.\n  Coefficients for the \\(E_i\\) and \\(E_{aa}\\) formulas must be\n  defined for each\n  improper type via the improper_coeff command as\n  in the example above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands.\n  These are the 2 coefficients for the \\(E_i\\) formula:\n  \n  \\(K\\) (energy/radian^2)\n  \\(\\chi_0\\) (degrees)\n  \n  \\(\\chi_0\\) is specified in degrees, but LAMMPS converts it to radians\n  internally; hence the units of K are in energy/radian^2.\n  For the \\(E_{aa}\\) formula, each line in a\n  improper_coeff command in the input script lists\n  7 coefficients, the first of which is aa to indicate they are\n  AngleAngle coefficients.  In a data file, these coefficients should be\n  listed under a AngleAngle Coeffs heading and you must leave out the\n  aa, i.e. only list 6 coefficients after the improper type.\n  \n  aa\n  \\(M_1\\) (energy/distance)\n  \\(M_2\\) (energy/distance)\n  \\(M_3\\) (energy/distance)\n  \\(\\theta_1\\) (degrees)\n  \\(\\theta_2\\) (degrees)\n  \\(\\theta_3\\) (degrees)\n  \n  The theta values are specified in degrees, but LAMMPS converts them to\n  radians internally; hence the units of M are in energy/radian^2.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "improper_style class2\n  \n  \n  ",
    "examples": "improper_style class2\n  improper_coeff 1 100.0 0\n  improper_coeff * aa 0.0 0.0 0.0 115.06 130.01 115.06\n  \n  \n  ",
    "restrictions": "This improper style can only be used if LAMMPS was built with the\n  CLASS2 package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "improper_style cossq",
    "description": "The cossq improper style uses the potential\n  \n  \\[E = \\frac{1}{2} K \\cos^2{\\left(\\chi - \\chi_0\\right)}\\]\n  where \\(\\chi\\) is the improper angle, \\(\\chi_0\\) is its\n  equilibrium value, and \\(K\\) is a prefactor.\n  If the 4 atoms in an improper quadruplet (listed in the data file read\n  by the read_data command) are ordered I,J,K,L then\n  \\(\\chi\\) is the angle between the plane of I,J,K and the plane of J,K,L.\n  Alternatively, you can think of atoms J,K,L as being in a plane, and\n  atom I above the plane, and \\(\\chi\\) as a measure of how far\n  out-of-plane I is with respect to the other 3 atoms.\n  Note that defining 4 atoms to interact in this way, does not mean that\n  bonds necessarily exist between I-J, J-K, or K-L, as they would in a\n  linear dihedral.  Normally, the bonds I-J, I-K, I-L would exist for an\n  improper to be defined between the 4 atoms.\n  The following coefficients must be defined for each improper type via\n  the improper_coeff command as in the example\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands:\n  \n  \\(K\\) (energy)\n  \\(\\chi_0\\) (degrees)\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "improper_style cossq\n  \n  \n  ",
    "examples": "improper_style cossq\n  improper_coeff 1 4.0 0.0\n  \n  \n  ",
    "restrictions": "This improper style can only be used if LAMMPS was built with the\n  USER-MISC package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "improper_style cvff",
    "description": "The cvff improper style uses the potential\n  \n  \\[E = K [1 + d  \\cos (n \\phi) ]\\]\n  where phi is the improper dihedral angle.\n  If the 4 atoms in an improper quadruplet (listed in the data file read\n  by the read_data command) are ordered I,J,K,L then\n  the improper dihedral angle is between the plane of I,J,K and the\n  plane of J,K,L.  Note that because this is effectively a dihedral\n  angle, the formula for this improper style is the same as for\n  dihedral_style harmonic.\n  Note that defining 4 atoms to interact in this way, does not mean that\n  bonds necessarily exist between I-J, J-K, or K-L, as they would in a\n  linear dihedral.  Normally, the bonds I-J, I-K, I-L would exist for an\n  improper to be defined between the 4 atoms.\n  The following coefficients must be defined for each improper type via\n  the improper_coeff command as in the example\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands:\n  \n  \\(K\\) (energy)\n  \\(d\\) (+1 or -1)\n  \\(n\\) (0,1,2,3,4,6)\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "improper_style cvff\n  \n  \n  ",
    "examples": "improper_style cvff\n  improper_coeff 1 80.0 -1 4\n  \n  \n  ",
    "restrictions": "This improper style can only be used if LAMMPS was built with the\n  MOLECULE package.  See the Build package doc page\n  for more info.\n  "
},
{
    "command": "improper_style distance",
    "description": "The distance improper style uses the potential\n  \n  \\[E = K_2 d^2 + K_4 d^4\\]\n  where \\(d\\) is the distance between the central atom and the plane formed\n  by the other three atoms.  If the 4 atoms in an improper quadruplet\n  (listed in the data file read by the read_data\n  command) are ordered I,J,K,L then the I-atom is assumed to be the\n  central atom.\n  \n  Note that defining 4 atoms to interact in this way, does not mean that\n  bonds necessarily exist between I-J, J-K, or K-L, as they would in a\n  linear dihedral. Normally, the bonds I-J, I-K, I-L would exist for an\n  improper to be defined between the 4 atoms.\n  The following coefficients must be defined for each improper type via\n  the improper_coeff command as in the example above, or in the data\n  file or restart files read by the read_data or read_restart commands:\n  \n  \\(K_2\\) (energy/distance^2)\n  \\(K_4\\) (energy/distance^4)\n  \n  ",
    "syntax": "improper_style distance\n  \n  \n  ",
    "examples": "improper_style distance\n  improper_coeff 1 80.0 100.0\n  \n  \n  ",
    "restrictions": "This improper style can only be used if LAMMPS was built with the\n  USER-MISC package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "improper_style distharm",
    "description": "The distharm improper style uses the potential\n  \n  \\[E = K (d - d_0)^2\\]\n  where \\(d\\) is the oriented distance between the central atom and the plane formed\n  by the other three atoms.  If the 4 atoms in an improper quadruplet\n  (listed in the data file read by the read_data\n  command) are ordered I,J,K,L then the L-atom is assumed to be the\n  central atom. Note that this is different from the convention used\n  in the improper_style distance. The distance \\(d\\) is oriented and can take\n  on negative values. This may lead to unwanted behavior if \\(d_0\\) is not equal to zero.\n  The following coefficients must be defined for each improper type via\n  the improper_coeff command as in the example above, or in the data\n  file or restart files read by the read_data or read_restart commands:\n  \n  \\(K\\) (energy/distance^2)\n  \\(d_0\\) (distance)\n  \n  ",
    "syntax": "improper_style distharm\n  \n  \n  ",
    "examples": "improper_style distharm\n  improper_coeff 1 25.0 0.5\n  \n  \n  ",
    "restrictions": "This improper style can only be used if LAMMPS was built with the\n  USER-YAFF package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "improper_style fourier",
    "description": "The fourier improper style uses the following potential:\n  \n  \\[E = K [C_0 + C_1 \\cos ( \\omega) + C_2 \\cos( 2 \\omega) ]\\]\n  where K is the force constant, C0, C1, C2 are dimensionless coefficients,\n  and omega is the angle between the IL axis and the IJK plane:\n  \n  If all parameter (see below) is not zero, the all the three possible angles will taken in account.\n  The following coefficients must be defined for each improper type via\n  the improper_coeff command as in the example\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands:\n  \n  \\(K\\) (energy)\n  \\(C_0\\) (unitless)\n  \\(C_1\\) (unitless)\n  \\(C_2\\) (unitless)\n  all  (0 or 1, optional)\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "improper_style fourier\n  \n  \n  ",
    "examples": "improper_style fourier\n  improper_coeff 1 100.0 0.0 1.0 0.5 1\n  \n  \n  ",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\n  USER_MISC package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "improper_style harmonic",
    "description": "The harmonic improper style uses the potential\n  \n  \\[E = K (\\chi - \\chi_0)^2\\]\n  where \\(\\chi\\) is the improper angle, \\(\\chi_0\\) is its equilibrium\n  value, and \\(K\\) is a prefactor.  Note that the usual 1/2 factor is\n  included in \\(K\\).\n  If the 4 atoms in an improper quadruplet (listed in the data file read\n  by the read_data command) are ordered I,J,K,L then\n  \\(\\chi\\)\n  is the angle between the plane of I,J,K and the plane of J,K,L.\n  Alternatively, you can think of atoms J,K,L as being in a plane, and\n  atom I above the plane, and \\(\\chi\\) as a measure of how far out-of-plane\n  I is with respect to the other 3 atoms.\n  Note that defining 4 atoms to interact in this way, does not mean that\n  bonds necessarily exist between I-J, J-K, or K-L, as they would in a\n  linear dihedral.  Normally, the bonds I-J, I-K, I-L would exist for an\n  improper to be defined between the 4 atoms.\n  The following coefficients must be defined for each improper type via\n  the improper_coeff command as in the example\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands:\n  \n  \\(K\\) (energy/radian^2)\n  \\(\\chi_0\\) (degrees)\n  \n  \\(\\chi_0\\) is specified in degrees, but LAMMPS converts it to radians\n  internally; hence the units of K are in energy/radian^2.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "improper_style harmonic\n  \n  \n  ",
    "examples": "improper_style harmonic\n  improper_coeff 1 100.0 0\n  \n  \n  ",
    "restrictions": "This improper style can only be used if LAMMPS was built with the\n  MOLECULE package.  See the Build package doc page\n  for more info.\n  "
},
{
    "command": "improper_style hybrid",
    "description": "The hybrid style enables the use of multiple improper styles in one\n  simulation.  An improper style is assigned to each improper type.  For\n  example, impropers in a polymer flow (of improper type 1) could be\n  computed with a harmonic potential and impropers in the wall\n  boundary (of improper type 2) could be computed with a cvff\n  potential.  The assignment of improper type to style is made via the\n  improper_coeff command or in the data file.\n  In the improper_coeff command, the first coefficient sets the improper\n  style and the remaining coefficients are those appropriate to that\n  style.  In the example above, the 2 improper_coeff commands would set\n  impropers of improper type 1 to be computed with a harmonic\n  potential with coefficients 120.0, 30 for \\(K\\), \\(\\chi_0\\).\n  Improper type 2 would be computed with a cvff potential with coefficients\n  20.0, -1, 2 for K, d, and n, respectively.\n  If the improper class2 potential is one of the hybrid styles, it\n  requires additional AngleAngle coefficients be specified in the data\n  file.  These lines must also have an additional “class2” argument\n  added after the improper type.  For improper types which are assigned\n  to other hybrid styles, use the style name (e.g. “harmonic”)\n  appropriate to that style.  The AngleAngle coeffs for that improper\n  type will then be ignored.\n  An improper style of none can be specified as the 2nd argument to\n  the improper_coeff command, if you desire to turn off certain improper\n  types.\n  ",
    "syntax": "improper_style hybrid style1 style2 ...\n  \n  \n  \n  style1,style2 = list of one or more improper styles\n  \n  ",
    "examples": "improper_style hybrid harmonic helix\n  improper_coeff 1 harmonic 120.0 30\n  improper_coeff 2 cvff 20.0 -1 2\n  \n  \n  ",
    "restrictions": "This improper style can only be used if LAMMPS was built with the\n  MOLECULE package.  See the Build package doc page\n  for more info.\n  Unlike other improper styles, the hybrid improper style does not store\n  improper coefficient info for individual sub-styles in a binary restart files.\n  Thus when restarting a simulation from a\n  restart file, you need to re-specify improper_coeff commands.\n  "
},
{
    "command": "improper_style inversion/harmonic",
    "description": "The inversion/harmonic improper style follows the Wilson-Decius\n  out-of-plane angle definition and uses an harmonic potential:\n  \n  \\[E = K \\left(\\omega - \\omega_0\\right)^2\\]\n  where \\(K\\) is the force constant and \\(\\omega\\) is the angle\n  evaluated for all three axis-plane combinations centered around the atom I.\n  For the IL axis and the IJK plane \\(\\omega\\) looks as follows:\n  \n  Note that the inversion/harmonic angle term evaluation differs to\n  the improper_umbrella due to the cyclic\n  evaluation of all possible angles \\(\\omega\\).\n  The following coefficients must be defined for each improper type via\n  the improper_coeff command as in the example\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands:\n  \n  \\(K\\) (energy)\n  \\(\\omega_0\\) (degrees)\n  \n  If \\(\\omega_0 = 0\\) the potential term has a single minimum for\n  the planar structure.  Otherwise it has two minima at +/- \\(\\omega_0\\),\n  with a barrier in between.\n  ",
    "syntax": "improper_style inversion/harmonic\n  \n  \n  ",
    "examples": "improper_style inversion/harmonic\n  improper_coeff 1 18.776340 0.000000\n  \n  \n  ",
    "restrictions": "This improper style can only be used if LAMMPS was built with the\n  USER-MOFFF package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "improper_style none",
    "description": "Using an improper style of none means improper forces and energies are\n  not computed, even if quadruplets of improper atoms were listed in the\n  data file read by the read_data command.\n  See the improper_style zero command for a way to\n  calculate improper statistics, but compute no improper interactions.\n  ",
    "syntax": "improper_style none\n  \n  \n  ",
    "examples": "improper_style none\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "improper_style ring",
    "description": "The ring improper style uses the potential\n  \n  \\[\\begin{split}E = &\\frac{1}{6} K \\left(\\Delta_{ijl} + \\Delta_{ijk} + \\Delta_{kjl} \\right)^6 \\\\\n  \\Delta_{ijl} = & \\cos{\\theta_{ijl} - \\cos{\\theta_0}} \\\\\n  \\Delta_{ijk} = & \\cos{\\theta_{ijk} - \\cos{\\theta_0}} \\\\\n  \\Delta_{kjl} = & \\cos{\\theta_{kjl} - \\cos{\\theta_0}}\\end{split}\\]\n  where \\(K\\) is a prefactor, \\(\\theta\\) is the angle formed by\n  the atoms specified by (i,j,k,l) indices and \\(\\theta_0\\) its\n  equilibrium value.\n  If the 4 atoms in an improper quadruplet (listed in the data file read\n  by the read_data command) are ordered i,j,k,l then\n  \\(\\theta_{ijl}\\) is the angle between atoms i,j and l,\n  \\(\\theta_{ijk}\\) is the angle between atoms i,j and k,\n  \\(\\theta_{kjl}\\) is the angle between atoms j,k, and l.\n  The “ring” improper style implements the improper potential introduced\n  by Destree et al., in Equation (9) of (Destree).  This\n  potential does not affect small amplitude vibrations but is used in an\n  ad-hoc way to prevent the onset of accidentally large amplitude\n  fluctuations leading to the occurrence of a planar conformation of the\n  three bonds i-j, j-k and j-l, an intermediate conformation toward the\n  chiral inversion of a methine carbon.  In the “Impropers” section of\n  data file four atoms: i, j, k and l are specified with i,j and l lying\n  on the backbone of the chain and k specifying the chirality of j.\n  The following coefficients must be defined for each improper type via\n  the improper_coeff command as in the example\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands:\n  \n  \\(K\\) (energy)\n  \\(\\theta_0\\) (degrees)\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "improper_style ring\n  \n  \n  ",
    "examples": "improper_style ring\n  improper_coeff 1 8000 70.5\n  \n  \n  ",
    "restrictions": "This improper style can only be used if LAMMPS was built with the\n  USER-MISC package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "improper_style sqdistharm",
    "description": "The sqdistharm improper style uses the potential\n  \n  \\[E = K (d^2 - {d_0}^2)^2\\]\n  where \\(d\\) is the distance between the central atom and the plane formed\n  by the other three atoms.  If the 4 atoms in an improper quadruplet\n  (listed in the data file read by the read_data\n  command) are ordered I,J,K,L then the L-atom is assumed to be the\n  central atom. Note that this is different from the convention used\n  in the improper_style distance.\n  The following coefficients must be defined for each improper type via\n  the improper_coeff command as in the example above, or in the data\n  file or restart files read by the read_data or read_restart commands:\n  \n  \\(K\\) (energy/distance^4)\n  \\({d_0}^2\\) (distance^2)\n  \n  Note that \\({d_0}^2\\) (in units distance^2) has be provided and not \\(d_0\\).\n  ",
    "syntax": "improper_style sqdistharm\n  \n  \n  ",
    "examples": "improper_style sqdistharm\n  improper_coeff 1 50.0 0.1\n  \n  \n  ",
    "restrictions": "This improper style can only be used if LAMMPS was built with the\n  USER-MISC package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "improper_style umbrella",
    "description": "The umbrella improper style uses the following potential, which is\n  commonly referred to as a classic inversion and used in the\n  DREIDING force field:\n  \n  \\[\\begin{split}E = & \\frac{1}{2}K\\left( \\frac{1}{\\sin\\omega_0}\\right) ^2 \\left( \\cos\\omega - \\cos\\omega_0\\right) ^2 \\qquad \\omega_0 \\neq 0^o \\\\\n  E = & K\\left( 1-cos\\omega\\right)  \\qquad \\omega_0 = 0^o\\end{split}\\]\n  where \\(K\\) is the force constant and \\(\\omega\\) is the angle between the IL\n  axis and the IJK plane:\n  \n  If \\(\\omega_0 = 0\\) the potential term has a minimum for the planar\n  structure.  Otherwise it has two minima at \\(\\omega +/- \\omega_0\\),\n  with a barrier in between.\n  See (Mayo) for a description of the DREIDING force field.\n  The following coefficients must be defined for each improper type via\n  the improper_coeff command as in the example\n  above, or in the data file or restart files read by the\n  read_data or read_restart\n  commands:\n  \n  \\(K\\) (energy)\n  \\(\\omega_0\\) (degrees)\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "improper_style umbrella\n  \n  \n  ",
    "examples": "improper_style umbrella\n  improper_coeff 1 100.0 180.0\n  \n  \n  ",
    "restrictions": "This improper style can only be used if LAMMPS was built with the\n  MOLECULE package.  See the Build package doc page\n  for more info.\n  "
},
{
    "command": "dihedral_style fourier",
    "description": "The fourier dihedral style uses the potential:\n  \n  \\[E = \\sum_{i=1,m} K_i  [ 1.0 + \\cos ( n_i \\phi - d_i ) ]\\]\n  The following coefficients must be defined for each dihedral type via the\n  dihedral_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(m\\) (integer >=1)\n  \\(K_1\\) (energy)\n  \\(n_1\\) (integer >= 0)\n  \\(d_1\\) (degrees)\n  […]\n  \\(K_m\\) (energy)\n  \\(n_m\\) (integer >= 0)\n  \\(d_m\\) (degrees)\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "dihedral_style fourier\n  \n  \n  ",
    "examples": "dihedral_style fourier\n  dihedral_coeff 1 3 -0.846200 3 0.0 7.578800 1 0 0.138000 2 -180.0\n  \n  \n  ",
    "restrictions": "This angle style can only be used if LAMMPS was built with the\n  USER_MISC package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "bond_style class2",
    "description": "The class2 bond style uses the potential\n  \n  \\[E = K_2 (r - r_0)^2 + K_3 (r - r_0)^3 + K_4 (r - r_0)^4\\]\n  where \\(r_0\\) is the equilibrium bond distance.\n  See (Sun) for a description of the COMPASS class2 force field.\n  The following coefficients must be defined for each bond type via the\n  bond_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(r_0\\) (distance)\n  \\(K_2\\) (energy/distance^2)\n  \\(K_3\\) (energy/distance^3)\n  \\(K_4\\) (energy/distance^4)\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "bond_style class2\n  \n  \n  ",
    "examples": "bond_style class2\n  bond_coeff 1 1.0 100.0 80.0 80.0\n  \n  \n  ",
    "restrictions": "This bond style can only be used if LAMMPS was built with the CLASS2\n  package.  See the Build package doc page for more\n  info.\n  "
},
{
    "command": "bond_style fene",
    "description": "The fene bond style uses the potential\n  \n  \\[E = -0.5 K R_0^2  \\ln \\left[ 1 - \\left(\\frac{r}{R_0}\\right)^2\\right] + 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6 \\right] + \\epsilon\\]\n  to define a finite extensible nonlinear elastic (FENE) potential\n  (Kremer), used for bead-spring polymer models.  The first\n  term is attractive, the 2nd Lennard-Jones term is repulsive.  The\n  first term extends to \\(R_0\\), the maximum extent of the bond.  The 2nd\n  term is cutoff at \\(2^\\frac{1}{6} \\sigma\\), the minimum of the LJ potential.\n  The following coefficients must be defined for each bond type via the\n  bond_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(K\\) (energy/distance^2)\n  \\(R_0\\) (distance)\n  \\(\\epsilon\\) (energy)\n  \\(\\sigma\\) (distance)\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "bond_style fene\n  \n  \n  ",
    "examples": "bond_style fene\n  bond_coeff 1 30.0 1.5 1.0 1.0\n  \n  \n  ",
    "restrictions": "This bond style can only be used if LAMMPS was built with the MOLECULE\n  package.  See the Build package doc page for more\n  info.\n  You typically should specify special_bonds fene\n  or special_bonds lj/coul 0 1 1 to use this bond\n  style.  LAMMPS will issue a warning it that’s not the case.\n  "
},
{
    "command": "bond_style fene/expand",
    "description": "The fene/expand bond style uses the potential\n  \n  \\[E = -0.5 K R_0^2 \\ln \\left[1 -\\left( \\frac{\\left(r - \\Delta\\right)}{R_0}\\right)^2 \\right] + 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{\\left(r - \\Delta\\right)}\\right)^{12} - \\left(\\frac{\\sigma}{\\left(r - \\Delta\\right)}\\right)^6 \\right] + \\epsilon\\]\n  to define a finite extensible nonlinear elastic (FENE) potential\n  (Kremer), used for bead-spring polymer models.  The first\n  term is attractive, the 2nd Lennard-Jones term is repulsive.\n  The fene/expand bond style is similar to fene except that an extra\n  shift factor of \\(\\Delta\\) (positive or negative) is added to \\(r\\) to\n  effectively change the bead size of the bonded atoms.  The first term\n  now extends to \\(R_0 + \\Delta\\) and the 2nd term is cutoff at \\(2^\\frac{1}{6} \\sigma + \\Delta\\).\n  The following coefficients must be defined for each bond type via the\n  bond_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(K\\) (energy/distance^2)\n  \\(R_0\\) (distance)\n  \\(\\epsilon\\) (energy)\n  \\(\\sigma\\) (distance)\n  \\(\\Delta\\) (distance)\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "bond_style fene/expand\n  \n  \n  ",
    "examples": "bond_style fene/expand\n  bond_coeff 1 30.0 1.5 1.0 1.0 0.5\n  \n  \n  ",
    "restrictions": "This bond style can only be used if LAMMPS was built with the MOLECULE\n  package.  See the Build package doc page for more\n  info.\n  You typically should specify special_bonds fene\n  or special_bonds lj/coul 0 1 1 to use this bond\n  style.  LAMMPS will issue a warning it that’s not the case.\n  "
},
{
    "command": "bond_style gromos",
    "description": "The gromos bond style uses the potential\n  \n  \\[E = K (r^2 - r_0^2)^2\\]\n  where \\(r_0\\) is the equilibrium bond distance.  Note that the usual 1/4\n  factor is included in \\(K\\).\n  The following coefficients must be defined for each bond type via the\n  bond_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(K\\) (energy/distance^4)\n  \\(r_0\\) (distance)\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "bond_style gromos\n  \n  \n  ",
    "examples": "bond_style gromos\n  bond_coeff 5 80.0 1.2\n  \n  \n  ",
    "restrictions": "This bond style can only be used if LAMMPS was built with the MOLECULE\n  package.  See the Build package doc page for more\n  info.\n  "
},
{
    "command": "bond_style harmonic",
    "description": "The harmonic bond style uses the potential\n  \n  \\[E = K (r - r_0)^2\\]\n  where \\(r_0\\) is the equilibrium bond distance.  Note that the usual 1/2\n  factor is included in \\(K\\).\n  The following coefficients must be defined for each bond type via the\n  bond_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(K\\) (energy/distance^2)\n  \\(r_0\\) (distance)\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "bond_style harmonic\n  \n  \n  ",
    "examples": "bond_style harmonic\n  bond_coeff 5 80.0 1.2\n  \n  \n  ",
    "restrictions": "This bond style can only be used if LAMMPS was built with the MOLECULE\n  package.  See the Build package doc page for more\n  info.\n  "
},
{
    "command": "bond_style harmonic/shift",
    "description": "The harmonic/shift bond style is a shifted harmonic bond that uses\n  the potential\n  \n  \\[E = \\frac{U_{\\text{min}}}{(r_0-r_c)^2} \\left[ (r-r_0)^2-(r_c-r_0)^2 \\right]\\]\n  where \\(r_0\\) is the equilibrium bond distance, and \\(r_c\\) the critical distance.\n  The potential is \\(-U_{\\text{min}}\\) at \\(r0\\) and zero at \\(r_c\\). The spring constant is\n  \\(k = U_{\\text{min}} / [ 2 (r_0-r_c)^2]\\).\n  The following coefficients must be defined for each bond type via the\n  bond_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(U_{\\text{min}}\\) (energy)\n  \\(r_0\\) (distance)\n  \\(r_c\\) (distance)\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "bond_style harmonic/shift\n  \n  \n  ",
    "examples": "bond_style harmonic/shift\n  bond_coeff 5 10.0 0.5 1.0\n  \n  \n  ",
    "restrictions": "This bond style can only be used if LAMMPS was built with the\n  USER-MISC package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "bond_style harmonic/shift/cut",
    "description": "The harmonic/shift/cut bond style is a shifted harmonic bond that\n  uses the potential\n  \n  \\[E = \\frac{U_{\\text{min}}}{(r_0-r_c)^2} \\left[ (r-r_0)^2-(r_c-r_0)^2 \\right]\\]\n  where \\(r_0\\) is the equilibrium bond distance, and rc the critical distance.\n  The bond potential is zero for distances \\(r > r_c\\). The potential is \\(-U_{\\text{min}}\\)\n  at \\(r_0\\) and zero at \\(r_c\\). The spring constant is \\(k = U_{\\text{min}} / [ 2 (r_0-r_c)^2]\\).\n  The following coefficients must be defined for each bond type via the\n  bond_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(U_{\\text{min}}\\) (energy)\n  \\(r_0\\) (distance)\n  \\(r_c\\) (distance)\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "bond_style harmonic/shift/cut\n  \n  \n  ",
    "examples": "bond_style harmonic/shift/cut\n  bond_coeff 5 10.0 0.5 1.0\n  \n  \n  ",
    "restrictions": "This bond style can only be used if LAMMPS was built with the\n  USER-MISC package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "bond_style hybrid",
    "description": "The hybrid style enables the use of multiple bond styles in one\n  simulation.  A bond style is assigned to each bond type.  For example,\n  bonds in a polymer flow (of bond type 1) could be computed with a\n  fene potential and bonds in the wall boundary (of bond type 2) could\n  be computed with a harmonic potential.  The assignment of bond type\n  to style is made via the bond_coeff command or in\n  the data file.\n  In the bond_coeff commands, the name of a bond style must be added\n  after the bond type, with the remaining coefficients being those\n  appropriate to that style.  In the example above, the 2 bond_coeff\n  commands set bonds of bond type 1 to be computed with a harmonic\n  potential with coefficients 80.0, 1.2 for \\(K\\), \\(r_0\\).  All other bond types\n  (2-N) are computed with a fene potential with coefficients 30.0,\n  1.5, 1.0, 1.0 for \\(K\\), \\(R_0\\), \\(\\epsilon\\), \\(\\sigma\\).\n  If bond coefficients are specified in the data file read via the\n  read_data command, then the same rule applies.\n  E.g. “harmonic” or “fene” must be added after the bond type, for each\n  line in the “Bond Coeffs” section, e.g.\n  Bond Coeffs\n  \n  1 harmonic 80.0 1.2\n  2 fene 30.0 1.5 1.0 1.0\n  ...\n  \n  \n  A bond style of none with no additional coefficients can be used in\n  place of a bond style, either in a input script bond_coeff command or\n  in the data file, if you desire to turn off interactions for specific\n  bond types.\n  ",
    "syntax": "bond_style hybrid style1 style2 ...\n  \n  \n  \n  style1,style2 = list of one or more bond styles\n  \n  ",
    "examples": "",
    "restrictions": "This bond style can only be used if LAMMPS was built with the MOLECULE\n  package.  See the Build package doc page for more\n  info.\n  Unlike other bond styles, the hybrid bond style does not store bond\n  coefficient info for individual sub-styles in a binary restart files.  Thus when restarting a simulation from a restart\n  file, you need to re-specify bond_coeff commands.\n  "
},
{
    "command": "bond_style mm3",
    "description": "The mm3 bond style uses the potential that is anharmonic in the bond\n  as defined in (Allinger)\n  \n  \\[E = K (r - r_0)^2 \\left[ 1 - 2.55(r-r_0) + (7/12) 2.55^2(r-r_0)^2 \\right]\\]\n  where \\(r_0\\) is the equilibrium value of the bond, and \\(K\\) is a\n  prefactor. The anharmonic prefactors have units angstrom^(-n):\n  -2.55 angstrom^(-1) and (7/12)2.55^2 angstrom^(-2). The code takes\n  care of the necessary unit conversion for these factors internally.\n  Note that the MM3 papers contains an error in Eq (1):\n  (7/12)2.55 should be replaced with (7/12)2.55^2\n  The following coefficients must be defined for each bond type via the\n  bond_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(K\\) (energy/distance^2)\n  \\(r_0\\) (distance)\n  \n  ",
    "syntax": "bond_style mm3\n  \n  \n  ",
    "examples": "bond_style mm3\n  bond_coeff 1 100.0 107.0\n  \n  \n  ",
    "restrictions": "This bond style can only be used if LAMMPS was built with the\n  USER_YAFF package.  See the Build package doc\n  page for more info.\n  "
},
{
    "command": "bond_style morse",
    "description": "The morse bond style uses the potential\n  \n  \\[E = D \\left[ 1 - e^{-\\alpha (r - r_0)} \\right]^2\\]\n  where \\(r_0\\) is the equilibrium bond distance, \\(\\alpha\\) is a stiffness\n  parameter, and \\(D\\) determines the depth of the potential well.\n  The following coefficients must be defined for each bond type via the\n  bond_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(D\\) (energy)\n  \\(\\alpha\\) (inverse distance)\n  \\(r_0\\) (distance)\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "bond_style morse\n  \n  \n  ",
    "examples": "bond_style morse\n  bond_coeff 5 1.0 2.0 1.2\n  \n  \n  ",
    "restrictions": "This bond style can only be used if LAMMPS was built with the MOLECULE\n  package.  See the Build package doc page for more\n  info.\n  "
},
{
    "command": "bond_style none",
    "description": "Using a bond style of none means bond forces and energies are not\n  computed, even if pairs of bonded atoms were listed in the data file\n  read by the read_data command.\n  See the bond_style zero command for a way to\n  calculate bond statistics, but compute no bond interactions.\n  ",
    "syntax": "bond_style none\n  \n  \n  ",
    "examples": "bond_style none\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  Related commands: none\n  bond_style zero\n  Default: none\n  "
},
{
    "command": "bond_style nonlinear",
    "description": "The nonlinear bond style uses the potential\n  \n  \\[E = \\frac{\\epsilon (r - r_0)^2}{ [ \\lambda^2 - (r - r_0)^2 ]}\\]\n  to define an anharmonic spring (Rector) of equilibrium\n  length \\(r_0\\) and maximum extension lamda.\n  The following coefficients must be defined for each bond type via the\n  bond_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(\\epsilon\\) (energy)\n  \\(r_0\\) (distance)\n  \\(\\lambda\\) (distance)\n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "bond_style nonlinear\n  \n  \n  ",
    "examples": "bond_style nonlinear\n  bond_coeff 2 100.0 1.1 1.4\n  \n  \n  ",
    "restrictions": "This bond style can only be used if LAMMPS was built with the MOLECULE\n  package.  See the Build package doc page for more\n  info.\n  "
},
{
    "command": "bond_style oxdna/fene",
    "description": "The oxdna/fene , oxdna2/fene and oxrna2/fene bond styles use the potential\n  \n  \\[E = - \\frac{\\epsilon}{2} \\ln \\left[ 1 - \\left(\\frac{r-r_0}{\\Delta}\\right)^2\\right]\\]\n  to define a modified finite extensible nonlinear elastic (FENE)\n  potential (Ouldridge) to model the connectivity of the\n  phosphate backbone in the oxDNA/oxRNA force field for coarse-grained\n  modelling of DNA/RNA.\n  The following coefficients must be defined for the bond type via the\n  bond_coeff command as given in the above example, or\n  in the data file or restart files read by the\n  read_data or read_restart\n  commands:\n  \n  \\(\\epsilon\\) (energy)\n  \\(\\Delta\\) (distance)\n  \\(r_0\\) (distance)\n  \n  \n  Note\n  The oxDNA bond style has to be used together with the\n  corresponding oxDNA pair styles for excluded volume interaction\n  oxdna/excv , stacking oxdna/stk , cross-stacking oxdna/xstk and\n  coaxial stacking interaction oxdna/coaxstk as well as\n  hydrogen-bonding interaction oxdna/hbond (see also documentation of\n  pair_style oxdna/excv). For the oxDNA2\n  (Snodin) bond style the analogous pair styles\n  oxdna2/excv , oxdna2/stk , oxdna2/xstk , oxdna2/coaxstk ,\n  oxdna2/hbond and an additional Debye-Hueckel pair style\n  oxdna2/dh have to be defined. The same applies to the oxRNA2\n  (Sulc1) styles.\n  The coefficients in the above example have to be kept fixed and cannot\n  be changed without reparameterizing the entire model.\n  \n  Example input and data files for DNA and RNA duplexes can be found in\n  examples/USER/cgdna/examples/oxDNA/ , /oxDNA2/ and /oxRNA2/.  A simple python\n  setup tool which creates single straight or helical DNA strands, DNA/RNA\n  duplexes or arrays of DNA/RNA duplexes can be found in\n  examples/USER/cgdna/util/.\n  Please cite (Henrich) in any publication that uses\n  this implementation.  The article contains general information\n  on the model, its implementation and performance as well as the structure of\n  the data and input file. The preprint version of the article can be found\n  here.\n  Please cite also the relevant oxDNA/oxRNA publications. These are\n  (Ouldridge) and\n  (Ouldridge-DPhil) for oxDNA,\n  (Snodin) for oxDNA2,\n  (Sulc1) for oxRNA2\n  and for sequence-specific hydrogen-bonding and stacking interactions\n  (Sulc2).\n  ",
    "syntax": "bond_style oxdna/fene\n  \n  bond_style oxdna2/fene\n  \n  bond_style oxrna2/fene\n  \n  \n  ",
    "examples": "bond_style oxdna/fene\n  bond_coeff * 2.0 0.25 0.7525\n  \n  bond_style oxdna2/fene\n  bond_coeff * 2.0 0.25 0.7564\n  \n  bond_style oxrna2/fene\n  bond_coeff * 2.0 0.25 0.76107\n  \n  \n  ",
    "restrictions": "This bond style can only be used if LAMMPS was built with the\n  USER-CGDNA package and the MOLECULE and ASPHERE package.  See the\n  Build package doc page for more info.\n  "
},
{
    "command": "bond_style table",
    "description": "Style table creates interpolation tables of length N from bond\n  potential and force values listed in a file(s) as a function of bond\n  length.  The files are read by the bond_coeff\n  command.\n  The interpolation tables are created by fitting cubic splines to the\n  file values and interpolating energy and force values at each of N\n  distances.  During a simulation, these tables are used to interpolate\n  energy and force values as needed.  The interpolation is done in one\n  of 2 styles: linear or spline.\n  For the linear style, the bond length is used to find 2 surrounding\n  table values from which an energy or force is computed by linear\n  interpolation.\n  For the spline style, a cubic spline coefficients are computed and\n  stored at each of the N values in the table.  The bond length is\n  used to find the appropriate set of coefficients which are used to\n  evaluate a cubic polynomial which computes the energy or force.\n  The following coefficients must be defined for each bond type via the\n  bond_coeff command as in the example above.\n  \n  filename\n  keyword\n  \n  The filename specifies a file containing tabulated energy and force\n  values.  The keyword specifies a section of the file.  The format of\n  this file is described below.\n  \n  The format of a tabulated file is as follows (without the\n  parenthesized comments):\n  # Bond potential for harmonic (one or more comment or blank lines)\n  \n  HAM                           (keyword is the first text on line)\n  N 101 FP 0 0 EQ 0.5           (N, FP, EQ  parameters)\n                                (blank line)\n  1 0.00 338.0000 1352.0000     (index, bond-length, energy, force)\n  2 0.01 324.6152 1324.9600\n  ...\n  101 1.00 338.0000 -1352.0000\n  \n  \n  A section begins with a non-blank line whose 1st character is not a\n  “#”; blank lines or lines starting with “#” can be used as comments\n  between sections.  The first line begins with a keyword which\n  identifies the section.  The line can contain additional text, but the\n  initial text must match the argument specified in the\n  bond_coeff command.  The next line lists (in any\n  order) one or more parameters for the table.  Each parameter is a\n  keyword followed by one or more numeric values.\n  The parameter “N” is required and its value is the number of table\n  entries that follow.  Note that this may be different than the N\n  specified in the bond_style table command.  Let\n  Ntable = N in the bond_style command, and Nfile = “N” in the\n  tabulated file.  What LAMMPS does is a preliminary interpolation by\n  creating splines using the Nfile tabulated values as nodal points.  It\n  uses these to interpolate as needed to generate energy and force\n  values at Ntable different points.  The resulting tables of length\n  Ntable are then used as described above, when computing energy and\n  force for individual bond lengths.  This means that if you want the\n  interpolation tables of length Ntable to match exactly what is in the\n  tabulated file (with effectively no preliminary interpolation), you\n  should set Ntable = Nfile.\n  The “FP” parameter is optional.  If used, it is followed by two values\n  fplo and fphi, which are the derivatives of the force at the innermost\n  and outermost bond lengths.  These values are needed by the spline\n  construction routines.  If not specified by the “FP” parameter, they\n  are estimated (less accurately) by the first two and last two force\n  values in the table.\n  The “EQ” parameter is also optional.  If used, it is followed by a the\n  equilibrium bond length, which is used, for example, by the fix shake command.  If not used, the equilibrium bond\n  length is to the distance in the table with the lowest potential energy.\n  Following a blank line, the next N lines list the tabulated values.\n  On each line, the 1st value is the index from 1 to N, the 2nd value is\n  the bond length r (in distance units), the 3rd value is the energy (in\n  energy units), and the 4th is the force (in force units).  The bond\n  lengths must range from a LO value to a HI value, and increase from\n  one line to the next.  If the actual bond length is ever smaller than\n  the LO value or larger than the HI value, then the calculation is\n  aborted with an error, so it is advisable to cover the whole range\n  of possible bond lengths.\n  Note that one file can contain many sections, each with a tabulated\n  potential.  LAMMPS reads the file section by section until it finds\n  one that matches the specified keyword.\n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  \n  Restart info:\n  This bond style writes the settings for the “bond_style table”\n  command to binary restart files, so a bond_style\n  command does not need to specified in an input script that reads a\n  restart file.  However, the coefficient information is not stored in\n  the restart file, since it is tabulated in the potential files.  Thus,\n  bond_coeff commands do need to be specified in the restart input\n  script.\n  ",
    "syntax": "bond_style table style N\n  \n  \n  \n  style = linear or spline = method of interpolation\n  N = use N values in table\n  \n  ",
    "examples": "bond_style table linear 1000\n  bond_coeff 1 file.table ENTRY1\n  \n  \n  ",
    "restrictions": "This bond style can only be used if LAMMPS was built with the MOLECULE\n  package.  See the Build package doc page for more\n  info.\n  "
},
{
    "command": "bond_style zero",
    "description": "Using an bond style of zero means bond forces and energies are not\n  computed, but the geometry of bond pairs is still accessible to other\n  commands.\n  As an example, the compute bond/local\n  command can be used to compute distances for the list of pairs of bond\n  atoms listed in the data file read by the read_data\n  command.  If no bond style is defined, this command cannot be used.\n  The optional nocoeff flag allows to read data files with a BondCoeff\n  section for any bond style. Similarly, any bond_coeff commands\n  will only be checked for the bond type number and the rest ignored.\n  Note that the bond_coeff command must be used for\n  all bond types. If specified, there can be only one value, which is\n  going to be used to assign an equilibrium distance, e.g. for use with\n  fix shake.\n  ",
    "syntax": "bond_style zero [nocoeff]\n  \n  \n  ",
    "examples": "bond_style zero\n  bond_style zero nocoeff\n  bond_coeff *\n  bond_coeff * 2.14\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  "
},
{
    "command": "bond_style quartic",
    "description": "The quartic bond style uses the potential\n  \n  \\[E = K (r - R_c)^ 2 (r - R_c - B_1) (r - R_c - B_2) + U_0 + 4 \\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6 \\right] + \\epsilon\\]\n  to define a bond that can be broken as the simulation proceeds (e.g.\n  due to a polymer being stretched).  The \\(\\sigma\\) and \\(\\epsilon\\) used in the\n  LJ portion of the formula are both set equal to 1.0 by LAMMPS.\n  The following coefficients must be defined for each bond type via the\n  bond_coeff command as in the example above, or in\n  the data file or restart files read by the read_data\n  or read_restart commands:\n  \n  \\(K\\) (energy/distance^4)\n  \\(B_1\\) (distance)\n  \\(B_2\\) (distance)\n  \\(R_c\\) (distance)\n  \\(U_0\\) (energy)\n  \n  This potential was constructed to mimic the FENE bond potential for\n  coarse-grained polymer chains.  When monomers with \\(\\sigma = \\epsilon = 1.0\\)\n  are used, the following choice of parameters gives a quartic potential that\n  looks nearly like the FENE potential:\n  \n  \\[\\begin{split}K &= 1200 \\\\\n  B_1 &= -0.55 \\\\\n  B_2 &= 0.25 \\\\\n  R_c &= 1.3 \\\\\n  U_0 &= 34.6878\\end{split}\\]\n  Different parameters can be specified using the bond_coeff\n  command, but you will need to choose them carefully so they form a suitable\n  bond potential.\n  \\(R_c\\) is the cutoff length at which the bond potential goes smoothly to a\n  local maximum.  If a bond length ever becomes \\(> R_c\\), LAMMPS “breaks”\n  the bond, which means two things.  First, the bond potential is turned\n  off by setting its type to 0, and is no longer computed.  Second, a\n  pairwise interaction between the two atoms is turned on, since they\n  are no longer bonded.\n  LAMMPS does the second task via a computational sleight-of-hand.  It\n  subtracts the pairwise interaction as part of the bond computation.\n  When the bond breaks, the subtraction stops.  For this to work, the\n  pairwise interaction must always be computed by the\n  pair_style command, whether the bond is broken or\n  not.  This means that special_bonds must be set\n  to 1,1,1, as indicated as a restriction below.\n  Note that when bonds are dumped to a file via the dump local command, bonds with type 0 are not included.  The\n  delete_bonds command can also be used to query the\n  status of broken bonds or permanently delete them, e.g.:\n  delete_bonds all stats\n  delete_bonds all bond 0 remove\n  \n  \n  \n  Styles with a gpu, intel, kk, omp, or opt suffix are\n  functionally the same as the corresponding style without the suffix.\n  They have been optimized to run faster, depending on your available\n  hardware, as discussed on the Speed packages doc\n  page.  The accelerated styles take the same arguments and should\n  produce the same results, except for round-off and precision issues.\n  These accelerated styles are part of the GPU, USER-INTEL, KOKKOS,\n  USER-OMP and OPT packages, respectively.  They are only enabled if\n  LAMMPS was built with those packages.  See the Build package doc page for more info.\n  You can specify the accelerated styles explicitly in your input script\n  by including their suffix, or you can use the -suffix command-line switch when you invoke LAMMPS, or you can use the\n  suffix command in your input script.\n  See the Speed packages doc page for more\n  instructions on how to use the accelerated styles effectively.\n  ",
    "syntax": "bond_style quartic\n  \n  \n  ",
    "examples": "bond_style quartic\n  bond_coeff 2 1200 -0.55 0.25 1.3 34.6878\n  \n  \n  ",
    "restrictions": "This bond style can only be used if LAMMPS was built with the MOLECULE\n  package.  See the Build package doc page for more\n  info.\n  The quartic style requires that special_bonds\n  parameters be set to 1,1,1.  Three- and four-body interactions (angle,\n  dihedral, etc) cannot be used with quartic bonds.\n  "
},
{
    "command": "angle_style none",
    "description": "Using an angle style of none means angle forces and energies are not\n  computed, even if triplets of angle atoms were listed in the data file\n  read by the read_data command.\n  See the angle_style zero command for a way to\n  calculate angle statistics, but compute no angle interactions.\n  ",
    "syntax": "angle_style none\n  \n  \n  ",
    "examples": "angle_style none\n  \n  \n  ",
    "restrictions": "none\n  "
},
{
    "command": "improper_style zero",
    "description": "Using an improper style of zero means improper forces and energies are\n  not computed, but the geometry of improper quadruplets is still\n  accessible to other commands.\n  As an example, the compute improper/local command can be used to\n  compute the chi values for the list of quadruplets of improper atoms\n  listed in the data file read by the read_data\n  command.  If no improper style is defined, this command cannot be\n  used.\n  The optional nocoeff flag allows to read data files with a ImproperCoeff\n  section for any improper style. Similarly, any improper_coeff commands\n  will only be checked for the improper type number and the rest ignored.\n  Note that the improper_coeff command must be\n  used for all improper types, though no additional values are\n  specified.\n  ",
    "syntax": "improper_style zero [nocoeff]\n  \n  \n  ",
    "examples": "improper_style zero\n  improper_style zero nocoeff\n  improper_coeff *\n  \n  \n  ",
    "restrictions": "\n  none\n  \n  Related commands: none\n  improper_style none\n  Default: none\n  "
},
];
